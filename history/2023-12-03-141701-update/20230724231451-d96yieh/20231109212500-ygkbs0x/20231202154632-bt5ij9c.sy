{"ID":"20231202154632-bt5ij9c","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231202154632-bt5ij9c","title":"Go 使用标准库 net http 包构建服务器","updated":"20231203141640"},"Children":[{"ID":"20231202154656-8xsv8yn","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231202154656-8xsv8yn","updated":"20231202154704"},"Children":[{"Type":"NodeText","Data":"概念"}]},{"ID":"20231202154632-vayagyv","Type":"NodeParagraph","Properties":{"id":"20231202154632-vayagyv","updated":"20231202155308"},"Children":[{"Type":"NodeText","Data":"在 Go 语言中，使用标准库 net/http 可以很方便的构建服务器，只要调用 ListenAndServe 函数，并传入参数IP地址与端口组成的字符串和处理器（handler）即可。"}]},{"ID":"20231202155631-0fm21nf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231202155631-0fm21nf","updated":"20231202162950"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func ListenAndServe(addr string, handler Handler) error\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231202163011-qa56mdw","Type":"NodeParagraph","Properties":{"id":"20231202163011-qa56mdw","updated":"20231202163011"},"Children":[{"Type":"NodeText","Data":"如果 IP 地址与端口组成的字符串参数为空字符串，那么服务器默认使用 80 端口进行网络连接，如果处理器（handler）参数为 nil，那么服务器将使用默认多路复用器 DefaultServeMux。"}]},{"ID":"20231202163014-y0c6488","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231202163014-y0c6488","updated":"20231202163027"},"Children":[{"Type":"NodeText","Data":"构建服务器"}]},{"ID":"20231202163027-9q2ejk6","Type":"NodeParagraph","Properties":{"id":"20231202163027-9q2ejk6","updated":"20231202163039"},"Children":[{"Type":"NodeText","Data":"Go 语言为我们提供了一个结构体 Server，其中包含了很多对服务器的其它配置，结构体 Server 的完整代码如下："}]},{"ID":"20231202163040-sly2xfg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231202163040-sly2xfg","updated":"20231202164759"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Server struct {\n\tAddr              string\n\tHandler           Handler\n\tTLSConfig         *tls.Config\n\tReadTimeout       time.Duration\n\tReadHeaderTimeout time.Duration\n\tWriteTimeout      time.Duration\n\tIdleTimeout       time.Duration\n\tMaxHeaderBytes    int\n\tTLSNextProto      map[string]func(*Server, *tls.Conn, Handler)\n\tConnState         func(listener net.Listener) context.Context\n\tErrorLog          *log.Logger\n\tBaseContext       func(listener net.Listener) context.Context\n\tConnContext       func(ctx context.Context, c net.Conn) context.Context\n\tinShutdown        atomic.Bool\n\tdisableKeepAlives int32\n\tnextProtoOnce     sync.Once\n\tnextProtoErr      error\n\tmu                sync.Mutex\n\tlisteners         map[*net.Listener]struct{}\n\tactiveConn        map[*conn]struct{}\n\tdoneChan          chan struct{}\n\tonShutdown        []func()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231202164856-9uc1dfp","Type":"NodeParagraph","Properties":{"id":"20231202164856-9uc1dfp","updated":"20231202164856"},"Children":[{"Type":"NodeText","Data":"使用结构体 Server 构建服务器："}]},{"ID":"20231202164857-q63ixd7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231202164857-q63ixd7","updated":"20231202165008"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"server := http.Server{\n\tAddr: \":8080\",\n\tHandler: nil,\n}\nserver.ListenAndServe()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231202165031-9s6kfxv","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231202165031-9s6kfxv","updated":"20231202165038"},"Children":[{"Type":"NodeText","Data":"接收HTTP 请求"}]},{"ID":"20231202165048-1aibdel","Type":"NodeParagraph","Properties":{"id":"20231202165048-1aibdel","updated":"20231202165048"},"Children":[{"Type":"NodeText","Data":"在 Go 语言中，一个处理器就是一个拥有 ServeHTTP 方法的接口，这个 ServeHTTP 方法需要接收两个参数，第一个参数是一个 ResponseWriter 接口，第二个参数是一个指向 Request 结构的指针。"}]},{"ID":"20231202165054-c9uxvu8","Type":"NodeParagraph","Properties":{"id":"20231202165054-c9uxvu8"}},{"ID":"20231202165048-duzvyel","Type":"NodeParagraph","Properties":{"id":"20231202165048-duzvyel","updated":"20231202165048"},"Children":[{"Type":"NodeText","Data":"DefaultServeMux 默认多路复用器是多路复用器 ServeMux 结构的一个实例，ServeMux 也拥有 ServeHTTP 方法。"}]},{"ID":"20231202165055-3inuob2","Type":"NodeParagraph","Properties":{"id":"20231202165055-3inuob2"}},{"ID":"20231202165048-n0u35ay","Type":"NodeParagraph","Properties":{"id":"20231202165048-n0u35ay","updated":"20231203141640"},"Children":[{"Type":"NodeText","Data":"所以 DefaultServeMux 既是 ServeMux 结构的实例，也是处理器 Handler 结构的实例，因此 DefaultServeMux 不仅是一个多路复用器，还是一个处理器。但是 DefaultServeMux  是一个特殊的处理器，它唯一要做的就是根据请求的 URL 将请求重定向到不同的处理器。"}]},{"ID":"20231202165057-7yw19m4","Type":"NodeParagraph","Properties":{"id":"20231202165057-7yw19m4"}},{"ID":"20231202165048-hi75fdq","Type":"NodeParagraph","Properties":{"id":"20231202165048-hi75fdq","updated":"20231202165048"},"Children":[{"Type":"NodeText","Data":"自定义一个处理器，替代 DefaultServeMux。"}]},{"ID":"20231202165239-dzfdk1k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231202165239-dzfdk1k","updated":"20231202165401"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type MyHandler struct {\n\n}\n\nfunc (h *MyHandler) ServerHTTP(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World!\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231202165402-x62makz","Type":"NodeParagraph","Properties":{"id":"20231202165402-x62makz","updated":"20231202165412"},"Children":[{"Type":"NodeText","Data":"使用自定义处理器，配置服务器。"}]},{"ID":"20231202165412-oxkz4yf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231202165412-oxkz4yf","updated":"20231202165536"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"handler := MyHandler{}\nserver := http.Server{\n\tAddr: \"127.0.0.1:8080\",\n\tHandler: \u0026handler\n}\n\nserver.ListenAndServe()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231202165537-d9ojyg4","Type":"NodeParagraph","Properties":{"id":"20231202165537-d9ojyg4","updated":"20231202165544"},"Children":[{"Type":"NodeText","Data":"细心的读者可能已经发现，使用自定义的处理器与服务器进行绑定，启动服务器，不管浏览器访问什么地址，服务器返回的都是同样的响应 Hello World!"}]},{"ID":"20231202165701-88g7t9d","Type":"NodeParagraph","Properties":{"id":"20231202165701-88g7t9d","updated":"20231202165711"},"Children":[{"Type":"NodeText","Data":"这是因为使用自定义的处理器替代了默认多路复用器 DefaultServeMux，服务器不会再通过 URL 匹配来将请求路由至不同的处理器。"}]},{"ID":"20231202212737-9w2f8d4","Type":"NodeParagraph","Properties":{"id":"20231202212737-9w2f8d4","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"怎么解决这个问题呢？"}]},{"ID":"20231202212737-hnlsfmv","Type":"NodeParagraph","Properties":{"id":"20231202212737-hnlsfmv","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"使用多个处理器。使用 http 包的 Handle 函数绑定到 DefaultServeMux。"}]},{"ID":"20231202212737-6zu4grs","Type":"NodeParagraph","Properties":{"id":"20231202212737-6zu4grs","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"为了使用多个处理器去处理不同的 URL，我们不再在 Serve 结构"}]},{"ID":"20231202212737-q4nt6jj","Type":"NodeParagraph","Properties":{"id":"20231202212737-q4nt6jj","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"的 Handler 字段中指定处理器，而是让服务器使用默认多路复用器 DefaultServeMux，"}]},{"ID":"20231202212737-v8oyonu","Type":"NodeParagraph","Properties":{"id":"20231202212737-v8oyonu","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"然后通过 http.Handle 函数将处理器绑定到 DefaultServeMux。http 包的 Handle 函数实际上是 ServeMux 结构的方法，为了操作便利而创建的函数，调用它们等同于调用 DefaultServeMux 的某个方法。"}]},{"ID":"20231202212737-mrd742y","Type":"NodeParagraph","Properties":{"id":"20231202212737-mrd742y","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"例如，调用 http.Handle，实际上就是在调用 DefaultServeMux 的 Handle 方法。"}]},{"ID":"20231202212737-gnecm39","Type":"NodeParagraph","Properties":{"id":"20231202212737-gnecm39","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20231202212737-4k5i09f","Type":"NodeParagraph","Properties":{"id":"20231202212737-4k5i09f","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"编写多个处理器，处理请求"}]}]}