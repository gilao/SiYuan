{"ID":"20230724020125-njxwx4y","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230724020125-njxwx4y","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230724020125-njxwx4y\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230724020126-wplht9x\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230724020126-8jvjt5d\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230724020126-wplht9x\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","title":"20. 使用Docker Compose部署应用","updated":"20230724020253"},"Children":[{"ID":"20230724020126-wplht9x","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724020126-wplht9x","updated":"20230724020126"},"Children":[{"Type":"NodeText","Data":"Compose文件"}]},{"ID":"20230724020126-2cue7pq","Type":"NodeParagraph","Properties":{"id":"20230724020126-2cue7pq","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Docker Compose使用YAML文件来定义多服务的应用。YAML是JSON的一个子集，因此也可以使用JSON。"}]},{"ID":"20230724020126-b4higqc","Type":"NodeParagraph","Properties":{"id":"20230724020126-b4higqc","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Docker Compose默认使用文件名docker-compose.yml。当然，用户也可以使用-f参数指定具体文件。"}]},{"ID":"20230724020126-i6vy0nu","Type":"NodeParagraph","Properties":{"id":"20230724020126-i6vy0nu","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"文件的基本结构包含4个一级key：version、services、networks、volumes"}]},{"ID":"20230724020126-dvljqpe","Type":"NodeParagraph","Properties":{"id":"20230724020126-dvljqpe","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"version是必须指定的，而且总是位于文件的第一行，它定义了Compose文件格式（主要是API)的版本。"}]},{"ID":"20230724020126-kp6gy0w","Type":"NodeParagraph","Properties":{"id":"20230724020126-kp6gy0w","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"services用于定义不同的应用服务。上边的例子定义了两个服务：一个名为web-fe的Web前端服务以及一个名为redis的内存数据库服务。Docker Compose会将每个服务部署在各自的容器中。"}]},{"ID":"20230724020126-3u0c5hs","Type":"NodeParagraph","Properties":{"id":"20230724020126-3u0c5hs","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"networks用于指引Docker创建新的网络。默认情况下，Docker Compose会创建bridge网络。这是一种单主机网络，只能够实现同一主机上容器的连接。当然，也可以使用driver属性来指定不同的网络类型。"}]},{"ID":"20230724020126-3nnrhev","Type":"NodeParagraph","Properties":{"id":"20230724020126-3nnrhev","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"下面的代码可以用来创建一个名为over-net的Overlay网络，允许独立的容器（standalone container）连接（attachable）到该网络上。"}]},{"ID":"20230724020221-j7v9euh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724020221-j7v9euh","updated":"20230724020236"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c2g="},{"Type":"NodeCodeBlockCode","Data":"networks:\n\n\tover-net:\n\n\tdriver:overlay\n\n\tattachable:true\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724020126-qs62amq","Type":"NodeParagraph","Properties":{"id":"20230724020126-qs62amq","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"volumes 用于指引Docker来创建新的卷"}]},{"ID":"20230724020126-jzckpwq","Type":"NodeParagraph","Properties":{"id":"20230724020126-jzckpwq","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例"}]},{"ID":"20230724020238-k0hi43c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724020238-k0hi43c","updated":"20230724020242"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c2g="},{"Type":"NodeCodeBlockCode","Data":"version: \"3.5\"\n\nservices:\n\n\tweb-fe:\n\n    build: .\n\n    command: python app.py\n\n    ports:\n\n      \\- target: 5000\n\n        published: 5000\n\n   networks:\n\n     \\- counter-net\n\n \t volumes:\n\n      \\- type: volume\n\n        source: counter-vol\n\n        target: /code\n\n\t redis:\n\n    image: \"redis:alpine\"\n\nnetworks:\n\n      counter-net:\n\nvolumes:\n\n\t\tcounter-vol;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724020126-wzs2jl1","Type":"NodeParagraph","Properties":{"id":"20230724020126-wzs2jl1","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"上面例子中的Compose文件使用的是v3.5版本的格式，定义了两个服务，一个名为 ****web-fe"},{"Type":"NodeText","Data":"和 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"redis"},{"Type":"NodeText","Data":"。因此DockerCompose会部署两个容器，一个容器的名字中会包含web-fe，而另一个会包含redis。"}]},{"ID":"20230724020126-uxribbo","Type":"NodeParagraph","Properties":{"id":"20230724020126-uxribbo","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"web-fe的服务定义中，包含如下指令。"}]},{"ID":"20230724020126-5mzab19","Type":"NodeParagraph","Properties":{"id":"20230724020126-5mzab19","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"build：.指定Docker基于当前目录（.）下Dockerfile中定义的指令来构建一个新镜像。该镜像会被用于启动该服务的容器。"}]},{"ID":"20230724020126-sf485va","Type":"NodeParagraph","Properties":{"id":"20230724020126-sf485va","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"command：python app.py指定Docker在容器中执行名为app.py的Python脚本作为主程序。因此镜像中必须包含app.py文件以及Python，这一点在Dockerfile中可以得到满足。"}]},{"ID":"20230724020126-fi5ywd9","Type":"NodeParagraph","Properties":{"id":"20230724020126-fi5ywd9","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"ports：指定Docker将容器内（-target）的5000端口映射到主机（published）的5000端口。这意味着发送到Docker主机5000端口的流量会被转发到容器的5000端口。容器中的应用监听端口5000。"}]},{"ID":"20230724020126-pcshbth","Type":"NodeParagraph","Properties":{"id":"20230724020126-pcshbth","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"networks：使得Docker可以将服务连接到指定的网络上。这个网络应该是已经存在的，或者是在networks一级key中定义的网络。对于Overlay网络来说，它还需要定义一个attachable标志，这样独立的容器才可以连接上它（这时Docker Compose会部署独立的容器而不是Docker服务）。"}]},{"ID":"20230724020126-uchpzg6","Type":"NodeParagraph","Properties":{"id":"20230724020126-uchpzg6","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"volumes：指定Docker将counter-vol卷（source:）挂载到容器内的/code（target:）。counter-vol卷应该是已存在的，或者是在文件下方的volumes一级key中定义的。"}]},{"ID":"20230724020126-mc4xziv","Type":"NodeParagraph","Properties":{"id":"20230724020126-mc4xziv","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Docker Compose会调用Docker来为web-fe服务部署一个独立的容器。该容器基于与Compose文件位于同一目录下的Dockerfile构建的镜像。基于该镜像启动的容器会运行app.py作为其主程序，将5000端口暴露给宿主机，连接到counter-net网络上，并挂载一个卷到/code。"}]},{"ID":"20230724020126-acu18hd","Type":"NodeParagraph","Properties":{"id":"20230724020126-acu18hd","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"redis服务的定义相对比较简单。"}]},{"ID":"20230724020126-yu56o34","Type":"NodeParagraph","Properties":{"id":"20230724020126-yu56o34","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"image: redis:alpine使得Docker可以基于redis:alpine镜像启动一个独立的名为redis的容器。这个镜像会被从Docker Hub上拉取下来。"}]},{"ID":"20230724020126-l0dmsqe","Type":"NodeParagraph","Properties":{"id":"20230724020126-l0dmsqe","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"networks：配置redis容器连接到counter-net网络。"}]},{"ID":"20230724020126-dqt9oud","Type":"NodeParagraph","Properties":{"id":"20230724020126-dqt9oud","updated":"20230724020126"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"由于两个服务都连接到counter-net网络，因此它们可以通过名称解析到对方的地址。了解这一点很重要，本例中上层应用被配置为通过名称与Redis服务通信。"}]},{"ID":"20230724020126-8jvjt5d","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724020126-8jvjt5d","updated":"20230724020126"},"Children":[{"Type":"NodeText","Data":"使用Docker Compose 部署应用"}]}]}