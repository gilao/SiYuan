{"ID":"20230904210259-9duzu0f","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f363","id":"20230904210259-9duzu0f","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230904210259-9duzu0f\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230904210259-jcykfpr\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230904210259-jcykfpr\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230904210259-jcykfpr\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","tags":"数组,未完成,双指针法","title":"3 移除元素","updated":"20230905224504"},"Children":[{"ID":"20230905222041-u230wh9","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230905222041-u230wh9","updated":"20230905222101"},"Children":[{"Type":"NodeText","Data":"题目"}]},{"ID":"20230905221205-8dlafyr","Type":"NodeParagraph","Properties":{"id":"20230905221205-8dlafyr","updated":"20230905221205"},"Children":[{"Type":"NodeText","Data":"给你一个数组 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":" "},{"Type":"NodeText","Data":"和一个值 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"val"},{"Type":"NodeText","Data":"​，你需要 "},{"Type":"NodeTextMark","TextMarkType":"strong a","TextMarkAHref":"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95","TextMarkTextContent":"原地"},{"Type":"NodeText","Data":" 移除所有数值等于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"val"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":" "},{"Type":"NodeText","Data":"的元素，并返回移除后数组的新长度。"}]},{"ID":"20230905221205-8b2r6ug","Type":"NodeParagraph","Properties":{"id":"20230905221205-8b2r6ug","updated":"20230905221205"},"Children":[{"Type":"NodeText","Data":"不要使用额外的数组空间，你必须仅使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"O(1)"},{"Type":"NodeText","Data":"​ 额外空间并 "},{"Type":"NodeTextMark","TextMarkType":"strong a","TextMarkAHref":"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95","TextMarkTextContent":"原地 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"修改输入数组"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230905221205-yj6kv7x","Type":"NodeParagraph","Properties":{"id":"20230905221205-yj6kv7x","updated":"20230905221205"},"Children":[{"Type":"NodeText","Data":"元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。"}]},{"ID":"20230905221205-h05wiqt","Type":"NodeParagraph","Properties":{"id":"20230905221205-h05wiqt","updated":"20230905221205"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"说明:"}]},{"ID":"20230905221205-90r96u7","Type":"NodeParagraph","Properties":{"id":"20230905221205-90r96u7","updated":"20230905221205"},"Children":[{"Type":"NodeText","Data":"为什么返回数值是整数，但输出的答案是数组呢?"}]},{"ID":"20230905221205-7v8vi3r","Type":"NodeParagraph","Properties":{"id":"20230905221205-7v8vi3r","updated":"20230905221205"},"Children":[{"Type":"NodeText","Data":"请注意，输入数组是以"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"「引用」"},{"Type":"NodeText","Data":"方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。"}]},{"ID":"20230905221205-69dri1i","Type":"NodeParagraph","Properties":{"id":"20230905221205-69dri1i","updated":"20230905221205"},"Children":[{"Type":"NodeText","Data":"你可以想象内部操作如下:"}]},{"ID":"20230905221205-o0vkgf6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230905221205-o0vkgf6","updated":"20230905221205"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i \u003c len; i++) {\n    print(nums[i]);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230905222013-0mvhbgh","Type":"NodeParagraph","Properties":{"id":"20230905222013-0mvhbgh","updated":"20230905222013"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例 1："}]},{"ID":"20230905222013-1vrn8pb","Type":"NodeHTMLBlock","Data":"\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003enums = [3,2,2,3], val = 3\n\u003cstrong\u003e输出：\u003c/strong\u003e2, nums = [2,2]\n\u003cstrong\u003e解释：\u003c/strong\u003e函数应该返回新的长度 \u003cstrong\u003e2\u003c/strong\u003e, 并且 nums\u003cem\u003e \u003c/em\u003e中的前两个元素均为 \u003cstrong\u003e2\u003c/strong\u003e。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n\u003c/pre\u003e","Properties":{"id":"20230905222013-1vrn8pb","updated":"20230905222013"}},{"ID":"20230905222013-0rld8l8","Type":"NodeParagraph","Properties":{"id":"20230905222013-0rld8l8","updated":"20230905222013"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例 2："}]},{"ID":"20230905222013-6zjjj1e","Type":"NodeHTMLBlock","Data":"\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003enums = [0,1,2,2,3,0,4,2], val = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e5, nums = [0,1,4,0,3]\n\u003cstrong\u003e解释：\u003c/strong\u003e函数应该返回新的长度 \u003cstrong\u003e\u003ccode\u003e5\u003c/code\u003e\u003c/strong\u003e, 并且 nums 中的前五个元素为 \u003cstrong\u003e\u003ccode\u003e0\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e1\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e3\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e0\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e4\u003c/strong\u003e。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\u003c/pre\u003e","Properties":{"id":"20230905222013-6zjjj1e","updated":"20230905222013"}},{"ID":"20230905222013-iloxkw2","Type":"NodeParagraph","Properties":{"id":"20230905222013-iloxkw2","updated":"20230905222013"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"提示："}]},{"ID":"20230905222013-mlxhsvn","Type":"NodeList","ListData":{},"Properties":{"id":"20230905222013-mlxhsvn","updated":"20230905222013"},"Children":[{"ID":"20230905222013-cub45xm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230905222013-cub45xm","updated":"20230905222013"},"Children":[{"ID":"20230905222013-747ow82","Type":"NodeParagraph","Properties":{"id":"20230905222013-747ow82","updated":"20230905222013"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0 \u0026lt;= nums.length \u0026lt;= 100"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20230905222013-9rhaepu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230905222013-9rhaepu","updated":"20230905222013"},"Children":[{"ID":"20230905222013-67o3a8l","Type":"NodeParagraph","Properties":{"id":"20230905222013-67o3a8l","updated":"20230905222013"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0 \u0026lt;= nums[i] \u0026lt;= 50"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20230905222013-u31shh6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230905222013-u31shh6","updated":"20230905222013"},"Children":[{"ID":"20230905222013-6cyhb61","Type":"NodeParagraph","Properties":{"id":"20230905222013-6cyhb61","updated":"20230905222013"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0 \u0026lt;= val \u0026lt;= 100"},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20230905222035-6jo6on7","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230905222035-6jo6on7","updated":"20230905222108"},"Children":[{"Type":"NodeText","Data":"思路"}]},{"ID":"20230905222109-ua89qqq","Type":"NodeParagraph","Properties":{"id":"20230905222109-ua89qqq","updated":"20230905222245"},"Children":[{"Type":"NodeText","Data":"要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。"}]},{"ID":"20230905222635-ca2wrm1","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230905222635-ca2wrm1","updated":"20230905222649"},"Children":[{"Type":"NodeText","Data":"暴力解法"}]},{"ID":"20230905222650-nhg12cn","Type":"NodeParagraph","Properties":{"id":"20230905222650-nhg12cn","updated":"20230905222707"},"Children":[{"Type":"NodeText","Data":"⽬暴⼒的解法就是两层for循环，⼀个for循环遍历数组元素 ，第⼆个for循环更新数组。"}]},{"ID":"20230905222708-mmra5iw","Type":"NodeParagraph","Properties":{"id":"20230905222708-mmra5iw","updated":"20230905223211"},"Children":[{"Type":"NodeText","Data":"删除过程如下：（更新为动态图）"}]},{"ID":"20230905222742-vzsvyik","Type":"NodeParagraph","Properties":{"id":"20230905222742-vzsvyik","updated":"20230905224004"},"Children":[{"Type":"NodeText","Data":"​​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"27.移除元素-暴力解法"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/27.移除元素-暴力解法-20230905224004-qziyiq2.gif"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​​"}]},{"ID":"20230905223226-uaqxjju","Type":"NodeParagraph","Properties":{"id":"20230905223226-uaqxjju","updated":"20230905223226"},"Children":[{"Type":"NodeText","Data":"很明显暴⼒解法的时间复杂度是O(n^2)，"}]},{"ID":"20230905223228-dtewf8y","Type":"NodeParagraph","Properties":{"id":"20230905223228-dtewf8y","updated":"20230905223235"},"Children":[{"Type":"NodeText","Data":"代码如下："}]},{"ID":"20230905223235-2jy8yfy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230905223235-2jy8yfy","updated":"20230905223657"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func removeElement(nums []int, val int) int {\n    size := len(nums)\n    for i := 0; i \u003c size; i++ {\n        if nums[i] == val {\n            for j := i + 1; j \u003c size; j++ {\n                nums[j-1] = nums[j]\n            }\n            i--   // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位\n            size-- // 此时数组的大小-1\n        }\n    }\n    return size\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230905223829-vfcisxf","Type":"NodeParagraph","Properties":{"id":"20230905223829-vfcisxf","updated":"20230905223829"},"Children":[{"Type":"NodeText","Data":"时间复杂度：O(n^2)"}]},{"ID":"20230905223829-hwl4cv0","Type":"NodeParagraph","Properties":{"id":"20230905223829-hwl4cv0","updated":"20230905223829"},"Children":[{"Type":"NodeText","Data":"空间复杂度：O(1)"}]},{"ID":"20230905223830-fak9zy6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230905223830-fak9zy6","updated":"20230905223840"},"Children":[{"Type":"NodeText","Data":"双指针法"}]},{"ID":"20230905223902-ycpuvgm","Type":"NodeParagraph","Properties":{"id":"20230905223902-ycpuvgm","updated":"20230905223902"},"Children":[{"Type":"NodeText","Data":"双指针法（快慢指针法）： 通过⼀个快指针和慢指针在⼀个for循环下完成两个for循环的⼯作。"}]},{"ID":"20230905223902-t1v7pfv","Type":"NodeParagraph","Properties":{"id":"20230905223902-t1v7pfv","updated":"20230905223902"},"Children":[{"Type":"NodeText","Data":"定义快慢指针"}]},{"ID":"20230905223902-b8pe1vp","Type":"NodeParagraph","Properties":{"id":"20230905223902-b8pe1vp","updated":"20230905223902"},"Children":[{"Type":"NodeText","Data":"快指针：寻找新数组的元素 ，新数组就是不含有⽬标元素的数组"}]},{"ID":"20230905223902-ocyhaha","Type":"NodeParagraph","Properties":{"id":"20230905223902-ocyhaha","updated":"20230905223902"},"Children":[{"Type":"NodeText","Data":"慢指针：指向更新 新数组下标的位置"}]},{"ID":"20230905223902-7rzoiyn","Type":"NodeParagraph","Properties":{"id":"20230905223902-7rzoiyn","updated":"20230905223902"},"Children":[{"Type":"NodeText","Data":"很多同学这道题⽬做的很懵，就是不理解 快慢指针究竟都是什么含义，所以⼀定要明确含义，后⾯的思路就更容易"}]},{"ID":"20230905223902-170isou","Type":"NodeParagraph","Properties":{"id":"20230905223902-170isou","updated":"20230905223902"},"Children":[{"Type":"NodeText","Data":"理解了。"}]},{"ID":"20230905223902-79zufod","Type":"NodeParagraph","Properties":{"id":"20230905223902-79zufod","updated":"20230905223902"},"Children":[{"Type":"NodeText","Data":"删除过程如下："}]},{"ID":"20230905224037-2i28fc3","Type":"NodeParagraph","Properties":{"id":"20230905224037-2i28fc3","updated":"20230905224056"},"Children":[{"Type":"NodeText","Data":"​​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"27.移除元素-双指针法"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/27.移除元素-双指针法-20230905224056-e1jq7kc.gif"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​​"}]},{"ID":"20230905224107-ngxnxo7","Type":"NodeParagraph","Properties":{"id":"20230905224107-ngxnxo7","updated":"20230905224107"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。"}]},{"ID":"20230905224159-o0ur4hm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230905224159-o0ur4hm","updated":"20230905224402"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 相向双指针法\nfunc removeElement(nums []int, val int) int {\n  // 有点像二分法查找的左闭右闭区间，所以下面是 \u003c= \n  left := 0\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230905224504-z2v2k8t","Type":"NodeParagraph","Properties":{"id":"20230905224504-z2v2k8t"}}]}