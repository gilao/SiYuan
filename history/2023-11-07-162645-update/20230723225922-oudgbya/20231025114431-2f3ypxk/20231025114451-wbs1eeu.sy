{"ID":"20231025114451-wbs1eeu","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f4a3","id":"20231025114451-wbs1eeu","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20231025114451-wbs1eeu\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231025114451-y8nos90\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231030005442-omspsk7\u0026quot;,\u0026quot;scrollTop\u0026quot;:9762\u0026#125;","tags":"go,时间轮算法,redis,未完成","title":"基于 golang 从零到一实现时间轮算法","updated":"20231107161712"},"Children":[{"ID":"20231025114451-y8nos90","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231025114451-y8nos90","updated":"20231025114554"},"Children":[{"Type":"NodeText","Data":"前言"}]},{"ID":"20231025114554-bew465x","Type":"NodeParagraph","Properties":{"id":"20231025114554-bew465x","updated":"20231025114559"},"Children":[{"Type":"NodeText","Data":"如何基于 golang 从零到一实现 redis."}]},{"ID":"20231025114652-2vzeaz3","Type":"NodeParagraph","Properties":{"id":"20231025114652-2vzeaz3","updated":"20231025142453"},"Children":[{"Type":"NodeText","Data":"这里选择的学习素材是 hdt3213 大佬于 github 上开源的 godis 项目. 在大佬的实现中，充分利用了 golang 的特性，将 redis 存储层由单线程模型转为并发模型，其中在实现数据的 expire 机制时，采用的是单机时间轮模型进行过期数据的删除操作。"}]},{"ID":"20231025142501-xk5rtlp","Type":"NodeParagraph","Properties":{"id":"20231025142501-xk5rtlp","updated":"20231025142514"},"Children":[{"Type":"NodeText","Data":"godis 项目开源地址："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"http://github.com/HDT3213/godis"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025142501-zhpxlt0","Type":"NodeParagraph","Properties":{"id":"20231025142501-zhpxlt0","updated":"20231025142501"},"Children":[{"Type":"NodeText","Data":"godis 时间轮代码："}]},{"ID":"20231025142505-j1mctdb","Type":"NodeParagraph","Properties":{"id":"20231025142505-j1mctdb","updated":"20231025142518"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"http://github.com/HDT3213/godis/blob/master/lib/timewheel/timewheel.go"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025142518-ahpw8f0","Type":"NodeParagraph","Properties":{"id":"20231025142518-ahpw8f0","updated":"20231025142604"},"Children":[{"Type":"NodeText","Data":"实际上，在我之前分享个人项目——分布式定时器 xtimer 中也有到了时间轮算法，这部分内容具有一定共性. 借此机会，本期单独对时间轮算法的原理和实践内容进行梳理，并基于 golang 从零到一开源实现出一个单机版和 redis 分布式版的时间轮，供大家一起交流探讨。"}]},{"ID":"20231025142605-bbx9a5m","Type":"NodeParagraph","Properties":{"id":"20231025142605-bbx9a5m","updated":"20231025142616"},"Children":[{"Type":"NodeText","Data":"个人开源的时间轮项目地址为："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"http://github.com/xiaoxuxiansheng/timewheel"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025142617-kmpyhct","Type":"NodeParagraph","Properties":{"id":"20231025142617-kmpyhct"}},{"ID":"20231025142817-h4c67eb","Type":"NodeParagraph","Properties":{"id":"20231025142817-h4c67eb"}},{"ID":"20231025142817-vsys36s","Type":"NodeParagraph","Properties":{"id":"20231025142817-vsys36s","updated":"20231025142829"},"Children":[{"Type":"NodeText","Data":"目录大纲如下"}]},{"ID":"20231025142843-e3766mv","Type":"NodeParagraph","Properties":{"id":"20231025142843-e3766mv","updated":"20231025142843"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025142843-lhxnrzk.png"},{"Type":"NodeCloseParen"}]}]},{"ID":"20231025142910-ceg9mlk","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231025142910-ceg9mlk","updated":"20231025142918"},"Children":[{"Type":"NodeText","Data":"时间轮原理"}]},{"ID":"20231025142941-sijmdpi","Type":"NodeParagraph","Properties":{"id":"20231025142941-sijmdpi","updated":"20231025142941"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025142941-6wd1yzk.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025142844-gknuimj","Type":"NodeParagraph","Properties":{"id":"20231025142844-gknuimj","updated":"20231025143211"},"Children":[{"Type":"NodeText","Data":"时间轮是定时任务调度系统中常用到的一种经典的算法模型. 有关时间轮算法的详细概念介绍，可以参见论文:《Hashed and Hierarchical Time Wheels: Data Structures for the Efficient Implementation of a Time Facility》http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf"}]},{"ID":"20231025143244-yclrahw","Type":"NodeParagraph","Properties":{"id":"20231025143244-yclrahw","updated":"20231025143252"},"Children":[{"Type":"NodeText","Data":"接下来我也会从个人角度出发，谈谈我对于时间轮算法的一些浅显理解."}]},{"ID":"20231025143257-px6cloy","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231025143257-px6cloy","updated":"20231025143303"},"Children":[{"Type":"NodeText","Data":"时间轮概念"}]},{"ID":"20231025143309-qtu7rcu","Type":"NodeParagraph","Properties":{"id":"20231025143309-qtu7rcu","updated":"20231025143314"},"Children":[{"Type":"NodeText","Data":"聊时间轮之前，先聊聊时间的概念。"}]},{"ID":"20231025143309-cszx3mj","Type":"NodeParagraph","Properties":{"id":"20231025143309-cszx3mj","updated":"20231025143311"},"Children":[{"Type":"NodeText","Data":"首先时间是一维、单向的，我们可以用一条一维的时间轴将其具象化. 我们对时间轴进行刻度拆分，每个刻度对应一个时间范围，那么刻度拆分得越细，则表示的时间范围越精确。"}]},{"ID":"20231025143342-mt8ifx9","Type":"NodeParagraph","Properties":{"id":"20231025143342-mt8ifx9","updated":"20231025143342"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025143342-fjjjxoz.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025143458-5tkehwc","Type":"NodeParagraph","Properties":{"id":"20231025143458-5tkehwc","updated":"20231025143458"},"Children":[{"Type":"NodeText","Data":"然而，我们知道时间是没有尽头的，因此这条一维时间轴的长度是无穷大的. 倘若我们想要建立一个数据结构去表达这条由一系列刻度聚合形成的时间轴，这个数据结构所占用的空间也是无穷无尽的."}]},{"ID":"20231025143458-ojjozz3","Type":"NodeParagraph","Properties":{"id":"20231025143458-ojjozz3","updated":"20231025143458"},"Children":[{"Type":"NodeText","Data":"那么，我们应该如何优化这个问题呢？此时，大家不妨低头看一眼自己的手表. 手表或时钟这类日常生活中用来关联表达时间的工具，采用的是首尾衔接的环状结构来替代无穷长度的一维时间轴，每当钟表划过一圈，刻度从新回到零值，但是已有的时间进度会传承往下."}]},{"ID":"20231025143458-twd5lkl","Type":"NodeParagraph","Properties":{"id":"20231025143458-twd5lkl","updated":"20231025143458"},"Children":[{"Type":"NodeText","Data":"本期所聊的时间轮算法采用的思路正是与之类似，下面我们梳理一下核心流程："}]},{"ID":"20231025143542-i962djv","Type":"NodeList","ListData":{},"Properties":{"id":"20231025143542-i962djv","updated":"20231025143542"},"Children":[{"ID":"20231025143542-88tyu3r","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143542-88tyu3r","updated":"20231025143542"},"Children":[{"ID":"20231025143542-521aaxl","Type":"NodeParagraph","Properties":{"id":"20231025143542-521aaxl","updated":"20231025143542"},"Children":[{"Type":"NodeText","Data":"建立一个环状数据结构"}]}]},{"ID":"20231025143551-nh8ik58","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143551-nh8ik58"},"Children":[{"ID":"20231025143551-qs9ljrd","Type":"NodeParagraph","Properties":{"id":"20231025143551-qs9ljrd"},"Children":[{"Type":"NodeText","Data":"每个刻度对应一个时间范围"}]}]},{"ID":"20231025143555-z351zk1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143555-z351zk1"},"Children":[{"ID":"20231025143555-x91q0o7","Type":"NodeParagraph","Properties":{"id":"20231025143555-x91q0o7"},"Children":[{"Type":"NodeText","Data":"创建定时任务时，根据距今的相对时长，推算出需要向后推移的刻度值"}]}]},{"ID":"20231025143542-wg2vmtp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143542-wg2vmtp","updated":"20231025143542"},"Children":[{"ID":"20231025143542-c705xln","Type":"NodeParagraph","Properties":{"id":"20231025143542-c705xln","updated":"20231025143557"},"Children":[{"Type":"NodeText","Data":"倘若来到环形数组的结尾，则重新从起点开始计算，但是记录时把执行轮次数加1"}]}]},{"ID":"20231025143542-a4m01t4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143542-a4m01t4","updated":"20231025143542"},"Children":[{"ID":"20231025143542-plo1hwj","Type":"NodeParagraph","Properties":{"id":"20231025143542-plo1hwj","updated":"20231025143559"},"Children":[{"Type":"NodeText","Data":"一个刻度可能存在多笔定时任务，所以每个刻度需要挂载一个定时任务链表"}]}]}]},{"ID":"20231025143602-4w6ug3f","Type":"NodeParagraph","Properties":{"id":"20231025143602-4w6ug3f","updated":"20231025145140"},"Children":[{"Type":"NodeText","Data":"接下来，我们建立时间轮的扫描机制，就如同钟表中的指针一般，按照固定的时间节奏，沿着环形数组周而复始地持续向下扫描. 每当来到一个刻度时，则取出链表中轮次为 0 的定时任务进行执行. 这就是时间轮算法的核心思路。"}]},{"ID":"20231025145156-wc0jvp8","Type":"NodeParagraph","Properties":{"id":"20231025145156-wc0jvp8","updated":"20231025145156"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025145156-fs2tcf6.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025143604-60o336e","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231025143604-60o336e","updated":"20231025145637"},"Children":[{"Type":"NodeText","Data":"多级时间轮"}]},{"ID":"20231025145644-lqjljdt","Type":"NodeParagraph","Properties":{"id":"20231025145644-lqjljdt","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"接下来聊一聊时间轮中的等级制度与多级时间轮的概念."}]},{"ID":"20231025145644-ao5z52q","Type":"NodeParagraph","Properties":{"id":"20231025145644-ao5z52q","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"首先捋一捋，时间轮每个周期轮次中，使用的数据结构容量与所表达的时间范围之间的关系."}]},{"ID":"20231025145644-rkjn53z","Type":"NodeParagraph","Properties":{"id":"20231025145644-rkjn53z","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"我们把时间轮中的每个刻度记为一个 slot，每个 slot 表示的时间范围记为 t."}]},{"ID":"20231025145644-gdl4obk","Type":"NodeParagraph","Properties":{"id":"20231025145644-gdl4obk","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"假设时间轮中总共包含 2m 个 slot，求问如何组织我们的时间轮数据结构，能够使得时间轮每个轮次对应表达的时间范围尽可能的长. （一个轮次对应的时间范围越长，在时间流逝过程中轮次的迭代速度就越慢，于是每个 slot 对应的定时任务链表长度就越短，执行定时任务时的检索效率就越高.）"}]},{"ID":"20231025145644-wa3v7my","Type":"NodeParagraph","Properties":{"id":"20231025145644-wa3v7my","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"这里最简单的方式就是进行采用一维纵向排列的方式，那么能够表达的时间范围就是 2m * t，某个刻度对应的时间值就记为 {slot_i}."}]},{"ID":"20231025145716-lcwh4ng","Type":"NodeParagraph","Properties":{"id":"20231025145716-lcwh4ng","updated":"20231025145716"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025145716-m89rg67.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025145723-yas22wa","Type":"NodeParagraph","Properties":{"id":"20231025145723-yas22wa","updated":"20231025145723"},"Children":[{"Type":"NodeText","Data":"另一种思路是，我们在时间轮中建立一种等级秩序."}]},{"ID":"20231025145723-6xnbwzr","Type":"NodeParagraph","Properties":{"id":"20231025145723-6xnbwzr","updated":"20231025145751"},"Children":[{"Type":"NodeText","Data":"比如我们将 2m 个 slot 拆成两个等级——level1 和 level2. 最终我们通过 {level1_slot}_{level2_slot} 的方式进行时间的表达."}]},{"ID":"20231025145723-tnkl6uv","Type":"NodeParagraph","Properties":{"id":"20231025145723-tnkl6uv","updated":"20231025145723"},"Children":[{"Type":"NodeText","Data":"我们给 level2 分配 m 个 slot，其中每个 slot 对应的时间范围同样为 t. 而 level1 同样也分配 m 个 slot，但是此时其中每个 slot 对应的时间范围应该为 m * t，因为在 level1 中的 slot 确定时，level2 中还有 m 种 slot 的组合方式."}]},{"ID":"20231025145723-swgq5xz","Type":"NodeParagraph","Properties":{"id":"20231025145723-swgq5xz","updated":"20231025145723"},"Children":[{"Type":"NodeText","Data":"如此一来，这种组织方式下，时间轮单个轮次所能表达的时间范围就是 m * m * t."}]},{"ID":"20231025145723-kqi6u3f","Type":"NodeParagraph","Properties":{"id":"20231025145723-kqi6u3f","updated":"20231025145723"},"Children":[{"Type":"NodeText","Data":"这里探讨的核心不是具体某级时间轮的时间范围结果，而是抛出了一种多级时间轮的思路，从一到二是质变，从二到三、从三到四就仅仅是量变的问题，可以继续复刻相同的思路."}]},{"ID":"20231028233553-lmlndic","Type":"NodeParagraph","Properties":{"id":"20231028233553-lmlndic","updated":"20231028233553"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231028233553-17gatoh.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231028233600-n7l1zve","Type":"NodeParagraph","Properties":{"id":"20231028233600-n7l1zve","updated":"20231028233600"},"Children":[{"Type":"NodeText","Data":"回过头来看，我们会发现日常使用的时间表达式正是采用了这样一种多级时间轮的等级制度，比如当前的时刻为：2023-09-23 15:50:00. 这本质上是一种通过 {year}-{month}-{date}-{hour}-{minute}-{second} 组成的 6 级时间轮等级结构."}]},{"ID":"20231028233600-br4sxln","Type":"NodeParagraph","Properties":{"id":"20231028233600-br4sxln","updated":"20231028233600"},"Children":[{"Type":"NodeText","Data":"后续在本文第 3 章探讨如何基于 redis zset 实现时间轮的话题中，我们会进一步利用这种多级时间轮的思路，将每个任务首先基于前 5 级 {year}-{month}-{date}-{hour}-{minute} 的等级表达式进行分钟级时间片的纵向拆分，最终在 1 分钟范围内进行定时任务的有序组织，保证在每次插入、删除和检索任务时，处理的数据量级能够维持在分钟级的数量，最大化地提高时间轮结果的处理性能."}]},{"ID":"20231028233615-j4imx7w","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231028233615-j4imx7w","updated":"20231028233628"},"Children":[{"Type":"NodeText","Data":"单机版实现"}]},{"ID":"20231029001635-sdoy0j7","Type":"NodeParagraph","Properties":{"id":"20231029001635-sdoy0j7","updated":"20231029001635"},"Children":[{"Type":"NodeText","Data":"聊完原理部分，下面我们一起进入实战环节."}]},{"ID":"20231029001635-v2j37ac","Type":"NodeParagraph","Properties":{"id":"20231029001635-v2j37ac","updated":"20231029001635"},"Children":[{"Type":"NodeText","Data":"在本章中，我们会使用 golang 标准库的定时器工具 time ticker 结合环状数组的设计思路，实现一个单机版的单级时间轮."}]},{"ID":"20231029001636-xht7pjm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231029001636-xht7pjm","updated":"20231029001640"},"Children":[{"Type":"NodeText","Data":"核心类"}]},{"ID":"20231029001640-ka1yhu2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231029001640-ka1yhu2","updated":"20231029001647"},"Children":[{"Type":"NodeText","Data":"时间轮"}]},{"ID":"20231029002231-jv1m7xp","Type":"NodeParagraph","Properties":{"id":"20231029002231-jv1m7xp","updated":"20231029002231"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231029002231-y18eqhu.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231029002239-cfiafkr","Type":"NodeParagraph","Properties":{"id":"20231029002239-cfiafkr","updated":"20231029002239"},"Children":[{"Type":"NodeText","Data":"在几个核心字段中："}]},{"ID":"20231029004635-qqgy5vc","Type":"NodeList","ListData":{},"Properties":{"id":"20231029004635-qqgy5vc","updated":"20231029004635"},"Children":[{"ID":"20231029004635-zlvjq0d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231029004635-zlvjq0d","updated":"20231029004635"},"Children":[{"ID":"20231029002239-coe1qpd","Type":"NodeParagraph","Properties":{"id":"20231029002239-coe1qpd","updated":"20231029004635"},"Children":[{"Type":"NodeText","Data":"slots——类似于时钟的表盘"}]}]},{"ID":"20231029004635-bmfscqn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231029004635-bmfscqn","updated":"20231029004635"},"Children":[{"ID":"20231029002239-08b1gdt","Type":"NodeParagraph","Properties":{"id":"20231029002239-08b1gdt","updated":"20231029004635"},"Children":[{"Type":"NodeText","Data":"curSlot——类似于时钟的指针"}]}]},{"ID":"20231029004635-pw603ha","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231029004635-pw603ha","updated":"20231029004635"},"Children":[{"ID":"20231029002239-qsaa4yl","Type":"NodeParagraph","Properties":{"id":"20231029002239-qsaa4yl","updated":"20231029004635"},"Children":[{"Type":"NodeText","Data":"ticker 是使用 golang 标准库的定时器工具，类似于驱动指针运转的齿轮"}]}]}]},{"ID":"20231029002239-7ebau6e","Type":"NodeParagraph","Properties":{"id":"20231029002239-7ebau6e","updated":"20231029002239"},"Children":[{"Type":"NodeText","Data":"在创建时间轮实例时，会通过一个异步的常驻 goroutine 执行定时任务的检索、添加、删除等操作，并通过几个 channel 进行 goroutine 的执行逻辑和生命周期的控制："}]},{"ID":"20231029004618-yui4pjc","Type":"NodeList","ListData":{},"Properties":{"id":"20231029004618-yui4pjc","updated":"20231029004618"},"Children":[{"ID":"20231029004618-6tqle73","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231029004618-6tqle73","updated":"20231029004618"},"Children":[{"ID":"20231029002239-y6u0acm","Type":"NodeParagraph","Properties":{"id":"20231029002239-y6u0acm","updated":"20231029004618"},"Children":[{"Type":"NodeText","Data":"stopc：用于停止 goroutine"}]}]},{"ID":"20231029004618-c4apu5d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231029004618-c4apu5d","updated":"20231029004618"},"Children":[{"ID":"20231029002239-8es4prr","Type":"NodeParagraph","Properties":{"id":"20231029002239-8es4prr","updated":"20231029004618"},"Children":[{"Type":"NodeText","Data":"addTaskCh：用于接收创建定时器指令"}]}]},{"ID":"20231029004618-rx2gi4b","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231029004618-rx2gi4b","updated":"20231029004618"},"Children":[{"ID":"20231029002239-psok0e0","Type":"NodeParagraph","Properties":{"id":"20231029002239-psok0e0","updated":"20231029004618"},"Children":[{"Type":"NodeText","Data":"removeTaskCh：用于接收删除定时任务的指令"}]}]}]},{"ID":"20231030003458-c7e8uqj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231030003458-c7e8uqj","updated":"20231030003459"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 单机版时间轮\ntype TimeWheel struct {\n\t// 单例工具，保证时间轮停止操作只能执行一次\n\tsync.Once\n\t// 时间轮运行时间间隔\n\tinterval time.Duration\n\t// 时间轮定时器\n\tticker *time.Ticker\n\t// 停止时间轮的 channel\n\tstopc chan struct{}\n\t// 新增定时任务的入口 channel\n\taddTaskCh chan *teskElement\n\t// 删除定时任务的入口 channel\n\tremoveTaskCh chan string\n\t// 通过 list 组成的环状数组，通过遍历环状数组的方式实现时间轮\n\t// 定时任务数量较大，每个 slot 槽内可能存在多个定时任务，因此通过 list 进行组装\n\tslots []*list.List\n\t// 当前遍历到的环状数组的索引\n\tcurSlot int\n\t// 定时任务 key 到任务节点的映射，便于在 list中删除任务节点\n\tkeyToETask map[string]*list.Element\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231030003510-qcntjhd","Type":"NodeParagraph","Properties":{"id":"20231030003510-qcntjhd","updated":"20231030003510"},"Children":[{"Type":"NodeText","Data":"此处有几个技术细节需要提及："}]},{"ID":"20231030003510-r666vea","Type":"NodeParagraph","Properties":{"id":"20231030003510-r666vea","updated":"20231030003510"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"首先："},{"Type":"NodeText","Data":" 所谓环状数组指的是逻辑意义上的. 在实际的实现过程中，会通过一个定长数组结合循环遍历的方式，来实现这个逻辑意义上的“环状”性质."}]},{"ID":"20231030003510-izdadqx","Type":"NodeParagraph","Properties":{"id":"20231030003510-izdadqx","updated":"20231030003510"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"其次："},{"Type":"NodeText","Data":" 数组每一轮能表达的时间范围是固定的. 每当在添加添加一个定时任务时，需要根据其延迟的相对时长推算出其所处的 slot 位置，其中可能跨遍历轮次的情况，这时候需要额外通过定时任务中的 cycle 字段来记录这一信息，避免定时任务被提前执行."}]},{"ID":"20231030003510-7zgea7t","Type":"NodeParagraph","Properties":{"id":"20231030003510-7zgea7t","updated":"20231030003510"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"最后："},{"Type":"NodeText","Data":" 时间轮中一个 slot 可能需要挂载多笔定时任务，因此针对每个 slot，需要采用 golang 标准库 container/list 中实现的双向链表进行定时任务数据的存储."}]},{"ID":"20231030004010-ynku86f","Type":"NodeParagraph","Properties":{"id":"20231030004010-ynku86f","updated":"20231030004010"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231030004010-j3ypam8.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231030004453-8vx1qy9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231030004453-8vx1qy9","updated":"20231030004459"},"Children":[{"Type":"NodeText","Data":"定时任务"}]},{"ID":"20231030004506-83weqq3","Type":"NodeParagraph","Properties":{"id":"20231030004506-83weqq3","updated":"20231030004506"},"Children":[{"Type":"NodeText","Data":"下面是对一笔定时任务的类定义："}]},{"ID":"20231030004522-919emhn","Type":"NodeList","ListData":{},"Properties":{"id":"20231030004522-919emhn","updated":"20231030004522"},"Children":[{"ID":"20231030004522-i2vq90h","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231030004522-i2vq90h","updated":"20231030004522"},"Children":[{"ID":"20231030004506-xlthz23","Type":"NodeParagraph","Properties":{"id":"20231030004506-xlthz23","updated":"20231030004522"},"Children":[{"Type":"NodeText","Data":"key：每个定时任务的全局唯一标识键"}]}]},{"ID":"20231030004522-u1teqtx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231030004522-u1teqtx","updated":"20231030004522"},"Children":[{"ID":"20231030004506-ig684y7","Type":"NodeParagraph","Properties":{"id":"20231030004506-ig684y7","updated":"20231030004522"},"Children":[{"Type":"NodeText","Data":" task：包含了定时任务执行逻辑的闭包函数"}]}]},{"ID":"20231030004522-xzddlr7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231030004522-xzddlr7","updated":"20231030004522"},"Children":[{"ID":"20231030004506-zjf3u1o","Type":"NodeParagraph","Properties":{"id":"20231030004506-zjf3u1o","updated":"20231030004522"},"Children":[{"Type":"NodeText","Data":"pos：定时任务在环形数组所处的位置，即数组的索引 index"}]}]},{"ID":"20231030004522-1ueej72","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231030004522-1ueej72","updated":"20231030004522"},"Children":[{"ID":"20231030004506-fa0go6n","Type":"NodeParagraph","Properties":{"id":"20231030004506-fa0go6n","updated":"20231030004522"},"Children":[{"Type":"NodeText","Data":"cycle：定时任务的延迟轮次. 时间轮的 curSlot 指针每完成一整轮的数组遍历，所有定时任务的 cycle 指数都需要减 1. 当定时任务 cycle 指数为 0 时，代表该任务在当前遍历轮次执行."}]}]}]},{"ID":"20231030004506-io3x2pu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231030004506-io3x2pu","updated":"20231030005247"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 封装了一笔定时任务的明细信息\ntype taskElement struct {\n\t// 内聚了定时任务执行逻辑的闭包函数\n\ttask func()\n\t// 定时任务挂载在环状数组中的索引位置\n\tpos int\n\t// 定时任务的延时轮次，指的是 curSlot 指针还要扫描过环状数组多少轮，才能满足执行该任务的条件\n\tcycle int\n\t// 定时任务的唯一标识键\n\tkey string\n}"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231030005249-g17tkro","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231030005249-g17tkro","updated":"20231030005258"},"Children":[{"Type":"NodeText","Data":"构造器"}]},{"ID":"20231030005442-mvisr5f","Type":"NodeParagraph","Properties":{"id":"20231030005442-mvisr5f","updated":"20231030005442"},"Children":[{"Type":"NodeText","Data":"在创建时间轮的构造器函数中，需要传入两个入参："}]},{"ID":"20231030005442-a6gvy63","Type":"NodeList","ListData":{},"Properties":{"id":"20231030005442-a6gvy63","updated":"20231030005453"},"Children":[{"ID":"20231030005453-l06mr56","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231030005453-l06mr56","updated":"20231030005453"},"Children":[{"ID":"20231030005453-gso928j","Type":"NodeParagraph","Properties":{"id":"20231030005453-gso928j","updated":"20231030005453"},"Children":[{"Type":"NodeText","Data":"slotNum：由使用方指定 slot 的个数，默认为 10"}]}]}]},{"ID":"20231030005442-szvjh3k","Type":"NodeList","ListData":{},"Properties":{"id":"20231030005442-szvjh3k","updated":"20231030005442"},"Children":[{"ID":"20231030005447-usclrka","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231030005447-usclrka"},"Children":[{"ID":"20231030005447-rpq8dok","Type":"NodeParagraph","Properties":{"id":"20231030005447-rpq8dok"},"Children":[{"Type":"NodeText","Data":"nterval：由使用方指定每个 slot 对应的时间范围，默认为 1 秒"}]}]}]},{"ID":"20231030005442-zp2z17b","Type":"NodeParagraph","Properties":{"id":"20231030005442-zp2z17b","updated":"20231030005442"},"Children":[{"Type":"NodeText","Data":"初始化时间轮实例的过程中，会完成定时器 ticker 以及各个 channel 的初始化，并针对数组 中的各个 slot 进行初始化，每个 slot 位置都需要填充一个 list."}]},{"ID":"20231030005442-omspsk7","Type":"NodeParagraph","Properties":{"id":"20231030005442-omspsk7","updated":"20231030005442"},"Children":[{"Type":"NodeText","Data":"每个时间轮实例都会异步调用 run 方法，启动一个常驻 goroutine 用于接收和处理定时任务."}]},{"ID":"20231106144703-ss3c1kg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231106144703-ss3c1kg","updated":"20231106145246"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 创建单机版时间轮 slotNum——时间轮环状数组长度  interval——扫描时间间隔\nfunc NewTimeWheel(slotNum int, interval time.Duration) *TimeWheel {\n\t// 环状数组长度默认为 10\n\tif slotNum \u003c= 0 {\n\t\tslotNum = 10\n\t}\n\t// 扫描时间间隔默认为 1 秒\n\tif interval \u003c= 0 {\n\t\tinterval = time.Second\n\t}\n\n\t// 初始化时间轮实例\n\tt := TimeWheel{\n\t\tinterval:     interval,\n\t\tticker:       time.NewTicker(interval),\n\t\tstopc:        make(chan struct{}),\n\t\tkeyToETask:   make(map[string]*list.Element),\n\t\tslots:        make([]*list.List, 0, slotNum),\n\t\taddTaskCh:    make(chan *taskElement),\n\t\tremoveTaskCh: make(chan string),\n\t}\n\tfor i := 0; i \u003c slotNum; i++ {\n\t\tt.slots = append(t.slots, list.New())\n\t}\n\n\t// 异步启动时间轮常驻 goroutine\n\tgo t.run()\n\treturn \u0026t\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231106145248-684qsrx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231106145248-684qsrx","updated":"20231106160417"},"Children":[{"Type":"NodeText","Data":"启动与停止"}]},{"ID":"20231106160418-g72zbf0","Type":"NodeParagraph","Properties":{"id":"20231106160418-g72zbf0","updated":"20231106160533"},"Children":[{"Type":"NodeText","Data":"时间轮运行的核心逻辑位于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"timeWhell.run"},{"Type":"NodeText","Data":"​ 方法中，该方法会通过 for 循环结合 select 多路复用的方式运行，属于 golang 中非常常见的异步编程风格。"}]},{"ID":"20231106160533-7d1ypws","Type":"NodeParagraph","Properties":{"id":"20231106160533-7d1ypws","updated":"20231106160633"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 运行过程中需要从以下四类 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​中接受不同的信号，并进行逻辑的分发处理："}]},{"ID":"20231106160641-2bl2zpx","Type":"NodeList","ListData":{},"Properties":{"id":"20231106160641-2bl2zpx","updated":"20231106160829"},"Children":[{"ID":"20231106160653-e5s960g","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231106160653-e5s960g","updated":"20231106160653"},"Children":[{"ID":"20231106160653-movk322","Type":"NodeParagraph","Properties":{"id":"20231106160653-movk322","updated":"20231106160755"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"stopc"},{"Type":"NodeText","Data":"​​：停止时间轮，使得当前"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​​退出"}]}]},{"ID":"20231106160755-o0s6zqz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231106160755-o0s6zqz","updated":"20231106160829"},"Children":[{"ID":"20231106160755-c1umhbj","Type":"NodeParagraph","Properties":{"id":"20231106160755-c1umhbj","updated":"20231107100005"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ticker"},{"Type":"NodeText","Data":"​​：接受到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ticker"},{"Type":"NodeText","Data":"​​的信号说明时间由往前推进了一个 interval，则需要批量检索并执行当前 slot 中的定时任务. 并推进指针 curSlot 往前偏移"}]}]},{"ID":"20231107100006-7vs98r1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107100006-7vs98r1"},"Children":[{"ID":"20231107100006-pdxyc1y","Type":"NodeParagraph","Properties":{"id":"20231107100006-pdxyc1y","updated":"20231107100040"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"addTaskCh"},{"Type":"NodeText","Data":"​：接收创建定时任务的指令"}]}]},{"ID":"20231107100040-2q8387g","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107100040-2q8387g"},"Children":[{"ID":"20231107100040-dcnisbi","Type":"NodeParagraph","Properties":{"id":"20231107100040-dcnisbi","updated":"20231107100121"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"removeTaskCh"},{"Type":"NodeText","Data":"​：接收删除定时任务的指令"}]}]}]},{"ID":"20231107100132-mz7al16","Type":"NodeParagraph","Properties":{"id":"20231107100132-mz7al16","updated":"20231107100133"},"Children":[{"Type":"NodeText","Data":"此处值得一提的是，后续不论是创建、删除还是检索定时任务，都是通过这个常驻 goroutine 完成的，因此在访问一些临界资源的时候，不需要加锁，因为不存在并发访问的情况"}]},{"ID":"20231107100200-8fg5urs","Type":"NodeParagraph","Properties":{"id":"20231107100200-8fg5urs","updated":"20231107100200"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231107100200-io4ywho.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231106160102-ckfo2mi","Type":"NodeParagraph","Properties":{"id":"20231106160102-ckfo2mi"}},{"ID":"20231106160045-9mlpf0a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231106160045-9mlpf0a","updated":"20231107110537"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 运行时间轮\nfunc (t *TimeWheel) run() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\t// ...\n\t\t}\n\t}()\n\n\t// 通过 for + select 的代码结构运行一个常驻 goroutine 是常规操作\n\tfor {\n\t\tselect {\n\t\t// 停止时间轮\n\t\tcase \u003c-t.stopc:\n\t\t\treturn\n\t\t// 接收到定时信号\n\t\tcase \u003c-t.ticker.C:\n\t\t\t// 批量执行定时任务\n\t\t\tt.tick()\n\t\t// 接收创建定时任务的信号\n\t\tcase task := \u003c-t.addTaskCh:\n\t\t\tt.addTask(task)\n\t\t// 接收到删除任务的定时信号\n\t\tcase removeKey := \u003c-t.removeTaskCh:\n\t\t\tt.removeTask(removeKey)\n\t\t}\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231107110515-dq50xq0","Type":"NodeParagraph","Properties":{"id":"20231107110515-dq50xq0","updated":"20231107110515"},"Children":[{"Type":"NodeText","Data":"时间轮提供了一个 Stop 方法，用于手动停止时间轮，回收对应的 goroutine 和 ticker 资源."}]},{"ID":"20231107110515-pj8qqkd","Type":"NodeParagraph","Properties":{"id":"20231107110515-pj8qqkd","updated":"20231107110515"},"Children":[{"Type":"NodeText","Data":"停止时间轮的操作是通过关闭 stopc channel 完成的，由于 channel 不允许被反复关闭，因此这里通过 sync.Once 保证该逻辑只被调用一次."}]},{"ID":"20231107110542-orhyukg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231107110542-orhyukg","updated":"20231107155126"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 停止时间轮\nfunc (t *TimeWheel) Stop() {\n\t//  通过单例工具，保证 channel 只能被关闭一次，避免 panic\n\tt.Do(func() {\n\t\t// 定制定时器 ticker\n\t\tt.ticker.Stop()\n\t\t// 关闭定时器运行的 stopc\n\t\tclose(t.stopc)\n\t})\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231107155131-bevkldy","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231107155131-bevkldy","updated":"20231107155142"},"Children":[{"Type":"NodeText","Data":"创建任务"}]},{"ID":"20231107155142-1iq62c1","Type":"NodeParagraph","Properties":{"id":"20231107155142-1iq62c1","updated":"20231107161315"},"Children":[{"Type":"NodeText","Data":"创建一笔定时任务的核心步骤如下："}]},{"ID":"20231107161315-owwuicv","Type":"NodeList","ListData":{},"Properties":{"id":"20231107161315-owwuicv","updated":"20231107161319"},"Children":[{"ID":"20231107161319-o3ne7bu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107161319-o3ne7bu","updated":"20231107161319"},"Children":[{"ID":"20231107161319-3xc0vpk","Type":"NodeParagraph","Properties":{"id":"20231107161319-3xc0vpk","updated":"20231107161408"},"Children":[{"Type":"NodeText","Data":"使用方往 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"addTaskCh"},{"Type":"NodeText","Data":"​ 中投递定时任务，由常驻 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 接收定时任务"}]}]},{"ID":"20231107161409-vjjbbud","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107161409-vjjbbud"},"Children":[{"ID":"20231107161409-g2eakpc","Type":"NodeParagraph","Properties":{"id":"20231107161409-g2eakpc","updated":"20231107161456"},"Children":[{"Type":"NodeText","Data":"根据执行时间，推算出定时任务所处的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slot"},{"Type":"NodeText","Data":"​ 位置以及需要延迟的轮次 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"cycle"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20231107161445-8y9svmq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107161445-8y9svmq"},"Children":[{"ID":"20231107161445-h3yayi2","Type":"NodeParagraph","Properties":{"id":"20231107161445-h3yayi2","updated":"20231107161543"},"Children":[{"Type":"NodeText","Data":"将定时任务包装成就一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list node"},{"Type":"NodeText","Data":"​，追加到对应 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slot"},{"Type":"NodeText","Data":"​ 位置的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list"},{"Type":"NodeText","Data":"​ 尾部"}]}]},{"ID":"20231107161544-dgkfw27","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107161544-dgkfw27"},"Children":[{"ID":"20231107161544-a263tsk","Type":"NodeParagraph","Properties":{"id":"20231107161544-a263tsk","updated":"20231107161700"},"Children":[{"Type":"NodeText","Data":"以定时任务唯一键为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"key"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list node"},{"Type":"NodeText","Data":"​ 为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"value"},{"Type":"NodeText","Data":"​，在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"keyToETask map"},{"Type":"NodeText","Data":"​ 中建立映射关系，方便后续删除任务时使用"}]}]}]},{"ID":"20231107161711-1qnlvq2","Type":"NodeParagraph","Properties":{"id":"20231107161711-1qnlvq2","updated":"20231107161711"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231107161711-15xefty.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231107161712-yfolo12","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231107161712-yfolo12","updated":"20231107161712"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}