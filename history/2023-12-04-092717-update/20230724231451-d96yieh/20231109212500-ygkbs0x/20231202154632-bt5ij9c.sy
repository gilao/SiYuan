{"ID":"20231202154632-bt5ij9c","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231202154632-bt5ij9c","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20231202154632-bt5ij9c\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231202154656-8xsv8yn\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231203171001-ncjvpue\u0026quot;,\u0026quot;scrollTop\u0026quot;:6742,\u0026quot;focusId\u0026quot;:\u0026quot;20231202154656-8xsv8yn\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","title":"Go 使用标准库 net http 包构建服务器","updated":"20231204092315"},"Children":[{"ID":"20231202154656-8xsv8yn","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231202154656-8xsv8yn","updated":"20231202154704"},"Children":[{"Type":"NodeText","Data":"概念"}]},{"ID":"20231202154632-vayagyv","Type":"NodeParagraph","Properties":{"id":"20231202154632-vayagyv","updated":"20231202155308"},"Children":[{"Type":"NodeText","Data":"在 Go 语言中，使用标准库 net/http 可以很方便的构建服务器，只要调用 ListenAndServe 函数，并传入参数IP地址与端口组成的字符串和处理器（handler）即可。"}]},{"ID":"20231202155631-0fm21nf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231202155631-0fm21nf","updated":"20231202162950"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func ListenAndServe(addr string, handler Handler) error\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231202163011-qa56mdw","Type":"NodeParagraph","Properties":{"id":"20231202163011-qa56mdw","updated":"20231202163011"},"Children":[{"Type":"NodeText","Data":"如果 IP 地址与端口组成的字符串参数为空字符串，那么服务器默认使用 80 端口进行网络连接，如果处理器（handler）参数为 nil，那么服务器将使用默认多路复用器 DefaultServeMux。"}]},{"ID":"20231202163014-y0c6488","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231202163014-y0c6488","updated":"20231202163027"},"Children":[{"Type":"NodeText","Data":"构建服务器"}]},{"ID":"20231202163027-9q2ejk6","Type":"NodeParagraph","Properties":{"id":"20231202163027-9q2ejk6","updated":"20231202163039"},"Children":[{"Type":"NodeText","Data":"Go 语言为我们提供了一个结构体 Server，其中包含了很多对服务器的其它配置，结构体 Server 的完整代码如下："}]},{"ID":"20231202163040-sly2xfg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231202163040-sly2xfg","updated":"20231202164759"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Server struct {\n\tAddr              string\n\tHandler           Handler\n\tTLSConfig         *tls.Config\n\tReadTimeout       time.Duration\n\tReadHeaderTimeout time.Duration\n\tWriteTimeout      time.Duration\n\tIdleTimeout       time.Duration\n\tMaxHeaderBytes    int\n\tTLSNextProto      map[string]func(*Server, *tls.Conn, Handler)\n\tConnState         func(listener net.Listener) context.Context\n\tErrorLog          *log.Logger\n\tBaseContext       func(listener net.Listener) context.Context\n\tConnContext       func(ctx context.Context, c net.Conn) context.Context\n\tinShutdown        atomic.Bool\n\tdisableKeepAlives int32\n\tnextProtoOnce     sync.Once\n\tnextProtoErr      error\n\tmu                sync.Mutex\n\tlisteners         map[*net.Listener]struct{}\n\tactiveConn        map[*conn]struct{}\n\tdoneChan          chan struct{}\n\tonShutdown        []func()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231202164856-9uc1dfp","Type":"NodeParagraph","Properties":{"id":"20231202164856-9uc1dfp","updated":"20231202164856"},"Children":[{"Type":"NodeText","Data":"使用结构体 Server 构建服务器："}]},{"ID":"20231202164857-q63ixd7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231202164857-q63ixd7","updated":"20231202165008"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"server := http.Server{\n\tAddr: \":8080\",\n\tHandler: nil,\n}\nserver.ListenAndServe()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231202165031-9s6kfxv","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231202165031-9s6kfxv","updated":"20231202165038"},"Children":[{"Type":"NodeText","Data":"接收HTTP 请求"}]},{"ID":"20231202165048-1aibdel","Type":"NodeParagraph","Properties":{"id":"20231202165048-1aibdel","updated":"20231202165048"},"Children":[{"Type":"NodeText","Data":"在 Go 语言中，一个处理器就是一个拥有 ServeHTTP 方法的接口，这个 ServeHTTP 方法需要接收两个参数，第一个参数是一个 ResponseWriter 接口，第二个参数是一个指向 Request 结构的指针。"}]},{"ID":"20231202165054-c9uxvu8","Type":"NodeParagraph","Properties":{"id":"20231202165054-c9uxvu8"}},{"ID":"20231202165048-duzvyel","Type":"NodeParagraph","Properties":{"id":"20231202165048-duzvyel","updated":"20231202165048"},"Children":[{"Type":"NodeText","Data":"DefaultServeMux 默认多路复用器是多路复用器 ServeMux 结构的一个实例，ServeMux 也拥有 ServeHTTP 方法。"}]},{"ID":"20231202165055-3inuob2","Type":"NodeParagraph","Properties":{"id":"20231202165055-3inuob2"}},{"ID":"20231202165048-n0u35ay","Type":"NodeParagraph","Properties":{"id":"20231202165048-n0u35ay","updated":"20231203141640"},"Children":[{"Type":"NodeText","Data":"所以 DefaultServeMux 既是 ServeMux 结构的实例，也是处理器 Handler 结构的实例，因此 DefaultServeMux 不仅是一个多路复用器，还是一个处理器。但是 DefaultServeMux  是一个特殊的处理器，它唯一要做的就是根据请求的 URL 将请求重定向到不同的处理器。"}]},{"ID":"20231202165057-7yw19m4","Type":"NodeParagraph","Properties":{"id":"20231202165057-7yw19m4"}},{"ID":"20231202165048-hi75fdq","Type":"NodeParagraph","Properties":{"id":"20231202165048-hi75fdq","updated":"20231202165048"},"Children":[{"Type":"NodeText","Data":"自定义一个处理器，替代 DefaultServeMux。"}]},{"ID":"20231202165239-dzfdk1k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231202165239-dzfdk1k","updated":"20231202165401"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type MyHandler struct {\n\n}\n\nfunc (h *MyHandler) ServerHTTP(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World!\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231202165402-x62makz","Type":"NodeParagraph","Properties":{"id":"20231202165402-x62makz","updated":"20231202165412"},"Children":[{"Type":"NodeText","Data":"使用自定义处理器，配置服务器。"}]},{"ID":"20231202165412-oxkz4yf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231202165412-oxkz4yf","updated":"20231202165536"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"handler := MyHandler{}\nserver := http.Server{\n\tAddr: \"127.0.0.1:8080\",\n\tHandler: \u0026handler\n}\n\nserver.ListenAndServe()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231202165537-d9ojyg4","Type":"NodeParagraph","Properties":{"id":"20231202165537-d9ojyg4","updated":"20231202165544"},"Children":[{"Type":"NodeText","Data":"细心的读者可能已经发现，使用自定义的处理器与服务器进行绑定，启动服务器，不管浏览器访问什么地址，服务器返回的都是同样的响应 Hello World!"}]},{"ID":"20231202165701-88g7t9d","Type":"NodeParagraph","Properties":{"id":"20231202165701-88g7t9d","updated":"20231202165711"},"Children":[{"Type":"NodeText","Data":"这是因为使用自定义的处理器替代了默认多路复用器 DefaultServeMux，服务器不会再通过 URL 匹配来将请求路由至不同的处理器。"}]},{"ID":"20231202212737-9w2f8d4","Type":"NodeParagraph","Properties":{"id":"20231202212737-9w2f8d4","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"怎么解决这个问题呢？"}]},{"ID":"20231202212737-hnlsfmv","Type":"NodeParagraph","Properties":{"id":"20231202212737-hnlsfmv","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"使用多个处理器。使用 http 包的 Handle 函数绑定到 DefaultServeMux。"}]},{"ID":"20231202212737-6zu4grs","Type":"NodeParagraph","Properties":{"id":"20231202212737-6zu4grs","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"为了使用多个处理器去处理不同的 URL，我们不再在 Serve 结构的 Handler 字段中指定处理器，而是让服务器使用默认多路复用器 DefaultServeMux，然后通过 http.Handle 函数将处理器绑定到 DefaultServeMux。"}]},{"ID":"20231203142218-yk3almn","Type":"NodeParagraph","Properties":{"id":"20231203142218-yk3almn"},"Children":[{"Type":"NodeText","Data":"http 包的 Handle 函数实际上是 ServeMux 结构的方法，为了操作便利而创建的函数，调用它们等同于调用 DefaultServeMux 的某个方法。"}]},{"ID":"20231203142309-nru3uy7","Type":"NodeParagraph","Properties":{"id":"20231203142309-nru3uy7"}},{"ID":"20231202212737-mrd742y","Type":"NodeParagraph","Properties":{"id":"20231202212737-mrd742y","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"例如，调用 http.Handle，实际上就是在调用 DefaultServeMux 的 Handle 方法。"}]},{"ID":"20231203142313-p10lacc","Type":"NodeParagraph","Properties":{"id":"20231203142313-p10lacc"}},{"ID":"20231202212737-gnecm39","Type":"NodeParagraph","Properties":{"id":"20231202212737-gnecm39","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20231202212737-4k5i09f","Type":"NodeParagraph","Properties":{"id":"20231202212737-4k5i09f","updated":"20231202212737"},"Children":[{"Type":"NodeText","Data":"编写多个处理器，处理请求"}]},{"ID":"20231203142316-q2mb9wn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231203142316-q2mb9wn","updated":"20231203145403"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type FirstHandler struct {\n\n}\n\nfunc (f *FirstHandler) ServerHTTP(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"FirstHandler\")\n}\n\ntype SecondHandler struct {\n\n}\n\nfunc (s *SecondHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w,\"SecondHandler\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231203145406-2890vki","Type":"NodeParagraph","Properties":{"id":"20231203145406-2890vki","updated":"20231203145417"},"Children":[{"Type":"NodeText","Data":"构建服务器："}]},{"ID":"20231203145417-lmqvetj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231203145417-lmqvetj","updated":"20231203150532"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"first := FirstHandler{}\nsecond := SecondHandler{}\n\nserver := http.Server{\n\tAddr: \"127.0.0.1:8080\",\n}\n\n// httop.Handle 函数\nhttp.Handle(\"/first\", \u0026first)\nhttp.Handle(\"/second\", \u0026second)\n\nserver.ListenAndServe()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231203150550-ck5r8w7","Type":"NodeParagraph","Properties":{"id":"20231203150550-ck5r8w7"}},{"ID":"20231203150543-a54jcji","Type":"NodeParagraph","Properties":{"id":"20231203150543-a54jcji","updated":"20231203150543"},"Children":[{"Type":"NodeText","Data":"以上我们通过使用 http.Handle 函数，将一个创建的处理器绑定到一个 URL 上，实现使用多个处理器处理不同的 URL。"}]},{"ID":"20231203150545-a8yimbt","Type":"NodeParagraph","Properties":{"id":"20231203150545-a8yimbt"}},{"ID":"20231203150543-whbf3v1","Type":"NodeParagraph","Properties":{"id":"20231203150543-whbf3v1","updated":"20231203150543"},"Children":[{"Type":"NodeText","Data":"现在，可能有读者会说，创建多个处理器来处理多个请求，这也太不优雅了，有没有其它方式呢？"}]},{"ID":"20231203150553-e0m74ea","Type":"NodeParagraph","Properties":{"id":"20231203150553-e0m74ea"}},{"ID":"20231203150543-y40ck17","Type":"NodeParagraph","Properties":{"id":"20231203150543-y40ck17","updated":"20231203150543"},"Children":[{"Type":"NodeText","Data":"先告诉大家答案，有其它方式，使用处理器函数。"}]},{"ID":"20231203150554-4ksedkh","Type":"NodeParagraph","Properties":{"id":"20231203150554-4ksedkh"}},{"ID":"20231203150543-x0artui","Type":"NodeParagraph","Properties":{"id":"20231203150543-x0artui","updated":"20231203150543"},"Children":[{"Type":"NodeText","Data":"http.HandleFunc 函数将自定义函数转换成一个处理器 Handler，并将它与 DefaultServeMux 进行绑定，从而简化创建并绑定 Handler 的工作。"}]},{"ID":"20231203150543-ol0g6fj","Type":"NodeParagraph","Properties":{"id":"20231203150543-ol0g6fj","updated":"20231203150543"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20231203150543-mi0dker","Type":"NodeParagraph","Properties":{"id":"20231203150543-mi0dker","updated":"20231203150543"},"Children":[{"Type":"NodeText","Data":"编写多个函数，处理请求"}]},{"ID":"20231203150612-0xio8g4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231203150612-0xio8g4","updated":"20231203151112"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func first(w http.ResponseWriter,r *http.Request) {\n\tfmt.Fprintf(w, \"func first\")\n}\n\nfunc second(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"func second\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231203150628-ll5o5re","Type":"NodeParagraph","Properties":{"id":"20231203150628-ll5o5re","updated":"20231203151121"},"Children":[{"Type":"NodeText","Data":"构建服务器："}]},{"ID":"20231203151121-7m7um89","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231203151121-7m7um89","updated":"20231203151134"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"server := http.Server{\n    Addr: \"127.0.0.1:8080\",\n}\n\n// http.HandleFunc\nhttp.HandleFunc(\"/first\", first)\nhttp.HandleFunc(\"/second\", second)\n\nserver.ListenAndServe()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231203151213-nt4ny77","Type":"NodeParagraph","Properties":{"id":"20231203151213-nt4ny77","updated":"20231203151213"},"Children":[{"Type":"NodeText","Data":"使用处理器函数和使用处理器，都可以实现根据请求的 URL 将请求重定向到不同的处理器，而且处理器函数比处理器的代码更为简洁。"}]},{"ID":"20231203151215-q5sisel","Type":"NodeParagraph","Properties":{"id":"20231203151215-q5sisel"}},{"ID":"20231203151213-maxovk1","Type":"NodeParagraph","Properties":{"id":"20231203151213-maxovk1","updated":"20231203151213"},"Children":[{"Type":"NodeText","Data":"但是也不是完全使用处理器函数代替处理器，因为如果代码已经包含了某个接口或某种类型，我们只需为它们添加 ServeHTTP 方法就可以将它们转变为处理器。"}]},{"ID":"20231203151217-ton8dir","Type":"NodeParagraph","Properties":{"id":"20231203151217-ton8dir"}},{"ID":"20231203151213-lw2ny70","Type":"NodeParagraph","Properties":{"id":"20231203151213-lw2ny70","updated":"20231203151213"},"Children":[{"Type":"NodeText","Data":"ServeMux 无法使用变量实现 URL 模式匹配，使用三方多路复用器 httprouter 包可以实现 URL 模式匹配。此外，还有一个非常优秀的三方多路复用器，gorilla/mux。篇幅限制，这里就不展开了。"}]},{"ID":"20231203151905-a70u4hu","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231203151905-a70u4hu","updated":"20231203151919"},"Children":[{"Type":"NodeText","Data":"处理HTTP 请求"}]},{"ID":"20231203151939-u9vonns","Type":"NodeParagraph","Properties":{"id":"20231203151939-u9vonns","updated":"20231203151948"},"Children":[{"Type":"NodeText","Data":"客户端和服务器端传递的消息，我们称之为 HTTP 报文，有两种类型，分别是 HTTP 请求和 HTTP 响应，并且这两种类型的结构相同。"}]},{"ID":"20231203151953-ox71159","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231203151953-ox71159","updated":"20231203151953"},"Children":[{"ID":"20231203151953-jvesv0k","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231203151953-jvesv0k","updated":"20231203151953"},"Children":[{"ID":"20231203151953-40g7xne","Type":"NodeParagraph","Properties":{"id":"20231203151953-40g7xne","updated":"20231203151953"},"Children":[{"Type":"NodeText","Data":"请求行/响应行"}]}]},{"ID":"20231203151953-orybdyd","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231203151953-orybdyd","updated":"20231203151953"},"Children":[{"ID":"20231203151953-m6nslxb","Type":"NodeParagraph","Properties":{"id":"20231203151953-m6nslxb","updated":"20231203151953"},"Children":[{"Type":"NodeText","Data":"零个/多个首部"}]}]},{"ID":"20231203151953-8b1uexw","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20231203151953-8b1uexw","updated":"20231203151953"},"Children":[{"ID":"20231203151953-s02otzm","Type":"NodeParagraph","Properties":{"id":"20231203151953-s02otzm","updated":"20231203151953"},"Children":[{"Type":"NodeText","Data":"一个空行"}]}]},{"ID":"20231203151953-r89h12w","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20231203151953-r89h12w","updated":"20231203151953"},"Children":[{"ID":"20231203151953-ybfk4ul","Type":"NodeParagraph","Properties":{"id":"20231203151953-ybfk4ul","updated":"20231203151953"},"Children":[{"Type":"NodeText","Data":"一个可选的报文主体"}]}]}]},{"ID":"20231203151955-26dsmbc","Type":"NodeParagraph","Properties":{"id":"20231203151955-26dsmbc","updated":"20231203152002"},"Children":[{"Type":"NodeText","Data":"在 Go 语言中，标准库 net/http 提供了一系列用于表示 HTTP 报文的结构体。其中，Request 结构体代表 HTTP 请求报文。"}]},{"ID":"20231203164729-3hr3nna","Type":"NodeParagraph","Properties":{"id":"20231203164729-3hr3nna"}},{"ID":"20231203164727-fwf0ohi","Type":"NodeParagraph","Properties":{"id":"20231203164727-fwf0ohi","updated":"20231203164727"},"Children":[{"Type":"NodeText","Data":"Request 结构体的组成部分："}]},{"ID":"20231203164727-in9499p","Type":"NodeList","ListData":{},"Properties":{"id":"20231203164727-in9499p","updated":"20231203164727"},"Children":[{"ID":"20231203164727-oj7h4vl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231203164727-oj7h4vl","updated":"20231203164727"},"Children":[{"ID":"20231203164727-cyvp62b","Type":"NodeParagraph","Properties":{"id":"20231203164727-cyvp62b","updated":"20231203164727"},"Children":[{"Type":"NodeText","Data":"URL 字段"}]}]},{"ID":"20231203164727-7etn1qo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231203164727-7etn1qo","updated":"20231203164727"},"Children":[{"ID":"20231203164727-jf59llj","Type":"NodeParagraph","Properties":{"id":"20231203164727-jf59llj","updated":"20231203164727"},"Children":[{"Type":"NodeText","Data":"Header 字段"}]}]},{"ID":"20231203164727-o1d1o2m","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231203164727-o1d1o2m","updated":"20231203164727"},"Children":[{"ID":"20231203164727-ujb67l3","Type":"NodeParagraph","Properties":{"id":"20231203164727-ujb67l3","updated":"20231203164727"},"Children":[{"Type":"NodeText","Data":"Body 字段"}]}]},{"ID":"20231203164727-o1n8blh","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231203164727-o1n8blh","updated":"20231203164727"},"Children":[{"ID":"20231203164727-ctwynca","Type":"NodeParagraph","Properties":{"id":"20231203164727-ctwynca","updated":"20231203164727"},"Children":[{"Type":"NodeText","Data":"Form 字段、PostForm 字段和 MultipartForm 字段"}]}]}]},{"ID":"20231203170121-k5qmlpf","Type":"NodeParagraph","Properties":{"id":"20231203170121-k5qmlpf","updated":"20231203170122"},"Children":[{"Type":"NodeText","Data":"请求/响应的首部都是使用 Header 类型描述，Header 类型使用一个 map 来表示 HTTP 首部中的多个键值对。Header 类型有 4 个基本方法，这些方法可以根据给定的键执行添加、删除、获取和设置等操作。"}]},{"ID":"20231203170204-lww2byt","Type":"NodeParagraph","Properties":{"id":"20231203170204-lww2byt","updated":"20231203170214"},"Children":[{"Type":"NodeText","Data":"获取请求首部得示例代码："}]},{"ID":"20231203170215-x8xeu9d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231203170215-x8xeu9d","updated":"20231203170954"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func headers(w http.ResponseWriter, r *http.Request) {\n\th := r.Header\n\tfmt.Fprintln(w,h)\n\th2 := r.Header[\"User-Agent\"]\n\tfmt.Fprintln(w, h2)\n\th3 := r.Header.Get(\"User-Agent\")\n\tfmt.Fprintln(w,h3)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231203170956-7tb357h","Type":"NodeParagraph","Properties":{"id":"20231203170956-7tb357h","updated":"20231203171001"},"Children":[{"Type":"NodeText","Data":"构建服务器"}]},{"ID":"20231203171001-ncjvpue","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231203171001-ncjvpue","updated":"20231204091652"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"server := http.Server{\n\tAddr: \"127.0.0.1:8080\",\n}\nhttp.HandleFunc(\"/headers\",headers)\nserver.ListenAndServe()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231204091653-fvw79we","Type":"NodeParagraph","Properties":{"id":"20231204091653-fvw79we","updated":"20231204091659"},"Children":[{"Type":"NodeText","Data":"代码中，通过 r.Header 获取所有首部，通过 r.Header[\"key\"] 获取指定的首部，直接引用 Header 获取的是一个字符串切片，如果我们需要获取字符串格式的首部值，可以使用 r.Header.Get(\"key\") 方法。"}]},{"ID":"20231204091724-gc6hub5","Type":"NodeParagraph","Properties":{"id":"20231204091724-gc6hub5","updated":"20231204091724"},"Children":[{"Type":"NodeText","Data":"请求/响应的主体都是用 Request 结构体的 Body 字段表示，这个字段是一个io.ReadCloser 接口，该接口即包含了 Reader 接口，也包含了 Closer 接口。其中 Reader 接口有 Read 方法，该方法接收一个字节切片参数，返回一个被读取内容的字节数和一个可选的错误。"}]},{"ID":"20231204091726-sw3wct0","Type":"NodeParagraph","Properties":{"id":"20231204091726-sw3wct0","updated":"20231204091729"},"Children":[{"Type":"NodeText","Data":"获取请求主体中的数据的代码："}]},{"ID":"20231204091737-tm3pyq6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231204091737-tm3pyq6","updated":"20231204092022"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func body(w http.ResponseWriter, r *http.Request) {\n\tlen  := r.ContentLength\n\tbody := make([]byte, len)\n\tr.Body.Read(body)\n\tfmt.Fprintln(w, string(body))\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231204092025-kf5pvst","Type":"NodeParagraph","Properties":{"id":"20231204092025-kf5pvst","updated":"20231204092031"},"Children":[{"Type":"NodeText","Data":"构建服务器："}]},{"ID":"20231204092033-usxekub","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231204092033-usxekub","updated":"20231204092144"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"server := http.Server{\n\t\tAddr: \"127.0.0.1:8080\",\n}\nhttp.HandleFunc(\"/body\",body)\nserver.ListenAndServe()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231204092135-p9c6lil","Type":"NodeParagraph","Properties":{"id":"20231204092135-p9c6lil","updated":"20231204092257"},"Children":[{"Type":"NodeText","Data":"代码中，通过 r.ContentLength 方法获取主体数据的字节长度，然后根据字节长度创建一个字节数组，然后调用 Read 方法将主体数据读取到字节数组中。"}]},{"ID":"20231204092258-0wul3b0","Type":"NodeParagraph","Properties":{"id":"20231204092258-0wul3b0","updated":"20231204092308"},"Children":[{"Type":"NodeText","Data":"可能有的读者朋友们开始抱怨了，这也太麻烦了。别担心，Go 语言标准库net/http 提供了相关函数来满足用户对数据提取方面的需求，通过调用 Request 结构体提供的方法，可以将 URL、主体的数据提取到该结构体的 Form、PostForm 和 MultipartForm 等字段中。"}]},{"ID":"20231204092313-s1tjkd8","Type":"NodeParagraph","Properties":{"id":"20231204092313-s1tjkd8","updated":"20231204092313"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20231204092313-qcw5u3h","Type":"NodeParagraph","Properties":{"id":"20231204092313-qcw5u3h","updated":"20231204092313"},"Children":[{"Type":"NodeText","Data":"使用 Request 结构体提供的方法提取数据（enctype 属性的值为application/x-www-form-urlencoded）"}]},{"ID":"20231204092315-fwrpwag","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231204092315-fwrpwag","updated":"20231204092315"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}