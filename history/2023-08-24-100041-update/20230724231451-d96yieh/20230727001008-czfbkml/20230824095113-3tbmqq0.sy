{"ID":"20230824095113-3tbmqq0","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230824095113-3tbmqq0","title":"36. 构建连接池","updated":"20230824100040"},"Children":[{"ID":"20230824095514-q45mt53","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230824095514-q45mt53","updated":"20230824095540"},"Children":[{"Type":"NodeText","Data":"创建连接池"}]},{"ID":"20230824095113-dft2t72","Type":"NodeParagraph","Properties":{"id":"20230824095113-dft2t72","updated":"20230824095202"},"Children":[{"Type":"NodeText","Data":"可以使用 sync.Pool和自定义结构来实现。"}]},{"ID":"20230824095254-l8pzrwb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230824095254-l8pzrwb","updated":"20230824095302"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\n// Connection 是一个模拟的连接结构体\ntype Connection struct {\n    ID int\n}\n\nfunc main() {\n    // 创建连接池\n    connectionPool := \u0026sync.Pool{\n       New: func() interface{} {\n          // 创建新的连接\n          fmt.Println(\"创建新的连接\")\n          return \u0026Connection{}\n       },\n    }\n\n    // 从连接池获取连接\n    conn1 := connectionPool.Get().(*Connection)\n    conn1.ID = 1\n    fmt.Printf(\"从连接池获取连接: %v\\n\", conn1)\n\n    // 归还连接到连接池\n    connectionPool.Put(conn1)\n    fmt.Printf(\"归还连接到连接池: %v\\n\", conn1)\n\n    // 重新获取连接，应该是之前归还的连接\n    conn2 := connectionPool.Get().(*Connection)\n    fmt.Printf(\"重新获取连接: %v\\n\", conn2)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230824095408-14rsoak","Type":"NodeParagraph","Properties":{"id":"20230824095408-14rsoak","updated":"20230824095414"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"我们创建了一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Connection"},{"Type":"NodeText","Data":"​ 结构体，它表示一个连接对象。然后，使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"sync.Pool"},{"Type":"NodeText","Data":"​ 创建一个连接池 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"connectionPool"},{"Type":"NodeText","Data":"​，其中的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"New"},{"Type":"NodeText","Data":"​ 函数用于在需要时创建新的连接对象。使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Get()"},{"Type":"NodeText","Data":"​ 方法从连接池中获取连接，使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Put()"},{"Type":"NodeText","Data":"​ 方法将连接归还到连接池中。"}]},{"ID":"20230824095408-7ioarpb","Type":"NodeParagraph","Properties":{"id":"20230824095408-7ioarpb","updated":"20230824095408"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"需要注意的是，连接池中的对象可能会在某些情况下被清理，因此不应该依赖于连接池中对象的生存时间。连接池主要用于提高性能，减少创建和销毁对象的开销。"}]},{"ID":"20230824095409-5d22erg","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230824095409-5d22erg","updated":"20230824095648"},"Children":[{"Type":"NodeText","Data":"gRPC 连接池"}]},{"ID":"20230824095649-hlw4z3d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230824095649-hlw4z3d","updated":"20230824100040"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\nimport (\n    \"log\"\n    \"sync\"\n\n    \"google.golang.org/grpc\"\n)\n\nvar (\n    pool *sync.Pool\n)\n\nfunc main() {\n     // 初始化连接池\n     pool = \u0026sync.Pool{\n         New: func() interface{} {\n              // 创建新的gRPC\n     }\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}