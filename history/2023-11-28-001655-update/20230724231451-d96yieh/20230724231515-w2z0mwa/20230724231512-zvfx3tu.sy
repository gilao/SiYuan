{"ID":"20230724231512-zvfx3tu","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f9a2","id":"20230724231512-zvfx3tu","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230724231512-zvfx3tu\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230724231513-77m6odn\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230724231514-evk8nnk\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230724231513-77m6odn\u0026quot;,\u0026quot;focusStart\u0026quot;:4,\u0026quot;focusEnd\u0026quot;:4\u0026#125;","tags":"公众号-小徐先生的编程世界,设计模式-单例模式","title":"4-Go 单例模式","updated":"20231128001653"},"Children":[{"ID":"20230724231513-77m6odn","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230724231513-77m6odn","updated":"20231127212707"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/KRgNwJt1C7q2ckeqCu9pCQ","TextMarkTextContent":"Go 单例模式"},{"Type":"NodeText","Data":"背景"}]},{"ID":"20231127212707-32wn1yt","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231127212707-32wn1yt","updated":"20231127220841"},"Children":[{"Type":"NodeText","Data":"应用背景"}]},{"ID":"20230724231514-evk8nnk","Type":"NodeParagraph","Properties":{"id":"20230724231514-evk8nnk","updated":"20231127220905"},"Children":[{"Type":"NodeText","Data":"单例模式是一类最经典最简单的设计模式. 在单例模式下，我们声明一个类并保证这个类只存在全局唯一的实例供外部反复使用.\n单例模式的适用场景包括："}]},{"ID":"20231127220921-zro6095","Type":"NodeList","ListData":{},"Properties":{"id":"20231127220921-zro6095","updated":"20231127220925"},"Children":[{"ID":"20231127220921-2xldbb0","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231127220921-2xldbb0","updated":"20231127220923"},"Children":[{"ID":"20231127220911-rsk5rpo","Type":"NodeParagraph","Properties":{"id":"20231127220911-rsk5rpo","updated":"20231127220923"},"Children":[{"Type":"NodeText","Data":"一些只允许存在一个实例的类，比如全局统一的监控统计模块"}]}]},{"ID":"20231127220921-7dawjiu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231127220921-7dawjiu","updated":"20231127220924"},"Children":[{"ID":"20231127220913-fc57za6","Type":"NodeParagraph","Properties":{"id":"20231127220913-fc57za6","updated":"20231127220924"},"Children":[{"Type":"NodeText","Data":"一些实例化时很耗费资源的类，比如协程池、连接池、和第三方交互的客户端等"}]}]},{"ID":"20231127220921-kcpasja","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231127220921-kcpasja","updated":"20231127220925"},"Children":[{"ID":"20231127220914-17ykowz","Type":"NodeParagraph","Properties":{"id":"20231127220914-17ykowz","updated":"20231127220925"},"Children":[{"Type":"NodeText","Data":"一些入参繁杂的系统模块组件，比如 controller、service、dao 等"}]}]}]},{"ID":"20231127220909-po7xqhb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231127220909-po7xqhb","updated":"20231127220952"},"Children":[{"Type":"NodeText","Data":"实现模式"}]},{"ID":"20231127220952-cgbq8y6","Type":"NodeParagraph","Properties":{"id":"20231127220952-cgbq8y6","updated":"20231128000305"},"Children":[{"Type":"NodeText","Data":" 在单例模式的实现上，可以分为饿汉式和懒汉式两种类型："}]},{"ID":"20231128000312-14s4ltu","Type":"NodeList","ListData":{},"Properties":{"id":"20231128000312-14s4ltu"},"Children":[{"ID":"20231128000312-rvf4jjf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231128000312-rvf4jjf"},"Children":[{"ID":"20231128000306-sciblta","Type":"NodeParagraph","Properties":{"id":"20231128000306-sciblta","updated":"20231128000314"},"Children":[{"Type":"NodeText","Data":"饿汉式：从一开始就完成单例的初始化工作，以备不时之需（肚子饿了，先干为敬.）"}]}]},{"ID":"20231128000312-4k687ia","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231128000312-4k687ia"},"Children":[{"ID":"20231128000307-097pqv9","Type":"NodeParagraph","Properties":{"id":"20231128000307-097pqv9","updated":"20231128000315"},"Children":[{"Type":"NodeText","Data":"懒汉式：贯彻佛系思想，不到逼不得已（需要被使用了），不执行单例的初始化工作"}]}]}]},{"ID":"20231128000318-apf5e9q","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231128000318-apf5e9q","updated":"20231128000419"},"Children":[{"Type":"NodeText","Data":"饿汉式单例模式"}]},{"ID":"20231128000419-vh6lohd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231128000419-vh6lohd","updated":"20231128000427"},"Children":[{"Type":"NodeText","Data":"饿汉式实现流程"}]},{"ID":"20231128000435-wek98i5","Type":"NodeParagraph","Properties":{"id":"20231128000435-wek98i5","updated":"20231128000435"},"Children":[{"Type":"NodeText","Data":"饿汉式和懒汉式中的“饿”和“懒”体现在单例初始化时机的不同. “饿” 指的是，对于单例对象而言，不论其后续有没有被使用到以及何时才会被使用到，都会在程序启动之初完成其初始化工作."}]},{"ID":"20231128000435-xd0j3fp","Type":"NodeParagraph","Properties":{"id":"20231128000435-xd0j3fp","updated":"20231128000435"},"Children":[{"Type":"NodeText","Data":"在实现上，可以将饿汉式单例模式的执行步骤拆解如下："}]},{"ID":"20231128000507-rfkmf43","Type":"NodeList","ListData":{},"Properties":{"id":"20231128000507-rfkmf43","updated":"20231128000507"},"Children":[{"ID":"20231128000507-agwp7xx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231128000507-agwp7xx","updated":"20231128000507"},"Children":[{"ID":"20231128000507-4b1dvtf","Type":"NodeParagraph","Properties":{"id":"20231128000507-4b1dvtf","updated":"20231128000507"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"单例类和构造方法声明为不可导出类型，避免被外部直接获取到（避免让外界拥有直接初始化的能力，导致单例模式被破坏）"}]}]},{"ID":"20231128000507-izhlx9j","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231128000507-izhlx9j","updated":"20231128000507"},"Children":[{"ID":"20231128000507-y02t8f1","Type":"NodeParagraph","Properties":{"id":"20231128000507-y02t8f1","updated":"20231128000507"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在代码启动之初，就初始化好一个全局单一的实例，作为后续所谓的“单例”"}]}]},{"ID":"20231128000507-bvxj12e","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231128000507-bvxj12e","updated":"20231128000507"},"Children":[{"ID":"20231128000507-8xsddwu","Type":"NodeParagraph","Properties":{"id":"20231128000507-8xsddwu","updated":"20231128000507"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"暴露一个可导出的单例获取方法 GetXXX()，用于返回这个单例对象"}]}]}]},{"ID":"20231128000558-g6zobqu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231128000558-g6zobqu","updated":"20231128000632"},"Children":[{"Type":"NodeText","Data":"饿汉式实现源码"}]},{"ID":"20231128000642-eochakq","Type":"NodeParagraph","Properties":{"id":"20231128000642-eochakq","updated":"20231128000642"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231128000642-70xzz17.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231128000812-emwfgdf","Type":"NodeParagraph","Properties":{"id":"20231128000812-emwfgdf","updated":"20231128000812"},"Children":[{"Type":"NodeText","Data":"下面给出实现饿汉式单例模式的代码示例："}]},{"ID":"20231128000812-7eqgbjl","Type":"NodeParagraph","Properties":{"id":"20231128000812-7eqgbjl","updated":"20231128000812"},"Children":[{"Type":"NodeText","Data":"• singleton 是需要被单例模式保护的类型"}]},{"ID":"20231128000812-6g3qmly","Type":"NodeParagraph","Properties":{"id":"20231128000812-6g3qmly","updated":"20231128000812"},"Children":[{"Type":"NodeText","Data":"• singleton 首字母小写，是不可导出的类型，避免被外界直接获取"}]},{"ID":"20231128000812-22ptzg9","Type":"NodeParagraph","Properties":{"id":"20231128000812-22ptzg9","updated":"20231128000812"},"Children":[{"Type":"NodeText","Data":"• 在包初始化函数 init 中完成了 singleton 单例的初始化工作"}]},{"ID":"20231128000812-elvk5zi","Type":"NodeParagraph","Properties":{"id":"20231128000812-elvk5zi","updated":"20231128000812"},"Children":[{"Type":"NodeText","Data":"• 对外暴露可导出方法 GetInstance，返回提前初始化好的全局单例对象 s"}]},{"ID":"20231128000815-74cague","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231128000815-74cague","updated":"20231128001308"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nvar s *Singleton\n\nfunc init() {\n\ts = newSingleton()\n}\n\ntype Singleton struct {\n\n}\n\nfunc newSingleton() *Singleton {\n\treturn \u0026Singleton{}\n}\n\nfunc (s *Singleton) Work() {\n\n}\n\nfunc GetInstance() *Singleton {\n\treturn s\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231128001317-gue0q22","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231128001317-gue0q22","updated":"20231128001326"},"Children":[{"Type":"NodeText","Data":"代码规范性讨论"}]},{"ID":"20231128001333-njdhjq4","Type":"NodeParagraph","Properties":{"id":"20231128001333-njdhjq4","updated":"20231128001333"},"Children":[{"Type":"NodeText","Data":"上述代码在实现上没有逻辑问题，但是存在一个比较容易引起争议的规范性问题，就是在对外可导出的 GetInstance 方法中，返回了不可导出的类型 singleton."}]},{"ID":"20231128001333-drwypf7","Type":"NodeParagraph","Properties":{"id":"20231128001333-drwypf7","updated":"20231128001333"},"Children":[{"Type":"NodeText","Data":"代码执行流程上 ok，但这种实现方式存在代码坏味道，相应的问题在 stackoverflow 上引起过讨论，对应链接如下，大家感兴趣可以去了解原贴中的讨论内容："}]},{"ID":"20231128001333-sf35rq1","Type":"NodeParagraph","Properties":{"id":"20231128001333-sf35rq1","updated":"20231128001333"},"Children":[{"Type":"NodeText","Data":"https://stackoverflow.com/questions/21470398/return-an-unexported-type-from-a-function"}]},{"ID":"20231128001352-03oiblq","Type":"NodeParagraph","Properties":{"id":"20231128001352-03oiblq","updated":"20231128001355"},"Children":[{"Type":"NodeText","Data":"不建议这么做的原因主要在于：\n• singleton 是包内的不可导出类型，在包外即便获取到了，也无法直接作为方法的入参或者出参进行传递，显得很呆\n• singleton 的对外暴露，使得 singleton 所在 package 的代码设计看起来是自相矛盾的，混淆了 singleton 这个不可导出类型的边界和定位\n综上，规范的处理方式是，在不可导出单例类 singleton 的基础上包括一层接口 interface，将其作为对对导出方法 GetInstance 的返回参数类型:"}]},{"ID":"20231128001446-ru16tm4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231128001446-ru16tm4","updated":"20231128001546"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Instance interface {\n     Work() \n}\n\nfunc GetInstance() Instance {\n    return s\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231128001603-1f25vyx","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231128001603-1f25vyx","updated":"20231128001627"},"Children":[{"Type":"NodeText","Data":"懒汉式单例模式"}]},{"ID":"20231128001627-7o37job","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231128001627-7o37job","updated":"20231128001635"},"Children":[{"Type":"NodeText","Data":"懒汉式实现流程"}]},{"ID":"20231128001635-6g422iu","Type":"NodeParagraph","Properties":{"id":"20231128001635-6g422iu","updated":"20231128001647"},"Children":[{"Type":"NodeText","Data":"懒汉式讲究的是”佛系”，某件事情如果是可做可不做，那我一定选择不做. 直到万不得已非做不可的时候，我才会采取行动（deadline 是第一生产力）.\n懒汉式的执行步骤如下：\n• 单例类声明为不可导出类型，避免被外界直接获取到\n• 声明一个全局单例变量, 但不进行初始化（注意只声明，不初始化）\n• 暴露一个对外公开的方法,用于获取这个单例\n• 在这个获取方法被调用时，会判断单例是否初始化过，倘若没有，则在此时才完成初始化工作"}]},{"ID":"20231128001653-3qo1rx4","Type":"NodeParagraph","Properties":{"id":"20231128001653-3qo1rx4"}}]}