{"ID":"20230727000634-i4nbe0v","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f3df","id":"20230727000634-i4nbe0v","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230727000634-i4nbe0v\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230727000635-3pxzw0j\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230727000770-34sqjhk\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230727000635-3pxzw0j\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","tags":"数据类型,map,引用类型","title":"06. map-？？？","updated":"20230727002313"},"Children":[{"ID":"20230727000635-3pxzw0j","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230727000635-3pxzw0j","updated":"20230727000635"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"6. map"}]},{"ID":"20230727000636-ammrm0u","Type":"NodeParagraph","Properties":{"id":"20230727000636-ammrm0u","updated":"20230727000636"},"Children":[{"Type":"NodeText","Data":"map是一种无序的基于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"key-value"},{"Type":"NodeText","Data":"的数据结构，Go语言中的map是引用类型，必须初始化才能使用。"}]},{"ID":"20230727000637-qmcpvma","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000637-qmcpvma","updated":"20230727000637"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 的声明"}]},{"ID":"20230727000638-3l5dagc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000638-3l5dagc","updated":"20230727000638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 声明\nvar map变量名  map[keytype]valuetype\n// var a map[string]string\n\n// map支持在声明的时候填充元素\nuserInfo := map[string]string{\n\t\t\"username\": \"沙河小王子\",\n\t\t\"password\": \"123456\",\n    }\n\n// 初始化 内置函数make 可以为map类型的变量分配内存\nmap变量名 := make(map[keytype]vlauetype)\n\n/* a := map[int]int{\n1:1\n2:2\n}\n*/\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000639-nuiqp30","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000639-nuiqp30","updated":"20230727000639"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 的增删查改"}]},{"ID":"20230727000640-sia0hjm","Type":"NodeParagraph","Properties":{"id":"20230727000640-sia0hjm","updated":"20230727000640"},"Children":[{"Type":"NodeText","Data":"==在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"中查找、删除、查找value的时间复杂度"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"O(1)"},{"Type":"NodeText","Data":"。=="}]},{"ID":"20230727000641-gtea6nl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000641-gtea6nl","updated":"20230727000641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 的增加与更新 (增、改)"}]},{"ID":"20230727000642-3saqdec","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000642-3saqdec","updated":"20230727000642"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"map[key] = value \n// 如果 key 还没有就是增加，如果key存在就是更改\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000643-dhq2gph","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000643-dhq2gph","updated":"20230727000643"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 的删除"}]},{"ID":"20230727000644-4xz8416","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000644-4xz8416","updated":"20230727000644"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func delete (m map[Type]Type, key Type)\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000645-u7vm2og","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000645-u7vm2og","updated":"20230727000645"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"delete(map,\"key\")\n//delete 是一个内置函数，如果key存在就删除该key-value，如果key不存在不操作，但是也不会报错\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000646-xizuufb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000646-xizuufb","updated":"20230727000646"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"m := map[string]int{\n  \"a\":1,\n  \"b\":2\n}\n\nfmt.Println(m)\ndelete(m,\"a\")\nfmt.Println(m)\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000647-b7tkvga","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000647-b7tkvga","updated":"20230727000647"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 查找"}]},{"ID":"20230727000648-gr3z7tp","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000648-gr3z7tp","updated":"20230727000648"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"直接给key值就能取得对应的value值"}]},{"ID":"20230727000649-ef7c0do","Type":"NodeParagraph","Properties":{"id":"20230727000649-ef7c0do","updated":"20230727000649"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map[key]"},{"Type":"NodeText","Data":" 就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"value"}]},{"ID":"20230727000650-9ii5mdq","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000650-9ii5mdq","updated":"20230727000650"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果对应的key 不存在，则会返回对应 value数据类型的空值"}]},{"ID":"20230727000651-x0w1bu0","Type":"NodeParagraph","Properties":{"id":"20230727000651-x0w1bu0","updated":"20230727000651"},"Children":[{"Type":"NodeText","Data":"比如value为 string，则返回空字符串"}]},{"ID":"20230727000652-blx1hlh","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000652-blx1hlh","updated":"20230727000652"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"判断key是否存在"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000653-g8owql9","Type":"NodeParagraph","Properties":{"id":"20230727000653-g8owql9","updated":"20230727000653"},"Children":[{"Type":"NodeText","Data":"如果我们想在通过key访问map之前就确定对应的key是否存在，有另外一种写法："}]},{"ID":"20230727000654-tbwup7d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000654-tbwup7d","updated":"20230727000654"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"v,ok := m[k]\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000655-mh1buo6","Type":"NodeParagraph","Properties":{"id":"20230727000655-mh1buo6","updated":"20230727000655"},"Children":[{"Type":"NodeText","Data":"上面的表达式中，有第二个返回值"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ok"},{"Type":"NodeText","Data":"，该值为boolean类型，当key存在时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ok"},{"Type":"NodeText","Data":"的值为true，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"v"},{"Type":"NodeText","Data":"为对应的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"value"},{"Type":"NodeText","Data":"；否则为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ok"},{"Type":"NodeText","Data":"为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"v"},{"Type":"NodeText","Data":"为空值。"}]},{"ID":"20230727000656-ur13bpd","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000656-ur13bpd","updated":"20230727000656"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"不能对map的value进行取址操作"}]},{"ID":"20230727000657-k3o91xg","Type":"NodeParagraph","Properties":{"id":"20230727000657-k3o91xg","updated":"20230727000657"},"Children":[{"Type":"NodeText","Data":"Go的数组和切片允许对元素进行取址操作，但不允许对map的元素进行取址操作："}]},{"ID":"20230727000658-639i0n6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000658-639i0n6","updated":"20230727000658"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//对数组元素取址\na := [3]int{1, 2, 3}\nfmt.Println(\u0026a[1])\n\n//对切片元素取址\ns := []int{1, 2, 3}\nfmt.Println(\u0026s[1])\n\nm := map[string]string{\n  \"test\":\"test\",\n}\n//对map元素取址，错误\nfmt.Println(\u0026m[\"test\"])\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000659-jsokjeu","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230727000659-jsokjeu","updated":"20230727000659"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"为什么GO要限制map的元素取地址呢"},{"Type":"NodeMark2CloseMarker","Data":"=="}]},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]}]},{"ID":"20230727000660-4mv9933","Type":"NodeParagraph","Properties":{"id":"20230727000660-4mv9933","updated":"20230727000660"},"Children":[{"Type":"NodeText","Data":"因为"},{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"Go可以在添加新的键值对时更改键值对的内存位置"},{"Type":"NodeMark2CloseMarker","Data":"=="}]},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]},{"Type":"NodeText","Data":"，故取地址可能会变的无效。Go将在后台执行此操作，以将检索键值对的复杂性保持在恒定水平。因此，"},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"地址可能会变得无效，Go宁愿禁止访问一个可能无效的地址。"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000661-f1vdeqw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000661-f1vdeqw","updated":"20230727000661"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 的遍历"}]},{"ID":"20230727000662-j0yx2q6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000662-j0yx2q6","updated":"20230727000662"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"for k,v := range map {}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000663-tgqkyrk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000663-tgqkyrk","updated":"20230727000663"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 的长度"}]},{"ID":"20230727000664-3108bok","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000664-3108bok","updated":"20230727000664"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"len(map)\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000665-umqnsko","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000665-umqnsko","updated":"20230727000665"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 的切片"}]},{"ID":"20230727000666-jlfutbe","Type":"NodeParagraph","Properties":{"id":"20230727000666-jlfutbe","updated":"20230727000666"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"切片的数据类型如果是map，我们称之为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"slice of map"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map切片"},{"Type":"NodeText","Data":"，这样使用则map个数就可以动态变化了"}]},{"ID":"20230727000667-nt0uvog","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000667-nt0uvog","updated":"20230727000667"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import \"fmt\"\n\nfunc Test() {\n  var m1 [1]map[string]string = [1]map[string]string{}\n  m1[0] = make(map[string]string,1)\n  m1[0][\"zhang\"] = \"san\"\n  m2 := m1[:]\n  m2 = append(m2,make(map[string]string))\n  m2[1][\"li\"] = \"si\"\n  fmt.Println(m2)\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000668-luqci2w","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c2g=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000668-luqci2w","updated":"20230727000668"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c2g=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"[map[zhang:san] map[li:si]]\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000669-8xtz9t1","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000669-8xtz9t1","updated":"20230727000669"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 排序"}]},{"ID":"20230727000670-v3meovj","Type":"NodeParagraph","Properties":{"id":"20230727000670-v3meovj","updated":"20230727000670"},"Children":[{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"go语言中没有一个专门的方法对map 进行排序"},{"Type":"NodeMark2CloseMarker","Data":"=="}]},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]}]},{"ID":"20230727000671-vhodsgk","Type":"NodeParagraph","Properties":{"id":"20230727000671-vhodsgk","updated":"20230727000671"},"Children":[{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"go中的map默认是无序的，注意，也不是按照添加的顺序存放的，你每次遍历得到的输出结果可能不一样"},{"Type":"NodeMark2CloseMarker","Data":"=="}]},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]}]},{"ID":"20230727000672-iznwclv","Type":"NodeParagraph","Properties":{"id":"20230727000672-iznwclv","updated":"20230727000672"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"go中的map的排序，先是将key进行排序，然后根据key值遍历输出即可"}]},{"ID":"20230727000673-03372hq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000673-03372hq","updated":"20230727000673"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package Map\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc Test6()  {\n\tm1:=make(map[int]int,10)\n\tm1[1]=100\n\tm1[2]=200\n\tm1[3]=300\n\tm1[4]=400\n\tm1[5]=500\n\tm1[6]=600\n\tvar keys []int\n\tfor i,val:=range m1{\n\t\tkeys=append(keys,i)\n\t\tfmt.Println(i,val)\n\t}\n\tsort.Ints(keys)\n\tfor _,val:=range keys{\n\t\tfmt.Println(m1[val])\n\t}\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000674-l5lao5a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000674-l5lao5a","updated":"20230727000674"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\tvar user = map[string]string{\n\t\t\"id\":   \"0001\",\n\t\t\"name\": \"小张\",\n\t\t\"age\":  \"18岁\",\n\t}\n\torder := []string{}\n\tfor k, _ := range user {\n\t\torder = append(order, k)\n\t}\n\n\tfor _, v := range order {\n\t\tfmt.Println(user[v])\n\t}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000675-7hnoluf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000675-7hnoluf","updated":"20230727000675"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"map 的比较"}]},{"ID":"20230727000676-8e7unvj","Type":"NodeParagraph","Properties":{"id":"20230727000676-8e7unvj","updated":"20230727000676"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":" 类型变量之间不能进行比较，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"只能与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nil"},{"Type":"NodeText","Data":"进行比较："}]},{"ID":"20230727000677-z4e2ivh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000677-z4e2ivh","updated":"20230727000677"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"var m map[int]string\n//判断是否等于nil\nif m == nil{\n fmt.Println(\"m hasn't been initialized\")\n}\n\nm1 := map[string]string{\"name\": \"小明\"}\nm2 := map[string]string{\"name\": \"小明\"}\n\n//报错\nif m1 == m2 {\n fmt.Println(\"相等\")\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000678-33ofzgr","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000678-33ofzgr","updated":"20230727000678"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 嵌套"}]},{"ID":"20230727000679-uilawu1","Type":"NodeParagraph","Properties":{"id":"20230727000679-uilawu1","updated":"20230727000679"},"Children":[{"Type":"NodeText","Data":"由于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"value"},{"Type":"NodeText","Data":"并没有数据类型的限制，所以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"value"},{"Type":"NodeText","Data":"也可以是另一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"类型："}]},{"ID":"20230727000680-ugcrj1w","Type":"NodeBlockquote","Properties":{"id":"20230727000680-ugcrj1w","updated":"20230727000680"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230727000681-d1c94d2","Type":"NodeParagraph","Properties":{"id":"20230727000681-d1c94d2","updated":"20230727000681"},"Children":[{"Type":"NodeText","Data":"理论上map嵌套map可以一直嵌套下去，但一般不会这么做"}]}]},{"ID":"20230727000682-8fvrcdq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000682-8fvrcdq","updated":"20230727000682"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"mm := map[string]map[int]string{\n \"a\": {1: \"test1\"},\n \"b\": {2: \"test2\"},\n \"c\": {2: \"test3\"},\n}\nfmt.Println(mm)\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000683-kv97ru8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000683-kv97ru8","updated":"20230727000683"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 的使用细节"}]},{"ID":"20230727000684-gfskdut","Type":"NodeParagraph","Properties":{"id":"20230727000684-gfskdut","updated":"20230727000684"},"Children":[{"Type":"NodeText","Data":"1）"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"map是引用类型"},{"Type":"NodeText","Data":"，遵守引用类型的传递机制，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"在一个函数接收map修改后，会直接修改原来的map"}]},{"ID":"20230727000685-e0ti0md","Type":"NodeParagraph","Properties":{"id":"20230727000685-e0ti0md","updated":"20230727000685"},"Children":[{"Type":"NodeText","Data":"2）"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"map的容量达到后，再想map增加元素，会自动扩容，并不会发生panic"},{"Type":"NodeText","Data":"，也就是说"},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"map能动态增长键值对"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000686-7x5f6g4","Type":"NodeParagraph","Properties":{"id":"20230727000686-7x5f6g4","updated":"20230727000686"},"Children":[{"Type":"NodeText","Data":"3）"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"map的value也经常使用struct类型"},{"Type":"NodeText","Data":"，更适合管理复杂的数据（比前面的value是一个map更好，比如value为student结构体"}]},{"ID":"20230727000687-b958mxm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000687-b958mxm","updated":"20230727000687"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 的底层原理"}]},{"ID":"20230727000688-go8fw7s","Type":"NodeParagraph","Properties":{"id":"20230727000688-go8fw7s","updated":"20230727000688"},"Children":[{"Type":"NodeText","Data":"=="},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Go 语言内置了 map 数据结构, map 的底层便是一个 HashTable (哈希表)"},{"Type":"NodeText","Data":"== , Go 语言的 map 的使用非常简易, 但其内部实现相对比较复杂, Go 语言的 Runtime 使用了多个数据结构来实现 HashTable, 本文完整剖析 Golang 对于 HashTable 的底层实现"}]},{"ID":"20230727000689-8r7m3s8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000689-8r7m3s8","updated":"20230727000689"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Hash (哈希)"}]},{"ID":"20230727000690-3k9ie6y","Type":"NodeParagraph","Properties":{"id":"20230727000690-3k9ie6y","updated":"20230727000690"},"Children":[{"Type":"NodeText","Data":"概念：哈希即可以是一种数据结构，也可以是一种函数概念"}]},{"ID":"20230727000691-885q2ig","Type":"NodeParagraph","Properties":{"id":"20230727000691-885q2ig","updated":"20230727000691"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"通过某种函数(hashFunc)使"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"元素的存储位置与它的关键码之间能够建立一一映射的关系"},{"Type":"NodeText","Data":"，那么在查找时通过该函数可以很快找到该元素。"}]},{"ID":"20230727000692-dtgipu0","Type":"NodeParagraph","Properties":{"id":"20230727000692-dtgipu0","updated":"20230727000692"},"Children":[{"Type":"NodeText","Data":"哈希("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://so.csdn.net/so/search?q=散列\u0026spm=1001.2101.3001.7020","TextMarkTextContent":"散列"},{"Type":"NodeText","Data":")方法，哈希方法中使用的转换函数称为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"哈希(散列)函数"},{"Type":"NodeText","Data":"，构造出来的结构称为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"哈希表(Hash Table)(或者称散列表)"}]},{"ID":"20230727000693-9tklret","Type":"NodeParagraph","Properties":{"id":"20230727000693-9tklret","updated":"20230727000693"},"Children":[{"Type":"NodeText","Data":"哈希算法不过是一个均匀的运算，它的输入可以是字符串，可以是数据，可以是任何文件，经过哈希运算后，变成一个固定长度的输出， 该输出就是哈希值。但是哈希算法有一个很大的特点，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"就是你不能从结果推算出输入,所以又称为不可逆的算法"}]},{"ID":"20230727000694-otsr7m0","Type":"NodeParagraph","Properties":{"id":"20230727000694-otsr7m0","updated":"20230727000694"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\d849bd76a9e84739ac4f434e0787812c.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000695-5em44be","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000695-5em44be","updated":"20230727000695"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"哈希的特性"}]},{"ID":"20230727000696-5yp3yat","Type":"NodeParagraph","Properties":{"id":"20230727000696-5yp3yat","updated":"20230727000696"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不可逆"},{"Type":"NodeText","Data":" ： 就如同你可以通过x"},{"Type":"NodeEmphasis","Children":[{"Type":"NodeEmA6kOpenMarker","Data":"*"},{"Type":"NodeText","Data":"y=z得到z，但你不能确定z=x"},{"Type":"NodeEmA6kCloseMarker","Data":"*"}]},{"Type":"NodeText","Data":"y，xy一定刚刚的数"}]},{"ID":"20230727000697-u7d5t2e","Type":"NodeParagraph","Properties":{"id":"20230727000697-u7d5t2e","updated":"20230727000697"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"运算快"},{"Type":"NodeText","Data":"：20G高清电影和一个5K文本文件复杂度相同，计算量都极小。越巧妙的hash函数碰撞越少，空间利用率越高"}]},{"ID":"20230727000698-x47wocq","Type":"NodeParagraph","Properties":{"id":"20230727000698-x47wocq","updated":"20230727000698"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"结果均匀"},{"Type":"NodeText","Data":"：哈希函数计算出来的地址能均匀分布在整个空间中，这时hash函数的设计原则"}]},{"ID":"20230727000699-gp03pux","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000699-gp03pux","updated":"20230727000699"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"常见哈希函数"}]},{"ID":"20230727000700-ovagr9g","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230727000700-ovagr9g","updated":"20230727000700"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"直接定制法–(常用)"}]},{"ID":"20230727000701-z7ehhkb","Type":"NodeParagraph","Properties":{"id":"20230727000701-z7ehhkb","updated":"20230727000701"},"Children":[{"Type":"NodeText","Data":"取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B优点：简单、均匀缺点：需要事先知道关键字的分布情况使用场景：适合查找比较小且连续的情况。"}]},{"ID":"20230727000702-7xvo6jk","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230727000702-7xvo6jk","updated":"20230727000702"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"除留余数法–(常用)"}]},{"ID":"20230727000703-r8m2jjt","Type":"NodeParagraph","Properties":{"id":"20230727000703-r8m2jjt","updated":"20230727000703"},"Children":[{"Type":"NodeText","Data":"设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：Hash(key) = key% p(p\u003c=m),将关键码转换成哈希地址。"}]},{"ID":"20230727000704-ozoukks","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000704-ozoukks","updated":"20230727000704"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"哈希冲突"},{"Type":"NodeMark2CloseMarker","Data":"=="}]},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]}]},{"ID":"20230727000705-xvulq7k","Type":"NodeParagraph","Properties":{"id":"20230727000705-xvulq7k","updated":"20230727000705"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"哈希冲突是不可避免的"}]},{"ID":"20230727000706-0h3siab","Type":"NodeParagraph","Properties":{"id":"20230727000706-0h3siab","updated":"20230727000706"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当计算出的hash值相同时，就会发生哈希冲突。常用的解决哈希冲突的方法有两种："}]},{"ID":"20230727000707-idlz49o","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230727000707-idlz49o","updated":"20230727000707"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"1."},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"闭散列（开放定址法）"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000708-3khe92t","Type":"NodeParagraph","Properties":{"id":"20230727000708-3khe92t","updated":"20230727000708"},"Children":[{"Type":"NodeText","Data":"当发生哈希冲突时，如果"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://so.csdn.net/so/search?q=哈希表\u0026spm=1001.2101.3001.7020","TextMarkTextContent":"哈希表"},{"Type":"NodeText","Data":"未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"下一个"},{"Type":"NodeText","Data":"” 空位置中去。那如何寻找下一个空位置呢？"}]},{"ID":"20230727000709-si6h5dd","Type":"NodeParagraph","Properties":{"id":"20230727000709-si6h5dd","updated":"20230727000709"},"Children":[{"Type":"NodeText","Data":"其中最简单的就是**"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"线性探测"},{"Type":"NodeText","Data":"**"}]},{"ID":"20230727000710-bpkeqfk","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000710-bpkeqfk","updated":"20230727000710"},"Children":[{"ID":"20230727000711-a5u9i73","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000711-a5u9i73","updated":"20230727000711"},"Children":[{"ID":"20230727000712-b4js9xe","Type":"NodeParagraph","Properties":{"id":"20230727000712-b4js9xe","updated":"20230727000712"},"Children":[{"Type":"NodeText","Data":"若没有冲突则直接插入值"}]}]},{"ID":"20230727000713-1yzvkmi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000713-1yzvkmi","updated":"20230727000713"},"Children":[{"ID":"20230727000714-nj577r8","Type":"NodeParagraph","Properties":{"id":"20230727000714-nj577r8","updated":"20230727000714"},"Children":[{"Type":"NodeText","Data":"若有冲突则向后查找至空位插入值"}]}]}]},{"ID":"20230727000715-5vqrg5d","Type":"NodeParagraph","Properties":{"id":"20230727000715-5vqrg5d","updated":"20230727000715"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\7155850cf1fa4345926d2391a5218b35.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000716-jzpnbn3","Type":"NodeParagraph","Properties":{"id":"20230727000716-jzpnbn3","updated":"20230727000716"},"Children":[{"Type":"NodeText","Data":"但这么做有弊端："}]},{"ID":"20230727000717-3g4p8cf","Type":"NodeParagraph","Properties":{"id":"20230727000717-3g4p8cf","updated":"20230727000717"},"Children":[{"Type":"NodeText","Data":"**一旦发生哈希冲突，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"所有的冲突连在一起"},{"Type":"NodeText","Data":"，容易产生数据“堆积”（查找时会多次重复比较，大大降低查找效率）即 "},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"“踩踏效应”"},{"Type":"NodeMark2CloseMarker","Data":"=="}]},{"Type":"NodeText","Data":"**"}]},{"ID":"20230727000718-8phx0su","Type":"NodeBlockquote","Properties":{"id":"20230727000718-8phx0su","updated":"20230727000718"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230727000719-9tt7crz","Type":"NodeParagraph","Properties":{"id":"20230727000719-9tt7crz","updated":"20230727000719"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"二次探测"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线性探测的缺陷是产生冲突的数据堆积在一块"},{"Type":"NodeText","Data":"，这和找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测为了避免该问题，他不再是挨着找下一个空位置，而是平方式的跳跃找下一个空位置，这样冲突就不会堆积在一片，而是会相对散开一些。"}]}]},{"ID":"20230727000720-fg1m6mw","Type":"NodeBlockquote","Properties":{"id":"20230727000720-fg1m6mw","updated":"20230727000720"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230727000721-mhgiynm","Type":"NodeParagraph","Properties":{"id":"20230727000721-mhgiynm","updated":"20230727000721"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"载荷因子"},{"Type":"NodeText","Data":": α是散列表装满程度的标志因子。由于表长是定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"通常，只要a取的合适（一般取0.7-0.8之间），哈希表的平均查找长度就会是常数也就是"}]},{"ID":"20230727000722-71cx1u0","Type":"NodeParagraph","Properties":{"id":"20230727000722-71cx1u0","updated":"20230727000722"},"Children":[{"Type":"NodeText","Data":"O（1）级别的。"}]},{"ID":"20230727000723-8wlrxqm","Type":"NodeParagraph","Properties":{"id":"20230727000723-8wlrxqm","updated":"20230727000723"},"Children":[{"Type":"NodeText","Data":"GO的载荷因子为6.5 但长度为8"}]}]},{"ID":"20230727000724-gvvbhwo","Type":"NodeParagraph","Properties":{"id":"20230727000724-gvvbhwo","updated":"20230727000724"},"Children":[{"Type":"NodeText","Data":"闭散列的删除"}]},{"ID":"20230727000725-3hm29ao","Type":"NodeParagraph","Properties":{"id":"20230727000725-3hm29ao","updated":"20230727000725"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他元素的搜索"},{"Type":"NodeText","Data":"。如上图的11，删除11之后，查找5就会误报。"}]},{"ID":"20230727000726-z6kiswa","Type":"NodeBlockquote","Properties":{"id":"20230727000726-z6kiswa","updated":"20230727000726"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230727000727-wvw48ec","Type":"NodeParagraph","Properties":{"id":"20230727000727-wvw48ec","updated":"20230727000727"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"闭散列最大的缺陷就是空间利用率比较低，这也是哈希的缺陷"}]}]},{"ID":"20230727000728-t83fv2r","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230727000728-t83fv2r","updated":"20230727000728"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.==开散列 又名"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"链地址法(开链法)"},{"Type":"NodeText","Data":"=="}]},{"ID":"20230727000729-kgtmgpm","Type":"NodeParagraph","Properties":{"id":"20230727000729-kgtmgpm","updated":"20230727000729"},"Children":[{"Type":"NodeText","Data":"首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中"}]},{"ID":"20230727000730-51rlac4","Type":"NodeParagraph","Properties":{"id":"20230727000730-51rlac4","updated":"20230727000730"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\53e188e794d043e8862878230887d5a5.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000731-37aplue","Type":"NodeParagraph","Properties":{"id":"20230727000731-37aplue","updated":"20230727000731"},"Children":[{"Type":"NodeText","Data":"首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中"}]},{"ID":"20230727000732-a6t0ei2","Type":"NodeParagraph","Properties":{"id":"20230727000732-a6t0ei2","updated":"20230727000732"},"Children":[{"Type":"NodeText","Data":"GO的map底层bucket桶即使用这个方法"}]},{"ID":"20230727000733-decd8oy","Type":"NodeParagraph","Properties":{"id":"20230727000733-decd8oy","updated":"20230727000733"},"Children":[{"Type":"NodeText","Data":"那如果就是出现了极端的情况，所有的数此时都冲突到一个桶中，那么这个桶中的数据就会太多了，应该怎么办？"}]},{"ID":"20230727000734-o5orkxw","Type":"NodeParagraph","Properties":{"id":"20230727000734-o5orkxw","updated":"20230727000734"},"Children":[{"Type":"NodeText","Data":"将此时的链表改换红黑树"}]},{"ID":"20230727000735-eonmufy","Type":"NodeParagraph","Properties":{"id":"20230727000735-eonmufy","updated":"20230727000735"},"Children":[{"Type":"NodeText","Data":"多阶哈希（不常使用）"}]},{"ID":"20230727000736-8pjooim","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000736-8pjooim","updated":"20230727000736"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"map 的底层结构"}]},{"ID":"20230727000737-600f4gg","Type":"NodeParagraph","Properties":{"id":"20230727000737-600f4gg","updated":"20230727000737"},"Children":[{"Type":"NodeText","Data":"map 的底层结构示意图"}]},{"ID":"20230727000738-jg1nfb9","Type":"NodeParagraph","Properties":{"id":"20230727000738-jg1nfb9","updated":"20230727000738"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"图片","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\640.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000739-cmh8yff","Type":"NodeParagraph","Properties":{"id":"20230727000739-cmh8yff","updated":"20230727000739"},"Children":[{"Type":"NodeText","Data":"Go map 在语言底层是通过如下的抽象结构来表征, 其位置在"}]},{"ID":"20230727000740-eabtgjd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000740-eabtgjd","updated":"20230727000740"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// Map contains Type fields specific to maps.\n// 映射包含特定于映射的类型字段。\ntype Map struct {\n\tKey  *Type // key type\n\tElem *Type // Val (elem) type\n\t\n\tBucket *Type\t// internal struct type representing a hash bucket \n    // 表示散列桶的内部结构类型\n\tHmap   *Type\t// internal struct type representing the Hmap (map header object)\t内部结构类型表示Hmap (映射头对象) \n\tHiter  *Type\t// internal struct type representing hash iterator state\t\n    // 内部结构类型，表示散列迭代器状态\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000741-thbm9c8","Type":"NodeParagraph","Properties":{"id":"20230727000741-thbm9c8","updated":"20230727000741"},"Children":[{"Type":"NodeText","Data":"前两个字段分别为 key value, 由于 go map 支持多种数据类型, go 会在编译期推断其具体的数据类型, Bucket 是哈希桶, Hmap 表征了 map 底层使用的 HashTable 的元信息, 如当前 HashTable 中含有的元素数据、桶指针等, Hiter 是用于遍历 go map 的数据结构, 将在下文中讨论"}]},{"ID":"20230727000742-jqnxvjq","Type":"NodeParagraph","Properties":{"id":"20230727000742-jqnxvjq","updated":"20230727000742"},"Children":[{"Type":"NodeText","Data":"Hmap 的具体化数据结构位于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://link.zhihu.com/?target=https%3A//golang.org/src/runtime/map.go","TextMarkTextContent":"src/runtime/map.go"},{"Type":"NodeText","Data":" 中, hmap 结构描述了 Go map 的关键信息"}]},{"ID":"20230727000743-v9qpnb1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000743-v9qpnb1","updated":"20230727000743"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// A header for  a Go map \ntype hmap struct{\n\t // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.\n    // Make sure this stays in sync with the compiler's definition.\n    count     int // # live cells == size of map.  Must be first (used by len() builtin)\n    flags     uint8\n    B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)\n    noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details\n    hash0     uint32 // hash seed\n\n    buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.\n    oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing\n    nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)\n\n    extra *mapextra // optional fields\n}\n\ntype mapextra struct {\n    overflow \t*[]*bmap\n    oldoverflow *[]*bmap\n    \n    nextOverflow   *bamp\n}\n\ntype bamp struct {\n    tophash [bucktCnt]uint8\n}\n\n//在编译期间会产生新的结构体\ntype bmap struct {\n    tophash [8]uint8 //存储哈希值的高8位\n    data    byte[1]\t// key value 数据：key/key/key/.../value/value/value...\n    overflow *bamp // 溢出bucket 的地址\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000744-bbmpw3t","Type":"NodeParagraph","Properties":{"id":"20230727000744-bbmpw3t","updated":"20230727000744"},"Children":[{"Type":"NodeText","Data":"其中"}]},{"ID":"20230727000745-z5u5fja","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000745-z5u5fja","updated":"20230727000745"},"Children":[{"ID":"20230727000746-c3u3p31","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000746-c3u3p31","updated":"20230727000746"},"Children":[{"ID":"20230727000747-4kw738k","Type":"NodeParagraph","Properties":{"id":"20230727000747-4kw738k","updated":"20230727000747"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"count 字段表征了 map 目前的元素数目, 当使用 len() 函数获取 map 长度时, 返回的便是 count 成员的值, 因此 len() 函数作用于 map 结构时, 其时间复杂度为 O(1)O(1)"},{"Type":"NodeText","Data":","}]}]},{"ID":"20230727000748-tmqer2k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000748-tmqer2k","updated":"20230727000748"},"Children":[{"ID":"20230727000749-gscu2z6","Type":"NodeParagraph","Properties":{"id":"20230727000749-gscu2z6","updated":"20230727000749"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"flag 字段标志 map 的状态"},{"Type":"NodeText","Data":", "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如 map 当前正在被遍历或正在被写入"},{"Type":"NodeText","Data":","}]}]},{"ID":"20230727000750-7wyqtha","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000750-7wyqtha","updated":"20230727000750"},"Children":[{"ID":"20230727000751-hj1mki7","Type":"NodeParagraph","Properties":{"id":"20230727000751-hj1mki7","updated":"20230727000751"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"B 是哈希桶数目以 2 为底的对数, 在 go map 中, 哈希桶的数目都是 2 的整数次幂(这样设计的好处是可以是用位运算来计算取余运算的值, 即 N mod M = N \u0026amp; (M-1)),"}]}]},{"ID":"20230727000752-ysxmfva","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000752-ysxmfva","updated":"20230727000752"},"Children":[{"ID":"20230727000753-8449s5s","Type":"NodeParagraph","Properties":{"id":"20230727000753-8449s5s","updated":"20230727000753"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"noverflow 是溢出桶的数目, 这个数值不是恒定精确的, 当其 B\u0026gt;=16 时为近似值,"}]}]},{"ID":"20230727000754-vvb63we","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000754-vvb63we","updated":"20230727000754"},"Children":[{"ID":"20230727000755-g1xvx1q","Type":"NodeParagraph","Properties":{"id":"20230727000755-g1xvx1q","updated":"20230727000755"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"hash0是随机哈希种子, map创建时调用 fastrand 函数生成的随机数, 设置的目的是为了降低哈希冲突的概率"},{"Type":"NodeText","Data":","}]}]},{"ID":"20230727000756-n5390xp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000756-n5390xp","updated":"20230727000756"},"Children":[{"ID":"20230727000757-1abjpe1","Type":"NodeParagraph","Properties":{"id":"20230727000757-1abjpe1","updated":"20230727000757"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"buckets 是指向当前哈希桶的指针"},{"Type":"NodeText","Data":","}]}]},{"ID":"20230727000758-owstn05","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000758-owstn05","updated":"20230727000758"},"Children":[{"ID":"20230727000759-sjke8t6","Type":"NodeParagraph","Properties":{"id":"20230727000759-sjke8t6","updated":"20230727000759"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"oldbuckets 是当桶扩容时指向旧桶的指针"},{"Type":"NodeText","Data":","}]}]},{"ID":"20230727000760-vv9pfyi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000760-vv9pfyi","updated":"20230727000760"},"Children":[{"ID":"20230727000761-y1qsis8","Type":"NodeParagraph","Properties":{"id":"20230727000761-y1qsis8","updated":"20230727000761"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"nevacuate 是当桶进行调整时指示的搬迁进度, 小于此地址的 buckets 是以前搬迁完毕的哈希桶,"}]}]},{"ID":"20230727000762-lrcb35q","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000762-lrcb35q","updated":"20230727000762"},"Children":[{"ID":"20230727000763-ew8cqlj","Type":"NodeParagraph","Properties":{"id":"20230727000763-ew8cqlj","updated":"20230727000763"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"mapextra 则是表征溢出桶的变量"}]}]}]},{"ID":"20230727000764-nau3g3y","Type":"NodeParagraph","Properties":{"id":"20230727000764-nau3g3y","updated":"20230727000764"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"image-20230303011048943","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\image-20230303011048943.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000765-ecqpagj","Type":"NodeParagraph","Properties":{"id":"20230727000765-ecqpagj","updated":"20230727000765"},"Children":[{"Type":"NodeText","Data":"在go 的map 实现中，它的底层结构体是 hmap， hmap 里维护着若干个bucket 数组，即桶数组。"}]},{"ID":"20230727000766-ovyogey","Type":"NodeParagraph","Properties":{"id":"20230727000766-ovyogey","updated":"20230727000766"},"Children":[{"Type":"NodeText","Data":"Bucket数组中每个元素都是bmap结构，也即每个bucket（桶）都是bmap结构，【ps：后文为了语义一致，和方便理解，就不再提bmap了，统一叫作桶】 每个桶中保存了8个kv对，如果8个满了，又来了一个key落在了这个桶里，会使用overflow连接下一个桶(溢出桶)。"}]},{"ID":"20230727000767-bpt6xli","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000767-bpt6xli","updated":"20230727000767"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"map中数据操作"}]},{"ID":"20230727000768-ng469os","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000768-ng469os","updated":"20230727000768"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Get获取数据"}]},{"ID":"20230727000769-7ju562p","Type":"NodeParagraph","Properties":{"id":"20230727000769-7ju562p","updated":"20230727000769"},"Children":[{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeText","Data":"假设当前 B=4 即桶数量为2^B=16个"},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]},{"Type":"NodeText","Data":"，要从map中获取k4对应的value"}]},{"ID":"20230727000770-34sqjhk","Type":"NodeParagraph","Properties":{"id":"20230727000770-34sqjhk","updated":"20230727000770"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"image-20230303011455809","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\image-20230303011455809.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000771-tww0xms","Type":"NodeParagraph","Properties":{"id":"20230727000771-tww0xms","updated":"20230727000771"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"参考上图，k4的get流程可以归纳为如下几步："}]},{"ID":"20230727000772-x2jpb12","Type":"NodeParagraph","Properties":{"id":"20230727000772-x2jpb12","updated":"20230727000772"},"Children":[{"Type":"NodeText","Data":"①"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"计算k4的hash值"},{"Type":"NodeText","Data":"。[由于当前主流机都是64位操作系统，所以计算结果有64个比特位]"}]},{"ID":"20230727000773-zaleeyb","Type":"NodeParagraph","Properties":{"id":"20230727000773-zaleeyb","updated":"20230727000773"},"Children":[{"Type":"NodeText","Data":"②"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"通过最后的“B”位来确定在哪号桶"},{"Type":"NodeText","Data":"，此时B为4，所以取k4对应哈希值的后4位，也就是0101，0101用十进制表示为5，所以在5号桶）"}]},{"ID":"20230727000774-9nzqmlt","Type":"NodeParagraph","Properties":{"id":"20230727000774-9nzqmlt","updated":"20230727000774"},"Children":[{"Type":"NodeText","Data":"③"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"根据k4对应的hash值前8位快速确定是在这个桶的哪个位置"},{"Type":"NodeText","Data":"（额外说明一下，在bmap中存放了每个key对应的tophash，是key的哈希值前8位),一旦发现前8位一致，则会执行下一步"}]},{"ID":"20230727000775-nv5mngk","Type":"NodeParagraph","Properties":{"id":"20230727000775-nv5mngk","updated":"20230727000775"},"Children":[{"Type":"NodeText","Data":"④"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对比key完整的hash是否匹配"},{"Type":"NodeText","Data":"，如果匹配则获取对应value"}]},{"ID":"20230727000776-js9e3a7","Type":"NodeParagraph","Properties":{"id":"20230727000776-js9e3a7","updated":"20230727000776"},"Children":[{"Type":"NodeText","Data":"⑤"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果都没有找到，就去连接的下一个溢出桶中找"}]},{"ID":"20230727000777-z55jkao","Type":"NodeParagraph","Properties":{"id":"20230727000777-z55jkao","updated":"20230727000777"},"Children":[{"Type":"NodeText","Data":"有很多同学会问这里为什么要多维护一个tophash，即hash前8位？"}]},{"ID":"20230727000778-njpw5je","Type":"NodeParagraph","Properties":{"id":"20230727000778-njpw5je","updated":"20230727000778"},"Children":[{"Type":"NodeText","Data":"这是因为tophash可以快速确定key是否正确，也可以把它理解成一种缓存措施，如果前8位都不对了，后面就没有必要比较了。"}]},{"ID":"20230727000779-kiqunzc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000779-kiqunzc","updated":"20230727000779"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"PUT存放数据"}]},{"ID":"20230727000780-ktt7t6s","Type":"NodeParagraph","Properties":{"id":"20230727000780-ktt7t6s","updated":"20230727000780"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\v2-c289a260a1d233fd862d79eef50fdf76_1440w.webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000781-h7k9mub","Type":"NodeParagraph","Properties":{"id":"20230727000781-h7k9mub","updated":"20230727000781"},"Children":[{"Type":"NodeText","Data":"img"}]},{"ID":"20230727000782-731r8mq","Type":"NodeParagraph","Properties":{"id":"20230727000782-731r8mq","updated":"20230727000782"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"map的赋值流程可总结位如下几步："}]},{"ID":"20230727000783-rkqqv4q","Type":"NodeParagraph","Properties":{"id":"20230727000783-rkqqv4q","updated":"20230727000783"},"Children":[{"Type":"NodeText","Data":"①"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"通过key的hash值后“B”位确定是哪一个桶"},{"Type":"NodeText","Data":"，图中示例为4号桶。"}]},{"ID":"20230727000784-i1tezm4","Type":"NodeParagraph","Properties":{"id":"20230727000784-i1tezm4","updated":"20230727000784"},"Children":[{"Type":"NodeText","Data":"② 遍历当前桶，通过key的tophash和hash值，防止key重复，然后"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"找到第一个可以插入的位置"},{"Type":"NodeText","Data":"，即空位置处存储数据。"}]},{"ID":"20230727000785-a59m6qw","Type":"NodeParagraph","Properties":{"id":"20230727000785-a59m6qw","updated":"20230727000785"},"Children":[{"Type":"NodeText","Data":"③如果"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当前桶元素已满，会通过overflow链接创建一个新的桶"},{"Type":"NodeText","Data":"，来存储数据。"}]},{"ID":"20230727000786-udb77n6","Type":"NodeParagraph","Properties":{"id":"20230727000786-udb77n6","updated":"20230727000786"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"关于hash冲突"},{"Type":"NodeText","Data":"：当两个不同的 key 落在同一个桶中，就是发生了哈希冲突。冲突的解决手段是采用链表法：在 桶 中，从前往后找到第一个空位进行插入。如果8个kv满了，那么当前桶就会连接到下一个溢出桶（bmap）。"}]},{"ID":"20230727000787-t97eesh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000787-t97eesh","updated":"20230727000787"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"扩容"}]},{"ID":"20230727000788-kgz5kwu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000788-kgz5kwu","updated":"20230727000788"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"扩容的方式"}]},{"ID":"20230727000789-savf3y9","Type":"NodeParagraph","Properties":{"id":"20230727000789-savf3y9","updated":"20230727000789"},"Children":[{"Type":"NodeText","Data":"扩容有两种，一种是等量扩容，另一种是2倍扩容"}]},{"ID":"20230727000790-urqbjcw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000790-urqbjcw","updated":"20230727000790"},"Children":[{"ID":"20230727000791-td7cxzc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000791-td7cxzc","updated":"20230727000791"},"Children":[{"ID":"20230727000792-twl62v0","Type":"NodeParagraph","Properties":{"id":"20230727000792-twl62v0","updated":"20230727000792"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"相同容量扩容"}]}]}]},{"ID":"20230727000793-pt064kh","Type":"NodeParagraph","Properties":{"id":"20230727000793-pt064kh","updated":"20230727000793"},"Children":[{"Type":"NodeText","Data":"由于map中不断的put和delete key，桶中可能会出现很多断断续续的空位，这些空位会导致连接的bmap溢出桶很长，导致扫描时间边长。这种扩容实际上是一种整理，把后置位的数据整理到前面。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这种情况下，元素会发生重排，但不会换桶。"}]},{"ID":"20230727000794-rrsusb1","Type":"NodeParagraph","Properties":{"id":"20230727000794-rrsusb1","updated":"20230727000794"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\v2-2ecbb8a8c52d395061f67e41620b1504_1440w.webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000795-a9j1kvy","Type":"NodeParagraph","Properties":{"id":"20230727000795-a9j1kvy","updated":"20230727000795"},"Children":[{"Type":"NodeText","Data":"img"}]},{"ID":"20230727000796-dx7msgw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000796-dx7msgw","updated":"20230727000796"},"Children":[{"ID":"20230727000797-f0pzdg1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000797-f0pzdg1","updated":"20230727000797"},"Children":[{"ID":"20230727000798-sjsbhag","Type":"NodeParagraph","Properties":{"id":"20230727000798-sjsbhag","updated":"20230727000798"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2倍容量扩容"}]}]}]},{"ID":"20230727000799-ld8ck6m","Type":"NodeParagraph","Properties":{"id":"20230727000799-ld8ck6m","updated":"20230727000799"},"Children":[{"Type":"NodeText","Data":"这种2倍扩容是由于当前桶数组确实不够用了，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"发生这种扩容时，元素会重排，可能会发生桶迁移"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230727000800-33h5rlh","Type":"NodeParagraph","Properties":{"id":"20230727000800-33h5rlh","updated":"20230727000800"},"Children":[{"Type":"NodeText","Data":"如图中所示，扩容前B=2,扩容后B=3，假设一元素key的hash值后三位为101，那么由上文的介绍可知，在扩容前，由hash值的后两位来决定几号桶，即 01 所以元素在1号桶。 在扩容发生后，由hash值得后三位来决定几号桶，即101所以元素会迁移到5号桶。"}]},{"ID":"20230727000801-xoq9i0r","Type":"NodeParagraph","Properties":{"id":"20230727000801-xoq9i0r","updated":"20230727000801"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\v2-d38e6d960012d58d4192f904985a4ca1_1440w.webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000802-adv7ub8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000802-adv7ub8","updated":"20230727000802"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"发生扩容的条件"}]},{"ID":"20230727000803-j3bwad4","Type":"NodeParagraph","Properties":{"id":"20230727000803-j3bwad4","updated":"20230727000803"},"Children":[{"Type":"NodeText","Data":"首先我们了解下"},{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeText","Data":"装载因子(loadFactor)"},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]},{"Type":"NodeText","Data":"的概念"}]},{"ID":"20230727000804-orprwve","Type":"NodeParagraph","Properties":{"id":"20230727000804-orprwve","updated":"20230727000804"},"Children":[{"Type":"NodeText","Data":"loadFactor:=count / (2^B) 即 装载因子 = map中元素的个数 / map中当前桶的个数"}]},{"ID":"20230727000805-wiongei","Type":"NodeParagraph","Properties":{"id":"20230727000805-wiongei","updated":"20230727000805"},"Children":[{"Type":"NodeText","Data":"通过计算公式我们可以得知，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"装载因子是指当前map中，每个桶中的平均元素个数。"}]},{"ID":"20230727000806-b3wonrp","Type":"NodeParagraph","Properties":{"id":"20230727000806-b3wonrp","updated":"20230727000806"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"扩容条件1"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"装载因子 \u0026gt; 6.5"},{"Type":"NodeText","Data":" (源码中定义的)"}]},{"ID":"20230727000807-ethybgf","Type":"NodeParagraph","Properties":{"id":"20230727000807-ethybgf","updated":"20230727000807"},"Children":[{"Type":"NodeText","Data":"这个也非常容易理解，正常情况下，如果没有溢出桶，那么一个桶中最多有8个元素，当平均每个桶中的数据超过了6.5个，那就意味着当前容量要不足了，发生扩容。"}]},{"ID":"20230727000808-e7yijgg","Type":"NodeParagraph","Properties":{"id":"20230727000808-e7yijgg","updated":"20230727000808"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"扩容条件2"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"溢出桶的数量过多"}]},{"ID":"20230727000809-5rza9fm","Type":"NodeParagraph","Properties":{"id":"20230727000809-5rza9fm","updated":"20230727000809"},"Children":[{"Type":"NodeText","Data":"当 B \u003c 15 时，如果overflow的bucket数量超过 2^B。"}]},{"ID":"20230727000810-ku0hptu","Type":"NodeParagraph","Properties":{"id":"20230727000810-ku0hptu","updated":"20230727000810"},"Children":[{"Type":"NodeText","Data":"当 B \u003e= 15 时，overflow的bucket数量超过 2^15。"}]},{"ID":"20230727000811-y3qc6b9","Type":"NodeParagraph","Properties":{"id":"20230727000811-y3qc6b9","updated":"20230727000811"},"Children":[{"Type":"NodeText","Data":"简单来讲，新加入key的hash值后B位都一样，使得个别桶一直在插入新数据，进而导致它的溢出桶链条越来越长。如此一来，当map在操作数据时，扫描速度就会变得很慢。及时的扩容，可以对这些元素进行重排，使元素在桶的位置更平均一些。"}]},{"ID":"20230727000812-cike948","Type":"NodeParagraph","Properties":{"id":"20230727000812-cike948","updated":"20230727000812"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"扩容时的细节"}]},{"ID":"20230727000813-0bism8e","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20230727000813-0bism8e","updated":"20230727000813"},"Children":[{"ID":"20230727000814-9pkq50y","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20230727000814-9pkq50y","updated":"20230727000814"},"Children":[{"ID":"20230727000815-dyu6lkd","Type":"NodeParagraph","Properties":{"id":"20230727000815-dyu6lkd","updated":"20230727000815"},"Children":[{"Type":"NodeText","Data":"在我们的hmap结构中有一个oldbuckets吗，扩容刚发生时，会先将老数据存到这个里面。"}]}]},{"ID":"20230727000816-ixsfxmv","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20230727000816-ixsfxmv","updated":"20230727000816"},"Children":[{"ID":"20230727000817-5u6eztb","Type":"NodeParagraph","Properties":{"id":"20230727000817-5u6eztb","updated":"20230727000817"},"Children":[{"Type":"NodeText","Data":"每次对map进行删改操作时，会触发从oldbucket中迁移到bucket的操作【非一次性，分多次】"}]}]},{"ID":"20230727000818-ldierzo","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20230727000818-ldierzo","updated":"20230727000818"},"Children":[{"ID":"20230727000819-kzxf2aw","Type":"NodeParagraph","Properties":{"id":"20230727000819-kzxf2aw","updated":"20230727000819"},"Children":[{"Type":"NodeText","Data":"在扩容没有完全迁移完成之前，每次get或者put遍历数据时，都会先遍历oldbuckets，然后再遍历buckets。"}]}]}]},{"ID":"20230727000820-0ri3qp6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000820-0ri3qp6","updated":"20230727000820"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"map的并发安全"}]},{"ID":"20230727000821-21cfar5","Type":"NodeParagraph","Properties":{"id":"20230727000821-21cfar5","updated":"20230727000821"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"map是线程不安全的"}]},{"ID":"20230727000822-lcbb0j6","Type":"NodeParagraph","Properties":{"id":"20230727000822-lcbb0j6","updated":"20230727000822"},"Children":[{"Type":"NodeText","Data":"在同一时间点，两个 goroutine 对同一个map进行读写操作是不安全的。举个栗子："}]},{"ID":"20230727000823-rfonsib","Type":"NodeParagraph","Properties":{"id":"20230727000823-rfonsib","updated":"20230727000823"},"Children":[{"Type":"NodeText","Data":"某map桶数量为4，即B=2。此时 goroutine1来插入key1， goroutine2来读取 key2. 可能会发生如下过程："}]},{"ID":"20230727000824-gbksszj","Type":"NodeParagraph","Properties":{"id":"20230727000824-gbksszj","updated":"20230727000824"},"Children":[{"Type":"NodeText","Data":"① goroutine2 计算key2的hash值,B=2，并确定桶号为1。"}]},{"ID":"20230727000825-l7xpm5y","Type":"NodeParagraph","Properties":{"id":"20230727000825-l7xpm5y","updated":"20230727000825"},"Children":[{"Type":"NodeText","Data":"② goroutine1添加key1，触发扩容条件。"}]},{"ID":"20230727000826-h7wzjdi","Type":"NodeParagraph","Properties":{"id":"20230727000826-h7wzjdi","updated":"20230727000826"},"Children":[{"Type":"NodeText","Data":"③ B=B+1=3, buckets数据迁移到oldbuckets。"}]},{"ID":"20230727000827-1zlu3wh","Type":"NodeParagraph","Properties":{"id":"20230727000827-1zlu3wh","updated":"20230727000827"},"Children":[{"Type":"NodeText","Data":"④ goroutine2从桶1中遍历，获取数据失败。"}]},{"ID":"20230727000828-u3bxinp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000828-u3bxinp","updated":"20230727000828"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用读写锁 map + sync.RWMutex"}]},{"ID":"20230727000829-7fb1zyv","Type":"NodeParagraph","Properties":{"id":"20230727000829-7fb1zyv","updated":"20230727000829"},"Children":[{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"在工作中，当我们涉及到对一个map进行并发读写时，一般采用的做法是采用golang中自带的mutex锁"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000830-at1d40e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000830-at1d40e","updated":"20230727000830"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" type Resource struct {\n     sync.RWMutex\n     m map[string]int\n }\n \n func main() {\n     r := Resource{m: make(map[string]int)}\n \n     go func() { //开一个goroutine写map\n         for j := 0; j \u003c 100; j++ {\n             r.Lock()\n             r.m[fmt.Sprintf(\"resource_%d\", j)] = j\n             r.Unlock()\n         }\n     }()\n     go func() { //开一个goroutine读map\n         for j := 0; j \u003c 100; j++ {\n             r.RLock()\n             fmt.Println(r.m[fmt.Sprintf(\"resource_%d\", j)])\n             r.RUnlock()\n         }\n     }()\n }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000831-lsngm1c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000831-lsngm1c","updated":"20230727000831"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用sync.map"}]},{"ID":"20230727000832-p55vlmr","Type":"NodeParagraph","Properties":{"id":"20230727000832-p55vlmr","updated":"20230727000832"},"Children":[{"Type":"NodeText","Data":"　sync.Map是用读写分离实现的，其思想是空间换时间。和map+RWLock的实现方式相比，它做了一些优化："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可以无锁访问read map，而且会优先操作read map，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong strong","TextMarkTextContent":"倘若只操作read map就可以满足要求(增删改查遍历)，那就不用去操作write map(它的读写都要加锁)，所以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式。"}]},{"ID":"20230727000833-c1o4j5s","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000833-c1o4j5s","updated":"20230727000833"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20230727000834-wns0afq","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000834-wns0afq","updated":"20230727000834"},"Children":[{"ID":"20230727000835-ui5vimu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000835-ui5vimu","updated":"20230727000835"},"Children":[{"ID":"20230727000836-hlxoqe4","Type":"NodeParagraph","Properties":{"id":"20230727000836-hlxoqe4","updated":"20230727000836"},"Children":[{"Type":"NodeText","Data":"map 是引用类型"}]}]},{"ID":"20230727000837-hfrjix5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000837-hfrjix5","updated":"20230727000837"},"Children":[{"ID":"20230727000838-c6y1xa5","Type":"NodeParagraph","Properties":{"id":"20230727000838-c6y1xa5","updated":"20230727000838"},"Children":[{"Type":"NodeText","Data":"map 遍历是无序的"}]}]},{"ID":"20230727000839-7fm77kr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000839-7fm77kr","updated":"20230727000839"},"Children":[{"ID":"20230727000840-so8512d","Type":"NodeParagraph","Properties":{"id":"20230727000840-so8512d","updated":"20230727000840"},"Children":[{"Type":"NodeText","Data":"map 是非线程安全的"}]}]},{"ID":"20230727000841-c9o9yh0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000841-c9o9yh0","updated":"20230727000841"},"Children":[{"ID":"20230727000842-74yo760","Type":"NodeParagraph","Properties":{"id":"20230727000842-74yo760","updated":"20230727000842"},"Children":[{"Type":"NodeText","Data":"map的哈希冲突解决方式是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zhuanlan.zhihu.com/p/421607260","TextMarkTextContent":"拉链法"}]}]},{"ID":"20230727000843-y6fvbnu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000843-y6fvbnu","updated":"20230727000843"},"Children":[{"ID":"20230727000844-xrkr8s5","Type":"NodeParagraph","Properties":{"id":"20230727000844-xrkr8s5","updated":"20230727000844"},"Children":[{"Type":"NodeText","Data":"map扩容不一定会新增空间，也有可能做了内存整理"}]}]},{"ID":"20230727000845-anpujpz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000845-anpujpz","updated":"20230727000845"},"Children":[{"ID":"20230727000846-oxfx7h0","Type":"NodeParagraph","Properties":{"id":"20230727000846-oxfx7h0","updated":"20230727000846"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对map数据进行操作时不可取地址"}]}]}]},{"ID":"20230727000847-dm3n7lo","Type":"NodeParagraph","Properties":{"id":"20230727000847-dm3n7lo","updated":"20230727000847"},"Children":[{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"因为随着map元素的增长，map底层重新分配空间会导致之前的地址无效。"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]}]}