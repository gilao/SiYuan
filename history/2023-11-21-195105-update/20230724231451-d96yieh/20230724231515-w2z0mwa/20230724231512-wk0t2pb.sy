{"ID":"20230724231512-wk0t2pb","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f381","id":"20230724231512-wk0t2pb","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230724231512-wk0t2pb\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230724231513-z2ud995\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230724231614-mb5vt2e\u0026quot;,\u0026quot;scrollTop\u0026quot;:0\u0026#125;","tags":"设计模式-装饰器模式,公众号-小徐先生的编程世界","title":"3-Go 装饰器模式","updated":"20231121195105"},"Children":[{"ID":"20230724231513-z2ud995","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230724231513-z2ud995","updated":"20231121003929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/XG2G1O67o-p_u_MPj5N0oQ","TextMarkTextContent":"Go 装饰器模式"}]},{"ID":"20231121100445-mm5qe9x","Type":"NodeParagraph","Properties":{"id":"20231121100445-mm5qe9x","updated":"20231121100445"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231121100445-7b90bdr.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231121194101-7225vf5","Type":"NodeParagraph","Properties":{"id":"20231121194101-7225vf5"}},{"ID":"20231121194103-z4x3g7t","Type":"NodeParagraph","Properties":{"id":"20231121194103-z4x3g7t","updated":"20231121194106"},"Children":[{"Type":"NodeText","Data":"本期和大家交流的是设计模式中的装饰器模式.\n下面聊聊关于装饰器模式的基本定义：装饰器模式能够在不改变原对象结构的基础上，动态地为对象增加附属能力. 在实现思路上，装饰器模式和“继承”一定的类似之处，但是两者侧重点有所不同，可以把装饰器模式作为“继承”的一种补充手段.\n这么干讲概念显得过于抽象，下面我们通过一个实际案例，来和大家具体地剖析一下有关于装饰器模式的实现思路：\n• 现在摆在我们面前的时一碗热腾腾的白米饭，我们需要在此基础上添加出各种配菜组合，搭配出一款美味的盖浇饭.\n• 当前可供我们选择主菜是几种肉食，包括培根、牛肉还有鸡排\n• 除了主菜外，还有几道副菜作为调剂，包括鸡蛋、青椒还有黑椒汁"}]},{"ID":"20231121194122-3zcu6an","Type":"NodeTable","TableAligns":[0,0,0],"Properties":{"colgroup":"||","id":"20231121194122-3zcu6an","updated":"20231121194122"},"Children":[{"Type":"NodeTableHead","Data":"thead","Children":[{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"主食"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"主菜"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"副菜"}]}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"米饭"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"培根"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"鸡蛋"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"米饭"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"牛肉"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"青椒"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"米饭"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"鸡排"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"黑椒汁"}]}]}]},{"ID":"20231121194124-1tzul1b","Type":"NodeParagraph","Properties":{"id":"20231121194124-1tzul1b","updated":"20231121194139"},"Children":[{"Type":"NodeText","Data":"基于以上条件，我们开始烹饪创作：\n• 比如选用主菜培根搭配上副菜鸡蛋，就形成了一碗鸡蛋培根盖浇饭；\n• 比如选用主菜牛肉搭配上副菜青椒，就形成了一碗青椒牛肉盖浇饭；\n• 比如选用主菜鸡排搭配上副菜黑椒汁，就形成了一碗黑椒鸡排盖浇饭.\n聊到这里，下面我们尝试通过编程的方式还原上面的场景问题.\n一种常见的实现方式是可以采用继承的方式进行实现：\n• 我们构造出一个最基础的父类：米饭\n• 在白米饭的基础上，根据添加的主菜肉食，实现出现对应的几个一级子类：培根饭、牛肉饭、鸡排饭\n• 在一级子类的基础上，再搭配上各种副菜，实现对应的几个二级子类，包括：鸡蛋培根饭、青椒培根饭、青椒牛肉饭、黑椒鸡排饭等等"}]},{"ID":"20231121194225-z2bwh7v","Type":"NodeParagraph","Properties":{"id":"20231121194225-z2bwh7v","updated":"20231121194225"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231121194225-y9ngg1j.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231121194226-wlh1wdz","Type":"NodeParagraph","Properties":{"id":"20231121194226-wlh1wdz","updated":"20231121195104"},"Children":[{"Type":"NodeText","Data":"在上述“继承”的实现思路中，我们需要对子类的等级以及种类进行枚举，包括通过加入主菜后形成的一系列一级子类以及加入主菜和副菜后形成的一系列二级子类，这样一套相对固定的等级架构也暴露出来一些问题：\n• 在实际场景中，主菜和副菜的结合可以是更加灵活多样的，比如作为副菜的鸡蛋不仅可以和主菜的培根组合，还可以和牛肉或者鸡排搭配；比如实际场景中，后续可能有更多的主菜和副菜类型出现，如果需要对所有的组合进行穷尽，则需要经历一轮笛卡尔内积，最终子类的数量将会严重膨胀无法收敛\n• 使用主菜和副菜对配菜的类型进行界定显得过于刻板，主菜和副菜本质上都是菜品而已，可以根据用户的喜好灵活添加，比如用户可以只要副菜或者只要主菜，可以只添加双份甚至三份的鸡蛋而不添加培根或者牛肉，也可以选择要一份主菜搭配多份配菜，比如一份牛肉两份鸡蛋等等. 这样的话，原本约定好的基于继承实现的等级架构就不再适用了\n结合以上两点，我们发现在这类“加料”的场景中，使用继承的设计模式未必合适. 我们不妨切换思路，不再聚焦于尝试对所有组合种类进行一一枚举，而是把注意力放在“加料”的这个过程行为当中：\n"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"• 首先,我们不再区分主菜和副菜，不论是鸡蛋还是培根还是青椒，我们都把它们当中一种普通的“菜品”\n• 针对于每一种“菜品”，我们定义出一个装饰器类\n• 每次使用一个装饰器类时，对应的逻辑是会往原本的主食中添加一份对应的“菜品”"},{"Type":"NodeText","Data":"\n在这种实现的思路下，就诞生出了基于“装饰器模式”的实现架构，如下图所示:"}]},{"ID":"20231121195105-esohv2j","Type":"NodeParagraph","Properties":{"id":"20231121195105-esohv2j"}}]}