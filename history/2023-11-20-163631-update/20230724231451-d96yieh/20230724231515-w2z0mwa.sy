{"ID":"20230724231515-w2z0mwa","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f3c0","id":"20230724231515-w2z0mwa","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230724231515-w2z0mwa\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231120155701-ytctahj\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231120161634-uix745e\u0026quot;,\u0026quot;scrollTop\u0026quot;:1885,\u0026quot;focusId\u0026quot;:\u0026quot;20231120161634-uix745e\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","title":"GO 设计模式","updated":"20231120163116"},"Children":[{"ID":"20231120155701-ytctahj","Type":"NodeParagraph","Properties":{"id":"20231120155701-ytctahj","updated":"20231120155720"},"Children":[{"Type":"NodeText","Data":"排名不分先后，仅为学习流程，便于记录"}]},{"ID":"20230724231515-0l2i4ez","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230724231515-0l2i4ez","updated":"20231120155644"},"Children":[{"Type":"NodeText","Data":"工厂模式"}]},{"ID":"20231120162117-jrye1bt","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120162117-jrye1bt","updated":"20231120162121"},"Children":[{"Type":"NodeText","Data":"图示"}]},{"ID":"20231120160530-mzpp66v","Type":"NodeParagraph","Properties":{"id":"20231120160530-mzpp66v","updated":"20231120162126"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120160530-gvrifyb.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120162140-xa4z1f6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120162140-xa4z1f6","updated":"20231120162140"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20231120162140-p4vmxz7","Type":"NodeParagraph","Properties":{"id":"20231120162140-p4vmxz7","updated":"20231120162140"},"Children":[{"Type":"NodeText","Data":"Go 语言中没有针对类的构造器方法定义统一的规范，倘若每次需要创建类的实例时，都需要在业务方法中事无俱细地执行实例初始化的细节，那么会存在缺陷的包括："}]},{"ID":"20231120162140-xf7w49w","Type":"NodeList","ListData":{},"Properties":{"id":"20231120162140-xf7w49w","updated":"20231120162140"},"Children":[{"ID":"20231120162140-8j48dis","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120162140-8j48dis","updated":"20231120162140"},"Children":[{"ID":"20231120162140-xwpjph4","Type":"NodeParagraph","Properties":{"id":"20231120162140-xwpjph4","updated":"20231120162140"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"业务方法和组件类之间产生过高的耦合度，需要了解到组件类的过多细节"}]}]},{"ID":"20231120162140-f7hpubh","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120162140-f7hpubh","updated":"20231120162140"},"Children":[{"ID":"20231120162140-ql3fpdz","Type":"NodeParagraph","Properties":{"id":"20231120162140-ql3fpdz","updated":"20231120162140"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"倘若组件类的定义发生变更，那么散落在各处业务方法中对类的构造流程都需要配合改动"}]}]}]},{"ID":"20231120162140-yvihfr3","Type":"NodeParagraph","Properties":{"id":"20231120162140-yvihfr3","updated":"20231120162140"},"Children":[{"Type":"NodeText","Data":"那么如何解决上述问题呢？在编程世界中，相当的一部分问题都可以通过增加一个中间层加以解决. 我们在此处遵循工厂模式的设计思路，在业务方法和类之间添加一个防腐中间层——工厂类，这样做能够带来的好处是："}]},{"ID":"20231120162140-5edcf2j","Type":"NodeList","ListData":{},"Properties":{"id":"20231120162140-5edcf2j","updated":"20231120162140"},"Children":[{"ID":"20231120162140-yaa176m","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120162140-yaa176m","updated":"20231120162140"},"Children":[{"ID":"20231120162140-g67cw7v","Type":"NodeParagraph","Properties":{"id":"20231120162140-g67cw7v","updated":"20231120162140"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实现类和业务方法之间的解耦，如果类的构造过程发生变更，可以统一收口在工厂类中进行处理，从而对业务方法屏蔽相关细节"}]}]},{"ID":"20231120162140-ysnbc7z","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120162140-ysnbc7z","updated":"20231120162140"},"Children":[{"ID":"20231120162140-96t8q9c","Type":"NodeParagraph","Properties":{"id":"20231120162140-96t8q9c","updated":"20231120162140"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"倘若有多个类都聚拢在工厂类中进行构造，这样各个类的构造流程中就天然形成了一个公共的切面，可以进行一些公共逻辑的执行"}]}]}]},{"ID":"20231120162142-xrbzsh9","Type":"NodeParagraph","Properties":{"id":"20231120162142-xrbzsh9"}},{"ID":"20231120162143-jpupglc","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120162143-jpupglc","updated":"20231120162155"},"Children":[{"Type":"NodeText","Data":"使用场景"}]},{"ID":"20231120162948-exjiodz","Type":"NodeParagraph","Properties":{"id":"20231120162948-exjiodz","updated":"20231120162948"},"Children":[{"Type":"NodeText","Data":"工厂设计模式的使用场景包括："}]},{"ID":"20231120162948-pwkjitv","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231120162948-pwkjitv","updated":"20231120162948"},"Children":[{"ID":"20231120162948-9c3706k","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231120162948-9c3706k","updated":"20231120162948"},"Children":[{"ID":"20231120162948-kytlgkd","Type":"NodeParagraph","Properties":{"id":"20231120162948-kytlgkd","updated":"20231120162948"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"对象的创建需要复杂的逻辑"},{"Type":"NodeText","Data":"：当对象的创建涉及到复杂的逻辑、条件判断或算法时，可以使用工厂模式将这些创建逻辑封装起来，使代码更加清晰和可维护。"}]}]},{"ID":"20231120162948-0fcbvvc","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231120162948-0fcbvvc","updated":"20231120162948"},"Children":[{"ID":"20231120162948-2f8oap6","Type":"NodeParagraph","Properties":{"id":"20231120162948-2f8oap6","updated":"20231120162948"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"对象的创建需要隐藏具体实现"},{"Type":"NodeText","Data":"：当需要隐藏具体对象的实现细节，只通过接口或基类与外部进行交互时，可以使用工厂模式来创建对象，提供统一的接口。"}]}]},{"ID":"20231120162948-13x672r","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20231120162948-13x672r","updated":"20231120162948"},"Children":[{"ID":"20231120162948-hzysz7p","Type":"NodeParagraph","Properties":{"id":"20231120162948-hzysz7p","updated":"20231120162948"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"动态地决定创建哪种类型的对象"},{"Type":"NodeText","Data":"：当需要根据运行时条件或配置文件来动态地决定创建哪种类型的对象时，可以使用工厂模式来根据条件创建相应的对象。"}]}]},{"ID":"20231120162948-1555arg","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20231120162948-1555arg","updated":"20231120162948"},"Children":[{"ID":"20231120162948-szlvo75","Type":"NodeParagraph","Properties":{"id":"20231120162948-szlvo75","updated":"20231120162948"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"遵循开闭原则"},{"Type":"NodeText","Data":"：当需要在不修改现有代码的情况下扩展系统，增加新的产品类型或变化时，可以使用工厂模式来添加新的具体工厂类和产品类，而无需修改已有的代码。"}]}]},{"ID":"20231120162948-5javs4e","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20231120162948-5javs4e","updated":"20231120162948"},"Children":[{"ID":"20231120162948-lfp48ak","Type":"NodeParagraph","Properties":{"id":"20231120162948-lfp48ak","updated":"20231120162948"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"将对象的创建集中管理"},{"Type":"NodeText","Data":"：当需要集中管理对象的创建过程，以便于统一维护和控制时，可以使用工厂模式来创建对象，避免分散的对象创建代码。"}]}]}]},{"ID":"20231120162948-ban6b0e","Type":"NodeParagraph","Properties":{"id":"20231120162948-ban6b0e","updated":"20231120162948"},"Children":[{"Type":"NodeText","Data":"总之，工厂设计模式适用于需要封装对象创建过程、隐藏具体实现、灵活地创建对象、动态地选择对象类型、遵循开闭原则和集中管理对象创建等场景。"}]},{"ID":"20231120160837-1fk4dyf","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231120160837-1fk4dyf","updated":"20231120160843"},"Children":[{"Type":"NodeText","Data":"观察者模式"}]},{"ID":"20231120162959-4h9lwgb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120162959-4h9lwgb","updated":"20231120163004"},"Children":[{"Type":"NodeText","Data":"图示"}]},{"ID":"20231120160835-269z4ek","Type":"NodeParagraph","Properties":{"id":"20231120160835-269z4ek","updated":"20231120160835"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120155358-116vk3c.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120163016-heaag6a","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120163016-heaag6a","updated":"20231120163021"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20231120160835-3dr17z0","Type":"NodeParagraph","Properties":{"id":"20231120160835-3dr17z0","updated":"20231120160835"},"Children":[{"Type":"NodeText","Data":"本期基于 go 语言和大家探讨设计模式中的观察者模式. 观察者模式适用于多对一的订阅/发布场景.\n• ”多“：指的是有多名观察者\n• ”一“：指的是有一个被观察事物\n• ”订阅“：指的是观察者时刻关注着事物的动态\n• ”发布“：指的是事物状态发生变化时是透明公开的，能够正常进入到观察者的视线"}]},{"ID":"20231120160835-d91ph72","Type":"NodeParagraph","Properties":{"id":"20231120160835-d91ph72","updated":"20231120160835"},"Children":[{"Type":"NodeText","Data":"在上述场景中，我们了解到核心对象有两类，一类是“观察者”，一类是“被观察的事物”，且两者间在数量上存在多对一的映射关系."}]},{"ID":"20231120160835-9vn1crl","Type":"NodeParagraph","Properties":{"id":"20231120160835-9vn1crl","updated":"20231120160835"},"Children":[{"Type":"NodeText","Data":"在具体作编程实现时，上述场景的实现思路可以是百花齐放的，而观察者模式只是为我们提供了一种相对规范的设计实现思路，其遵循的核心宗旨是实现“观察者”与“被观察对象”之间的解耦，并将其设计为通用的模块，便于后续的扩展和复用."}]},{"ID":"20231120161634-uix745e","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120161634-uix745e","updated":"20231120163030"},"Children":[{"Type":"NodeText","Data":"使用场景"}]},{"ID":"20231120163115-zcfiq89","Type":"NodeParagraph","Properties":{"id":"20231120163115-zcfiq89","updated":"20231120163115"},"Children":[{"Type":"NodeText","Data":"观察者设计模式的使用场景包括："}]},{"ID":"20231120163115-z4zds7h","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231120163115-z4zds7h","updated":"20231120163115"},"Children":[{"ID":"20231120163115-c405wtk","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231120163115-c405wtk","updated":"20231120163115"},"Children":[{"ID":"20231120163115-9bjpjat","Type":"NodeParagraph","Properties":{"id":"20231120163115-9bjpjat","updated":"20231120163115"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"事件处理与通知"},{"Type":"NodeText","Data":"：当一个对象的状态变化需要通知其他对象进行相应的处理时，可以使用观察者模式。例如，图形界面中的按钮点击事件通知相关的监听器进行处理。"}]}]},{"ID":"20231120163115-d42pjim","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231120163115-d42pjim","updated":"20231120163115"},"Children":[{"ID":"20231120163115-e67ixo8","Type":"NodeParagraph","Properties":{"id":"20231120163115-e67ixo8","updated":"20231120163115"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"消息队列系统"},{"Type":"NodeText","Data":"：在消息队列系统中，多个订阅者（观察者）对特定的消息进行订阅，当消息到达时，通知所有订阅者进行处理。"}]}]},{"ID":"20231120163115-wkukrig","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20231120163115-wkukrig","updated":"20231120163115"},"Children":[{"ID":"20231120163115-7ca435v","Type":"NodeParagraph","Properties":{"id":"20231120163115-7ca435v","updated":"20231120163115"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"GUI开发"},{"Type":"NodeText","Data":"：在图形用户界面（GUI）开发中，当一个组件的状态变化需要影响其他组件时，可以使用观察者模式来实现组件之间的通信。"}]}]},{"ID":"20231120163115-gu3ychp","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20231120163115-gu3ychp","updated":"20231120163115"},"Children":[{"ID":"20231120163115-nx7ocin","Type":"NodeParagraph","Properties":{"id":"20231120163115-nx7ocin","updated":"20231120163115"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Stock报价系统"},{"Type":"NodeText","Data":"：在股票交易系统中，股票价格的变化会通知多个观察者（如投资者），以便及时更新股票价格。"}]}]},{"ID":"20231120163115-eis40cv","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20231120163115-eis40cv","updated":"20231120163115"},"Children":[{"ID":"20231120163115-0y41q9s","Type":"NodeParagraph","Properties":{"id":"20231120163115-0y41q9s","updated":"20231120163115"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"网络应用"},{"Type":"NodeText","Data":"：在网络应用中，当服务器端数据发生变化时，需要及时通知客户端进行更新，可以使用观察者模式来实现。"}]}]}]},{"ID":"20231120163115-3c36ngp","Type":"NodeParagraph","Properties":{"id":"20231120163115-3c36ngp","updated":"20231120163115"},"Children":[{"Type":"NodeText","Data":"总之，观察者设计模式适用于存在一对多关系，当一个对象的状态变化需要通知多个其他对象进行相应处理的场景，以实现对象间的松耦合和交互。"}]},{"ID":"20231120163116-rm7oaa4","Type":"NodeParagraph","Properties":{"id":"20231120163116-rm7oaa4"}}]}