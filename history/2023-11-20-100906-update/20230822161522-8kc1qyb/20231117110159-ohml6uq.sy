{"ID":"20231117110159-ohml6uq","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f984","id":"20231117110159-ohml6uq","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20231117110159-ohml6uq\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231117110300-hblfjg8\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231117110436-j6wo8do\u0026quot;,\u0026quot;scrollTop\u0026quot;:1300,\u0026quot;focusId\u0026quot;:\u0026quot;20231117110436-j6wo8do\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","tags":"需要仔细看,gRPC","title":"gRPC 转码大文件","updated":"20231117110439"},"Children":[{"ID":"20231117110300-hblfjg8","Type":"NodeParagraph","Properties":{"id":"20231117110300-hblfjg8"}},{"ID":"20231117110306-kb6s93b","Type":"NodeParagraph","Properties":{"id":"20231117110306-kb6s93b","updated":"20231117110306"},"Children":[{"Type":"NodeText","Data":"要使用 gRPC 转码流式传输任意内容，您可以使用 "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/googleapis/googleapis/blob/master/google/api/httpbody.proto","TextMarkTextContent":"google.api.HttpBody"},{"Type":"NodeText","Data":" 消息来控制内容类型。这也可用于流式处理请求，其中第一条消息从请求中获取参数。"}]},{"ID":"20231117110306-opxxoc4","Type":"NodeParagraph","Properties":{"id":"20231117110306-opxxoc4","updated":"20231117110306"},"Children":[{"Type":"NodeText","Data":"下面是一个示例服务，其中包含用于上传和下载文件的注释："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Files"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231117110307-3oa2ubw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117110307-3oa2ubw","updated":"20231117110351"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"import \"google/api/httpbody.proto\";\n\nservice Files {\n  // HTTP | gRPC\n  // -----|-----\n  // `POST /files/cat.jpg \u003cbody\u003e` | `UploadDownload(filename: \"cat.jpg\", file:\n  // { content_type: \"image/jpeg\", data: \u003cbody\u003e})\"`\n  rpc UploadDownload(UploadFileRequest) returns (google.api.HttpBody) {\n    option (google.api.http) = {\n      post : \"/files/{filename}\"\n      body : \"file\"\n    };\n  }\n  // Stream files greater than the gRPC message size limits.\n  rpc LargeUploadDownload(stream UploadFileRequest)\n      returns (stream google.api.HttpBody) {\n    option (google.api.http) = {\n      post : \"/files/large/{filename}\"\n      body : \"file\"\n    };\n  }\n}\nmessage UploadFileRequest {\n  string filename = 1; // Encoded from the URL path\n  google.api.HttpBody file = 2;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117110352-r5f22vt","Type":"NodeParagraph","Properties":{"id":"20231117110352-r5f22vt","updated":"20231117110356"},"Children":[{"Type":"NodeText","Data":"通常，你会在 gRPC 请求中发送和接收文件，并让传输将消息封送到类型中。像这样："}]},{"ID":"20231117110357-qslmcxu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117110357-qslmcxu","updated":"20231117110402"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Server struct {\n\ttestpb.UnimplementedFilesServer\n}\n\n// UploadDownload echoes the request body to the response as a unary request.\nfunc (s *Server) UploadDownload(ctx context.Context, req *testpb.UploadFileRequest) (*httpbody.HttpBody, error) {\n\tlog.Printf(\"got %s!\", req.Filename)\n\treturn \u0026httpbody.HttpBody{\n\t\tContentType: req.File.GetContentType(),\n\t\tData:        req.File.GetData(),\n\t}, nil\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117110408-mmpbhdk","Type":"NodeParagraph","Properties":{"id":"20231117110408-mmpbhdk","updated":"20231117110408"},"Children":[{"Type":"NodeText","Data":"这有效，但效率低下。正文需要分块为字节并提供给处理程序。然后，需要将消息转换回响应的字节流。对于小请求来说，这可能没问题，但大文件会通过字节进行搅动。我们还失去了漂亮的接口，更不用说像 io 这样更好的接口了。ReaderFrom 和 io.Writer让 Go 变得如此之快。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"io.Readerio.Writer"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231117110408-ks89q76","Type":"NodeParagraph","Properties":{"id":"20231117110408-ks89q76","updated":"20231117110408"},"Children":[{"Type":"NodeText","Data":"因此，如果我们的 mux 是 HTTP 服务器，我们可以包装它并在常规 .这样做的缺点是，我们生成的代码不再是事实的来源。我们需要确保我们也正确处理请求参数，并使其与 protobuf 注解保持同步。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"func(w http.ResponseWriter, r *http.Request)"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231117110424-pt4cwkh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231117110424-pt4cwkh","updated":"20231117110424"},"Children":[{"Type":"NodeText","Data":"作为HTTPBody"}]},{"ID":"20231117110424-ofha5t9","Type":"NodeParagraph","Properties":{"id":"20231117110424-ofha5t9","updated":"20231117110425"},"Children":[{"Type":"NodeText","Data":"让我们用两种新方法更快地获得："}]},{"ID":"20231117110436-0uv0a0a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117110436-0uv0a0a","updated":"20231117110436"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func AsHTTPBodyReader(stream grpc.ServerStream, msg proto.Message) (io.Reader, error)\nfunc AsHTTPBodyWriter(stream grpc.ServerStream, msg proto.Message) (io.Writer, error)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117110436-nx1jv8k","Type":"NodeParagraph","Properties":{"id":"20231117110436-nx1jv8k","updated":"20231117110436"},"Children":[{"Type":"NodeText","Data":"这使用流来检查消息，并提供高效且流式传输大型消息（在后台，它返回原始 HTTP 正文读取器和写入器，因此 WriterTo 和 ReaderFrom 工作！ 此方法仅适用于 gRPC 转码流的流式处理请求或流式处理响应。它处理第一条消息的解组和编组，以正确设置参数。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"google.api.HttpBodyio.Readerio.Writer"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231117110436-b3nhgem","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117110436-b3nhgem","updated":"20231117110436"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// LargeUploadDownload echoes the request body as the response body with contentType.\nfunc (s *Server) LargeUploadDownload(stream testpb.Files_LargeUploadDownloadServer) error {\n\tvar req testpb.UploadFileRequest\n\tr, err := larking.AsHTTPBodyReader(stream, \u0026req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlog.Printf(\"got %s!\", req.Filename)\n\n\trsp := httpbody.HttpBody{\n\t\tContentType: req.File.GetContentType(),\n\t}\n\tw, err := larking.AsHTTPBodyWriter(stream, \u0026rsp)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err := io.Copy(w, r)\n\treturn err\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117110436-j6wo8do","Type":"NodeParagraph","Properties":{"id":"20231117110436-j6wo8do","updated":"20231117110439"}}]}