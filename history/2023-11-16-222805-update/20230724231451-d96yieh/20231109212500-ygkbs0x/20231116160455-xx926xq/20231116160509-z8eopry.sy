{"ID":"20231116160509-z8eopry","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231116160509-z8eopry","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20231116160509-z8eopry\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231116160520-55lfp8g\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231116160509-0dmdc2w\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20231116160520-55lfp8g\u0026quot;,\u0026quot;focusStart\u0026quot;:27,\u0026quot;focusEnd\u0026quot;:27\u0026#125;","title":"Gin 框架如何处理 painc","updated":"20231116222446"},"Children":[{"ID":"20231116215158-py4ihe3","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231116215158-py4ihe3","updated":"20231116215207"},"Children":[{"Type":"NodeText","Data":"painc 的发生："}]},{"ID":"20231116215054-bont0pw","Type":"NodeParagraph","Properties":{"id":"20231116215054-bont0pw","updated":"20231116215149"},"Children":[{"Type":"NodeText","Data":"在golang中，如果在子协程中遇到 panic，那么主协程也会被终止。"}]},{"ID":"20231116215150-79jmmrp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231116215150-79jmmrp","updated":"20231116215313"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n    // 在子协程中引起panic，主协程也会退出\n\tgo func() {\n\t\tpanic(\"hello world\")\n\t}()\n  \n\t// Listen and Server in 0.0.0.0:8080\n\tr.Run(\":8080\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231116215329-8z4ydof","Type":"NodeParagraph","Properties":{"id":"20231116215329-8z4ydof","updated":"20231116220052"},"Children":[{"Type":"NodeText","Data":"panic被描述为不可处理的错误。在web服务中就是服务会崩溃。当然，这在生产环境下是不可接受的。那么，如何能够做到发生panic时技能捕获该panic又能让服务继续健康运行呢？"}]},{"ID":"20231116220104-68731az","Type":"NodeParagraph","Properties":{"id":"20231116220104-68731az","updated":"20231116220127"},"Children":[{"Type":"NodeText","Data":"这就是golang中提供的recover函数了。"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-font-background3); color: var(--b3-card-warning-color);"},"TextMarkType":"text strong","TextMarkTextContent":"recover函数能够捕获Panic错误并恢复程序的正常运行。 "},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-font-background3); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeText","Data":"接下来，我们看下recover函数在gin框架中是如何应用的。"}]},{"ID":"20231116220323-a6ohn6n","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231116220323-a6ohn6n","updated":"20231116220342"},"Children":[{"Type":"NodeText","Data":"Recovery 中间件"}]},{"ID":"20231116220451-ungncn3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231116220451-ungncn3","updated":"20231116221123"},"Children":[{"Type":"NodeText","Data":"Gin.Default"}]},{"ID":"20231116220106-6opdhnz","Type":"NodeParagraph","Properties":{"id":"20231116220106-6opdhnz","updated":"20231116220200"},"Children":[{"Type":"NodeText","Data":"首先，要提到的就是gin框架中的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"recovery中间件"},{"Type":"NodeText","Data":"。在gin中，是通过使用该中间件来捕获panic，并保证服务不down机的。 "},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-font-background6);"},"TextMarkType":"text","TextMarkTextContent":"如果使用gin.Default()函数进行构建gin对象，那么默认就注册了Recovery中间件。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-font-background6);\"}"}]},{"ID":"20231116220211-37ndhwp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231116220211-37ndhwp","updated":"20231116220253"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func Default() *Engine {\n\tdebugPrintWARNINGDefault()\n\tengine := New()\n    //  注册了Recovery中间件\n\tengine.Use(Logger(), Recovery())\n\treturn engine\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231116221126-kjbniuz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231116221126-kjbniuz","updated":"20231116221138"},"Children":[{"Type":"NodeText","Data":"Recovery() "}]},{"ID":"20231116221153-nvxnxpq","Type":"NodeParagraph","Properties":{"id":"20231116221153-nvxnxpq","updated":"20231116221155"},"Children":[{"Type":"NodeText","Data":"我们来看下Recovery()中间件都做了些什么。"}]},{"ID":"20231116221153-okoj3ep","Type":"NodeParagraph","Properties":{"id":"20231116221153-okoj3ep","updated":"20231116221153"},"Children":[{"Type":"NodeText","Data":"Recovery()函数定义如下："}]},{"ID":"20231116221158-w8vc6b5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231116221158-w8vc6b5","updated":"20231116221227"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func Recovery() HandlerFunc {\n\treturn RecoveryWithWriter(DefaultErrorWriter)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231116221245-rr9f4i3","Type":"NodeParagraph","Properties":{"id":"20231116221245-rr9f4i3","updated":"20231116221245"},"Children":[{"Type":"NodeText","Data":"这里的DefaultErrorWriter是默认的输出端，即os.Stderr。即指错误的输出到什么地方。"}]},{"ID":"20231116221245-ztn5rbq","Type":"NodeParagraph","Properties":{"id":"20231116221245-ztn5rbq","updated":"20231116221245"},"Children":[{"Type":"NodeText","Data":"接下来看RecoveryWithWriter函数中的实现"}]},{"ID":"20231116221247-qgi4qn9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231116221247-qgi4qn9","updated":"20231116221409"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// RecoveryWithWriter returns a middleware for a given writer that recovers from any panics and writes a 500 if there was one.\nfunc RecoveryWithWriter(out io.Writer, recovery ...RecoveryFunc) HandlerFunc {\n\tif len(recovery) \u003e 0 {\n\t\treturn CustomRecoveryWithWriter(out, recovery[0])\n\t}\n\treturn CustomRecoveryWithWriter(out, defaultHandleRecovery)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231116221426-de5aazr","Type":"NodeParagraph","Properties":{"id":"20231116221426-de5aazr","updated":"20231116221433"},"Children":[{"Type":"NodeText","Data":"这里有一个参数是defaultHandleRecovery，我们看下它的实现："}]},{"ID":"20231116221435-srudq4u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231116221435-srudq4u","updated":"20231116221457"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func defaultHandleRecovery(c *Context, err any) {\n\tc.AbortWithStatus(http.StatusInternalServerError)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231116221900-5lsac05","Type":"NodeParagraph","Properties":{"id":"20231116221900-5lsac05","updated":"20231116221900"},"Children":[{"Type":"NodeText","Data":"就是写入了一个代表内部服务器错误的状态码500，并结束了本次请求。"}]},{"ID":"20231116221900-02yoly1","Type":"NodeParagraph","Properties":{"id":"20231116221900-02yoly1","updated":"20231116221900"},"Children":[{"Type":"NodeText","Data":"这里关键点是CustomRecoveryWithWriter的实现，代码很长，我们分段来看。如下："}]},{"ID":"20231116221902-zd1xixk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231116221902-zd1xixk","updated":"20231116222446"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// CustomRecoveryWithWriter returns a middleware for a given writer that recovers from any panics and calls the provided handle func to handle it.\n// CustomRecoveryWithWriter为给定的编写器返回一个中间件，该编写器可以从任何死机中恢复，并调用提供的句柄函数来处理它。\nfunc CustomRecoveryWithWriter(out io.Writer, handle RecoveryFunc) HandlerFunc {\n\tvar logger *log.Logger\n\tif out != nil {\n\t\tlogger = log.New(out, \"\\n\\n\\x1b[31m\", log.LstdFlags)\n\t}\n\treturn func(c *Context) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\t// Check for a broken connection, as it is not really a\n\t\t\t\t// condition that warrants a panic stack trace.\n\t\t\t\tvar brokenPipe bool\n\t\t\t\tif ne, ok := err.(*net.OpError); ok {\n\t\t\t\t\tvar se *os.SyscallError\n\t\t\t\t\tif errors.As(ne, \u0026se) {\n\t\t\t\t\t\tseStr := strings.ToLower(se.Error())\n\t\t\t\t\t\tif strings.Contains(seStr, \"broken pipe\") ||\n\t\t\t\t\t\t\tstrings.Contains(seStr, \"connection reset by peer\") {\n\t\t\t\t\t\t\tbrokenPipe = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif logger != nil {\n\t\t\t\t\tstack := stack(3)\n\t\t\t\t\thttpRequest, _ := httputil.DumpRequest(c.Request, false)\n\t\t\t\t\theaders := strings.Split(string(httpRequest), \"\\r\\n\")\n\t\t\t\t\tfor idx, header := range headers {\n\t\t\t\t\t\tcurrent := strings.Split(header, \":\")\n\t\t\t\t\t\tif current[0] == \"Authorization\" {\n\t\t\t\t\t\t\theaders[idx] = current[0] + \": *\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theadersToStr := strings.Join(headers, \"\\r\\n\")\n\t\t\t\t\tif brokenPipe {\n\t\t\t\t\t\tlogger.Printf(\"%s\\n%s%s\", err, headersToStr, reset)\n\t\t\t\t\t} else if IsDebugging() {\n\t\t\t\t\t\tlogger.Printf(\"[Recovery] %s panic recovered:\\n%s\\n%s\\n%s%s\",\n\t\t\t\t\t\t\ttimeFormat(time.Now()), headersToStr, err, stack, reset)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.Printf(\"[Recovery] %s panic recovered:\\n%s\\n%s%s\",\n\t\t\t\t\t\t\ttimeFormat(time.Now()), err, stack, reset)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif brokenPipe {\n\t\t\t\t\t// If the connection is dead, we can't write a status to it.\n\t\t\t\t\tc.Error(err.(error)) //nolint: errcheck\n\t\t\t\t\tc.Abort()\n\t\t\t\t} else {\n\t\t\t\t\thandle(c, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tc.Next()\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}