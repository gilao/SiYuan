{"ID":"20230724231515-w2z0mwa","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f3c0","id":"20230724231515-w2z0mwa","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230724231515-w2z0mwa\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231120155701-ytctahj\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231120160530-mzpp66v\u0026quot;,\u0026quot;scrollTop\u0026quot;:601,\u0026quot;focusId\u0026quot;:\u0026quot;20231120160715-0jszrcx\u0026quot;,\u0026quot;focusStart\u0026quot;:57,\u0026quot;focusEnd\u0026quot;:57\u0026#125;","title":"GO 设计模式","updated":"20231120160843"},"Children":[{"ID":"20231120155701-ytctahj","Type":"NodeParagraph","Properties":{"id":"20231120155701-ytctahj","updated":"20231120155720"},"Children":[{"Type":"NodeText","Data":"排名不分先后，仅为学习流程，便于记录"}]},{"ID":"20230724231515-0l2i4ez","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230724231515-0l2i4ez","updated":"20231120155644"},"Children":[{"Type":"NodeText","Data":"工厂模式"}]},{"ID":"20231120160715-pwdch26","Type":"NodeParagraph","Properties":{"id":"20231120160715-pwdch26","updated":"20231120160715"},"Children":[{"Type":"NodeText","Data":"Go 语言中没有针对类的构造器方法定义统一的规范，倘若每次需要创建类的实例时，都需要在业务方法中事无俱细地执行实例初始化的细节，那么会存在缺陷的包括："}]},{"ID":"20231120160715-3mf8aud","Type":"NodeList","ListData":{},"Properties":{"id":"20231120160715-3mf8aud","updated":"20231120160715"},"Children":[{"ID":"20231120160715-f93a8n2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120160715-f93a8n2","updated":"20231120160715"},"Children":[{"ID":"20231120160715-7k4u0ec","Type":"NodeParagraph","Properties":{"id":"20231120160715-7k4u0ec","updated":"20231120160715"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"业务方法和组件类之间产生过高的耦合度，需要了解到组件类的过多细节"}]}]},{"ID":"20231120160715-n4xou0w","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120160715-n4xou0w","updated":"20231120160715"},"Children":[{"ID":"20231120160715-7vlweyc","Type":"NodeParagraph","Properties":{"id":"20231120160715-7vlweyc","updated":"20231120160715"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"倘若组件类的定义发生变更，那么散落在各处业务方法中对类的构造流程都需要配合改动"}]}]}]},{"ID":"20231120160715-4spcc4y","Type":"NodeParagraph","Properties":{"id":"20231120160715-4spcc4y","updated":"20231120160715"},"Children":[{"Type":"NodeText","Data":"那么如何解决上述问题呢？在编程世界中，相当的一部分问题都可以通过增加一个中间层加以解决. 我们在此处遵循工厂模式的设计思路，在业务方法和类之间添加一个防腐中间层——工厂类，这样做能够带来的好处是："}]},{"ID":"20231120160715-4hx1ooq","Type":"NodeList","ListData":{},"Properties":{"id":"20231120160715-4hx1ooq","updated":"20231120160715"},"Children":[{"ID":"20231120160715-lzt2jdm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120160715-lzt2jdm","updated":"20231120160715"},"Children":[{"ID":"20231120160715-lgh03im","Type":"NodeParagraph","Properties":{"id":"20231120160715-lgh03im","updated":"20231120160715"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实现类和业务方法之间的解耦，如果类的构造过程发生变更，可以统一收口在工厂类中进行处理，从而对业务方法屏蔽相关细节"}]}]},{"ID":"20231120160715-thpukhd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120160715-thpukhd","updated":"20231120160715"},"Children":[{"ID":"20231120160715-0jszrcx","Type":"NodeParagraph","Properties":{"id":"20231120160715-0jszrcx","updated":"20231120160715"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"倘若有多个类都聚拢在工厂类中进行构造，这样各个类的构造流程中就天然形成了一个公共的切面，可以进行一些公共逻辑的执行"}]}]}]},{"ID":"20231120160530-mzpp66v","Type":"NodeParagraph","Properties":{"id":"20231120160530-mzpp66v","updated":"20231120160646"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120160530-gvrifyb.png"},{"Type":"NodeCloseParen"}]}]},{"ID":"20231120160837-1fk4dyf","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231120160837-1fk4dyf","updated":"20231120160843"},"Children":[{"Type":"NodeText","Data":"观察者模式"}]},{"ID":"20231120160835-269z4ek","Type":"NodeParagraph","Properties":{"id":"20231120160835-269z4ek","updated":"20231120160835"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120155358-116vk3c.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120160835-3dr17z0","Type":"NodeParagraph","Properties":{"id":"20231120160835-3dr17z0","updated":"20231120160835"},"Children":[{"Type":"NodeText","Data":"本期基于 go 语言和大家探讨设计模式中的观察者模式. 观察者模式适用于多对一的订阅/发布场景.\n• ”多“：指的是有多名观察者\n• ”一“：指的是有一个被观察事物\n• ”订阅“：指的是观察者时刻关注着事物的动态\n• ”发布“：指的是事物状态发生变化时是透明公开的，能够正常进入到观察者的视线"}]},{"ID":"20231120160835-d91ph72","Type":"NodeParagraph","Properties":{"id":"20231120160835-d91ph72","updated":"20231120160835"},"Children":[{"Type":"NodeText","Data":"在上述场景中，我们了解到核心对象有两类，一类是“观察者”，一类是“被观察的事物”，且两者间在数量上存在多对一的映射关系."}]},{"ID":"20231120160835-9vn1crl","Type":"NodeParagraph","Properties":{"id":"20231120160835-9vn1crl","updated":"20231120160835"},"Children":[{"Type":"NodeText","Data":"在具体作编程实现时，上述场景的实现思路可以是百花齐放的，而观察者模式只是为我们提供了一种相对规范的设计实现思路，其遵循的核心宗旨是实现“观察者”与“被观察对象”之间的解耦，并将其设计为通用的模块，便于后续的扩展和复用."}]}]}