{"ID":"20231202122517-zmyy6h5","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f3df","id":"20231202122517-zmyy6h5","tags":"公众号-Golang语言开发栈,Go-panic","title":"Golang 语言怎么使用 Painc 函数","updated":"20231202122912"},"Children":[{"ID":"20231202122517-sjy6589","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231202122517-sjy6589","updated":"20231202122550"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20231202122550-o55kn4v","Type":"NodeParagraph","Properties":{"id":"20231202122550-o55kn4v","updated":"20231202122650"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"    panic 是一个 Go 内置函数，它用来停止当前常规控制流并启动 panicking（运行时恐慌）过程。"}]},{"ID":"20231202122658-i1rm4j3","Type":"NodeParagraph","Properties":{"id":"20231202122658-i1rm4j3"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"    当函数 F 调用 panic 函数时，函数 F 的执行停止，函数 F 中已进行了求值的 defer 函数都将得到正常执行，然后函数 F 将控制权返还给其调用者。"}]},{"ID":"20231202122702-owebsd9","Type":"NodeParagraph","Properties":{"id":"20231202122702-owebsd9"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"    对于函数 F 的调用者而言，函数 F 之后的行为就如同调用者调用的函数是 panic 一样，该 panicking（运行时恐慌）过程将继续在栈上进行下去，直到当前 goroutine 中的所有函数都返回为止，此时程序将崩溃退出。"}]},{"ID":"20231202122652-r4ehgyg","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231202122652-r4ehgyg","updated":"20231202122726"},"Children":[{"Type":"NodeText","Data":"panic 触发方式和引发后果"}]},{"ID":"20231202122734-d5l05zc","Type":"NodeParagraph","Properties":{"id":"20231202122734-d5l05zc","updated":"20231202122734"},"Children":[{"Type":"NodeText","Data":"Golang 语言是静态强类型语言，在编译时，大多数问题就会被发现。但是一些会触发 panic 的问题只能在运行时才会被发现。"}]},{"ID":"20231202122734-bpx5wtr","Type":"NodeParagraph","Properties":{"id":"20231202122734-bpx5wtr","updated":"20231202122734"},"Children":[{"Type":"NodeText","Data":"panic 触发方式有两种，除了上面讲到的，在运行时遇到错误触发 panic，比如越界访问数组，不相同类型的变量强制类型转换等，还可以通过直接调用 panic 函数触发 panic。"}]},{"ID":"20231202122752-gcc2y1b","Type":"NodeParagraph","Properties":{"id":"20231202122752-gcc2y1b","updated":"20231202122753"},"Children":[{"Type":"NodeText","Data":"怎么通过显式调用 panic 函数触发 panic，panic 函数接收一个 interface{} 空接口类型的参数，也就是说，panic 函数可以接收一个任意类型的参数，代码如下："}]},{"ID":"20231202122754-ujg6vqr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231202122754-ujg6vqr","updated":"20231202122806"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func panic(v interface{})\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231202122810-78ftvsj","Type":"NodeParagraph","Properties":{"id":"20231202122810-78ftvsj","updated":"20231202122816"},"Children":[{"Type":"NodeText","Data":"什么时候通过显式调用 panic 函数触发 panic？"}]},{"ID":"20231202122817-z958kqz","Type":"NodeParagraph","Properties":{"id":"20231202122817-z958kqz","updated":"20231202122823"},"Children":[{"Type":"NodeText","Data":"虽然 panic 可以使程序崩溃，我们尽量少用 panic，但是少用不等于不用。阅读过 golang 源码的读者应该发现在 golang 标准库代码中有显式调用 panic 函数的代码片段，比如 golang 标准库的 json 包。"}]},{"ID":"20231202122824-gjogkt8","Type":"NodeBlockquote","Properties":{"id":"20231202122824-gjogkt8","updated":"20231202122839"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231202122833-0dl9l9y","Type":"NodeParagraph","Properties":{"id":"20231202122833-0dl9l9y","updated":"20231202122839"},"Children":[{"Type":"NodeText","Data":"请参阅在 encode.go 文件中 encodeState 类型的 error 和 marshal 方法的代码。"}]}]},{"ID":"20231202122848-66njrk2","Type":"NodeParagraph","Properties":{"id":"20231202122848-66njrk2","updated":"20231202122848"},"Children":[{"Type":"NodeText","Data":"另外，当我们在程序中处理会影响程序正确运行的错误时，也可以考虑使用显式调用 panic 函数来返回错误。"}]},{"ID":"20231202122848-fwk5uih","Type":"NodeParagraph","Properties":{"id":"20231202122848-fwk5uih","updated":"20231202122848"},"Children":[{"Type":"NodeText","Data":"不管是显式调用 panic 函数，还是运行时检测到违法情况自动触发 panic，都会导致程序崩溃。那么，我们应该怎么处理 panic 呢？"}]},{"ID":"20231202122849-t8p9kum","Type":"NodeParagraph","Properties":{"id":"20231202122849-t8p9kum","updated":"20231202122857"},"Children":[{"Type":"NodeText","Data":"通常的做法是使用 defer 和 recover 捕获 panic，将 panic 错误写入日志文件，将程序恢复正常执行。需要注意的是，panic 是谁触发谁捕获，当我们调用三方库时，调用方是不会考虑处理三方库的 panic 异常。"}]},{"ID":"20231202122858-r733wys","Type":"NodeParagraph","Properties":{"id":"20231202122858-r733wys","updated":"20231202122904"},"Children":[{"Type":"NodeText","Data":"但是，对于一些严重的 panic 异常，例如 main 函数和 init 函数中执行的程序代码，不应该使用 recover 捕获并将程序恢复正常执行，而是应该及时让 panic 执行，使程序崩溃，及时暴露出问题并解决。"}]},{"ID":"20231202122912-2zeowm7","Type":"NodeParagraph","Properties":{"id":"20231202122912-2zeowm7"}}]}