{"ID":"20230823115837-u8nwjsa","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230823115837-u8nwjsa","title":"gRPC简介","updated":"20230823115929"},"Children":[{"ID":"20230823115929-mxfgmi0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230823115929-mxfgmi0","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"Grpc 框架介绍"}]},{"ID":"20230823115929-59pcin3","Type":"NodeParagraph","Properties":{"id":"20230823115929-59pcin3","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目前，最常见最传统的进程间通信方式是构建一个Restful服务，将应用程序建模为一个可访问的资源集合，然后通过http协议进行服务调用，获取资源或者变更资源状态。然而，在比较多的场景下Restful服务对于构建进程间通信来说过于庞大、低效且容易出错，需要一个比Restful服务更高效的高可扩展、松耦合的进程间通信技术。因此，诞生了gRPC，一种用于构建分布式应用程序和微服务的现代进程间通信方式。"}]},{"ID":"20230823115929-1jol437","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230823115929-1jol437","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://www.jianshu.com/p/8fb407ddc253","TextMarkTextContent":"深入浅出gRPC "}]},{"ID":"20230823115929-vm2jo9t","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230823115929-vm2jo9t","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"什么是gRPC？"}]},{"ID":"20230823115929-jd2wv7d","Type":"NodeParagraph","Properties":{"id":"20230823115929-jd2wv7d","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"gRPC是一种进程间通信技术。"},{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"gRPC 中，客户端可以直接调用不同机器上的服务端的方法，就像调用本地函数一样。"}]},{"ID":"20230823115929-6orm9au","Type":"NodeParagraph","Properties":{"id":"20230823115929-6orm9au","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"gRPC"},{"Type":"NodeText","Data":" 是 Google 发起的一个开源"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"远程过程调用系统"},{"Type":"NodeText","Data":"，该系统"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"面向服务端和协议端（客户端）"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"基于 HTTP/2 协议传输"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"基于Protobuf序列化协议开发"},{"Type":"NodeText","Data":"，拥有"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"双向流"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"流控"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"头部压缩"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"单TCP连接上的多路复用请求"},{"Type":"NodeText","Data":"等特性。"}]},{"ID":"20230823115929-u2qiyfx","Type":"NodeParagraph","Properties":{"id":"20230823115929-u2qiyfx","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"gRPC 是在 HTTP/2 之上实现的 RPC 框架，****HTTP/2 是第 7 层（应用层）协议"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"它运行在 TCP（第 4 层 - 传输层）协议之上"}]},{"ID":"20230823115929-zz0he3m","Type":"NodeParagraph","Properties":{"id":"20230823115929-zz0he3m","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"与许多 RPC 系统一样，"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"gRPC"},{"Type":"NodeText","Data":" 基于定义服务的思想，"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"指定可以远程调用的接口及其参数和返回类型"},{"Type":"NodeText","Data":"。服务端实现这个接口并运行一个 gRPC "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://cloud.tencent.com/product/cvm?from=10680","TextMarkTextContent":"服务器"},{"Type":"NodeText","Data":"来处理客户端调用。而"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"客户端有一个stub（在某些语言中也称为client），它提供与服务器相同的方法"},{"Type":"NodeText","Data":"。"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"客户端通过调用stub的方法来与服务端进行通信，获取响应结果。"}]},{"ID":"20230823115929-24emnfw","Type":"NodeParagraph","Properties":{"id":"20230823115929-24emnfw","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"微信截图_20230306220441"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file:///E:/Typora%20picture/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230306220441.png?lastModify=1692763145"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230823115929-yr5wfvh","Type":"NodeParagraph","Properties":{"id":"20230823115929-yr5wfvh","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"下图为开发gRPC应用的一个示例："}]},{"ID":"20230823115929-cwrjvvy","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20230823115929-cwrjvvy","updated":"20230823115929"},"Children":[{"ID":"20230823115929-mabzr5l","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20230823115929-mabzr5l","updated":"20230823115929"},"Children":[{"ID":"20230823115929-3hilo2v","Type":"NodeParagraph","Properties":{"id":"20230823115929-3hilo2v","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"首先，"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"你需要定义一个服务接口"},{"Type":"NodeText","Data":"。服务接口定义"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"包含有关客户端如何使用你的服务、允许客户端远程调用哪些方法、调用这些方法时需要传递哪些参数、返回格式是怎么样的等信息。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"一般通过"},{"Type":"NodeTextMark","TextMarkType":"strong a","TextMarkAHref":"https://developers.google.com/protocol-buffers","TextMarkTextContent":"protocol buffer"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"来定义服务接口。"}]}]},{"ID":"20230823115929-kopzoe4","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20230823115929-kopzoe4","updated":"20230823115929"},"Children":[{"ID":"20230823115929-gr4if0g","Type":"NodeParagraph","Properties":{"id":"20230823115929-gr4if0g","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"使用protocol buffer定义好服务接口"},{"Type":"NodeText","Data":"之后，你可"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"以使用它提供的protoc工具生成被称为"},{"Type":"NodeTextMark","TextMarkType":"mark em","TextMarkTextContent":"服务器骨架(Server Skeleton)"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"的服务端代码，它通过提供低级通信抽象来简化服务器端逻辑"},{"Type":"NodeText","Data":"。此外，你"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"还可以生成客户端代码，称为"},{"Type":"NodeTextMark","TextMarkType":"mark em","TextMarkTextContent":"客户端存根(client stub)"},{"Type":"NodeText","Data":"，它通过抽象来简化客户端通信，以隐藏不同编程语言的低级通信。"}]}]},{"ID":"20230823115929-4t8tva3","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20230823115929-4t8tva3","updated":"20230823115929"},"Children":[{"ID":"20230823115929-yb0yrwg","Type":"NodeParagraph","Properties":{"id":"20230823115929-yb0yrwg","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"客户端使用你在服务接口定义中指定的方法来进行远程调用，就像进行本地函数调用一样简单"},{"Type":"NodeText","Data":"。"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"底层 gRPC 框架会自动帮你处理数据序列化、网络通信、"},{"Type":"NodeTextMark","TextMarkType":"mark a","TextMarkAHref":"https://cloud.tencent.com/product/mfas?from=10680","TextMarkTextContent":"身份验证"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"、访问控制、可观察性等远程通信相关的所有复杂的工作。"}]}]}]},{"ID":"20230823115929-gk7er38","Type":"NodeParagraph","Properties":{"id":"20230823115929-gk7er38","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image-20230306220759953"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file:///E:/Typora%20picture/image-20230306220759953.png?lastModify=1692763145"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230823115929-yoe0ki5","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230823115929-yoe0ki5","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"RPC技术的演进"}]},{"ID":"20230823115929-x3cyuvd","Type":"NodeParagraph","Properties":{"id":"20230823115929-x3cyuvd","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RPC技术随着时间的推移出现了翻天覆地的变化，出现了各种RPC技术的实现来满足现代需求，并提供更好、更高效的开发体验。本节主要是了解RPC技术是如何演化成如今的gRPC的。"}]},{"ID":"20230823115929-hwhmwaq","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230823115929-hwhmwaq","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"常规的RPC"}]},{"ID":"20230823115929-0mkxmdd","Type":"NodeParagraph","Properties":{"id":"20230823115929-0mkxmdd","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RPC 是一种流行的进程间通信技术，用于构建客户端-服务器应用程序。使用 RPC，客户端可以像调用本地方法一样远程调用方法的功能。早期有几个比较流行的RPC实现，例如CORBA、RMI等，它们用于构建和连接服务或应用程序。然而，****大多数此类传统的RPC实现都非常复杂，因为它们建立在TCP等通信协议之上，互操作性较差，定义的协议规范也很繁琐。"}]},{"ID":"20230823115929-mymvwmh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230823115929-mymvwmh","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"SOAP"}]},{"ID":"20230823115929-0ro0528","Type":"NodeParagraph","Properties":{"id":"20230823115929-0ro0528","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"由于 CORBA 等传统 RPC 实现的局限性，简单对象访问协议 (SOAP) 被微软、IBM 等大型企业设计并大力推广。SOAP 是面向服务架构 (SOA) 中的标准通信技术，用于在服务（在 SOA 的上下文中通常称为 Web 服务）之间交换基于 XML 的结构化数据，并通过任何底层通信协议（例如 ，HTTP）进行通信。"}]},{"ID":"20230823115929-na5gv8o","Type":"NodeParagraph","Properties":{"id":"20230823115929-na5gv8o","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"使用 SOAP，你可以定义服务接口、该服务的操作以及用于调用这些操作的关联 XML 消息格式。****SOAP 是一种相当流行的技术，但消息格式的复杂性以及围绕 SOAP 构建的规范的复杂性降低了构建分布式应用程序的敏捷性。"},{"Type":"NodeText","Data":"因此，在现代分布式应用程序开发中，SOAP Web 服务被认为是一种遗留技术。大多数现有的分布式应用程序现在都不是使用 SOAP，而是使用 REST 架构风格开发的。"}]},{"ID":"20230823115929-1u3tr37","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230823115929-1u3tr37","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"REST"}]},{"ID":"20230823115929-21bvjzd","Type":"NodeParagraph","Properties":{"id":"20230823115929-21bvjzd","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Representational State Transfer (REST) 是一种源自 Roy Fielding 博士论文的架构风格"},{"Type":"NodeText","Data":"。Fielding 是 HTTP 规范的主要作者之一，也是 REST 架构风格的鼻祖。"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"REST 是面向资源架构 (ROA) 的基础，你可以将分布式应用程序建模为资源的集合，访问这些资源的客户端可以更改这些资源的状态（创建、读取、更新或删除）。"}]},{"ID":"20230823115929-ityvsyl","Type":"NodeParagraph","Properties":{"id":"20230823115929-ityvsyl","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"REST 的实际实现是 HTTP"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在 HTTP 中，你可以将 RESTful Web 应用程序建模为可使用唯一标识符 (URL) 访问的资源集合，可通过HTTP方法（GET、POST、PUT、DELETE、PATCH 等）来变更这些资源的状态。资源状态以文本格式表示，例如 JSON、XML、HTML、YAML 等。"}]},{"ID":"20230823115929-ykr1l43","Type":"NodeParagraph","Properties":{"id":"20230823115929-ykr1l43","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong mark","TextMarkTextContent":"使用带有 HTTP 和 JSON 的 REST 架构风格构建应用程序已成为构建微服务的常见方式。"},{"Type":"NodeText","Data":"然而，随着微服务数量的激增及网络交互的愈发复杂，RESTful 服务已经无法满足预期的现代需求。RESTful 服务有几个关键限制，使它难以成为现代基于微服务的应用程序的消息传递协议："}]},{"ID":"20230823115929-ar55pms","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20230823115929-ar55pms","updated":"20230823115929"},"Children":[{"ID":"20230823115929-t2mdj30","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20230823115929-t2mdj30","updated":"20230823115929"},"Children":[{"ID":"20230823115929-8k3ppkl","Type":"NodeParagraph","Properties":{"id":"20230823115929-8k3ppkl","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"低效的基于文本的消息协议。"},{"Type":"NodeText","Data":"本质上，RESTful 服务构建在基于文本的传输协议（如 HTTP 1.x）之上，并使用人类可读的文本格式（如 JSON）进行传输。当涉及到服务到服务的通信时，使用 JSON 等文本格式是非常低效的，因为通信的过程中会涉及到文本格式和二进制格式的转换，而且同样的内容，使用文本格式编码与使用其他简单编码方式相比，占用的空间更多，需要传输的数据也就更大。"}]}]},{"ID":"20230823115929-tqjw14v","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20230823115929-tqjw14v","updated":"20230823115929"},"Children":[{"ID":"20230823115929-quob7m0","Type":"NodeParagraph","Properties":{"id":"20230823115929-quob7m0","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"应用程序之间缺乏强类型接口。"},{"Type":"NodeText","Data":"当你开发 RESTful 服务时，不需要对应用程序之间共享的信息进行服务定义和类型定义。这会导致服务之间通信时容易出现不兼容、运行时错误和交互问题。"}]}]},{"ID":"20230823115929-7isjmp4","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20230823115929-7isjmp4","updated":"20230823115929"},"Children":[{"ID":"20230823115929-x56ixdu","Type":"NodeParagraph","Properties":{"id":"20230823115929-x56ixdu","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"REST 架构风格难以执行。"},{"Type":"NodeText","Data":"作为一种架构风格，REST 有很多“良好实践”，你需要遵循这些“良好实践”来实现真正的 RESTful 服务。但是它们没有作为实现协议（例如 HTTP）的一部分强制执行，这使得在实现阶段很难强制执行它们。"}]}]}]},{"ID":"20230823115929-n9wzjua","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230823115929-n9wzjua","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"gRPC"}]},{"ID":"20230823115929-agicdpj","Type":"NodeParagraph","Properties":{"id":"20230823115929-agicdpj","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"谷歌一直在使用一个名为"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://oreil.ly/vat5r","TextMarkTextContent":"Stubby"},{"Type":"NodeText","Data":"的通用 RPC 框架来连接数千个在多个数据中心运行并使用不同技术构建的微服务。其核心 RPC 层被设计成可以处理每天数百亿规模的请求。Stubby 有很多很棒的特性，但是它与 Google 的内部基础架构耦合得太紧密了，没有标准化，不能用作通用框架。"}]},{"ID":"20230823115929-aio4zv2","Type":"NodeParagraph","Properties":{"id":"20230823115929-aio4zv2","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"2015 年，Google发布了开源 RPC 框架gRPC，它是一个标准化的、通用的、跨平台的 RPC 基础设施。gRPC 旨在提供与 Stubby 相同的可扩展性、性能和功能。"}]},{"ID":"20230823115929-xz92yed","Type":"NodeParagraph","Properties":{"id":"20230823115929-xz92yed","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"从那时起，随着 Netflix、Square、Lyft、Docker、Cisco 和 CoreOS 等大公司的大规模采用，gRPC 的受欢迎程度在过去几年中急剧增长。后来，gRPC 加入了云原生计算基金会 (CNCF，最受欢迎的开源软件基金会之一，致力于使云原生计算变得普遍和可持续)，并从 CNCF 生态系统项目中获得了巨大的关注度。"}]},{"ID":"20230823115929-639jxre","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230823115929-639jxre","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"为什么选择 gRPC？"}]},{"ID":"20230823115929-58hsjbr","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230823115929-58hsjbr","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"gRPC的优势"}]},{"ID":"20230823115929-d9wpkw7","Type":"NodeParagraph","Properties":{"id":"20230823115929-d9wpkw7","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"gRPC带来的优势是越来越多地公司采用 gRPC 的关键。这些优势包括："}]},{"ID":"20230823115929-y2jmdp8","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20230823115929-y2jmdp8","updated":"20230823115929"},"Children":[{"ID":"20230823115929-86w51id","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20230823115929-86w51id","updated":"20230823115929"},"Children":[{"ID":"20230823115929-uwnotc9","Type":"NodeParagraph","Properties":{"id":"20230823115929-uwnotc9","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark strong","TextMarkTextContent":"实现的进程间通信方式高效。"},{"Type":"NodeText","Data":"gRPC 不使用 JSON 或 XML 等文本格式，"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"而是使用基于二进制协议的protocol buffer与 gRPC 服务、客户端进行通信。"},{"Type":"NodeText","Data":"此外，"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"gRPC 是在 HTTP/2 之上实现的protocol buffer"},{"Type":"NodeText","Data":"，这使得进程间通信更快。"}]}]},{"ID":"20230823115929-psup2vy","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20230823115929-psup2vy","updated":"20230823115929"},"Children":[{"ID":"20230823115929-op7jd0g","Type":"NodeParagraph","Properties":{"id":"20230823115929-op7jd0g","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark strong","TextMarkTextContent":"具有简单、定义良好的服务接口和协议"},{"Type":"NodeText","Data":"。你"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"首先定义服务接口"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"然后处理实现细节"},{"Type":"NodeText","Data":"。因此，与用于RESTful服务定义的 OpenAPI/Swagger 和用于 SOAP Web 服务的 WSDL 不同，"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"gRPC 提供了简单但一致、可靠且可扩展的应用程序开发体验"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20230823115929-vlgg3ie","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20230823115929-vlgg3ie","updated":"20230823115929"},"Children":[{"ID":"20230823115929-cvhf8hx","Type":"NodeParagraph","Properties":{"id":"20230823115929-cvhf8hx","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark strong","TextMarkTextContent":"强类型"},{"Type":"NodeText","Data":"。protocol buffer清楚地定义了应用程序之间通信的数据类型，这使得分布式应用程序开发更加稳定。因为静态类型有助于减少你在构建跨多个团队和技术的云原生应用程序时遇到的大多数运行时和交互错误。"}]}]},{"ID":"20230823115929-j6qw01h","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20230823115929-j6qw01h","updated":"20230823115929"},"Children":[{"ID":"20230823115929-da6ll8u","Type":"NodeParagraph","Properties":{"id":"20230823115929-da6ll8u","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark strong","TextMarkTextContent":"支持多语言"},{"Type":"NodeText","Data":"。gRPC被设计成支持多种编程语言。使用protocol buffer的服务定义与语言无关。因此，你可以选择grpc支持的任意语言，并与任何现有的 gRPC 服务或客户端进行通信。"}]}]},{"ID":"20230823115929-vsy6c6q","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20230823115929-vsy6c6q","updated":"20230823115929"},"Children":[{"ID":"20230823115929-bu26l1a","Type":"NodeParagraph","Properties":{"id":"20230823115929-bu26l1a","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark strong","TextMarkTextContent":"支持双向流式传输。"},{"Type":"NodeText","Data":"gRPC 对客户端或服务器端流式传输具有原生支持，这使得开发流媒体服务或流媒体客户端变得更加容易。"}]}]},{"ID":"20230823115929-eey60us","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Ni4=","Num":6},"Properties":{"id":"20230823115929-eey60us","updated":"20230823115929"},"Children":[{"ID":"20230823115929-83btka5","Type":"NodeParagraph","Properties":{"id":"20230823115929-83btka5","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark strong","TextMarkTextContent":"内置多种高级特性。gRPC 提供对高级特性的内置支持，例如身份验证、加密、元数据交换、压缩、负载平衡、服务发现等。"}]}]},{"ID":"20230823115929-zs4rufu","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Ny4=","Num":7},"Properties":{"id":"20230823115929-zs4rufu","updated":"20230823115929"},"Children":[{"ID":"20230823115929-3o46o9n","Type":"NodeParagraph","Properties":{"id":"20230823115929-3o46o9n","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark strong","TextMarkTextContent":"与云原生生态系统高度集成。"},{"Type":"NodeText","Data":"gRPC 是 CNCF 的一部分，大多数现代框架和技术都为 gRPC 提供了开箱即用的原生支持。例如，"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://oreil.ly/vGQsj","TextMarkTextContent":"Envoy"},{"Type":"NodeText","Data":"等 CNCF 下的许多项目都支持使用 gRPC 作为通信协议。"}]}]}]},{"ID":"20230823115929-tne3oyp","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230823115929-tne3oyp","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"gRPC的缺点"}]},{"ID":"20230823115929-32jqisi","Type":"NodeParagraph","Properties":{"id":"20230823115929-32jqisi","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"与任何技术一样，gRPC 也有一些缺点："}]},{"ID":"20230823115929-wyznwx2","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20230823115929-wyznwx2","updated":"20230823115929"},"Children":[{"ID":"20230823115929-az5puqe","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20230823115929-az5puqe","updated":"20230823115929"},"Children":[{"ID":"20230823115929-0fvtv5b","Type":"NodeParagraph","Properties":{"id":"20230823115929-0fvtv5b","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark strong","TextMarkTextContent":"它可能不适合面向外部的服务。当你想将应用程序或服务提供给外部客户端使用时，gRPC 可能不是最合适的协议，因为大多数外部使用者对 gRPC 还很陌生。"},{"Type":"NodeText","Data":"而且，gRPC 服务的协议驱动、强类型化特性可能会降低你向外部提供的服务的灵活性，因为外部使用者可以控制的东西要少得多。"}]}]},{"ID":"20230823115929-53z1jmv","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20230823115929-53z1jmv","updated":"20230823115929"},"Children":[{"ID":"20230823115929-gh59wes","Type":"NodeParagraph","Properties":{"id":"20230823115929-gh59wes","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"mark strong","TextMarkTextContent":"生态系统相对较小。"},{"Type":"NodeText","Data":"与传统的 REST/HTTP 协议相比，gRPC 生态系统仍然相对较小。浏览器和移动应用程序对 gRPC 的支持仍处于初级阶段。"}]}]}]},{"ID":"20230823115929-3dc332f","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230823115929-3dc332f","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"gRPC与其他协议：Apache Thrift和GraphQL"}]},{"ID":"20230823115929-kpknfm7","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230823115929-kpknfm7","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"Apache Thrift"}]},{"ID":"20230823115929-0fvz5ei","Type":"NodeParagraph","Properties":{"id":"20230823115929-0fvz5ei","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://thrift.apache.org/","TextMarkTextContent":"Apache Thrift"},{"Type":"NodeText","Data":"是一个类似于 gRPC 的 RPC 框架（最初由 Facebook 开发，后来捐赠给 Apache）。它使用自己的接口定义语言并提供对多种编程语言的支持。Thrift 允许你在定义文件中定义数据类型和服务接口，并根据你定义的文件为客户端和服务器端生成代码。Thrift 传输层为网络 I/O 提供抽象，并将 Thrift 与系统的其余部分解耦，这意味着它可以在任何传输实现上运行，例如 TCP、HTTP 等。"}]},{"ID":"20230823115929-su23epl","Type":"NodeParagraph","Properties":{"id":"20230823115929-su23epl","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果将 Thrift 与 gRPC 进行比较，你会发现两者几乎都遵循相同的设计和使用目标。但是，两者之间有几个重要的区别："}]},{"ID":"20230823115929-ppjjfng","Type":"NodeList","ListData":{},"Properties":{"id":"20230823115929-ppjjfng","updated":"20230823115929"},"Children":[{"ID":"20230823115929-o7ho8eg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230823115929-o7ho8eg","updated":"20230823115929"},"Children":[{"ID":"20230823115929-2vo31sp","Type":"NodeParagraph","Properties":{"id":"20230823115929-2vo31sp","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"传输。gRPC并未给网络 I/O 提供抽象，而是强依赖于 HTTP/2 。它基于HTTP/2实现了传输的高效，并支持流式传输等消息传递模式。"}]}]},{"ID":"20230823115929-uw62p9b","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230823115929-uw62p9b","updated":"20230823115929"},"Children":[{"ID":"20230823115929-8l61icq","Type":"NodeParagraph","Properties":{"id":"20230823115929-8l61icq","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"流式传输。gRPC 原生支持双向流（客户端和服务器）。"}]}]},{"ID":"20230823115929-ldnhn1c","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230823115929-ldnhn1c","updated":"20230823115929"},"Children":[{"ID":"20230823115929-bdvql2i","Type":"NodeParagraph","Properties":{"id":"20230823115929-bdvql2i","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"性能。虽然没有 gRPC 与 Thrift 的官方比较结果，但有一些在线资源对两者进行了性能比较，显示 Thrift 的数据更好。然而，gRPC 在几乎所有版本中都做过严格的性能基准测试，与Thrift相比，性能相差较小。因此，在选择使用Thrift还是gRPC时，性能不太可能成为决定因素。"}]}]}]},{"ID":"20230823115929-kj9mdwl","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230823115929-kj9mdwl","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"GraphQL"}]},{"ID":"20230823115929-5gxj9va","Type":"NodeParagraph","Properties":{"id":"20230823115929-5gxj9va","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://graphql.org/","TextMarkTextContent":"GraphQL"},{"Type":"NodeText","Data":"是另一种技术（由Facebook最先创建并标准化），在构建进程间通信方面非常流行。GraphQL 为传统的客户端-服务器通信提供了一种完全不一样的实现，它是 API 的一种查询语言，允许客户端来决定他们想要什么数据、他们想要怎么获取数据以及他们想要什么格式的数据。而gRPC对于客户端和服务器之间的通信方式有一个固定的协议。"}]},{"ID":"20230823115929-iz2qcq5","Type":"NodeParagraph","Properties":{"id":"20230823115929-iz2qcq5","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"GraphQL 更适合直接面向外部的服务或 API，其中客户端需要对从服务器获取的数据进行更多控制。"}]},{"ID":"20230823115929-l3e1woj","Type":"NodeParagraph","Properties":{"id":"20230823115929-l3e1woj","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在 GraphQL 和 gRPC 的大多数现实例子中，GraphQL 被用于面向外部的服务/API，而面向内部的服务则使用 gRPC 实现。"}]},{"ID":"20230823115929-f31uppp","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230823115929-f31uppp","updated":"20230823115929"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20230823115929-m7c9ds1","Type":"NodeParagraph","Properties":{"id":"20230823115929-m7c9ds1","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"gRPC 是一种可扩展、松耦合且类型安全的解决方案，与传统的基于 REST/HTTP 的通信相比，它实现了更高效的进程间通信。它允许你像本地方法调用一样调用、调试分布式应用程序。"}]},{"ID":"20230823115929-fzqhnu0","Type":"NodeParagraph","Properties":{"id":"20230823115929-fzqhnu0","updated":"20230823115929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"gRPC 也可以被认为是传统 RPC 的演变，并且已经设法克服了它们的局限性。它被各种互联网公司广泛采用，以满足其进程间通信需求，最常用于构建内部服务到服务的通信。"}]}]}