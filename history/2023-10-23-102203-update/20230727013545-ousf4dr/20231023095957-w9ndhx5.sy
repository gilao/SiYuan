{"ID":"20231023095957-w9ndhx5","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f6fa","id":"20231023095957-w9ndhx5","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20231023095957-w9ndhx5\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231023095957-3ljmjd7\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231023101210-mzlesi6\u0026quot;,\u0026quot;scrollTop\u0026quot;:13625,\u0026quot;focusId\u0026quot;:\u0026quot;20231023101210-mzlesi6\u0026quot;,\u0026quot;focusStart\u0026quot;:88,\u0026quot;focusEnd\u0026quot;:88\u0026#125;","tags":"公众号-捡田螺的小男孩,未完成","title":"接口请求合并，效率直接加倍","updated":"20231023101210"},"Children":[{"ID":"20231023095957-3ljmjd7","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231023095957-3ljmjd7","updated":"20231023100054"},"Children":[{"Type":"NodeText","Data":"请求合并到底有什么意义呢？"}]},{"ID":"20231023100224-95lyx3b","Type":"NodeParagraph","Properties":{"id":"20231023100224-95lyx3b"},"Children":[{"Type":"NodeText","Data":"我们来看下图。"}]},{"ID":"20231023100111-4zdk7ph","Type":"NodeParagraph","Properties":{"id":"20231023100111-4zdk7ph","updated":"20231023100111"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231023100111-5ndv8sw.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231023100120-j1i4i3b","Type":"NodeParagraph","Properties":{"id":"20231023100120-j1i4i3b","updated":"20231023100134"},"Children":[{"Type":"NodeText","Data":"假设我们3个用户（用户id分别是1、2、3），现在他们都要查询自己的基本信息，请求到服务器，服务器端请求数据库，发出3次请求。我们都知道数据库连接资源是相当宝贵的，那么我们怎么尽可能节省连接资源呢？"}]},{"ID":"20231023100135-gsa73hx","Type":"NodeBlockquote","Properties":{"id":"20231023100135-gsa73hx","updated":"20231023100143"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231023100142-1jrbva9","Type":"NodeParagraph","Properties":{"id":"20231023100142-1jrbva9","updated":"20231023100143"},"Children":[{"Type":"NodeText","Data":"这里把数据库换成被调用的远程服务，也是同样的道理。"}]}]},{"ID":"20231023100144-5bvaodv","Type":"NodeParagraph","Properties":{"id":"20231023100144-5bvaodv","updated":"20231023100147"},"Children":[{"Type":"NodeText","Data":"我们改变下思路，如下图所示。"}]},{"ID":"20231023100200-paiwnw3","Type":"NodeParagraph","Properties":{"id":"20231023100200-paiwnw3","updated":"20231023100200"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231023100200-axh754c.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231023100211-jog2s1v","Type":"NodeParagraph","Properties":{"id":"20231023100211-jog2s1v","updated":"20231023100211"},"Children":[{"Type":"NodeText","Data":"我们在服务器端把请求合并，只发出一条SQL查询数据库，数据库返回后，服务器端处理返回数据，根据一个唯一请求ID，把数据分组，返回给对应用户。"}]},{"ID":"20231023100214-zdst5dg","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231023100214-zdst5dg","updated":"20231023100236"},"Children":[{"Type":"NodeText","Data":"技术手段"}]},{"ID":"20231023100237-s8kf1o2","Type":"NodeList","ListData":{},"Properties":{"id":"20231023100237-s8kf1o2","updated":"20231023100429"},"Children":[{"ID":"20231023100238-fq0b6tx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231023100238-fq0b6tx","updated":"20231023100238"},"Children":[{"ID":"20231023100238-kt46k0o","Type":"NodeParagraph","Properties":{"id":"20231023100238-kt46k0o","updated":"20231023100304"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"LinkedBlockQueue"},{"Type":"NodeText","Data":"​ 阻塞队列"}]}]},{"ID":"20231023100304-4j7n95u","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231023100304-4j7n95u"},"Children":[{"ID":"20231023100304-sl6pji1","Type":"NodeParagraph","Properties":{"id":"20231023100304-sl6pji1","updated":"20231023100336"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":"​ 定时任务线程池"}]}]},{"ID":"20231023100336-vtevgvb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231023100336-vtevgvb","updated":"20231023100429"},"Children":[{"ID":"20231023100336-hkc3wfz","Type":"NodeParagraph","Properties":{"id":"20231023100336-hkc3wfz","updated":"20231023100429"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"CompleteableFuture future"},{"Type":"NodeText","Data":"​阻塞机制"}]}]}]},{"ID":"20231023101210-5w6wqjd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231023101210-5w6wqjd","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20231023101210-u1we805","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-u1we805","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"查询用户的代码"}]},{"ID":"20231023101210-htfa4pt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231023101210-htfa4pt","updated":"20231023101210"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"public interface UserService {\n\n    Map\u003cString, Users\u003e queryUserByIdBatch(List\u003cUserWrapBatchService.Request\u003e userReqs);\n}\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UsersMapper usersMapper;\n\n    @Override\n    public Map\u003cString, Users\u003e queryUserByIdBatch(List\u003cUserWrapBatchService.Request\u003e userReqs) {\n        // 全部参数\n        List\u003cLong\u003e userIds = userReqs.stream().map(UserWrapBatchService.Request::getUserId).collect(Collectors.toList());\n        QueryWrapper\u003cUsers\u003e queryWrapper = new QueryWrapper\u003c\u003e();\n        // 用in语句合并成一条SQL，避免多次请求数据库的IO\n        queryWrapper.in(\"id\", userIds);\n        List\u003cUsers\u003e users = usersMapper.selectList(queryWrapper);\n        Map\u003cLong, List\u003cUsers\u003e\u003e userGroup = users.stream().collect(Collectors.groupingBy(Users::getId));\n        HashMap\u003cString, Users\u003e result = new HashMap\u003c\u003e();\n        userReqs.forEach(val -\u003e {\n            List\u003cUsers\u003e usersList = userGroup.get(val.getUserId());\n            if (!CollectionUtils.isEmpty(usersList)) {\n                result.put(val.getRequestId(), usersList.get(0));\n            } else {\n                // 表示没数据\n                result.put(val.getRequestId(), null);\n            }\n        });\n        return result;\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231023101210-mout9v8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-mout9v8","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"合并请求的实现"}]},{"ID":"20231023101210-sknmgt2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231023101210-sknmgt2","updated":"20231023101210"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"package com.springboot.sample.service.impl;\n\nimport com.springboot.sample.bean.Users;\nimport com.springboot.sample.service.UserService;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.Resource;\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/***\n * zzq\n * 包装成批量执行的地方\n * */\n@Service\npublic class UserWrapBatchService {\n    @Resource\n    private UserService userService;\n\n    /**\n     * 最大任务数\n     **/\n    public static int MAX_TASK_NUM = 100;\n\n\n    /**\n     * 请求类,code为查询的共同特征,例如查询商品,通过不同id的来区分\n     * CompletableFuture将处理结果返回\n     */\n    public class Request {\n        // 请求id 唯一\n        String requestId;\n        // 参数\n        Long userId;\n        //TODO Java 8 的 CompletableFuture 并没有 timeout 机制\n        CompletableFuture\u003cUsers\u003e completableFuture;\n\n        public String getRequestId() {\n            return requestId;\n        }\n\n        public void setRequestId(String requestId) {\n            this.requestId = requestId;\n        }\n\n        public Long getUserId() {\n            return userId;\n        }\n\n        public void setUserId(Long userId) {\n            this.userId = userId;\n        }\n\n        public CompletableFuture getCompletableFuture() {\n            return completableFuture;\n        }\n\n        public void setCompletableFuture(CompletableFuture completableFuture) {\n            this.completableFuture = completableFuture;\n        }\n    }\n\n    /*\n    LinkedBlockingQueue是一个阻塞的队列,内部采用链表的结果,通过两个ReenTrantLock来保证线程安全\n    LinkedBlockingQueue与ArrayBlockingQueue的区别\n    ArrayBlockingQueue默认指定了长度,而LinkedBlockingQueue的默认长度是Integer.MAX_VALUE,也就是无界队列,在移除的速度小于添加的速度时，容易造成OOM。\n    ArrayBlockingQueue的存储容器是数组,而LinkedBlockingQueue是存储容器是链表\n    两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，\n    而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，\n    也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。\n     */\n    private final Queue\u003cRequest\u003e queue = new LinkedBlockingQueue();\n\n    @PostConstruct\n    public void init() {\n        //定时任务线程池,创建一个支持定时、周期性或延时任务的限定线程数目(这里传入的是1)的线程池\n        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);\n\n        scheduledExecutorService.scheduleAtFixedRate(() -\u003e {\n            int size = queue.size();\n            //如果队列没数据,表示这段时间没有请求,直接返回\n            if (size == 0) {\n                return;\n            }\n            List\u003cRequest\u003e list = new ArrayList\u003c\u003e();\n            System.out.println(\"合并了 [\" + size + \"] 个请求\");\n            //将队列的请求消费到一个集合保存\n            for (int i = 0; i \u003c size; i++) {\n                // 后面的SQL语句是有长度限制的，所以还要做限制每次批量的数量,超过最大任务数，等下次执行\n                if (i \u003c MAX_TASK_NUM) {\n                    list.add(queue.poll());\n                }\n            }\n            //拿到我们需要去数据库查询的特征,保存为集合\n            List\u003cRequest\u003e userReqs = new ArrayList\u003c\u003e();\n            for (Request request : list) {\n                userReqs.add(request);\n            }\n            //将参数传入service处理, 这里是本地服务，也可以把userService 看成RPC之类的远程调用\n            Map\u003cString, Users\u003e response = userService.queryUserByIdBatch(userReqs);\n            //将处理结果返回各自的请求\n            for (Request request : list) {\n                Users result = response.get(request.requestId);\n                request.completableFuture.complete(result);    //completableFuture.complete方法完成赋值,这一步执行完毕,下面future.get()阻塞的请求可以继续执行了\n            }\n        }, 100, 10, TimeUnit.MILLISECONDS);\n        //scheduleAtFixedRate是周期性执行 schedule是延迟执行 initialDelay是初始延迟 period是周期间隔 后面是单位\n        //这里我写的是 初始化后100毫秒后执行，周期性执行10毫秒执行一次\n    }\n\n    public Users queryUser(Long userId) {\n        Request request = new Request();\n        // 这里用UUID做请求id\n        request.requestId = UUID.randomUUID().toString().replace(\"-\", \"\");\n        request.userId = userId;\n        CompletableFuture\u003cUsers\u003e future = new CompletableFuture\u003c\u003e();\n        request.completableFuture = future;\n        //将对象传入队列\n        queue.offer(request);\n        //如果这时候没完成赋值,那么就会阻塞,直到能够拿到值\n        try {\n            return future.get();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231023101210-b3by49b","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-b3by49b","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"控制层调用"}]},{"ID":"20231023101210-9bfgdkz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231023101210-9bfgdkz","updated":"20231023101210"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"/***\n * 请求合并\n * */\n@RequestMapping(\"/merge\")\npublic Callable\u003cUsers\u003e merge(Long userId) {\n    return new Callable\u003cUsers\u003e() {\n        @Override\n        public Users call() throws Exception {\n            return userBatchService.queryUser(userId);\n        }\n    };\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231023101210-6i5xg8g","Type":"NodeParagraph","Properties":{"id":"20231023101210-6i5xg8g","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"Callable是什么可以参考："}]},{"ID":"20231023101210-5dgs8am","Type":"NodeBlockquote","Properties":{"id":"20231023101210-5dgs8am","updated":"20231023101210"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231023101210-okpbe88","Type":"NodeParagraph","Properties":{"id":"20231023101210-okpbe88","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"https://blog.csdn.net/baidu_19473529/article/details/123596792"}]}]},{"ID":"20231023101210-7ohor64","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-7ohor64","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"模拟高并发查询的代码"}]},{"ID":"20231023101210-mv9cwcv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231023101210-mv9cwcv","updated":"20231023101210"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"package com.springboot.sample;\n\nimport org.springframework.web.client.RestTemplate;\n\nimport java.util.Random;\nimport java.util.concurrent.CountDownLatch;\n\npublic class TestBatch {\n    private static int threadCount = 30;\n\n    private final static CountDownLatch COUNT_DOWN_LATCH = new CountDownLatch(threadCount); //为保证30个线程同时并发运行\n\n    private static final RestTemplate restTemplate = new RestTemplate();\n\n    public static void main(String[] args) {\n\n\n        for (int i = 0; i \u003c threadCount; i++) {//循环开30个线程\n            new Thread(new Runnable() {\n                public void run() {\n                    COUNT_DOWN_LATCH.countDown();//每次减一\n                    try {\n                        COUNT_DOWN_LATCH.await(); //此处等待状态，为了让30个线程同时进行\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n\n                    for (int j = 1; j \u003c= 3; j++) {\n                        int param = new Random().nextInt(4);\n                        if (param \u003c=0){\n                            param++;\n                        }\n                        String responseBody = restTemplate.getForObject(\"http://localhost:8080/asyncAndMerge/merge?userId=\" + param, String.class);\n                        System.out.println(Thread.currentThread().getName() + \"参数 \" + param + \" 返回值 \" + responseBody);\n                    }\n                }\n            }).start();\n\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231023101210-umqevdu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-umqevdu","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"测试效果"}]},{"ID":"20231023101210-tgmmsvs","Type":"NodeParagraph","Properties":{"id":"20231023101210-tgmmsvs","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rB4TgNtRS15UMzwgjK4PJ6EqIe1XpeBjKKYJdVMB62u5HWsqE9zDTNduVxbiaURIDhpQ0hia8EXXP1w/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"\n图片"}]},{"ID":"20231023101210-0y34y9u","Type":"NodeParagraph","Properties":{"id":"20231023101210-0y34y9u","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rB4TgNtRS15UMzwgjK4PJ6EwWQ9UwcOvIibdRr8rhibudh4hAPD3Z3Liccs2Xf2icyoQDVa36TjvV25JQ/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"\n图片"}]},{"ID":"20231023101210-zv6fn6t","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-zv6fn6t","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"要注意的问题"}]},{"ID":"20231023101210-uooe793","Type":"NodeList","ListData":{},"Properties":{"id":"20231023101210-uooe793","updated":"20231023101210"},"Children":[{"ID":"20231023101210-ml15a2l","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231023101210-ml15a2l","updated":"20231023101210"},"Children":[{"ID":"20231023101210-xum5gso","Type":"NodeParagraph","Properties":{"id":"20231023101210-xum5gso","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"Java 8 的 CompletableFuture 并没有 timeout 机制"}]}]},{"ID":"20231023101210-pprbswr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231023101210-pprbswr","updated":"20231023101210"},"Children":[{"ID":"20231023101210-xjrxy6n","Type":"NodeParagraph","Properties":{"id":"20231023101210-xjrxy6n","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"后面的SQL语句是有长度限制的，所以还要做限制每次批量的数量,超过最大任务数，等下次执行（本例中加了MAX_TASK_NUM判断）"}]}]}]},{"ID":"20231023101210-9xep0gi","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231023101210-9xep0gi","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"使用队列的超时解决Java 8 的 CompletableFuture 并没有 timeout 机制"}]},{"ID":"20231023101210-0u7i3hi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-0u7i3hi","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"核心代码"}]},{"ID":"20231023101210-2mkqvcc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231023101210-2mkqvcc","updated":"20231023101210"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"package com.springboot.sample.service.impl;\n\nimport com.springboot.sample.bean.Users;\nimport com.springboot.sample.service.UserService;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.Resource;\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/***\n * zzq\n * 包装成批量执行的地方，使用queue解决超时问题\n * */\n@Service\npublic class UserWrapBatchQueueService {\n    @Resource\n    private UserService userService;\n\n    /**\n     * 最大任务数\n     **/\n    public static int MAX_TASK_NUM = 100;\n\n\n    /**\n     * 请求类,code为查询的共同特征,例如查询商品,通过不同id的来区分\n     * CompletableFuture将处理结果返回\n     */\n    public class Request {\n        // 请求id\n        String requestId;\n\n        // 参数\n        Long userId;\n        // 队列，这个有超时机制\n        LinkedBlockingQueue\u003cUsers\u003e usersQueue;\n\n\n        public String getRequestId() {\n            return requestId;\n        }\n\n        public void setRequestId(String requestId) {\n            this.requestId = requestId;\n        }\n\n        public Long getUserId() {\n            return userId;\n        }\n\n        public void setUserId(Long userId) {\n            this.userId = userId;\n        }\n\n        public LinkedBlockingQueue\u003cUsers\u003e getUsersQueue() {\n            return usersQueue;\n        }\n\n        public void setUsersQueue(LinkedBlockingQueue\u003cUsers\u003e usersQueue) {\n            this.usersQueue = usersQueue;\n        }\n    }\n\n    /*\n    LinkedBlockingQueue是一个阻塞的队列,内部采用链表的结果,通过两个ReenTrantLock来保证线程安全\n    LinkedBlockingQueue与ArrayBlockingQueue的区别\n    ArrayBlockingQueue默认指定了长度,而LinkedBlockingQueue的默认长度是Integer.MAX_VALUE,也就是无界队列,在移除的速度小于添加的速度时，容易造成OOM。\n    ArrayBlockingQueue的存储容器是数组,而LinkedBlockingQueue是存储容器是链表\n    两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，\n    而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，\n    也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。\n     */\n    private final Queue\u003cRequest\u003e queue = new LinkedBlockingQueue();\n\n    @PostConstruct\n    public void init() {\n        //定时任务线程池,创建一个支持定时、周期性或延时任务的限定线程数目(这里传入的是1)的线程池\n        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);\n\n        scheduledExecutorService.scheduleAtFixedRate(() -\u003e {\n            int size = queue.size();\n            //如果队列没数据,表示这段时间没有请求,直接返回\n            if (size == 0) {\n                return;\n            }\n            List\u003cRequest\u003e list = new ArrayList\u003c\u003e();\n            System.out.println(\"合并了 [\" + size + \"] 个请求\");\n            //将队列的请求消费到一个集合保存\n            for (int i = 0; i \u003c size; i++) {\n                // 后面的SQL语句是有长度限制的，所以还要做限制每次批量的数量,超过最大任务数，等下次执行\n                if (i \u003c MAX_TASK_NUM) {\n                    list.add(queue.poll());\n                }\n            }\n            //拿到我们需要去数据库查询的特征,保存为集合\n            List\u003cRequest\u003e userReqs = new ArrayList\u003c\u003e();\n            for (Request request : list) {\n                userReqs.add(request);\n            }\n            //将参数传入service处理, 这里是本地服务，也可以把userService 看成RPC之类的远程调用\n            Map\u003cString, Users\u003e response = userService.queryUserByIdBatchQueue(userReqs);\n            for (Request userReq : userReqs) {\n                // 这里再把结果放到队列里\n                Users users = response.get(userReq.getRequestId());\n                userReq.usersQueue.offer(users);\n            }\n\n        }, 100, 10, TimeUnit.MILLISECONDS);\n        //scheduleAtFixedRate是周期性执行 schedule是延迟执行 initialDelay是初始延迟 period是周期间隔 后面是单位\n        //这里我写的是 初始化后100毫秒后执行，周期性执行10毫秒执行一次\n    }\n\n    public Users queryUser(Long userId) {\n        Request request = new Request();\n        // 这里用UUID做请求id\n        request.requestId = UUID.randomUUID().toString().replace(\"-\", \"\");\n        request.userId = userId;\n        LinkedBlockingQueue\u003cUsers\u003e usersQueue = new LinkedBlockingQueue\u003c\u003e();\n        request.usersQueue = usersQueue;\n        //将对象传入队列\n        queue.offer(request);\n        //取出元素时，如果队列为空，给定阻塞多少毫秒再队列取值，这里是3秒\n        try {\n            return usersQueue.poll(3000,TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n...省略..\n\n    @Override\n    public Map\u003cString, Users\u003e queryUserByIdBatchQueue(List\u003cUserWrapBatchQueueService.Request\u003e userReqs) {\n        // 全部参数\n        List\u003cLong\u003e userIds = userReqs.stream().map(UserWrapBatchQueueService.Request::getUserId).collect(Collectors.toList());\n        QueryWrapper\u003cUsers\u003e queryWrapper = new QueryWrapper\u003c\u003e();\n        // 用in语句合并成一条SQL，避免多次请求数据库的IO\n        queryWrapper.in(\"id\", userIds);\n        List\u003cUsers\u003e users = usersMapper.selectList(queryWrapper);\n        Map\u003cLong, List\u003cUsers\u003e\u003e userGroup = users.stream().collect(Collectors.groupingBy(Users::getId));\n        HashMap\u003cString, Users\u003e result = new HashMap\u003c\u003e();\n        // 数据分组\n        userReqs.forEach(val -\u003e {\n            List\u003cUsers\u003e usersList = userGroup.get(val.getUserId());\n            if (!CollectionUtils.isEmpty(usersList)) {\n                result.put(val.getRequestId(), usersList.get(0));\n            } else {\n                // 表示没数据 , 这里要new，不然加入队列会空指针\n                result.put(val.getRequestId(), new Users());\n            }\n        });\n        return result;\n    }\n\n...省略...\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231023101210-m3haon0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231023101210-m3haon0","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"小结"}]},{"ID":"20231023101210-mzlesi6","Type":"NodeParagraph","Properties":{"id":"20231023101210-mzlesi6","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"请求合并，批量的办法能大幅节省被调用系统的连接资源，本例是以数据库为例，其他RPC调用也是类似的道理。缺点就是请求的时间在执行实际的逻辑之前增加了等待时间，不适合低并发的场景。"}]}]}