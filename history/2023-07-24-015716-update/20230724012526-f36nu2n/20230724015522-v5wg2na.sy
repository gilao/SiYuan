{"ID":"20230724015522-v5wg2na","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f950","id":"20230724015522-v5wg2na","tags":"Docker,需要仔细看,未完成","title":"13. 隔离 限制危险","updated":"20230724015617"},"Children":[{"ID":"20230724015527-jei6z7a","Type":"NodeParagraph","Properties":{"id":"20230724015527-jei6z7a","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"容器提供的是进程上下文的隔离，而不是整个系统的虚拟化。、"}]},{"ID":"20230724015527-bi8l2l5","Type":"NodeParagraph","Properties":{"id":"20230724015527-bi8l2l5","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"本章覆盖剩余的部分，并且包含了加强系统安全的内容。"}]},{"ID":"20230724015527-jgjx38i","Type":"NodeParagraph","Properties":{"id":"20230724015527-jgjx38i","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"本章包含的特性主要专注于管理或者限制正在运行的软件的危险性。"}]},{"ID":"20230724015527-pvgmuvr","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724015527-pvgmuvr","updated":"20230724015527"},"Children":[{"Type":"NodeText","Data":"1. 资源分配"}]},{"ID":"20230724015527-zixrtb2","Type":"NodeParagraph","Properties":{"id":"20230724015527-zixrtb2","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"物理系统资源非常稀少，比如说内存和CPU时间。如果进程的资源消耗超过可用的物理资源，那么进程将会遭遇性能问题并且可能会停止运行。构建强隔离系统的内容包含对单独的容器提供资源的定量分配。"}]},{"ID":"20230724015527-x01ijls","Type":"NodeParagraph","Properties":{"id":"20230724015527-x01ijls","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果你想要确保一个程序不会因使用资源过多而压垮其他程序，最简单的办法就是限制这个进程所能够使用的资源。****Docker为docker run和docker create命令提供了三个选项来管理三种不同类型资源的分配。这三种类型为内存、CPU和设备。"}]},{"ID":"20230724015527-4d2c65u","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724015527-4d2c65u","updated":"20230724015527"},"Children":[{"Type":"NodeText","Data":"1. 内存限制"}]},{"ID":"20230724015527-6al6sts","Type":"NodeParagraph","Properties":{"id":"20230724015527-6al6sts","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"内存限制是你能够对容器所做的最基础的限制。****它限制了容器中的进程能够使用的内存大小。"},{"Type":"NodeText","Data":"内存限制对确保一个容器不会因使用资源过多而影响到运行在同一台计算机上的其他容器非常有用。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"你可以通过在docker run或docker create命令上使用-m或--memory选项来设置内存限制。"},{"Type":"NodeText","Data":"这个选项会接受一个值和一个基础单元作为参数。格式如下："}]},{"ID":"20230724015527-4oh3vtr","Type":"NodeParagraph","Properties":{"id":"20230724015527-4oh3vtr","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"where unit = b,k,m or g"}]},{"ID":"20230724015527-ji4ai15","Type":"NodeParagraph","Properties":{"id":"20230724015527-ji4ai15","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在这个命令中，b表示字节，k表示千字节，m表示兆字节，g表示千兆字节。"}]},{"ID":"20230724015527-s8mgkv7","Type":"NodeParagraph","Properties":{"id":"20230724015527-s8mgkv7","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"理解内存限制最重要的是明白内存限制并不是内存保留。并不是说它保证具体大小的内存是可用的，而是说****它会防止容器使用超出具体大小的内存资源。"}]},{"ID":"20230724015527-byazqbl","Type":"NodeParagraph","Properties":{"id":"20230724015527-byazqbl","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"你应该考虑两件事情。第一，你正在运行的软件能够在预期的内存限制下正常工作么? 第二，运行软件的系统能够支持分配的内存数量么?"}]},{"ID":"20230724015527-vvl8vem","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724015527-vvl8vem","updated":"20230724015527"},"Children":[{"Type":"NodeText","Data":"2. CPU"}]},{"ID":"20230724015527-tbvdon9","Type":"NodeParagraph","Properties":{"id":"20230724015527-tbvdon9","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"CPU时间和内存一样稀少，但是CPU时间少的后果不是失败，而是性能降低。一个等待CPU时间的暂停进程依旧工作正常，但是如果进程在进行一些重要的数据处理任务，或者是正在进行收入回收（revenue-generating）的web应用或者App的后端服务，那么进程的缓慢可能比进程失败更加糟糕。Docker允许你从两种方式来限制容器CPU资源。"}]},{"ID":"20230724015527-ftbxvr4","Type":"NodeParagraph","Properties":{"id":"20230724015527-ftbxvr4","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"第一，你可以指定容器的相对权重。Linux使用这个权重来决定该容器应该占用的CPU时间百分比。这个百分比是相对于所有对容器可用的处理器的CPU周期的总和来计算的。"}]},{"ID":"20230724015527-6jeos6o","Type":"NodeParagraph","Properties":{"id":"20230724015527-6jeos6o","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"为了设置一个容器的CPU时间分配和建立它的相对权重，docker run和docker create命令都提供了一个--cpu-shares选项。选项的值应该是一个整数（这意味着你不应该加上引号）。"}]},{"ID":"20230724015527-j25da5z","Type":"NodeParagraph","Properties":{"id":"20230724015527-j25da5z","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"CPU资源限制不同于内存限制，只有在CPU时间上存在竞争时，它才会被强制执行。如果其他的进程和容器处于空闲中，那么被限制的容器可能会超出CPU资源限制。这是可取的，因为这种策略确保CPU不会被浪费，而且当其他进程需要CPU时，被限制的进程会让出CPU。这个工具的目的就是为了防止一个或者多个进程使用过多资源而压垮计算机，而不是为了阻碍这些进程的性能。默认配置不会限制容器，因此容器能够使用100%的CPU。"}]},{"ID":"20230724015527-cn078e6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724015527-cn078e6","updated":"20230724015527"},"Children":[{"Type":"NodeText","Data":"3. 设备的访问权"}]},{"ID":"20230724015527-uib8kj2","Type":"NodeParagraph","Properties":{"id":"20230724015527-uib8kj2","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"设备的访问并不是一种限制。这更像是一种资源认证控制。"}]},{"ID":"20230724015527-l69p0p4","Type":"NodeParagraph","Properties":{"id":"20230724015527-l69p0p4","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在默认情况下，容器对某些设备具有访问权，此外，Docker为每个容器创建了剩下的设备（比如虚拟终端）。"}]},{"ID":"20230724015527-f512ews","Type":"NodeParagraph","Properties":{"id":"20230724015527-f512ews","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"有时，在主机和特定容器之间共享设备可能非常重要。考虑这种情况，当你正在运行某些计算机视觉软件，这些软件需要网络摄像头的访问权。在这种情况下，你需要授予运行有这些软件的容器对网络摄像头的访问权；你可以使用--device选项来指定一个设备的集合，这些设备会被挂载进新容器中。下面这个例子会将在/dev/video0位置的网络摄像头映射到新容器的同一个位置上。注意，当且仅当在/dev/video0上有一个网络摄像头设备时，这个例子才能正确运行："}]},{"ID":"20230724015527-sce5ep7","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724015527-sce5ep7","updated":"20230724015527"},"Children":[{"Type":"NodeText","Data":"2. 共享内存"}]},{"ID":"20230724015527-6nqsgv5","Type":"NodeParagraph","Properties":{"id":"20230724015527-6nqsgv5","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Docker 为每一个容器创建了一个独立且唯一的 IPC 命名空间。Linux的IPC命名空间分区共享内存单元，比如说命名的共享内存块、信号量和消息队列。如果你不确定这些是什么，没有关系，你只需要知道 Linux 程序使用这些工具来协调处理的。IPC命名空间的作用就是防止一个容器中的进程访问主机或者其他容器的内存。"}]},{"ID":"20230724015527-31dxdto","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724015527-31dxdto","updated":"20230724015527"},"Children":[{"Type":"NodeText","Data":"1. 跨容器的进程间通信"}]},{"ID":"20230724015527-peaoua3","Type":"NodeParagraph","Properties":{"id":"20230724015527-peaoua3","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"每一个进程都使用相同的 key 来标识共享的内存资源，但是它们指向的却是不同的内存。原因在于，每一个容器都拥有它们自己的共享内存命名空间。"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果你想要在不同容器中使用共享内存进行通信，那么你需要使用--ipc选项来连接它们的IPC命令空间。--ipc选项支持这样一种容器模式，它创建的新容器的IPC命名空间和另外一个目标容器是一样的。"}]},{"ID":"20230724015527-i89txe2","Type":"NodeParagraph","Properties":{"id":"20230724015527-i89txe2","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"复用共享内存命名空间，会导致明显的安全隐患。但是如果你需要这个功能，你能够简单地通过这个选项就能获得。在容器间共享内存是比主机上共享内存更加安全的替代方案。"}]},{"ID":"20230724015527-49i439t","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724015527-49i439t","updated":"20230724015527"},"Children":[{"Type":"NodeText","Data":"2. 开放内存容器"}]},{"ID":"20230724015527-cpwlwdq","Type":"NodeParagraph","Properties":{"id":"20230724015527-cpwlwdq","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"内存隔离是一种优良特性。如果你想要和主机运行在同一个命名空间中，你可以使用开放内存容器（open memory container）"}]},{"ID":"20230724015527-qllhzvr","Type":"NodeParagraph","Properties":{"id":"20230724015527-qllhzvr","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"运行以上命令后，这些容器就能够互相通信，并且能够和运行在主机上的进程通信。从例子中你能够看到，你通过指定--ipc选项的值为host来获得这个功能。当你想要和一个必须运行在主机上的进程进行通信时，你可能会使用这个功能，但是，在一般情况下，应该避免使用它。"}]},{"ID":"20230724015527-s8dc1l0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724015527-s8dc1l0","updated":"20230724015527"},"Children":[{"Type":"NodeText","Data":"3. 理解用户"}]},{"ID":"20230724015527-gu1x6dm","Type":"NodeParagraph","Properties":{"id":"20230724015527-gu1x6dm","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在默认情况下，Docker以容器中的root用户来启动容器。root用户几乎拥有对当前容器的所有访问特权。任何以root用户运行的进程都会继承它的权限。如果其中一个进程有漏洞，那么它可能就会危害整个容器。有两种方法能够限制这种危害，但是防止这种问题的最有效办法就是不使用root用户。"}]},{"ID":"20230724015527-03kxfml","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724015527-03kxfml","updated":"20230724015527"},"Children":[{"Type":"NodeText","Data":"1. Linux用户命令空间"}]},{"ID":"20230724015527-hqrdj8h","Type":"NodeParagraph","Properties":{"id":"20230724015527-hqrdj8h","updated":"20230724015617"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Docker还没有集成USR命名空间。这意味着，如果一个容器的用户ID（数字，不是名字）和主机上的一个用户一样，那么该容器中的用户和主机上的用户拥有相同的主机文件权限。这并不是一个问题，因为容器中的文件系统的改动只会保留在容器的文件系统中，不会影响到主机。但是，这能够影响到卷（volume）。"}]},{"ID":"20230724015527-4wg4g7h","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724015527-4wg4g7h","updated":"20230724015527"},"Children":[{"Type":"NodeText","Data":"2. run-as 用户"}]},{"ID":"20230724015527-rvh1v0m","Type":"NodeParagraph","Properties":{"id":"20230724015527-rvh1v0m","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在你创建一个容器之前，如果你能够说明哪一个用户名（和用户ID）默认被使用，这是极好的。在默认情况下，这个由镜像指定。目前没有办法能够检测出一个镜像指定的默认用户。这个信息也不包含在Docker Hub中。并且也没有命令能够检测镜像的元数据。"}]},{"ID":"20230724015527-gofhlby","Type":"NodeParagraph","Properties":{"id":"20230724015527-gofhlby","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"最接近预期并且可用的是docker inspect命令。inspect子命令能够显示出一个容器的元数据。容器元数据包含了镜像的元数据。"}]},{"ID":"20230724015527-b2153zj","Type":"NodeParagraph","Properties":{"id":"20230724015527-b2153zj","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果显示结果空白，那么容器会默认使用root用户来启动。如果结果不为空，要么镜像作者指定了一个默认的run-as用户，要么就是当你创建这个容器时，你指定了run-as用户。第二个命令中的-f或--format选项允许你为输出结果指定模板。"}]},{"ID":"20230724015527-jwi0hrr","Type":"NodeParagraph","Properties":{"id":"20230724015527-jwi0hrr","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"保证运行时配置不出问题的最佳方法就是从可信赖的源拉取镜像或者自己构建镜像。"}]},{"ID":"20230724015527-le2bxi2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724015527-le2bxi2","updated":"20230724015527"},"Children":[{"Type":"NodeText","Data":"3. 用户和卷"}]},{"ID":"20230724015527-w72k52i","Type":"NodeParagraph","Properties":{"id":"20230724015527-w72k52i","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"既然你已经了解了容器中的用户如何和主机上的用户共享同一个用户ID空间，接下来你需要了解这两个用户如何互相影响。产生影响的主要理由就是卷（volume）中文件的文件权限问题。"}]},{"ID":"20230724015527-9jctf6c","Type":"NodeParagraph","Properties":{"id":"20230724015527-9jctf6c","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"着卷（volume）中的文件的文件权限在容器中也是有效的。但这也意味着用户ID空间被共享了。主机上的root用户和容器中的root用户的ID都是0。因此，尽管容器中ID为65534的nobody用户不能够访问主机上root用户创建的文件，但是容器中的root用户可以。"}]},{"ID":"20230724015527-g7zbi3c","Type":"NodeParagraph","Properties":{"id":"20230724015527-g7zbi3c","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"除非你想要主机的文件能够被容器访问，否则不要将文件以卷的形式挂载到容器上。"}]},{"ID":"20230724015527-4pxrk3h","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724015527-4pxrk3h","updated":"20230724015527"},"Children":[{"Type":"NodeText","Data":"4. 能力 操作系统功能的授权"}]},{"ID":"20230724015527-o8owfh6","Type":"NodeParagraph","Properties":{"id":"20230724015527-o8owfh6","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Docker 能够支持容器中进程的功能授权。在 Linxu 中这些功能授权被称为能力（capabilities），不过作为对其他操作系统的原生支持，其他的后端实现也需要被提供。"}]},{"ID":"20230724015527-wcwovgh","Type":"NodeParagraph","Properties":{"id":"20230724015527-wcwovgh","updated":"20230724015527"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"无论什么时候，一个进程尝试使用一个关卡系统调用，这个进程的能力就会被检测，看看是否存在需要的能力。如果存在，调用成功，否则调用失败。"}]}]}