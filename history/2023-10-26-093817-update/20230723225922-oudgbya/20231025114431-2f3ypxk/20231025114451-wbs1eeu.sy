{"ID":"20231025114451-wbs1eeu","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f4a3","id":"20231025114451-wbs1eeu","tags":"go,时间轮算法,redis,未完成","title":"基于 golang 从零到一实现时间轮算法","updated":"20231025145751"},"Children":[{"ID":"20231025114451-y8nos90","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231025114451-y8nos90","updated":"20231025114554"},"Children":[{"Type":"NodeText","Data":"前言"}]},{"ID":"20231025114554-bew465x","Type":"NodeParagraph","Properties":{"id":"20231025114554-bew465x","updated":"20231025114559"},"Children":[{"Type":"NodeText","Data":"如何基于 golang 从零到一实现 redis."}]},{"ID":"20231025114652-2vzeaz3","Type":"NodeParagraph","Properties":{"id":"20231025114652-2vzeaz3","updated":"20231025142453"},"Children":[{"Type":"NodeText","Data":"这里选择的学习素材是 hdt3213 大佬于 github 上开源的 godis 项目. 在大佬的实现中，充分利用了 golang 的特性，将 redis 存储层由单线程模型转为并发模型，其中在实现数据的 expire 机制时，采用的是单机时间轮模型进行过期数据的删除操作。"}]},{"ID":"20231025142501-xk5rtlp","Type":"NodeParagraph","Properties":{"id":"20231025142501-xk5rtlp","updated":"20231025142514"},"Children":[{"Type":"NodeText","Data":"godis 项目开源地址："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"http://github.com/HDT3213/godis"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025142501-zhpxlt0","Type":"NodeParagraph","Properties":{"id":"20231025142501-zhpxlt0","updated":"20231025142501"},"Children":[{"Type":"NodeText","Data":"godis 时间轮代码："}]},{"ID":"20231025142505-j1mctdb","Type":"NodeParagraph","Properties":{"id":"20231025142505-j1mctdb","updated":"20231025142518"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"http://github.com/HDT3213/godis/blob/master/lib/timewheel/timewheel.go"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025142518-ahpw8f0","Type":"NodeParagraph","Properties":{"id":"20231025142518-ahpw8f0","updated":"20231025142604"},"Children":[{"Type":"NodeText","Data":"实际上，在我之前分享个人项目——分布式定时器 xtimer 中也有到了时间轮算法，这部分内容具有一定共性. 借此机会，本期单独对时间轮算法的原理和实践内容进行梳理，并基于 golang 从零到一开源实现出一个单机版和 redis 分布式版的时间轮，供大家一起交流探讨。"}]},{"ID":"20231025142605-bbx9a5m","Type":"NodeParagraph","Properties":{"id":"20231025142605-bbx9a5m","updated":"20231025142616"},"Children":[{"Type":"NodeText","Data":"个人开源的时间轮项目地址为："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"http://github.com/xiaoxuxiansheng/timewheel"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025142617-kmpyhct","Type":"NodeParagraph","Properties":{"id":"20231025142617-kmpyhct"}},{"ID":"20231025142817-h4c67eb","Type":"NodeParagraph","Properties":{"id":"20231025142817-h4c67eb"}},{"ID":"20231025142817-vsys36s","Type":"NodeParagraph","Properties":{"id":"20231025142817-vsys36s","updated":"20231025142829"},"Children":[{"Type":"NodeText","Data":"目录大纲如下"}]},{"ID":"20231025142843-e3766mv","Type":"NodeParagraph","Properties":{"id":"20231025142843-e3766mv","updated":"20231025142843"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025142843-lhxnrzk.png"},{"Type":"NodeCloseParen"}]}]},{"ID":"20231025142910-ceg9mlk","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231025142910-ceg9mlk","updated":"20231025142918"},"Children":[{"Type":"NodeText","Data":"时间轮原理"}]},{"ID":"20231025142941-sijmdpi","Type":"NodeParagraph","Properties":{"id":"20231025142941-sijmdpi","updated":"20231025142941"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025142941-6wd1yzk.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025142844-gknuimj","Type":"NodeParagraph","Properties":{"id":"20231025142844-gknuimj","updated":"20231025143211"},"Children":[{"Type":"NodeText","Data":"时间轮是定时任务调度系统中常用到的一种经典的算法模型. 有关时间轮算法的详细概念介绍，可以参见论文:《Hashed and Hierarchical Time Wheels: Data Structures for the Efficient Implementation of a Time Facility》http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf"}]},{"ID":"20231025143244-yclrahw","Type":"NodeParagraph","Properties":{"id":"20231025143244-yclrahw","updated":"20231025143252"},"Children":[{"Type":"NodeText","Data":"接下来我也会从个人角度出发，谈谈我对于时间轮算法的一些浅显理解."}]},{"ID":"20231025143257-px6cloy","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231025143257-px6cloy","updated":"20231025143303"},"Children":[{"Type":"NodeText","Data":"时间轮概念"}]},{"ID":"20231025143309-qtu7rcu","Type":"NodeParagraph","Properties":{"id":"20231025143309-qtu7rcu","updated":"20231025143314"},"Children":[{"Type":"NodeText","Data":"聊时间轮之前，先聊聊时间的概念。"}]},{"ID":"20231025143309-cszx3mj","Type":"NodeParagraph","Properties":{"id":"20231025143309-cszx3mj","updated":"20231025143311"},"Children":[{"Type":"NodeText","Data":"首先时间是一维、单向的，我们可以用一条一维的时间轴将其具象化. 我们对时间轴进行刻度拆分，每个刻度对应一个时间范围，那么刻度拆分得越细，则表示的时间范围越精确。"}]},{"ID":"20231025143342-mt8ifx9","Type":"NodeParagraph","Properties":{"id":"20231025143342-mt8ifx9","updated":"20231025143342"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025143342-fjjjxoz.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025143458-5tkehwc","Type":"NodeParagraph","Properties":{"id":"20231025143458-5tkehwc","updated":"20231025143458"},"Children":[{"Type":"NodeText","Data":"然而，我们知道时间是没有尽头的，因此这条一维时间轴的长度是无穷大的. 倘若我们想要建立一个数据结构去表达这条由一系列刻度聚合形成的时间轴，这个数据结构所占用的空间也是无穷无尽的."}]},{"ID":"20231025143458-ojjozz3","Type":"NodeParagraph","Properties":{"id":"20231025143458-ojjozz3","updated":"20231025143458"},"Children":[{"Type":"NodeText","Data":"那么，我们应该如何优化这个问题呢？此时，大家不妨低头看一眼自己的手表. 手表或时钟这类日常生活中用来关联表达时间的工具，采用的是首尾衔接的环状结构来替代无穷长度的一维时间轴，每当钟表划过一圈，刻度从新回到零值，但是已有的时间进度会传承往下."}]},{"ID":"20231025143458-twd5lkl","Type":"NodeParagraph","Properties":{"id":"20231025143458-twd5lkl","updated":"20231025143458"},"Children":[{"Type":"NodeText","Data":"本期所聊的时间轮算法采用的思路正是与之类似，下面我们梳理一下核心流程："}]},{"ID":"20231025143542-i962djv","Type":"NodeList","ListData":{},"Properties":{"id":"20231025143542-i962djv","updated":"20231025143542"},"Children":[{"ID":"20231025143542-88tyu3r","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143542-88tyu3r","updated":"20231025143542"},"Children":[{"ID":"20231025143542-521aaxl","Type":"NodeParagraph","Properties":{"id":"20231025143542-521aaxl","updated":"20231025143542"},"Children":[{"Type":"NodeText","Data":"建立一个环状数据结构"}]}]},{"ID":"20231025143551-nh8ik58","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143551-nh8ik58"},"Children":[{"ID":"20231025143551-qs9ljrd","Type":"NodeParagraph","Properties":{"id":"20231025143551-qs9ljrd"},"Children":[{"Type":"NodeText","Data":"每个刻度对应一个时间范围"}]}]},{"ID":"20231025143555-z351zk1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143555-z351zk1"},"Children":[{"ID":"20231025143555-x91q0o7","Type":"NodeParagraph","Properties":{"id":"20231025143555-x91q0o7"},"Children":[{"Type":"NodeText","Data":"创建定时任务时，根据距今的相对时长，推算出需要向后推移的刻度值"}]}]},{"ID":"20231025143542-wg2vmtp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143542-wg2vmtp","updated":"20231025143542"},"Children":[{"ID":"20231025143542-c705xln","Type":"NodeParagraph","Properties":{"id":"20231025143542-c705xln","updated":"20231025143557"},"Children":[{"Type":"NodeText","Data":"倘若来到环形数组的结尾，则重新从起点开始计算，但是记录时把执行轮次数加1"}]}]},{"ID":"20231025143542-a4m01t4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143542-a4m01t4","updated":"20231025143542"},"Children":[{"ID":"20231025143542-plo1hwj","Type":"NodeParagraph","Properties":{"id":"20231025143542-plo1hwj","updated":"20231025143559"},"Children":[{"Type":"NodeText","Data":"一个刻度可能存在多笔定时任务，所以每个刻度需要挂载一个定时任务链表"}]}]}]},{"ID":"20231025143602-4w6ug3f","Type":"NodeParagraph","Properties":{"id":"20231025143602-4w6ug3f","updated":"20231025145140"},"Children":[{"Type":"NodeText","Data":"接下来，我们建立时间轮的扫描机制，就如同钟表中的指针一般，按照固定的时间节奏，沿着环形数组周而复始地持续向下扫描. 每当来到一个刻度时，则取出链表中轮次为 0 的定时任务进行执行. 这就是时间轮算法的核心思路。"}]},{"ID":"20231025145156-wc0jvp8","Type":"NodeParagraph","Properties":{"id":"20231025145156-wc0jvp8","updated":"20231025145156"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025145156-fs2tcf6.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025143604-60o336e","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231025143604-60o336e","updated":"20231025145637"},"Children":[{"Type":"NodeText","Data":"多级时间轮"}]},{"ID":"20231025145644-lqjljdt","Type":"NodeParagraph","Properties":{"id":"20231025145644-lqjljdt","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"接下来聊一聊时间轮中的等级制度与多级时间轮的概念."}]},{"ID":"20231025145644-ao5z52q","Type":"NodeParagraph","Properties":{"id":"20231025145644-ao5z52q","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"首先捋一捋，时间轮每个周期轮次中，使用的数据结构容量与所表达的时间范围之间的关系."}]},{"ID":"20231025145644-rkjn53z","Type":"NodeParagraph","Properties":{"id":"20231025145644-rkjn53z","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"我们把时间轮中的每个刻度记为一个 slot，每个 slot 表示的时间范围记为 t."}]},{"ID":"20231025145644-gdl4obk","Type":"NodeParagraph","Properties":{"id":"20231025145644-gdl4obk","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"假设时间轮中总共包含 2m 个 slot，求问如何组织我们的时间轮数据结构，能够使得时间轮每个轮次对应表达的时间范围尽可能的长. （一个轮次对应的时间范围越长，在时间流逝过程中轮次的迭代速度就越慢，于是每个 slot 对应的定时任务链表长度就越短，执行定时任务时的检索效率就越高.）"}]},{"ID":"20231025145644-wa3v7my","Type":"NodeParagraph","Properties":{"id":"20231025145644-wa3v7my","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"这里最简单的方式就是进行采用一维纵向排列的方式，那么能够表达的时间范围就是 2m * t，某个刻度对应的时间值就记为 {slot_i}."}]},{"ID":"20231025145716-lcwh4ng","Type":"NodeParagraph","Properties":{"id":"20231025145716-lcwh4ng","updated":"20231025145716"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025145716-m89rg67.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025145723-yas22wa","Type":"NodeParagraph","Properties":{"id":"20231025145723-yas22wa","updated":"20231025145723"},"Children":[{"Type":"NodeText","Data":"另一种思路是，我们在时间轮中建立一种等级秩序."}]},{"ID":"20231025145723-6xnbwzr","Type":"NodeParagraph","Properties":{"id":"20231025145723-6xnbwzr","updated":"20231025145751"},"Children":[{"Type":"NodeText","Data":"比如我们将 2m 个 slot 拆成两个等级——level1 和 level2. 最终我们通过 {level1_slot}_{level2_slot} 的方式进行时间的表达."}]},{"ID":"20231025145723-tnkl6uv","Type":"NodeParagraph","Properties":{"id":"20231025145723-tnkl6uv","updated":"20231025145723"},"Children":[{"Type":"NodeText","Data":"我们给 level2 分配 m 个 slot，其中每个 slot 对应的时间范围同样为 t. 而 level1 同样也分配 m 个 slot，但是此时其中每个 slot 对应的时间范围应该为 m * t，因为在 level1 中的 slot 确定时，level2 中还有 m 种 slot 的组合方式."}]},{"ID":"20231025145723-swgq5xz","Type":"NodeParagraph","Properties":{"id":"20231025145723-swgq5xz","updated":"20231025145723"},"Children":[{"Type":"NodeText","Data":"如此一来，这种组织方式下，时间轮单个轮次所能表达的时间范围就是 m * m * t."}]},{"ID":"20231025145723-kqi6u3f","Type":"NodeParagraph","Properties":{"id":"20231025145723-kqi6u3f","updated":"20231025145723"},"Children":[{"Type":"NodeText","Data":"这里探讨的核心不是具体某级时间轮的时间范围结果，而是抛出了一种多级时间轮的思路，从一到二是质变，从二到三、从三到四就仅仅是量变的问题，可以继续复刻相同的思路."}]}]}