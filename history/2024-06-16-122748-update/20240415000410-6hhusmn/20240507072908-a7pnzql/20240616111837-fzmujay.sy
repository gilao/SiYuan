{"ID":"20240616111837-fzmujay","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240616111837-fzmujay","title":"第九章 函数与栈","type":"doc","updated":"20240616122047"},"Children":[{"ID":"20240616111846-moggoyx","Type":"NodeParagraph","Properties":{"id":"20240616111846-moggoyx"}},{"ID":"20240616111837-jzyqy3a","Type":"NodeParagraph","Properties":{"id":"20240616111837-jzyqy3a","updated":"20240616111859"},"Children":[{"Type":"NodeText","Data":"函数是程序中为了执行特定任务而存在的一系列执行代码。函数接受输入并返回输出，执行程序的过程可以看作一系列函数的调用过程。Go语言中最重要的函数为main函数，其是程序执行用户代码的入口，在每个程序中都需要存在。"}]},{"ID":"20240616115935-nh55ms5","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240616115935-nh55ms5","updated":"20240616115948"},"Children":[{"Type":"NodeText","Data":"9.1 函数基本使用方式"}]},{"ID":"20240616115948-pt4ti3n","Type":"NodeParagraph","Properties":{"id":"20240616115948-pt4ti3n","updated":"20240616120053"},"Children":[{"Type":"NodeText","Data":"使用函数具有减少冗余、隐藏信息、提高代码清晰度等优点。"}]},{"ID":"20240616120054-9s7ylum","Type":"NodeParagraph","Properties":{"id":"20240616120054-9s7ylum","updated":"20240616120059"},"Children":[{"Type":"NodeText","Data":"Go语言中，函数是一等公民（first-class），这意味着可以将它看作变量，并且它可以作为参数传递、返回及赋值。"}]},{"ID":"20240616120111-4zrz9y4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240616120111-4zrz9y4","updated":"20240616120424"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 函数作为返回值\nfunc makeGreeter() func () string {\n  return func() string {\n    return \"hello jonson\"\n  }\n}\n\n// 函数作为参数\nfunc visit(number []int, callback func(int)) {\n  for _, n := range numbers {\n    callback(n)\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240616120302-65bu40v","Type":"NodeParagraph","Properties":{"id":"20240616120302-65bu40v","updated":"20240616120438"},"Children":[{"Type":"NodeText","Data":"o语言中的函数还具有多返回值的特点，多返回值最常用于返回error错误信息，从而被调用者捕获。"}]},{"ID":"20240616120454-bkgrxd8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240616120454-bkgrxd8","updated":"20240616120508"},"Children":[{"Type":"NodeText","Data":"9.2 函数闭包与陷阱"}]},{"ID":"20240616120508-e373pgh","Type":"NodeParagraph","Properties":{"id":"20240616120508-e373pgh","updated":"20240616120910"},"Children":[{"Type":"NodeText","Data":"Go语言同样支持匿名函数和闭包。闭包（Closure）是在函数作为一类公民的编程语言中实现词法绑定的一种技术，闭包包含了函数的入口地址和其关联的环境。闭包和普通函数最大的区别在于，闭包函数中可以引用闭包外的变量。"}]},{"ID":"20240616120912-ncqwv8q","Type":"NodeParagraph","Properties":{"id":"20240616120912-ncqwv8q","updated":"20240616120918"},"Children":[{"Type":"NodeText","Data":"下面是通过闭包设计的一个http中间件，通过闭包可以轻易地在原有函数的基础上包裹中间功能，而不破坏原有函数。"}]},{"ID":"20240616120918-gp9vk3m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240616120918-gp9vk3m","updated":"20240616121906"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n  http.HandleFunc(\"/hello\",timed(hello))\n  http.ListenAndServe(\":3000\",nil)\n}\nfunc timed(f func(http.ResponseWriter, *http.Request))\nfunc (http.ResponseWriter, *http.Request) {\n  return func(w http.ResponseWriter, r *http.Reqeust) {\n    start := time.Now()\n    f(w,r)\n    end := time.Now()\n    fmt.Println(\"The request: took\", end.Sub(start))\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240616121914-17gvb1y","Type":"NodeParagraph","Properties":{"id":"20240616121914-17gvb1y","updated":"20240616121919"},"Children":[{"Type":"NodeText","Data":"当闭包与range同时使用时，可能出现下例中的错误，这也是Go语言中一类非常经典的错误，被收录在了Go语言“共同的错误”。"}]},{"ID":"20240616121920-fedog52","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240616121920-fedog52","updated":"20240616121937"},"Children":[{"Type":"NodeText","Data":"9.3 函数栈"}]},{"ID":"20240616121937-eze0wim","Type":"NodeParagraph","Properties":{"id":"20240616121937-eze0wim","updated":"20240616121955"},"Children":[{"Type":"NodeText","Data":"在大多数现代计算机系统中，每个线程都有一个被称为栈的内存区域，其遵循一种先入先出（FIFO）的形式，增长方向为从高地址到低地址。"}]},{"ID":"20240616121959-s9zj9ks","Type":"NodeParagraph","Properties":{"id":"20240616121959-s9zj9ks","updated":"20240616122000"},"Children":[{"Type":"NodeText","Data":"当函数执行时，函数的参数、返回地址、局部变量会被压入栈中，当函数退出时，这些数据会被回收。当函数还没有退出就调用另一个函数时，形成了一条函数调用链。"}]},{"ID":"20240616122047-q4brg8p","Type":"NodeParagraph","Properties":{"id":"20240616122047-q4brg8p","updated":"20240616122047"},"Children":[{"Type":"NodeText","Data":"例如，函数A调用了函数B，被调函数B至少需要存储调用方函数A提供的返回地址的位置，以便在函数B执行完毕后，能够立即返回函数A之前的位置继续执行。\n每个函数在执行过程中都使用一块栈内存来保存返回地址、局部变量、函数参数等，我们将这一块区域称为函数的栈帧（stack frame）。"}]}]}