{"ID":"20231117222034-1fbuwl6","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f9e1","id":"20231117222034-1fbuwl6","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20231117222034-1fbuwl6\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231120092037-knyud81\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231120103414-hurfn42\u0026quot;,\u0026quot;scrollTop\u0026quot;:8576,\u0026quot;focusId\u0026quot;:\u0026quot;20231120102635-mmu5quc\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","tags":"公众号-小徐先生的编程世界","title":"Golang 设计模式之工厂模式","updated":"20231120150543"},"Children":[{"ID":"20231120092037-knyud81","Type":"NodeParagraph","Properties":{"id":"20231120092037-knyud81","updated":"20231120092037"},"Children":[{"Type":"NodeText","Data":"本期会基于 Go 语言，和大家一起聊聊设计模式中的工厂模式. 本期分享内容包含如下几个部分："}]},{"ID":"20231120092037-1uv71cc","Type":"NodeList","ListData":{},"Properties":{"id":"20231120092037-1uv71cc","updated":"20231120092109"},"Children":[{"ID":"20231120092109-gpg4zds","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092109-gpg4zds","updated":"20231120092109"},"Children":[{"ID":"20231120092109-uwta6rb","Type":"NodeParagraph","Properties":{"id":"20231120092109-uwta6rb","updated":"20231120092109"},"Children":[{"Type":"NodeText","Data":"工厂模式的使用背景"}]}]}]},{"ID":"20231120092037-hmntapa","Type":"NodeList","ListData":{},"Properties":{"id":"20231120092037-hmntapa","updated":"20231120092103"},"Children":[{"ID":"20231120092055-zcuq9fd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092055-zcuq9fd","updated":"20231120092103"},"Children":[{"ID":"20231120092055-lsu1849","Type":"NodeParagraph","Properties":{"id":"20231120092055-lsu1849","updated":"20231120092103"},"Children":[{"Type":"NodeText","Data":"简单工厂模式"}]}]}]},{"ID":"20231120092037-wrvdl4x","Type":"NodeList","ListData":{},"Properties":{"id":"20231120092037-wrvdl4x","updated":"20231120092037"},"Children":[{"ID":"20231120092037-6n8x3uj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092037-6n8x3uj","updated":"20231120092037"},"Children":[{"ID":"20231120092037-octiwt2","Type":"NodeParagraph","Properties":{"id":"20231120092037-octiwt2","updated":"20231120092113"},"Children":[{"Type":"NodeText","Data":"工厂方法模式"}]}]},{"ID":"20231120092037-n8r496q","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092037-n8r496q","updated":"20231120092037"},"Children":[{"ID":"20231120092037-qof4hpa","Type":"NodeParagraph","Properties":{"id":"20231120092037-qof4hpa","updated":"20231120092114"},"Children":[{"Type":"NodeText","Data":"抽象工厂模式"}]}]},{"ID":"20231120092037-vwqdo0p","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092037-vwqdo0p","updated":"20231120092037"},"Children":[{"ID":"20231120092037-u0pv57t","Type":"NodeParagraph","Properties":{"id":"20231120092037-u0pv57t","updated":"20231120092116"},"Children":[{"Type":"NodeText","Data":"容器工厂模式"}]}]}]},{"ID":"20231120092120-fpl2nbm","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231120092120-fpl2nbm","updated":"20231120092130"},"Children":[{"Type":"NodeText","Data":"使用背景"}]},{"ID":"20231120092140-tossif1","Type":"NodeParagraph","Properties":{"id":"20231120092140-tossif1","updated":"20231120092140"},"Children":[{"Type":"NodeText","Data":"Go 语言中没有针对类的构造器方法定义统一的规范，倘若每次需要创建类的实例时，都需要在业务方法中事无俱细地执行实例初始化的细节，那么会存在缺陷的包括："}]},{"ID":"20231120092155-48o1cvn","Type":"NodeList","ListData":{},"Properties":{"id":"20231120092155-48o1cvn","updated":"20231120092249"},"Children":[{"ID":"20231120092155-g1fo210","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092155-g1fo210","updated":"20231120092249"},"Children":[{"ID":"20231120092140-q114q08","Type":"NodeParagraph","Properties":{"id":"20231120092140-q114q08","updated":"20231120092249"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"业务方法和组件类之间产生过高的耦合度，需要了解到组件类的过多细节"}]}]},{"ID":"20231120092155-jdey396","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092155-jdey396","updated":"20231120092244"},"Children":[{"ID":"20231120092140-mena9f5","Type":"NodeParagraph","Properties":{"id":"20231120092140-mena9f5","updated":"20231120092244"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"倘若组件类的定义发生变更，那么散落在各处业务方法中对类的构造流程都需要配合改动"}]}]}]},{"ID":"20231120092140-1zf144s","Type":"NodeParagraph","Properties":{"id":"20231120092140-1zf144s","updated":"20231120092140"},"Children":[{"Type":"NodeText","Data":"那么如何解决上述问题呢？在编程世界中，相当的一部分问题都可以通过增加一个中间层加以解决. 我们在此处遵循工厂模式的设计思路，在业务方法和类之间添加一个防腐中间层——工厂类，这样做能够带来的好处是："}]},{"ID":"20231120092140-kyeam62","Type":"NodeList","ListData":{},"Properties":{"id":"20231120092140-kyeam62","updated":"20231120092303"},"Children":[{"ID":"20231120092140-ig6u65u","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092140-ig6u65u","updated":"20231120092300"},"Children":[{"ID":"20231120092140-0zl6gsm","Type":"NodeParagraph","Properties":{"id":"20231120092140-0zl6gsm","updated":"20231120092300"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实现类和业务方法之间的解耦，如果类的构造过程发生变更，可以统一收口在工厂类中进行处理，从而对业务方法屏蔽相关细节"}]}]},{"ID":"20231120092140-mkiytbd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092140-mkiytbd","updated":"20231120092303"},"Children":[{"ID":"20231120092140-ajl2xq0","Type":"NodeParagraph","Properties":{"id":"20231120092140-ajl2xq0","updated":"20231120092303"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"倘若有多个类都聚拢在工厂类中进行构造，这样各个类的构造流程中就天然形成了一个公共的切面，可以进行一些公共逻辑的执行"}]}]}]},{"ID":"20231120092559-xdrlx6i","Type":"NodeParagraph","Properties":{"id":"20231120092559-xdrlx6i","updated":"20231120092559"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120092559-ntg9k9e.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120092602-s48kytr","Type":"NodeParagraph","Properties":{"id":"20231120092602-s48kytr","updated":"20231120092614"},"Children":[{"Type":"NodeText","Data":"工厂模式属于设计模式中的一种，在实现上，又可以进一步细分为：简单工厂模式、工厂方法模式和抽象工厂模式三种类型，这三种类型我们会在本文的2-4章中进行逐一介绍. 除开上面提到的三种经典类型外，本文还会在第5章中额外和大家介绍一种比较另类的容器工厂模式."}]},{"ID":"20231120092620-4cm2ptq","Type":"NodeParagraph","Properties":{"id":"20231120092620-4cm2ptq","updated":"20231120092633"},"Children":[{"Type":"NodeText","Data":"​​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120092633-fw51axp.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120092654-1a7yzp1","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231120092654-1a7yzp1","updated":"20231120092700"},"Children":[{"Type":"NodeText","Data":"简单工厂模式"}]},{"ID":"20231120092710-3imdtjf","Type":"NodeParagraph","Properties":{"id":"20231120092710-3imdtjf","updated":"20231120092710"},"Children":[{"Type":"NodeText","Data":"首先和大家聊聊简单工厂模式. 设计模式中的内容都相对抽象，我这里先不作具体的概念定义，而是通过具体的实例和大家一起进行设计过程的推演，最后再对简单工厂模式的内容进行小结."}]},{"ID":"20231120092710-x97zsr3","Type":"NodeParagraph","Properties":{"id":"20231120092710-x97zsr3","updated":"20231120092710"},"Children":[{"Type":"NodeText","Data":"假设现在有这样一个编程场景："}]},{"ID":"20231120092710-c33272u","Type":"NodeList","ListData":{},"Properties":{"id":"20231120092710-c33272u","updated":"20231120092721"},"Children":[{"ID":"20231120092710-xewbha3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092710-xewbha3","updated":"20231120092715"},"Children":[{"ID":"20231120092710-5kb6uix","Type":"NodeParagraph","Properties":{"id":"20231120092710-5kb6uix","updated":"20231120092715"},"Children":[{"Type":"NodeText","Data":"水果 Fruit 是一个抽象的 interface，水果的共性是都可以食用水果，这里我们不纠结主被动的语义，赋以 Fruit 一个 Eat 方法"}]}]},{"ID":"20231120092710-3nb66cq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092710-3nb66cq","updated":"20231120092717"},"Children":[{"ID":"20231120092710-3p7h9d3","Type":"NodeParagraph","Properties":{"id":"20231120092710-3p7h9d3","updated":"20231120092717"},"Children":[{"Type":"NodeText","Data":"有三个具体的水果实现类，橘子 Orange、草莓 Strawberry、樱桃 cherry，分别实现了 Fruit 对应的 Eat 方法"}]}]},{"ID":"20231120092710-osutgnl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092710-osutgnl","updated":"20231120092721"},"Children":[{"ID":"20231120092710-g9i0q5e","Type":"NodeParagraph","Properties":{"id":"20231120092710-g9i0q5e","updated":"20231120092721"},"Children":[{"Type":"NodeText","Data":"有一个具体的水果工厂类 FruitFactory，专门用于水果的生产工作，对应的生产方法为 CreateFruit 方法，可以按照用户指定的水果类型，生产出对应的水果"}]}]}]},{"ID":"20231120092710-fdj11ia","Type":"NodeParagraph","Properties":{"id":"20231120092710-fdj11ia","updated":"20231120092710"},"Children":[{"Type":"NodeText","Data":"上面聊到的几个类之间形成的 UML 类图如下所示："}]},{"ID":"20231120092746-86nj0fg","Type":"NodeParagraph","Properties":{"id":"20231120092746-86nj0fg","updated":"20231120092746"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120092746-3gn0m9m.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120092748-8eg783b","Type":"NodeParagraph","Properties":{"id":"20231120092748-8eg783b","updated":"20231120092815"},"Children":[{"Type":"NodeText","Data":"下面进行代码展示. 水果 Fruit interface 实现如下："}]},{"ID":"20231120092815-8ve9awh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120092815-8ve9awh","updated":"20231120092846"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Fruit interface {\n\tEat()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120092846-njy6u0p","Type":"NodeParagraph","Properties":{"id":"20231120092846-njy6u0p","updated":"20231120092857"},"Children":[{"Type":"NodeText","Data":"橘子 Orange、草莓 Strawberry、樱桃 Cherry 三种水果的具体实现类如下："}]},{"ID":"20231120092858-fqwol8l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120092858-fqwol8l","updated":"20231120093612"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Orange struct {\n\tname string\n}\n\nfunc NewOrange(name string) Fruit {\n\treturn \u0026Orange{\n\t\tname: name,\n\t}\n}\n\nfunc (o *Orange) Eat() {\n\tfmt.Println(\"I am orange: %s, i am about to bi eaten...\", o.name)\n}\n\ntype Strawberry struct {\n\tname string\n}\n\nfunc NewStrawberry(name string) Fruit {\n\treturn \u0026Strawberry{\n\t\tname: name,\n\t}\n}\n\nfunc (s *Strawberry) Eat() {\n\tfmt.Printf(\"i am strawberry: %s, i am about to be eaten...\", s.name)\n}\n\ntype Cherry struct {\n\tname string\n}\n\n\nfunc NewCherry(name string) Fruit {\n\treturn \u0026Cherry{\n\t\tname: name,\n\t}\n}\n\n\nfunc (c *Cherry) Eat() {\n\tfmt.Printf(\"i am cherry: %s, i am about to be eaten...\", c.name)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120093614-ffvk2si","Type":"NodeParagraph","Properties":{"id":"20231120093614-ffvk2si","updated":"20231120093621"},"Children":[{"Type":"NodeText","Data":"下面是关于生产水果的工厂类 FruitFactory 的定义，其中 CreateFruit 方法是用于生产水果的核心方法："}]},{"ID":"20231120093646-3sn2izs","Type":"NodeList","ListData":{},"Properties":{"id":"20231120093646-3sn2izs","updated":"20231120093646"},"Children":[{"ID":"20231120093646-ja3c0pf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120093646-ja3c0pf","updated":"20231120093646"},"Children":[{"ID":"20231120093646-a3vj6lm","Type":"NodeParagraph","Properties":{"id":"20231120093646-a3vj6lm","updated":"20231120093646"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"利用工厂生产三类时存在的公共切面，进行随机数的取值，用来给生产出来的水果命名"}]}]},{"ID":"20231120093646-aq3ro0w","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120093646-aq3ro0w","updated":"20231120093646"},"Children":[{"ID":"20231120093646-1aoxw9j","Type":"NodeParagraph","Properties":{"id":"20231120093646-1aoxw9j","updated":"20231120093646"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"根据使用方传入的水果类型 typ，调用对应水果类型的构造器方法，并将生产出来的水果进行返回"}]}]},{"ID":"20231120093646-x7n0pph","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120093646-x7n0pph","updated":"20231120093646"},"Children":[{"ID":"20231120093646-4bmgs1w","Type":"NodeParagraph","Properties":{"id":"20231120093646-4bmgs1w","updated":"20231120093646"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果使用方法传入的水果类型 typ 非法，则对外抛出错误"}]}]}]},{"ID":"20231120093715-gs3a8kw","Type":"NodeParagraph","Properties":{"id":"20231120093715-gs3a8kw"}},{"ID":"20231120094045-tc6xzb8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120094045-tc6xzb8","updated":"20231120094046"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type FruitFactory struct {\n}\n\nfunc NewFruitFactory() *FruitFactory {\n\treturn \u0026FruitFactory{}\n}\n\nfunc (f *FruitFactory) CreateFruit(typ string) (Fruit, error) {\n\tsrc := rand.NewSource(time.Now().UnixNano())\n\trander := rand.New(src)\n\tname := strconv.Itoa(rander.Int())\n\n\tswitch typ {\n\tcase \"orange\":\n\t\treturn NewOrange(name), nil\n\tcase \"strawberry\":\n\t\treturn NewStrawberry(name), nil\n\tcase \"cherry\":\n\t\treturn NewCherry(name), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"fruit typ: %s is not supported yet\", typ)\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120094159-ychebkq","Type":"NodeParagraph","Properties":{"id":"20231120094159-ychebkq","updated":"20231120094435"},"Children":[{"Type":"NodeText","Data":"上述实现代码实现起来的直观明了，这正是简单工厂模式的优势所在，然而我们同样需要注意到其中存在的局限性——不利于实现类的扩展："}]},{"ID":"20231120094159-hop1ct8","Type":"NodeParagraph","Properties":{"id":"20231120094159-hop1ct8","updated":"20231120094519"},"Children":[{"Type":"NodeText","Data":"• 每当有新的水果实现类需要支持时，需要在 FruitFactory 生产水果的 CreateFruit 方法中进行修改，在 switch case 中增加新的分支，这样做是不符合代码设计规范中的开闭原则的（"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"开闭原则：面向扩展开放，面向修改关闭"},{"Type":"NodeText","Data":"）"}]},{"ID":"20231120094159-33pj0kh","Type":"NodeParagraph","Properties":{"id":"20231120094159-33pj0kh","updated":"20231120094447"},"Children":[{"Type":"NodeText","Data":"• 此外，当需要支持的水果类型 typ 数量提升时，这个 CreateFruit 方法会存在方法圈复杂度过高的问题"}]},{"ID":"20231120094159-fg36093","Type":"NodeParagraph","Properties":{"id":"20231120094159-fg36093","updated":"20231120094449"},"Children":[{"Type":"NodeText","Data":"针对于第一个问题，是简单工厂模式的固有硬伤，需要切换到本文第 3 章中介绍到的工厂方法模式才能予以解决."}]},{"ID":"20231120094159-qum3x5y","Type":"NodeParagraph","Properties":{"id":"20231120094159-qum3x5y","updated":"20231120094453"},"Children":[{"Type":"NodeText","Data":"针对于存在的第二个问题，可以采用表驱动替代 switch case 分支映射的方式进行优化："}]},{"ID":"20231120094159-e1hzohs","Type":"NodeParagraph","Properties":{"id":"20231120094159-e1hzohs","updated":"20231120094455"},"Children":[{"Type":"NodeText","Data":"• 将水果构造器函数定义为一个类型 fruitCreator"}]},{"ID":"20231120094159-1wlrvcr","Type":"NodeParagraph","Properties":{"id":"20231120094159-1wlrvcr","updated":"20231120095019"},"Children":[{"Type":"NodeText","Data":"• 在水果构造工厂 FruitFactory 中，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"内置一个 map creators，根据水果类型映射到具体的构造器方法 fruitCreator"}]},{"ID":"20231120094159-46ebtft","Type":"NodeParagraph","Properties":{"id":"20231120094159-46ebtft","updated":"20231120094458"},"Children":[{"Type":"NodeText","Data":"• 在水果构造工厂的构造器方法中，完成 creators map 的初始化"}]},{"ID":"20231120094159-ylsgl85","Type":"NodeParagraph","Properties":{"id":"20231120094159-ylsgl85","updated":"20231120094459"},"Children":[{"Type":"NodeText","Data":"• 在 FruitFactory.CreateFruit 方法中，根据水果类型映射到对应的构造器方法 fruitCreator，然后进行水果的构造"}]},{"ID":"20231120094205-numhev2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120094205-numhev2","updated":"20231120095049"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type fruitCreator func(name string) Fruit\n\n\ntype FruitFactory struct {\n\tcreators map[string]fruitCreator\n}\n\n\nfunc NewFruitFactory() *FruitFactory {\n\treturn \u0026FruitFactory{\n\t\tcreators: map[string]fruitCreator{\n\t\t\t\"orange\":     NewOrange,\n\t\t\t\"strawberry\": NewStrawberry,\n\t\t\t\"cherry\":     NewCherry,\n\t\t},\n\t}\n}\n\n\nfunc (f *FruitFactory) CreateFruit(typ string) (Fruit, error) {\n\tfruitCreator, ok := f.creators[typ]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"fruit typ: %s is not supported yet\", typ)\n\t}\n\n\n\tsrc := rand.NewSource(time.Now().UnixNano())\n\trander := rand.New(src)\n\tname := strconv.Itoa(rander.Int())\n\treturn fruitCreator(name), nil\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120102320-z7tqb0y","Type":"NodeParagraph","Properties":{"id":"20231120102320-z7tqb0y"}},{"ID":"20231120102322-jpthtgt","Type":"NodeParagraph","Properties":{"id":"20231120102322-jpthtgt","updated":"20231120102349"},"Children":[{"Type":"NodeText","Data":"下面通过一段单测代码，给出简单工厂模式的使用示例："}]},{"ID":"20231120102349-60jj0d7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120102349-60jj0d7","updated":"20231120102357"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func Test_factory(t *testing.T) {\n    // 构造工厂\n    fruitFactory := NewFruitFactory()\n\n\n    // 尝个橘子\n    orange, _ := fruitFactory.CreateFruit(\"orange\")\n    orange.Eat()\n\n\n    // 来颗樱桃\n    cherry, _ := fruitFactory.CreateFruit(\"cherry\")\n    cherry.Eat()\n\n\n    // 来个西瓜，因为未实现会报错\n    watermelon, err := fruitFactory.CreateFruit(\"watermelon\")\n    if err != nil {\n        t.Error(err)\n        return\n    }\n    watermelon.Eat()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120102510-tm5yp8m","Type":"NodeParagraph","Properties":{"id":"20231120102510-tm5yp8m"}},{"ID":"20231120102511-slang8l","Type":"NodeParagraph","Properties":{"id":"20231120102511-slang8l","updated":"20231120102511"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"下面对简单工厂模式做个小结："}]},{"ID":"20231120102511-g09sm14","Type":"NodeList","ListData":{},"Properties":{"id":"20231120102511-g09sm14","updated":"20231120102511"},"Children":[{"ID":"20231120102511-5lvv62p","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120102511-5lvv62p","updated":"20231120102511"},"Children":[{"ID":"20231120102511-gaud8zk","Type":"NodeParagraph","Properties":{"id":"20231120102511-gaud8zk","updated":"20231120102511"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"对于拟构造的组件，需要依据其共性，抽离出一个公共 interface"}]}]},{"ID":"20231120102511-tuj8tu2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120102511-tuj8tu2","updated":"20231120102511"},"Children":[{"ID":"20231120102511-funb1ck","Type":"NodeParagraph","Properties":{"id":"20231120102511-funb1ck","updated":"20231120102511"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"每个具体的组件类型对 interface 加以实现"}]}]},{"ID":"20231120102511-6hl6b55","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120102511-6hl6b55","updated":"20231120102511"},"Children":[{"ID":"20231120102511-lroyguh","Type":"NodeParagraph","Properties":{"id":"20231120102511-lroyguh","updated":"20231120102511"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"定义一个具体的工厂类，在构造器方法接受具体的组件类型，完成对应类型组件的构造"}]}]}]},{"ID":"20231120102511-do9swco","Type":"NodeParagraph","Properties":{"id":"20231120102511-do9swco","updated":"20231120102511"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"简单工厂模式的优势包括："}]},{"ID":"20231120102511-fxq0ytu","Type":"NodeList","ListData":{},"Properties":{"id":"20231120102511-fxq0ytu","updated":"20231120102511"},"Children":[{"ID":"20231120102511-wqwmqtb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120102511-wqwmqtb","updated":"20231120102511"},"Children":[{"ID":"20231120102511-0igsll0","Type":"NodeParagraph","Properties":{"id":"20231120102511-0igsll0","updated":"20231120102511"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"属于工厂模式最为简单直观的一种类型"}]}]},{"ID":"20231120102511-fvd0iv5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120102511-fvd0iv5","updated":"20231120102511"},"Children":[{"ID":"20231120102511-22qyjto","Type":"NodeParagraph","Properties":{"id":"20231120102511-22qyjto","updated":"20231120102511"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"构造各类组件时的聚拢收口效果最好，提供的公共切面最全面到位"}]}]}]},{"ID":"20231120102511-tgegm2r","Type":"NodeParagraph","Properties":{"id":"20231120102511-tgegm2r","updated":"20231120102511"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"存在的劣势为："}]},{"ID":"20231120102511-is33jae","Type":"NodeList","ListData":{},"Properties":{"id":"20231120102511-is33jae","updated":"20231120102511"},"Children":[{"ID":"20231120102511-45w1jkw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120102511-45w1jkw","updated":"20231120102511"},"Children":[{"ID":"20231120102511-azfva8h","Type":"NodeParagraph","Properties":{"id":"20231120102511-azfva8h","updated":"20231120102511"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"组件类扩展时，需要直接修改工厂的组件构造方法，不符合开闭原则"}]}]}]},{"ID":"20231120102617-1z05ntx","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231120102617-1z05ntx","updated":"20231120102627"},"Children":[{"Type":"NodeText","Data":"工厂方法模式"}]},{"ID":"20231120102635-2jb9764","Type":"NodeParagraph","Properties":{"id":"20231120102635-2jb9764","updated":"20231120102635"},"Children":[{"Type":"NodeText","Data":"为了解决简单工厂模式中存在的问题，我们对设计流程进行修改："}]},{"ID":"20231120102635-50xcklx","Type":"NodeList","ListData":{},"Properties":{"id":"20231120102635-50xcklx","updated":"20231120102642"},"Children":[{"ID":"20231120102635-zibyyi7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120102635-zibyyi7","updated":"20231120102639"},"Children":[{"ID":"20231120102635-8zapq5o","Type":"NodeParagraph","Properties":{"id":"20231120102635-8zapq5o","updated":"20231120102639"},"Children":[{"Type":"NodeText","Data":"关于组件的定义模式不变. 一个抽象的 Fruit interface，多个具体的水果实现 Orange、Strawberry、Cherry"}]}]},{"ID":"20231120102635-dsx4t43","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120102635-dsx4t43","updated":"20231120102641"},"Children":[{"ID":"20231120102635-rgyvq5p","Type":"NodeParagraph","Properties":{"id":"20231120102635-rgyvq5p","updated":"20231120102641"},"Children":[{"Type":"NodeText","Data":"将工厂类 FruitFactory 由具体的实现类改为抽象的 interface"}]}]},{"ID":"20231120102635-kttqciw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120102635-kttqciw","updated":"20231120102642"},"Children":[{"ID":"20231120102635-mmu5quc","Type":"NodeParagraph","Properties":{"id":"20231120102635-mmu5quc","updated":"20231120102642"},"Children":[{"Type":"NodeText","Data":"针对每类水果，提供出一个具体的工厂实现类，如 OrangeFactory、StrawberryFactory、CherryFactory"}]}]}]},{"ID":"20231120102635-ng75dyh","Type":"NodeParagraph","Properties":{"id":"20231120102635-ng75dyh","updated":"20231120102635"},"Children":[{"Type":"NodeText","Data":"对应的UML类图如下："}]},{"ID":"20231120102653-dr1deit","Type":"NodeParagraph","Properties":{"id":"20231120102653-dr1deit","updated":"20231120102653"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120102653-gqyl4hn.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120102658-w4xlspe","Type":"NodeParagraph","Properties":{"id":"20231120102658-w4xlspe","updated":"20231120103338"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在工厂方法模式中，对抽象组件 Fruit interface 以及几个具体实现类 Orange、Strawberry 和 Cherry 的定义和简单工厂模式如出一辙，这里不再重复展示代码."}]},{"ID":"20231120102658-5ctx3t0","Type":"NodeParagraph","Properties":{"id":"20231120102658-5ctx3t0","updated":"20231120103346"},"Children":[{"Type":"NodeText","Data":"与简单工厂模式有所区别的是， "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"水果工厂类 FruitFactory 在此处变成一个抽象的 interface，且针对每种具体的水果实现类需要对应地声明一种工厂实现类，包括 OrangeFactory、StrawberryFactory、CherryFactory，具体的实现代码如下："}]},{"ID":"20231120102933-qjqr4y5","Type":"NodeParagraph","Properties":{"id":"20231120102933-qjqr4y5"}},{"ID":"20231120102934-jnxbvrc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120102934-jnxbvrc","updated":"20231120102943"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type FruitFactory interface {\n    CreateFruit() Fruit\n}\n\n\ntype OrangeFactory struct {\n}\n\n\nfunc NewOrangeFactory() FruitFactory {\n    return \u0026OrangeFactory{}\n}\n\n\nfunc (o *OrangeFactory) CreateFruit() Fruit {\n    return NewOrange(\"\")\n}\n\n\ntype StrawberryFactory struct {\n}\n\n\nfunc NewStrawberryFactory() FruitFactory {\n    return \u0026StrawberryFactory{}\n}\n\n\nfunc (s *StrawberryFactory) CreateFruit() Fruit {\n    return NewStrawberry(\"\")\n}\n\n\ntype CherryFactory struct {\n}\n\n\nfunc NewCherryFactory() FruitFactory {\n    return \u0026CherryFactory{}\n}\n\n\nfunc (c *CherryFactory) CreateFruit() Fruit {\n    return NewCherry(\"\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120103403-mq7l7je","Type":"NodeParagraph","Properties":{"id":"20231120103403-mq7l7je","updated":"20231120103412"},"Children":[{"Type":"NodeText","Data":"这样的设计模式下，即便后续有频繁扩展水果实现类的需求，也无须对老模块的代码进行修改，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"而是需要扩展实现一个水果 Fruit 的实现类以及对应的水果工厂实现类即可，"},{"Type":"NodeText","Data":"比如，倘若此处我们需要在水果列表中扩展一个“西瓜”的话，那么需要新增的代码如下："}]},{"ID":"20231120103414-hurfn42","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120103414-hurfn42","updated":"20231120103513"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Watermelon struct {\n    name string\n}\n\n\nfunc NewWatermelon(name string) Fruit {\n    return \u0026Watermelon{\n        name: name,\n    }\n}\n\n\nfunc (w *Watermelon) Eat() {\n    fmt.Printf(\"i am watermelon: %s, i am about to be eaten...\", w.na\n\n\ntype WatermelonFactory struct {\n}\n\n\nfunc NewWatermelon() FruitFactory {\n    return \u0026WatermelonFactory{}\n}\n\n\nfunc (w *WatermelonFactory) CreateFruit() Fruit {\n    return NewWatermelon(\"\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120103505-0923r0d","Type":"NodeParagraph","Properties":{"id":"20231120103505-0923r0d","updated":"20231120103552"},"Children":[{"Type":"NodeText","Data":"下面是使用到工厂方法模式的单测代码示例："}]},{"ID":"20231120103532-of9h0jk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120103532-of9h0jk","updated":"20231120103821"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func Test_factory(t *testing.T) {\n  // 尝个橘子\n  orangeFactory  := NewOrangeFactory()\n  orange := orangeFactory.CreateFruit()\n  orange.Eat()\n\n  // 来个樱桃\n  cherryFactory := NewCherryFactory()\n  cherry := cherryFactory.CreateFruit()\n  cherry.Eat()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120103834-bmoilcv","Type":"NodeParagraph","Properties":{"id":"20231120103834-bmoilcv","updated":"20231120103834"},"Children":[{"Type":"NodeText","Data":"工厂方法模式相较于简单工厂模式而言，解决了扩展水果类不满足开闭原则的问题，然而工厂方法模式也有其固有的缺陷："}]},{"ID":"20231120103834-oq9owb6","Type":"NodeList","ListData":{},"Properties":{"id":"20231120103834-oq9owb6","updated":"20231120103841"},"Children":[{"ID":"20231120103834-i1g4f8i","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120103834-i1g4f8i","updated":"20231120103841"},"Children":[{"ID":"20231120103834-8gan6s3","Type":"NodeParagraph","Properties":{"id":"20231120103834-8gan6s3","updated":"20231120103841"},"Children":[{"Type":"NodeText","Data":"需要为每个水果单独实现一个工厂类,代码冗余度较高"}]}]},{"ID":"20231120103834-w8ekmel","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120103834-w8ekmel","updated":"20231120103839"},"Children":[{"ID":"20231120103834-of65ied","Type":"NodeParagraph","Properties":{"id":"20231120103834-of65ied","updated":"20231120103839"},"Children":[{"Type":"NodeText","Data":"原本构造多个水果类时存在的公共切面不复存在，一些通用的逻辑需要在每个水果工厂实现类中重复声明一遍"}]}]}]},{"ID":"20231120103858-endtst4","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231120103858-endtst4","updated":"20231120103910"},"Children":[{"Type":"NodeText","Data":"抽象工厂模式"}]},{"ID":"20231120103921-gtjbiec","Type":"NodeParagraph","Properties":{"id":"20231120103921-gtjbiec","updated":"20231120103921"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120103921-1qdts5j.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120103927-ex0oyar","Type":"NodeParagraph","Properties":{"id":"20231120103927-ex0oyar","updated":"20231120103927"},"Children":[{"Type":"NodeText","Data":"接下来，我们进行抽象工厂模式的介绍. 这里，针对工厂需要构造的组件，我们通过两个维度进行拆解："}]},{"ID":"20231120103938-kzu7p3g","Type":"NodeList","ListData":{},"Properties":{"id":"20231120103938-kzu7p3g","updated":"20231120103938"},"Children":[{"ID":"20231120103938-n7iszj5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120103938-n7iszj5","updated":"20231120103938"},"Children":[{"ID":"20231120103938-os7ljmi","Type":"NodeParagraph","Properties":{"id":"20231120103938-os7ljmi","updated":"20231120103938"},"Children":[{"Type":"NodeText","Data":"我们假设水果 Fruit 中仅包含两种具体的水果：草莓 strawberry 和柠檬 lemon"}]}]},{"ID":"20231120103938-bnkdeg5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120103938-bnkdeg5","updated":"20231120103938"},"Children":[{"ID":"20231120103938-4pdpn6s","Type":"NodeParagraph","Properties":{"id":"20231120103938-4pdpn6s","updated":"20231120103940"},"Children":[{"Type":"NodeText","Data":"我们把每种具体的水果实现类称为一个产品等级，strawberry 是一个产品等级，lemon 也是一个产品等级"}]}]},{"ID":"20231120103938-ha8bwj0","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120103938-ha8bwj0","updated":"20231120103938"},"Children":[{"ID":"20231120103938-p0bo51w","Type":"NodeParagraph","Properties":{"id":"20231120103938-p0bo51w","updated":"20231120103942"},"Children":[{"Type":"NodeText","Data":"在同一个水果实现类中，我们额外新增一个品牌的维度，成为产品族. 例如 strawberry 和 lemon 可以由不同品牌的厂商进行生产，比如水果品牌佳农 GoodFarmer 生产的草莓为 GoodFarmerStrawberry，生产的柠檬为 GoodFarmerLemon；水果品牌 Dole都乐生产的草莓为 DoleStrawberry，生产的柠檬为 DoleLemon"}]}]}]},{"ID":"20231120104003-1gzq82s","Type":"NodeParagraph","Properties":{"id":"20231120104003-1gzq82s","updated":"20231120104044"},"Children":[{"Type":"NodeText","Data":"基于上述两个维度，我们尝试对简单工厂模式和厂方法模式中优势进行聚拢："}]},{"ID":"20231120104044-wlbtaz1","Type":"NodeList","ListData":{},"Properties":{"id":"20231120104044-wlbtaz1","updated":"20231120104045"},"Children":[{"ID":"20231120104045-yhcit2e","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120104045-yhcit2e","updated":"20231120104045"},"Children":[{"ID":"20231120104045-xq1e160","Type":"NodeParagraph","Properties":{"id":"20231120104045-xq1e160","updated":"20231120104210"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"首先，我们把种类相对稳定，不需要频繁扩展变更的维度定义为产品等级，比如上述例子中的Fruit，我们需要固定明确后续Fruit 只包含草莓 strawberry 和柠檬 lemon 两类，没有频繁扩展的诉求"}]}]},{"ID":"20231120104212-32q1fsp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120104212-32q1fsp"},"Children":[{"ID":"20231120104212-ev53na3","Type":"NodeParagraph","Properties":{"id":"20231120104212-ev53na3","updated":"20231120104221"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"针对于种类需要频繁变更的维度，我们将其定义为产品族. 比如上述例子中的品牌，我们目前支持了佳农 GoodFarmer 和都乐 Dole，后续还可以继续扩展支持更丰富的水果品牌，如 佳沛 Zespri、佳沃 JOYVIO 等"}]}]},{"ID":"20231120104235-9gy9hql","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120104235-9gy9hql"},"Children":[{"ID":"20231120104235-3npmeby","Type":"NodeParagraph","Properties":{"id":"20231120104235-3npmeby","updated":"20231120104241"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"每次需要扩展产品族时，都需要实现对应产品族的工厂 factory 实现类，而无需对老的实现方法直接进行修改，符合开闭原则"}]}]},{"ID":"20231120104246-2trl6e2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120104246-2trl6e2"},"Children":[{"ID":"20231120104246-c49kcrt","Type":"NodeParagraph","Properties":{"id":"20231120104246-c49kcrt","updated":"20231120104253"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"针对于不频繁变动的产品等级，如草莓 strawberry 与柠檬 lemon，每个品牌都会有一个具体的 factory 工厂实现类. 其中会统一声明对应于每种水果的构造方法，此时具备实现公共切面的能力"}]}]}]},{"ID":"20231120104307-828l2nh","Type":"NodeParagraph","Properties":{"id":"20231120104307-828l2nh","updated":"20231120104308"},"Children":[{"Type":"NodeText","Data":"按照上述思路，抽象工厂模式我们定义的 UML 类图如下："}]},{"ID":"20231120104421-4yxaxat","Type":"NodeParagraph","Properties":{"id":"20231120104421-4yxaxat","updated":"20231120150524"},"Children":[{"Type":"NodeText","Data":"​​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120150520-4dlozy2.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​​"}]},{"ID":"20231120143606-1nm64q0","Type":"NodeParagraph","Properties":{"id":"20231120143606-1nm64q0","updated":"20231120150540"},"Children":[{"Type":"NodeText","Data":"在抽象工厂模式下，我们需要将每种水果类型定义为一个抽象的 interface，包括草莓 strawberry 和柠檬 lemon. 其中 strawberry 包含一个方法 SweetAttack：当草莓被食用时，它会发起一轮甜蜜攻势；柠檬 Lemon 包含的方法为 AcidAttack，食用它时需要承受一轮酸劲攻势."}]},{"ID":"20231120150542-q8oqyam","Type":"NodeParagraph","Properties":{"id":"20231120150542-q8oqyam"}},{"ID":"20231120150543-uu6xqlt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120150543-uu6xqlt","updated":"20231120150543"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}