{"ID":"20230727014431-hz8mtja","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f3bb","id":"20230727014431-hz8mtja","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230727014431-hz8mtja\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230727014431-pio6ufo\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230727014435-txq5xg4\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230727014431-pio6ufo\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","tags":"高并发架构,服务治理,限流,Go 代码,未完成","title":"Go 限流的常见方法","updated":"20230727014435"},"Children":[{"ID":"20230727014431-pio6ufo","Type":"NodeParagraph","Properties":{"id":"20230727014431-pio6ufo","updated":"20230727014435"}},{"ID":"20230727014435-yzf8pku","Type":"NodeParagraph","Properties":{"id":"20230727014435-yzf8pku","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"最近做的项目需要对系统设计并发控制和流控，刚好趁这个时间，把Go的并发控制和限流策略整体梳理一下，因为篇幅原因，本章只整理限流方面的内容，后面再整理Go的并发控制内容。"}]},{"ID":"20230727014435-l8owysd","Type":"NodeParagraph","Properties":{"id":"20230727014435-l8owysd","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1. 并发控制限流"}]},{"ID":"20230727014435-gtle671","Type":"NodeParagraph","Properties":{"id":"20230727014435-gtle671","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"利用channel的缓冲设定，我们就可以来实现并发的限制。我们只要在执行并发的同时，往一个带有缓冲的 channel 里写入点东西（随便写啥，内容不重要）。让并发的 goroutine在执行完成后把这个 channel 里的东西给读走。这样整个并发的数量就将控制在这个 channel的缓冲区大小上。"}]},{"ID":"20230727014435-tdr3qpc","Type":"NodeParagraph","Properties":{"id":"20230727014435-tdr3qpc","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"比如我们可以用一个 bool 类型的带缓冲 channel 作为并发限制的计数器。"}]},{"ID":"20230727014435-94zepmx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230727014435-94zepmx","updated":"20230727014435"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"chLimit := make(chan bool, 1)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230727014435-aega3wk","Type":"NodeParagraph","Properties":{"id":"20230727014435-aega3wk","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"然后在并发执行的地方，每创建一个新的 goroutine，都往 chLimit 里塞个东西。"}]},{"ID":"20230727014435-vd1ujf2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230727014435-vd1ujf2","updated":"20230729012110"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"for i,sleeptime := range input {\n    chs[i] = make(chan string,1)\n    chLimit \u003c- true\n    go limitFunc(chLimit, chs[i], i, sleeptime, timeout)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230727014435-35s5ksy","Type":"NodeParagraph","Properties":{"id":"20230727014435-35s5ksy","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这里通过 go 关键字并发执行的是新构造的函数。他在执行完后，会把 chLimit的缓冲区里给消费掉一个。"}]},{"ID":"20230727014435-16bm1x8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230727014435-16bm1x8","updated":"20230729012113"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"limitFunc := func(chLimit chan bool, ch chan string, task_id, sleeptime,timeout int) {\n    Run(task_id, sleeptime, timeout, ch)\n    \u003c-chLimit\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230727014435-6o2tbu9","Type":"NodeParagraph","Properties":{"id":"20230727014435-6o2tbu9","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这样一来，当创建的 goroutine 数量到达 chLimit 的缓冲区上限后。主 goroutine 就挂起阻塞了，直到这些 goroutine 执行完毕，消费掉了 chLimit 缓冲区中的数据，程序才会继续创建新的 goroutine 。我们并发数量限制的目的也就达到了。"}]},{"ID":"20230727014435-94o1bqf","Type":"NodeParagraph","Properties":{"id":"20230727014435-94o1bqf","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"完整代码："}]},{"ID":"20230727014435-3awjt7n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230727014435-3awjt7n","updated":"20230729012121"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main \npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc Run(taskId, sleeptime, timeout int, ch chan string) {\n    chRun := make(chan string)\n    go run(taskId, sleeptime, chRun)\n    select {\n    case re := \u003c-chRun:\n        ch \u003c- re\n    case \u003c-time.After(time.Duration(timeout) * time.Second):\n        re := fmt.Sprintf(\"task id %d , timeout\", taskId)\n        ch \u003c- re\n    }\n}\n\nfunc run(taskId, sleeptime int, ch chan string) {\n    time.Sleep(time.Duration(sleeptime) * time.Second)\n    ch \u003c- fmt.Sprintf(\"task id %d , sleep %d second\", taskId, sleeptime)\n    return\n}\n\nfunc main() {\n    input := []int{3, 2, 1}\n    timeout := 2\n    chLimit := make(chan bool, 1)\n    chs := make([]chan string, len(input))\n    limitFunc := func(chLimit chan bool, ch chan string, task_id, sleeptime, timeout int) {\n        Run(task_id, sleeptime, timeout, ch)\n        \u003c-chLimit\n    }\n    startTime := time.Now()\n    fmt.Println(\"Multirun start\")\n    for i, sleeptime := range input {\n        chs[i] = make(chan string, 1)\n        chLimit \u003c- true\n        go limitFunc(chLimit, chs[i], i, sleeptime, timeout)\n    }\n    for _, ch := range chs {\n        fmt.Println(\u003c-ch)\n    }\n    endTime := time.Now()\n    fmt.Printf(\"Multissh finished. Process time %s. Number of task is %d\\n\", endTime.Sub(startTime), len(input))\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230727014435-5aew00z","Type":"NodeParagraph","Properties":{"id":"20230727014435-5aew00z","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"运行结果："}]},{"ID":"20230727014435-kbne3pb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230727014435-kbne3pb","updated":"20230729014012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"Multirun start\ntask id 0 , timeout\ntask id 1 , timeout\ntask id 2 , sleep 1 second\nMultissh finished. Process time 5.0402955s. Number of task is 3\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230727014435-s1inh0g","Type":"NodeParagraph","Properties":{"id":"20230727014435-s1inh0g","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"2. 计数器"}]},{"ID":"20230727014435-vof1xc9","Type":"NodeParagraph","Properties":{"id":"20230727014435-vof1xc9","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"计数器是一种最简单限流算法，其原理就是：在一段时间间隔内，对请求进行计数，与阀值进行比较判断是否需要限流，一旦到了时间临界点，将计数器清零。这个就像你去坐车一样，车厢规定了多少个位置，满了就不让上车了，不然就是超载了，被交警叔叔抓到了就要罚款的，如果我们的系统那就不是罚款的事情了，可能直接崩掉了。"}]},{"ID":"20230727014435-useonq6","Type":"NodeParagraph","Properties":{"id":"20230727014435-useonq6","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"程序执行逻辑："}]},{"ID":"20230727014435-cfqi04l","Type":"NodeList","ListData":{},"Properties":{"id":"20230727014435-cfqi04l","updated":"20230727014435"},"Children":[{"ID":"20230727014435-ygu4qum","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-ygu4qum","updated":"20230727014435"},"Children":[{"ID":"20230727014435-47xbply","Type":"NodeParagraph","Properties":{"id":"20230727014435-47xbply","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"可以在程序中设置一个变量 count，当过来一个请求我就将这个数+1，同时记录请求时间。"}]}]},{"ID":"20230727014435-8umwibi","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-8umwibi","updated":"20230727014435"},"Children":[{"ID":"20230727014435-bx2ulmh","Type":"NodeParagraph","Properties":{"id":"20230727014435-bx2ulmh","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"当下一个请求来的时候判断 count 的计数值是否超过设定的频次，以及当前请求的时间和第一次请求时间是否在 1 分钟内。"}]}]},{"ID":"20230727014435-7sxit38","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-7sxit38","updated":"20230727014435"},"Children":[{"ID":"20230727014435-39s0xf9","Type":"NodeParagraph","Properties":{"id":"20230727014435-39s0xf9","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果在 1 分钟内并且超过设定的频次则证明请求过多，后面的请求就拒绝掉。"}]}]},{"ID":"20230727014435-cms1wab","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-cms1wab","updated":"20230727014435"},"Children":[{"ID":"20230727014435-ag8aa94","Type":"NodeParagraph","Properties":{"id":"20230727014435-ag8aa94","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果该请求与第一个请求的间隔时间大于计数周期，且 count 值还在限流范围内，就重置 count。"}]}]}]},{"ID":"20230727014435-p3guufn","Type":"NodeParagraph","Properties":{"id":"20230727014435-p3guufn","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"代码实现："}]},{"ID":"20230727014435-ny5qui4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230727014435-ny5qui4","updated":"20230729020610"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"log\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Counter struct {\n\trate  int           // 技术周期内最多允许的请求数\n\tbegin time.Time     // 计数开始时间\n\tcycle time.Duration // 计数周期\n\tcount int           // 计数周期内累计收到的请求数\n\tlock  sync.Mutex\n}\n\nfunc (l *Counter) ALlow() bool {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\tif l.count == l.rate-1 {\n\t\tnow := time.Now()\n\t\tif now.Sub(l.begin) \u003e= l.cycle {\n\t\t\t// 速度允许范围内，重置计数器\n\t\t\tl.Reset(now)\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t} else {\n\t\t// 没有达到速率限制，计数加1\n\t\tl.count++\n\t\treturn true\n\t}\n}\n\nfunc (l *Counter) Set(r int, cycle time.Duration) {\n\tl.rate = r\n\tl.begin = time.Now()\n\tl.cycle = cycle\n\tl.count = 0\n}\n\nfunc (l *Counter) Reset(t time.Time) {\n\tl.begin = t\n\tl.count = 0\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tvar lr Counter\n\tlr.Set(3, time.Second) // 1s 内最多请求3次\n\tfor i := 0; i \u003c 10; i++ {\n\t\twg.Add(1)\n\t\tlog.Println(\"创建请求：\", i)\n\t\tgo func(i int) {\n\t\t\tif lr.ALlow() {\n\t\t\t\tlog.Println(\"响应请求：\", i)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(i)\n\t\ttime.Sleep(200 * time.Millisecond)\n\t}\n\twg.Wait()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230727014435-dce52rb","Type":"NodeParagraph","Properties":{"id":"20230727014435-dce52rb","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"输出："}]},{"ID":"20230727014435-krmmi76","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230727014435-krmmi76","updated":"20230729020820"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"2023/07/29 02:04:30 创建请求： 0\n2023/07/29 02:04:30 响应请求： 0\n2023/07/29 02:04:30 创建请求： 1\n2023/07/29 02:04:30 响应请求： 1\n2023/07/29 02:04:30 创建请求： 2\n2023/07/29 02:04:30 创建请求： 3\n2023/07/29 02:04:31 创建请求： 4\n2023/07/29 02:04:31 创建请求： 5\n2023/07/29 02:04:31 响应请求： 5\n2023/07/29 02:04:31 创建请求： 6\n2023/07/29 02:04:31 响应请求： 6\n2023/07/29 02:04:31 创建请求： 7\n2023/07/29 02:04:31 响应请求： 7\n2023/07/29 02:04:31 创建请求： 8\n2023/07/29 02:04:32 创建请求： 9\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230727014435-s6u5j0y","Type":"NodeParagraph","Properties":{"id":"20230727014435-s6u5j0y","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"可以看到我们设置的是每200ms创建一个请求，明显高于1秒最多3个请求的限制，运行起来之后发现编号为 2、3、4、8、9 的请求被丢弃，说明限流成功。"}]},{"ID":"20230727014435-0sy97hs","Type":"NodeParagraph","Properties":{"id":"20230727014435-0sy97hs","updated":"20230730171404"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"那么问题来了，如果有个需求对于某个接口 /query 每分钟最多允许访问 200 次，假设有个用户在第 59 秒"}]},{"ID":"20230730173424-1nrceci","Type":"NodeParagraph","Properties":{"id":"20230730173424-1nrceci"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"的最后几毫秒瞬间发送 200 个请求，当 59 秒结束后 Counter 清零了，他在下一秒的时候又发送 200 个请求。那么在 1 秒钟内这个用户发送了 2 倍的请求，这个是符合我们的设计逻辑的，这也是计数器方法的设计缺陷，系统可能会承受恶意用户的大量请求，甚至击穿系统。这种方法虽然简单，但也有个大问题就是没有很好的处理单位时间的边界。"}]},{"ID":"20230727014435-m9n5zie","Type":"NodeParagraph","Properties":{"id":"20230727014435-m9n5zie","updated":"20230727014435"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file://E:\\Typora%20picture\\640.png?lastModify=1690393472"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230727014435-c38gx4l","Type":"NodeParagraph","Properties":{"id":"20230727014435-c38gx4l","updated":"20230730171418"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"不过说实话，这个计数引用了锁，在高并发场景，这个方式可能不太实用，我建议将锁去掉，然后将l.count++的逻辑通过原子计数处理，这样就可以保证l.count自增时不会被多个线程同时执行，即通过原子计数的方式实现限流。"}]},{"ID":"20230727014435-ge6jj4w","Type":"NodeParagraph","Properties":{"id":"20230727014435-ge6jj4w","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"3. 滑动窗口"}]},{"ID":"20230727014435-hx6kfun","Type":"NodeParagraph","Properties":{"id":"20230727014435-hx6kfun","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"滑动窗口是针对计数器存在的临界点缺陷，所谓 滑动窗口（Sliding window） 是一种流量控制技术，这个词出现在 TCP 协议中。滑动窗口把固定时间片进行划分，并且随着时间的流逝，进行移动，固定数量的可以移动的格子，进行计数并判断阀值。"}]},{"ID":"20230727014435-n505r0d","Type":"NodeParagraph","Properties":{"id":"20230727014435-n505r0d","updated":"20230727014435"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file://E:\\Typora%20picture\\640-16902636167451.png?lastModify=1690393472"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230727014435-imyn67e","Type":"NodeParagraph","Properties":{"id":"20230727014435-imyn67e","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"上图中我们用红色的虚线代表一个时间窗口（一分钟），每个时间窗口有 6 个格子，每个格子是 10 秒钟。每过 10 秒钟时间窗口向右移动一格，可以看红色箭头的方向。我们为每个格子都设置一个独立的计数器 Counter，假如一个请求在 0:45 访问了那么我们将第五个格子的计数器 +1（也是就是 0:40~0:50），在判断限流的时候需要把所有格子的计数加起来和设定的频次进行比较即可。"}]},{"ID":"20230727014435-y2zrblv","Type":"NodeParagraph","Properties":{"id":"20230727014435-y2zrblv","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"那么滑动窗口如何解决我们上面遇到的问题呢？来看下面的图："}]},{"ID":"20230727014435-at07pmu","Type":"NodeParagraph","Properties":{"id":"20230727014435-at07pmu","updated":"20230727014435"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file://E:\\Typora%20picture\\640-16902636167462.png?lastModify=1690393472"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230727014435-7rr5ykq","Type":"NodeParagraph","Properties":{"id":"20230727014435-7rr5ykq","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"当用户在0:59 秒钟发送了 200个请求就会被第六个格子的计数器记录 +200，当下一秒的时候时间窗口向右移动了一个，此时计数器已经记录了该用户发送的 200 个请求，所以再发送的话就会触发限流，则拒绝新的请求。"}]},{"ID":"20230727014435-wys6wzv","Type":"NodeParagraph","Properties":{"id":"20230727014435-wys6wzv","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"其实计数器就是滑动窗口啊，只不过只有一个格子而已，所以想让限流做的更精确只需要划分更多的格子就可以了，为了更精确我们也不知道到底该设置多少个格子，****格子的数量影响着滑动窗口算法的精度，依然有时间片的概念，无法根本解决临界点问题。"}]},{"ID":"20230727014435-qy8wwgv","Type":"NodeParagraph","Properties":{"id":"20230727014435-qy8wwgv","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"4. 漏桶"}]},{"ID":"20230727014435-eputxex","Type":"NodeParagraph","Properties":{"id":"20230727014435-eputxex","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"漏桶算法（Leaky Bucket），原理就是一个固定容量的漏桶，按照固定速率流出水滴。用过水龙头都知道，打开龙头开关水就会流下滴到水桶里，而漏桶指的是水桶下面有个漏洞可以出水。如果水龙头开的特别大那么水流速就会过大，这样就可能导致水桶的水满了然后溢出。"}]},{"ID":"20230727014435-4wq6zvo","Type":"NodeParagraph","Properties":{"id":"20230727014435-4wq6zvo","updated":"20230727014435"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file://E:\\Typora%20picture\\640-16902636167463.png?lastModify=1690393472"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230727014435-rswjk6h","Type":"NodeParagraph","Properties":{"id":"20230727014435-rswjk6h","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"一个固定容量的桶，有水流进来，也有水流出去。对于流进来的水来说，我们无法预计一共有多少水会流进来，也无法预计水流的速度。但是对于流出去的水来说，这个桶可以固定水流出的速率（处理速度），从而达到 流量整形 和 流量控制 的效果。"}]},{"ID":"20230727014435-nwklhe8","Type":"NodeParagraph","Properties":{"id":"20230727014435-nwklhe8","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"代码实现："}]},{"ID":"20230727014435-d5rwhtp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230727014435-d5rwhtp","updated":"20230730214327"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type LeakyBucket struct {\n\trate       float64 // 固定每秒出水速率\n\tcapacity   float64 // 桶的容量\n\twater      float64 // 桶中当前的水量\n\tlastLeakMs int64   // 桶上次漏水时间戳 ms\n\tlock       sync.Mutex\n}\n\nfunc (l *LeakyBucket) Allow() bool {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\tnow := time.Now().UnixNano() / 1e6\n\teclipse := float64((now - l.lastLeakMs)) * l.rate / 1000 // 先执行漏水\n\tl.water = l.water - eclipse\n\tl.water = math.Max(0, l.water)\n\tl.lastLeakMs = now\n\tif (l.water + 1) \u003c l.capacity {\n\t\t// 尝试加水，并且水还未满\n\t\tl.water++\n\t\treturn true\n\t} else {\n\t\t// 水满，拒绝加水\n\t\treturn false\n\t}\n}\n\nfunc (l *LeakyBucket) Set(r, c float64) {\n\tl.rate = r\n\tl.capacity = c\n\tl.water = 0\n\tl.lastLeakMs = time.Now().UnixNano() / 1e6\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230727014435-jgzjrc9","Type":"NodeParagraph","Properties":{"id":"20230727014435-jgzjrc9","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"漏桶算法有以下特点："}]},{"ID":"20230727014435-qukjdbr","Type":"NodeList","ListData":{},"Properties":{"id":"20230727014435-qukjdbr","updated":"20230727014435"},"Children":[{"ID":"20230727014435-788ddid","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-788ddid","updated":"20230727014435"},"Children":[{"ID":"20230727014435-pd7qeu9","Type":"NodeParagraph","Properties":{"id":"20230727014435-pd7qeu9","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"漏桶具有固定容量，出水速率是固定常量（流出请求）"}]}]},{"ID":"20230727014435-rs69ptt","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-rs69ptt","updated":"20230727014435"},"Children":[{"ID":"20230727014435-k50i4l6","Type":"NodeParagraph","Properties":{"id":"20230727014435-k50i4l6","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果桶是空的，则不需流出水滴"}]}]},{"ID":"20230727014435-3ro7lsh","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-3ro7lsh","updated":"20230727014435"},"Children":[{"ID":"20230727014435-nftpdsv","Type":"NodeParagraph","Properties":{"id":"20230727014435-nftpdsv","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"可以以任意速率流入水滴到漏桶（流入请求）"}]}]},{"ID":"20230727014435-czq7o1b","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-czq7o1b","updated":"20230727014435"},"Children":[{"ID":"20230727014435-uoflysf","Type":"NodeParagraph","Properties":{"id":"20230727014435-uoflysf","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）"}]}]}]},{"ID":"20230727014435-j0dm5ce","Type":"NodeParagraph","Properties":{"id":"20230727014435-j0dm5ce","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"漏桶限制的是常量流出速率（即流出速率是一个固定常量值），****所以最大的速率就是出水的速率，不能出现突发流量。"}]},{"ID":"20230727014435-6m868fh","Type":"NodeParagraph","Properties":{"id":"20230727014435-6m868fh","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"5. 令牌桶"}]},{"ID":"20230727014435-7zhgzcf","Type":"NodeParagraph","Properties":{"id":"20230727014435-7zhgzcf","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"令牌桶算法（Token Bucket）是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。"}]},{"ID":"20230727014435-neb0f8h","Type":"NodeParagraph","Properties":{"id":"20230727014435-neb0f8h","updated":"20230727014435"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file://E:\\Typora%20picture\\640-16902636167464.png?lastModify=1690393472"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230727014435-eoglah8","Type":"NodeParagraph","Properties":{"id":"20230727014435-eoglah8","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"我们有一个固定的桶，桶里存放着令牌（token）。一开始桶是空的，系统按固定的时间（rate）往桶里添加令牌，直到桶里的令牌数满，多余的请求会被丢弃。当请求来的时候，从桶里移除一个令牌，如果桶是空的则拒绝请求或者阻塞。"}]},{"ID":"20230727014435-nfxsbuv","Type":"NodeParagraph","Properties":{"id":"20230727014435-nfxsbuv","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"代码实现："}]},{"ID":"20230727014435-wkkml2j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230727014435-wkkml2j","updated":"20230730214343"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"import (\n\t\"fmt\"\n\t\"net\"\n\t\"golang.org/x/net/netutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tfmt.Printf(\"Listen: %v\\n\", err)\n\t}\n\tdefer l.Close()\n\tl = LimitListener(l, max)\n\thttp.Serve(l,http.HandlerFunc())\n\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230727014435-6jdqjhj","Type":"NodeParagraph","Properties":{"id":"20230727014435-6jdqjhj","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"令牌桶有以下特点："}]},{"ID":"20230727014435-oc1n9s1","Type":"NodeList","ListData":{},"Properties":{"id":"20230727014435-oc1n9s1","updated":"20230727014435"},"Children":[{"ID":"20230727014435-agjrj4t","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-agjrj4t","updated":"20230727014435"},"Children":[{"ID":"20230727014435-l3jzbep","Type":"NodeParagraph","Properties":{"id":"20230727014435-l3jzbep","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"令牌按固定的速率被放入令牌桶中"}]}]},{"ID":"20230727014435-mv293i1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-mv293i1","updated":"20230727014435"},"Children":[{"ID":"20230727014435-a59eblz","Type":"NodeParagraph","Properties":{"id":"20230727014435-a59eblz","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"桶中最多存放 B 个令牌，当桶满时，新添加的令牌被丢弃或拒绝"}]}]},{"ID":"20230727014435-5bmqgrt","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-5bmqgrt","updated":"20230727014435"},"Children":[{"ID":"20230727014435-mapi3hb","Type":"NodeParagraph","Properties":{"id":"20230727014435-mapi3hb","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果桶中的令牌不足 N 个，则不会删除令牌，且请求将被限流（丢弃或阻塞等待）"}]}]}]},{"ID":"20230727014435-qdggqij","Type":"NodeParagraph","Properties":{"id":"20230727014435-qdggqij","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"令牌桶限制的是平均流入速率"},{"Type":"NodeText","Data":"（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌...），"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"并允许一定程度突发流量，所以也是非常常用的限流算法。"}]},{"ID":"20230727014435-0pml69i","Type":"NodeParagraph","Properties":{"id":"20230727014435-0pml69i","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"6. httpserver频率限制"}]},{"ID":"20230727014435-i3wy2te","Type":"NodeParagraph","Properties":{"id":"20230727014435-i3wy2te","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"使用golang来编写httpserver时，可以使用官方已经有实现好的包："}]},{"ID":"20230727014435-62lhf10","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230727014435-62lhf10","updated":"20230730214502"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"import (\n\t\"fmt\"\n\t\"net\"\n\t\"golang.org/x/net/netutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tfmt.Printf(\"Listen: %v\\n\", err)\n\t}\n\tdefer l.Close()\n\tl = LimitListener(l, max)\n\thttp.Serve(l,http.HandlerFunc())\n        // ......\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230727014435-kzko8y7","Type":"NodeParagraph","Properties":{"id":"20230727014435-kzko8y7","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"源码的基本思路就是为连接数计数，通过make chan来建立一个最大连接数的channel, 每次accept就+1，close时候就-1. 当到达最大连接数时，就等待空闲连接出来之后再accept。"}]},{"ID":"20230727014435-m8cy31n","Type":"NodeParagraph","Properties":{"id":"20230727014435-m8cy31n","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"7. Redis消息队列限流"}]},{"ID":"20230727014435-16z447f","Type":"NodeParagraph","Properties":{"id":"20230727014435-16z447f","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"我们都知道消息队列可以实现异步、解耦和削峰。使用Redis的List类型的消息队列，指定队列固定长度，开始会一直往队列塞数据，当下游消费能力不足，队列处于满员状态时，生产者的数据直接丢弃，以此实现限流。这里其实有个疑问，因为channel其实也可以理解为一个队列，那么channel是否也可以通过这种方式实现限流呢？"}]},{"ID":"20230727014435-9d4d6io","Type":"NodeParagraph","Properties":{"id":"20230727014435-9d4d6io","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"当消息队列满时，上游不能塞数据，会直接阻塞住，如果不想阻塞，那么就需要判断队列的长度，如果满员，就直接丢弃请求，那么每次往队列塞数据前，就需要判断队列的长度了，但是channel的长度大小其实是不知道的，所以从这个层面来看，channel应该不能通过改方式实现限流。"}]},{"ID":"20230727014435-1n4hw5n","Type":"NodeParagraph","Properties":{"id":"20230727014435-1n4hw5n","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"8. 总结"}]},{"ID":"20230727014435-4ncb4o7","Type":"NodeParagraph","Properties":{"id":"20230727014435-4ncb4o7","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实现限流的方式，应该还有很多，就不再列举了，上面很多内容都是从网上摘抄的，自己整理一遍，印象也会更深刻一些，下面通过个人的理解，总结一下每种限流的优缺点，也便于以后选型。"}]},{"ID":"20230727014435-3v85tce","Type":"NodeParagraph","Properties":{"id":"20230727014435-3v85tce","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"并发控制限流："}]},{"ID":"20230727014435-6b9zjem","Type":"NodeList","ListData":{},"Properties":{"id":"20230727014435-6b9zjem","updated":"20230727014435"},"Children":[{"ID":"20230727014435-45yl0ox","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-45yl0ox","updated":"20230727014435"},"Children":[{"ID":"20230727014435-td3hjnv","Type":"NodeParagraph","Properties":{"id":"20230727014435-td3hjnv","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"优点：通过控制消费者的线程数，来控制消费者的并发数量；"}]}]},{"ID":"20230727014435-0anut9n","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-0anut9n","updated":"20230727014435"},"Children":[{"ID":"20230727014435-runt827","Type":"NodeParagraph","Properties":{"id":"20230727014435-runt827","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺点：感觉这种限流场景好Low，首先没有见过这么用，然后处理数据的数量，每个线程能执行多少，都没有一个确定的值，不是很好的限流方式。"}]}]}]},{"ID":"20230727014435-y1xpgpe","Type":"NodeParagraph","Properties":{"id":"20230727014435-y1xpgpe","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"计数器："}]},{"ID":"20230727014435-ravzl23","Type":"NodeList","ListData":{},"Properties":{"id":"20230727014435-ravzl23","updated":"20230727014435"},"Children":[{"ID":"20230727014435-1b010ka","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-1b010ka","updated":"20230727014435"},"Children":[{"ID":"20230727014435-ngbwo25","Type":"NodeParagraph","Properties":{"id":"20230727014435-ngbwo25","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"优点：固定时间段计数，实现简单，适用不太精准的场景；"}]}]},{"ID":"20230727014435-l4wueju","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-l4wueju","updated":"20230727014435"},"Children":[{"ID":"20230727014435-x9z58m4","Type":"NodeParagraph","Properties":{"id":"20230727014435-x9z58m4","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺点：对边界没有很好处理，导致限流不能精准控制。"}]}]}]},{"ID":"20230727014435-era45oj","Type":"NodeParagraph","Properties":{"id":"20230727014435-era45oj","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"滑动窗口："}]},{"ID":"20230727014435-q05dlo0","Type":"NodeList","ListData":{},"Properties":{"id":"20230727014435-q05dlo0","updated":"20230727014435"},"Children":[{"ID":"20230727014435-d2335xp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-d2335xp","updated":"20230727014435"},"Children":[{"ID":"20230727014435-kw3wcgg","Type":"NodeParagraph","Properties":{"id":"20230727014435-kw3wcgg","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"优点：将固定时间段分块，时间比“计数器”复杂，适用于稍微精准的场景；"}]}]},{"ID":"20230727014435-c75xaa5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-c75xaa5","updated":"20230727014435"},"Children":[{"ID":"20230727014435-ub21emo","Type":"NodeParagraph","Properties":{"id":"20230727014435-ub21emo","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺点：实现稍微复杂，还是不能彻底解决“计数器”存在的边界问题。"}]}]}]},{"ID":"20230727014435-z74088p","Type":"NodeParagraph","Properties":{"id":"20230727014435-z74088p","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"漏桶："}]},{"ID":"20230727014435-yjq34se","Type":"NodeList","ListData":{},"Properties":{"id":"20230727014435-yjq34se","updated":"20230727014435"},"Children":[{"ID":"20230727014435-1ik6q3g","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-1ik6q3g","updated":"20230727014435"},"Children":[{"ID":"20230727014435-sibg17a","Type":"NodeParagraph","Properties":{"id":"20230727014435-sibg17a","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"优点：可以很好的控制消费频率；"}]}]},{"ID":"20230727014435-okwo4uw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-okwo4uw","updated":"20230727014435"},"Children":[{"ID":"20230727014435-9l8e9tj","Type":"NodeParagraph","Properties":{"id":"20230727014435-9l8e9tj","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺点：实现稍微复杂，单位时间内，不能多消费，感觉不太灵活。"}]}]}]},{"ID":"20230727014435-tm18z11","Type":"NodeParagraph","Properties":{"id":"20230727014435-tm18z11","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"令牌桶："}]},{"ID":"20230727014435-z0qmrlb","Type":"NodeList","ListData":{},"Properties":{"id":"20230727014435-z0qmrlb","updated":"20230727014435"},"Children":[{"ID":"20230727014435-1u7z29k","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-1u7z29k","updated":"20230727014435"},"Children":[{"ID":"20230727014435-mamy3zt","Type":"NodeParagraph","Properties":{"id":"20230727014435-mamy3zt","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"优点：可以解决“漏桶”不能灵活消费的问题，又能避免过渡消费，强烈推荐；"}]}]},{"ID":"20230727014435-y33fhca","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-y33fhca","updated":"20230727014435"},"Children":[{"ID":"20230727014435-wgno8d3","Type":"NodeParagraph","Properties":{"id":"20230727014435-wgno8d3","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺点：实现稍微复杂，其它缺点没有想到。"}]}]}]},{"ID":"20230727014435-wzfsatq","Type":"NodeParagraph","Properties":{"id":"20230727014435-wzfsatq","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"httpserver频率限制："}]},{"ID":"20230727014435-u89ejfn","Type":"NodeList","ListData":{},"Properties":{"id":"20230727014435-u89ejfn","updated":"20230727014435"},"Children":[{"ID":"20230727014435-4jabs9b","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-4jabs9b","updated":"20230727014435"},"Children":[{"ID":"20230727014435-ju4kyxj","Type":"NodeParagraph","Properties":{"id":"20230727014435-ju4kyxj","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"优点：实现简单，直接有第三方库支持，也能很好支持限流；"}]}]},{"ID":"20230727014435-6w9tklg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-6w9tklg","updated":"20230727014435"},"Children":[{"ID":"20230727014435-q64g870","Type":"NodeParagraph","Properties":{"id":"20230727014435-q64g870","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺点：如果需要使用限流，我应该不会使用这种。"}]}]}]},{"ID":"20230727014435-1xa3rqs","Type":"NodeParagraph","Properties":{"id":"20230727014435-1xa3rqs","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Redis消息队列："}]},{"ID":"20230727014435-txq5xg4","Type":"NodeList","ListData":{},"Properties":{"id":"20230727014435-txq5xg4","updated":"20230727014435"},"Children":[{"ID":"20230727014435-yq1on06","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-yq1on06","updated":"20230727014435"},"Children":[{"ID":"20230727014435-wdwwb6h","Type":"NodeParagraph","Properties":{"id":"20230727014435-wdwwb6h","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"优点：适用数据流动的场景，经常和异步和解耦结合使用，支持数据存储；"}]}]},{"ID":"20230727014435-1svwsih","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230727014435-1svwsih","updated":"20230727014435"},"Children":[{"ID":"20230727014435-7pjz0kh","Type":"NodeParagraph","Properties":{"id":"20230727014435-7pjz0kh","updated":"20230727014435"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺点：一般只能结合Redis使用，因为Redis是单进程单线程模型处理数据（现在已经支持多线程，但是命令执行部分其实还是单线程），如果用其它消息队列，就需要加锁来处理并发控制，就得不偿失了。"}]}]}]}]}