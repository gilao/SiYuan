{"ID":"20231117222034-1fbuwl6","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f9e1","id":"20231117222034-1fbuwl6","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20231117222034-1fbuwl6\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231117222034-ik9da67\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231117222606-nbryloc\u0026quot;,\u0026quot;scrollTop\u0026quot;:20232,\u0026quot;focusId\u0026quot;:\u0026quot;20231117222606-2bknz4j\u0026quot;,\u0026quot;focusStart\u0026quot;:13,\u0026quot;focusEnd\u0026quot;:13\u0026#125;","tags":"公众号-小徐先生的编程世界","title":"Golang 设计模式之工厂模式","updated":"20231120093716"},"Children":[{"ID":"20231120092037-knyud81","Type":"NodeParagraph","Properties":{"id":"20231120092037-knyud81","updated":"20231120092037"},"Children":[{"Type":"NodeText","Data":"本期会基于 Go 语言，和大家一起聊聊设计模式中的工厂模式. 本期分享内容包含如下几个部分："}]},{"ID":"20231120092037-1uv71cc","Type":"NodeList","ListData":{},"Properties":{"id":"20231120092037-1uv71cc","updated":"20231120092109"},"Children":[{"ID":"20231120092109-gpg4zds","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092109-gpg4zds","updated":"20231120092109"},"Children":[{"ID":"20231120092109-uwta6rb","Type":"NodeParagraph","Properties":{"id":"20231120092109-uwta6rb","updated":"20231120092109"},"Children":[{"Type":"NodeText","Data":"工厂模式的使用背景"}]}]}]},{"ID":"20231120092037-hmntapa","Type":"NodeList","ListData":{},"Properties":{"id":"20231120092037-hmntapa","updated":"20231120092103"},"Children":[{"ID":"20231120092055-zcuq9fd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092055-zcuq9fd","updated":"20231120092103"},"Children":[{"ID":"20231120092055-lsu1849","Type":"NodeParagraph","Properties":{"id":"20231120092055-lsu1849","updated":"20231120092103"},"Children":[{"Type":"NodeText","Data":"简单工厂模式"}]}]}]},{"ID":"20231120092037-wrvdl4x","Type":"NodeList","ListData":{},"Properties":{"id":"20231120092037-wrvdl4x","updated":"20231120092037"},"Children":[{"ID":"20231120092037-6n8x3uj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092037-6n8x3uj","updated":"20231120092037"},"Children":[{"ID":"20231120092037-octiwt2","Type":"NodeParagraph","Properties":{"id":"20231120092037-octiwt2","updated":"20231120092113"},"Children":[{"Type":"NodeText","Data":"工厂方法模式"}]}]},{"ID":"20231120092037-n8r496q","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092037-n8r496q","updated":"20231120092037"},"Children":[{"ID":"20231120092037-qof4hpa","Type":"NodeParagraph","Properties":{"id":"20231120092037-qof4hpa","updated":"20231120092114"},"Children":[{"Type":"NodeText","Data":"抽象工厂模式"}]}]},{"ID":"20231120092037-vwqdo0p","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092037-vwqdo0p","updated":"20231120092037"},"Children":[{"ID":"20231120092037-u0pv57t","Type":"NodeParagraph","Properties":{"id":"20231120092037-u0pv57t","updated":"20231120092116"},"Children":[{"Type":"NodeText","Data":"容器工厂模式"}]}]}]},{"ID":"20231120092120-fpl2nbm","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231120092120-fpl2nbm","updated":"20231120092130"},"Children":[{"Type":"NodeText","Data":"使用背景"}]},{"ID":"20231120092140-tossif1","Type":"NodeParagraph","Properties":{"id":"20231120092140-tossif1","updated":"20231120092140"},"Children":[{"Type":"NodeText","Data":"Go 语言中没有针对类的构造器方法定义统一的规范，倘若每次需要创建类的实例时，都需要在业务方法中事无俱细地执行实例初始化的细节，那么会存在缺陷的包括："}]},{"ID":"20231120092155-48o1cvn","Type":"NodeList","ListData":{},"Properties":{"id":"20231120092155-48o1cvn","updated":"20231120092249"},"Children":[{"ID":"20231120092155-g1fo210","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092155-g1fo210","updated":"20231120092249"},"Children":[{"ID":"20231120092140-q114q08","Type":"NodeParagraph","Properties":{"id":"20231120092140-q114q08","updated":"20231120092249"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"业务方法和组件类之间产生过高的耦合度，需要了解到组件类的过多细节"}]}]},{"ID":"20231120092155-jdey396","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092155-jdey396","updated":"20231120092244"},"Children":[{"ID":"20231120092140-mena9f5","Type":"NodeParagraph","Properties":{"id":"20231120092140-mena9f5","updated":"20231120092244"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"倘若组件类的定义发生变更，那么散落在各处业务方法中对类的构造流程都需要配合改动"}]}]}]},{"ID":"20231120092140-1zf144s","Type":"NodeParagraph","Properties":{"id":"20231120092140-1zf144s","updated":"20231120092140"},"Children":[{"Type":"NodeText","Data":"那么如何解决上述问题呢？在编程世界中，相当的一部分问题都可以通过增加一个中间层加以解决. 我们在此处遵循工厂模式的设计思路，在业务方法和类之间添加一个防腐中间层——工厂类，这样做能够带来的好处是："}]},{"ID":"20231120092140-kyeam62","Type":"NodeList","ListData":{},"Properties":{"id":"20231120092140-kyeam62","updated":"20231120092303"},"Children":[{"ID":"20231120092140-ig6u65u","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092140-ig6u65u","updated":"20231120092300"},"Children":[{"ID":"20231120092140-0zl6gsm","Type":"NodeParagraph","Properties":{"id":"20231120092140-0zl6gsm","updated":"20231120092300"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实现类和业务方法之间的解耦，如果类的构造过程发生变更，可以统一收口在工厂类中进行处理，从而对业务方法屏蔽相关细节"}]}]},{"ID":"20231120092140-mkiytbd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092140-mkiytbd","updated":"20231120092303"},"Children":[{"ID":"20231120092140-ajl2xq0","Type":"NodeParagraph","Properties":{"id":"20231120092140-ajl2xq0","updated":"20231120092303"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"倘若有多个类都聚拢在工厂类中进行构造，这样各个类的构造流程中就天然形成了一个公共的切面，可以进行一些公共逻辑的执行"}]}]}]},{"ID":"20231120092559-xdrlx6i","Type":"NodeParagraph","Properties":{"id":"20231120092559-xdrlx6i","updated":"20231120092559"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120092559-ntg9k9e.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120092602-s48kytr","Type":"NodeParagraph","Properties":{"id":"20231120092602-s48kytr","updated":"20231120092614"},"Children":[{"Type":"NodeText","Data":"工厂模式属于设计模式中的一种，在实现上，又可以进一步细分为：简单工厂模式、工厂方法模式和抽象工厂模式三种类型，这三种类型我们会在本文的2-4章中进行逐一介绍. 除开上面提到的三种经典类型外，本文还会在第5章中额外和大家介绍一种比较另类的容器工厂模式."}]},{"ID":"20231120092620-4cm2ptq","Type":"NodeParagraph","Properties":{"id":"20231120092620-4cm2ptq","updated":"20231120092633"},"Children":[{"Type":"NodeText","Data":"​​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120092633-fw51axp.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120092654-1a7yzp1","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231120092654-1a7yzp1","updated":"20231120092700"},"Children":[{"Type":"NodeText","Data":"简单工厂模式"}]},{"ID":"20231120092710-3imdtjf","Type":"NodeParagraph","Properties":{"id":"20231120092710-3imdtjf","updated":"20231120092710"},"Children":[{"Type":"NodeText","Data":"首先和大家聊聊简单工厂模式. 设计模式中的内容都相对抽象，我这里先不作具体的概念定义，而是通过具体的实例和大家一起进行设计过程的推演，最后再对简单工厂模式的内容进行小结."}]},{"ID":"20231120092710-x97zsr3","Type":"NodeParagraph","Properties":{"id":"20231120092710-x97zsr3","updated":"20231120092710"},"Children":[{"Type":"NodeText","Data":"假设现在有这样一个编程场景："}]},{"ID":"20231120092710-c33272u","Type":"NodeList","ListData":{},"Properties":{"id":"20231120092710-c33272u","updated":"20231120092721"},"Children":[{"ID":"20231120092710-xewbha3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092710-xewbha3","updated":"20231120092715"},"Children":[{"ID":"20231120092710-5kb6uix","Type":"NodeParagraph","Properties":{"id":"20231120092710-5kb6uix","updated":"20231120092715"},"Children":[{"Type":"NodeText","Data":"水果 Fruit 是一个抽象的 interface，水果的共性是都可以食用水果，这里我们不纠结主被动的语义，赋以 Fruit 一个 Eat 方法"}]}]},{"ID":"20231120092710-3nb66cq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092710-3nb66cq","updated":"20231120092717"},"Children":[{"ID":"20231120092710-3p7h9d3","Type":"NodeParagraph","Properties":{"id":"20231120092710-3p7h9d3","updated":"20231120092717"},"Children":[{"Type":"NodeText","Data":"有三个具体的水果实现类，橘子 Orange、草莓 Strawberry、樱桃 cherry，分别实现了 Fruit 对应的 Eat 方法"}]}]},{"ID":"20231120092710-osutgnl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120092710-osutgnl","updated":"20231120092721"},"Children":[{"ID":"20231120092710-g9i0q5e","Type":"NodeParagraph","Properties":{"id":"20231120092710-g9i0q5e","updated":"20231120092721"},"Children":[{"Type":"NodeText","Data":"有一个具体的水果工厂类 FruitFactory，专门用于水果的生产工作，对应的生产方法为 CreateFruit 方法，可以按照用户指定的水果类型，生产出对应的水果"}]}]}]},{"ID":"20231120092710-fdj11ia","Type":"NodeParagraph","Properties":{"id":"20231120092710-fdj11ia","updated":"20231120092710"},"Children":[{"Type":"NodeText","Data":"上面聊到的几个类之间形成的 UML 类图如下所示："}]},{"ID":"20231120092746-86nj0fg","Type":"NodeParagraph","Properties":{"id":"20231120092746-86nj0fg","updated":"20231120092746"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120092746-3gn0m9m.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120092748-8eg783b","Type":"NodeParagraph","Properties":{"id":"20231120092748-8eg783b","updated":"20231120092815"},"Children":[{"Type":"NodeText","Data":"下面进行代码展示. 水果 Fruit interface 实现如下："}]},{"ID":"20231120092815-8ve9awh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120092815-8ve9awh","updated":"20231120092846"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Fruit interface {\n\tEat()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120092846-njy6u0p","Type":"NodeParagraph","Properties":{"id":"20231120092846-njy6u0p","updated":"20231120092857"},"Children":[{"Type":"NodeText","Data":"橘子 Orange、草莓 Strawberry、樱桃 Cherry 三种水果的具体实现类如下："}]},{"ID":"20231120092858-fqwol8l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120092858-fqwol8l","updated":"20231120093612"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Orange struct {\n\tname string\n}\n\nfunc NewOrange(name string) Fruit {\n\treturn \u0026Orange{\n\t\tname: name,\n\t}\n}\n\nfunc (o *Orange) Eat() {\n\tfmt.Println(\"I am orange: %s, i am about to bi eaten...\", o.name)\n}\n\ntype Strawberry struct {\n\tname string\n}\n\nfunc NewStrawberry(name string) Fruit {\n\treturn \u0026Strawberry{\n\t\tname: name,\n\t}\n}\n\nfunc (s *Strawberry) Eat() {\n\tfmt.Printf(\"i am strawberry: %s, i am about to be eaten...\", s.name)\n}\n\ntype Cherry struct {\n\tname string\n}\n\n\nfunc NewCherry(name string) Fruit {\n\treturn \u0026Cherry{\n\t\tname: name,\n\t}\n}\n\n\nfunc (c *Cherry) Eat() {\n\tfmt.Printf(\"i am cherry: %s, i am about to be eaten...\", c.name)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120093614-ffvk2si","Type":"NodeParagraph","Properties":{"id":"20231120093614-ffvk2si","updated":"20231120093621"},"Children":[{"Type":"NodeText","Data":"下面是关于生产水果的工厂类 FruitFactory 的定义，其中 CreateFruit 方法是用于生产水果的核心方法："}]},{"ID":"20231120093646-3sn2izs","Type":"NodeList","ListData":{},"Properties":{"id":"20231120093646-3sn2izs","updated":"20231120093646"},"Children":[{"ID":"20231120093646-ja3c0pf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120093646-ja3c0pf","updated":"20231120093646"},"Children":[{"ID":"20231120093646-a3vj6lm","Type":"NodeParagraph","Properties":{"id":"20231120093646-a3vj6lm","updated":"20231120093646"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"利用工厂生产三类时存在的公共切面，进行随机数的取值，用来给生产出来的水果命名"}]}]},{"ID":"20231120093646-aq3ro0w","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120093646-aq3ro0w","updated":"20231120093646"},"Children":[{"ID":"20231120093646-1aoxw9j","Type":"NodeParagraph","Properties":{"id":"20231120093646-1aoxw9j","updated":"20231120093646"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"根据使用方传入的水果类型 typ，调用对应水果类型的构造器方法，并将生产出来的水果进行返回"}]}]},{"ID":"20231120093646-x7n0pph","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231120093646-x7n0pph","updated":"20231120093646"},"Children":[{"ID":"20231120093646-4bmgs1w","Type":"NodeParagraph","Properties":{"id":"20231120093646-4bmgs1w","updated":"20231120093646"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果使用方法传入的水果类型 typ 非法，则对外抛出错误"}]}]}]},{"ID":"20231120093715-gs3a8kw","Type":"NodeParagraph","Properties":{"id":"20231120093715-gs3a8kw"}},{"ID":"20231120093716-x940zk0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120093716-x940zk0","updated":"20231120093716"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}