{"ID":"20230724231512-69dhak1","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f9c7","id":"20230724231512-69dhak1","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230724231512-69dhak1\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230724231513-zhegkes\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231120155610-pnav15u\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230724231513-zhegkes\u0026quot;,\u0026quot;focusStart\u0026quot;:1,\u0026quot;focusEnd\u0026quot;:1\u0026#125;","tags":"公众号-小徐先生的编程世界,设计模式-观察者模式","title":"2-Go 观察者模式","updated":"20231121003232"},"Children":[{"ID":"20230724231513-zhegkes","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230724231513-zhegkes","updated":"20231120155340"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/QOXh86eX8z5Ts4O1pky44g","TextMarkTextContent":"Go 观察者模式"},{"Type":"NodeText","Data":"原理介绍"}]},{"ID":"20231120155358-pbzz5ab","Type":"NodeParagraph","Properties":{"id":"20231120155358-pbzz5ab","updated":"20231120155608"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120155358-116vk3c.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120155553-wc4q0kl","Type":"NodeParagraph","Properties":{"id":"20231120155553-wc4q0kl","updated":"20231120155601"},"Children":[{"Type":"NodeText","Data":"本期基于 go 语言和大家探讨设计模式中的观察者模式. 观察者模式适用于多对一的订阅/发布场景.\n• ”多“：指的是有多名观察者\n• ”一“：指的是有一个被观察事物\n• ”订阅“：指的是观察者时刻关注着事物的动态\n• ”发布“：指的是事物状态发生变化时是透明公开的，能够正常进入到观察者的视线"}]},{"ID":"20231120155610-pnav15u","Type":"NodeParagraph","Properties":{"id":"20231120155610-pnav15u","updated":"20231120155622"},"Children":[{"Type":"NodeText","Data":"在上述场景中，我们了解到核心对象有两类，一类是“观察者”，一类是“被观察的事物”，且两者间在数量上存在多对一的映射关系."}]},{"ID":"20231120160813-lvav3n8","Type":"NodeParagraph","Properties":{"id":"20231120160813-lvav3n8","updated":"20231120160813"},"Children":[{"Type":"NodeText","Data":"在具体作编程实现时，上述场景的实现思路可以是百花齐放的，而观察者模式只是为我们提供了一种相对规范的设计实现思路，其遵循的核心宗旨是实现“观察者”与“被观察对象”之间的解耦，并将其设计为通用的模块，便于后续的扩展和复用."}]},{"ID":"20231120160813-0f7ofpg","Type":"NodeParagraph","Properties":{"id":"20231120160813-0f7ofpg","updated":"20231120160813"},"Children":[{"Type":"NodeText","Data":"学习设计模式时，我们脑海中需要中需要明白，教条是相对刻板的，而场景和问题则是灵活多变的，在工程实践中，我们避免生搬硬套，要做到因地制宜，随机应变."}]},{"ID":"20231120161646-d3ale6e","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231120161646-d3ale6e","updated":"20231120161653"},"Children":[{"Type":"NodeText","Data":"代码实践"}]},{"ID":"20231120161953-a5tre11","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120161953-a5tre11","updated":"20231120161958"},"Children":[{"Type":"NodeText","Data":"核心角色"}]},{"ID":"20231120162029-fn5890l","Type":"NodeParagraph","Properties":{"id":"20231120162029-fn5890l","updated":"20231120210758"},"Children":[{"Type":"NodeText","Data":"在观察者模式中，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"核心的角色包含三类：\n• Observer：观察者. 指的是关注事物动态的角色\n• Event：事物的变更事件. 其中 Topic 标识了事物的身份以及变更的类型，Val 是变更详情\n• EventBus：事件总线. 位于观察者与事物之间承上启下的代理层. 负责维护管理观察者，并且在事物发生变更时，将情况同步给每个观察者."}]},{"ID":"20231120162054-ru11prc","Type":"NodeParagraph","Properties":{"id":"20231120162054-ru11prc","updated":"20231120162054"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120162054-7m21yl5.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120164103-83ayjrl","Type":"NodeParagraph","Properties":{"id":"20231120164103-83ayjrl","updated":"20231120210805"},"Children":[{"Type":"NodeText","Data":"观察者模式的核心就在于建立了 EventBus 的角色. 由于 EventBus 模块的诞生，实现了观察者与具体被观察事物之间的解耦：\n• "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"针对于观察者而言，需要向 EventBus 完成注册操作，注册时需要声明自己关心的变更事件类型（调用 EventBus 的 Subscribe 方法），不再需要直接和事物打交道\n• 针对于事物而言，在其发生变更时，只需要将变更情况向 EventBus 统一汇报即可（调用 EventBus 的 Publish 方法），不再需要和每个观察者直接交互\n• 对于 EventBus，需要提前维护好每个观察者和被关注事物之间的映射关系，保证在变更事件到达时，能找到所有的观察者逐一进行通知（调用 Observer 的 OnChange 方法）"}]},{"ID":"20231120164214-ozyrdd7","Type":"NodeParagraph","Properties":{"id":"20231120164214-ozyrdd7","updated":"20231120210745"},"Children":[{"Type":"NodeText","Data":"三类角色组织生成的UML 类图如下所示："}]},{"ID":"20231120210745-88few5z","Type":"NodeParagraph","Properties":{"id":"20231120210745-88few5z"}},{"ID":"20231120211542-ea9l4lz","Type":"NodeParagraph","Properties":{"id":"20231120211542-ea9l4lz","updated":"20231120211542"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120211542-kz8cw67.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120211554-yxrhhwy","Type":"NodeParagraph","Properties":{"id":"20231120211554-yxrhhwy","updated":"20231120211603"},"Children":[{"Type":"NodeText","Data":"对应的代码实现示例展示如下："}]},{"ID":"20231120211603-ow5nrdx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120211603-ow5nrdx","updated":"20231120211833"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Event struct {\n  Topic string \n  Val interface{} \n}\n\ntype Observer interface {\n  OnChange(ctx context.Context, e *Event) error\n}\n\ntype EventBus interface {\n  Subscribe(topic string, o Observer)\n  Unsubscibe(topic string, o Observer)\n  Publish(ctx context.Context, e *Event)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120211841-9db6zen","Type":"NodeParagraph","Properties":{"id":"20231120211841-9db6zen","updated":"20231120211841"},"Children":[{"Type":"NodeText","Data":"观察者 Observer 需要实现 OnChange 方法，用于向 EventBus 暴露出通知自己的“联系方式”，并且在方法内部实现好当关注对象发生变更时，自己需要采取的处理逻辑."}]},{"ID":"20231120211841-yh3lj22","Type":"NodeParagraph","Properties":{"id":"20231120211841-yh3lj22","updated":"20231120211841"},"Children":[{"Type":"NodeText","Data":"下面给出一个简单的观察者实现示例 BaseObserver："}]},{"ID":"20231120211842-mze8126","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120211842-mze8126","updated":"20231120214436"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type BaseObserver struct {\n  name string\n}\n\nfunc NewBaseObserver(name string)  *BaseObserver {\n  return \u0026BaseObserver{\n      name: name,\n    }\n}\n\nfunc (b *BaseObserver) OnChange(ctx context.Context, e *Event) error {\n    fmt.Printf(\"observer: %s, event key: %s, event val: %v\", b.name,e.Topic, e.Val)\n    // ...\n    return nil\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120212018-i7kuzep","Type":"NodeParagraph","Properties":{"id":"20231120212018-i7kuzep","updated":"20231120214452"},"Children":[{"Type":"NodeText","Data":"事件总线 EventBus 需要实现 Subscribe 和 Unsubscribe 方法暴露给观察者，用于新增或删除订阅关系，其实现示例如下："}]},{"ID":"20231120214454-vgmadie","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120214454-vgmadie","updated":"20231120215250"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type BaseEventBus struct {\n\tmux       sync.RWMutex\n\tobservers map[string]map[Observer]struct{}\n}\n\n\nfunc NewBaseEventBus() BaseEventBus {\n\treturn BaseEventBus{\n\t\tobservers: make(map[string]map[Observer]struct{}),\n\t}\n}\n\n\nfunc (b *BaseEventBus) Subscribe(topic string, o Observer) {\n\tb.mux.Lock()\n\tdefer b.mux.Unlock()\n\t_, ok := b.observers[topic]\n\tif !ok {\n\t\tb.observers[topic] = make(map[Observer]struct{})\n\t}\n\tb.observers[topic][o] = struct{}{}\n}\n\n\nfunc (b *BaseEventBus) Unsubscribe(topic string, o Observer) {\n\tb.mux.Lock()\n\tdefer b.mux.Unlock()\n\tdelete(b.observers[topic], o)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120215324-sps4ay6","Type":"NodeParagraph","Properties":{"id":"20231120215324-sps4ay6","updated":"20231120215324"},"Children":[{"Type":"NodeText","Data":"针对 EventBus 将事物变更事件同步给每个观察者的 Publish 流程，可以分为同步模式和异步模式，分别在 2.2 小节和 2.3 小节中展开介绍."}]},{"ID":"20231120215733-qmde4n0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120215733-qmde4n0","updated":"20231120215747"},"Children":[{"Type":"NodeText","Data":"同步模式"}]},{"ID":"20231120215748-k0f16em","Type":"NodeParagraph","Properties":{"id":"20231120215748-k0f16em","updated":"20231120215759"},"Children":[{"Type":"NodeText","Data":"在同步模式的实现中，通过 SyncEventBus 实现了 EventBus 的同步通知版本，对应类图如下："}]},{"ID":"20231120220857-6avf3y3","Type":"NodeParagraph","Properties":{"id":"20231120220857-6avf3y3","updated":"20231120220857"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120220857-3l61bzc.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120220902-z16sbtp","Type":"NodeParagraph","Properties":{"id":"20231120220902-z16sbtp"}},{"ID":"20231120220912-2qfr0jj","Type":"NodeParagraph","Properties":{"id":"20231120220912-2qfr0jj","updated":"20231120220912"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120220912-5m01l9s.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120220914-ghv0oqz","Type":"NodeParagraph","Properties":{"id":"20231120220914-ghv0oqz","updated":"20231120220920"},"Children":[{"Type":"NodeText","Data":"在同步模式下，EventBus 在接受到变更事件 Event 时，会根据事件类型 Topic 匹配到对应的观察者列表 observers，然后采用串行遍历的方式分别调用 Observer.OnChange 方法对每个观察者进行通知，并对处理流程中遇到的错误进行聚合，放到 handleErr 方法中进行统一的后处理."}]},{"ID":"20231120222115-yx1s13g","Type":"NodeParagraph","Properties":{"id":"20231120222115-yx1s13g"}},{"ID":"20231120222115-5w140dg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120222115-5w140dg","updated":"20231120223853"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type SyncEventBus struct {\n\tBaseEventBus\n}\n\nfunc NewSyncEventBus() *SyncEventBus {\n\treturn \u0026SyncEventBus{\n\t\tBaseEventBus: NewBaseEventBus(),\n\t}\n}\n\nfunc (s *SyncEventBus) Publish(ctx context.Context, e *Event) {\n\ts.mux.RLock()\n\tsubscribers := s.observers[e.Topic]\n\ts.mux.RUnlock()\n\n\terrs := make(map[Observer]error)\n\tfor subscriber := range subscribers {\n\t\tif err := subscriber.OnChange(ctx, e); err != nil {\n\t\t\terrs[subscriber] = err\n\t\t}\n\t}\n\n\ts.handleErr(ctx, errs)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120223854-8b6qs43","Type":"NodeParagraph","Properties":{"id":"20231120223854-8b6qs43","updated":"20231120223901"},"Children":[{"Type":"NodeText","Data":"此处对 handleErr 方法的实现逻辑进行建立了简化，在真实的实践场景中，可以针对遇到的错误建立更完善的后处理流程，如采取重试或告知之类的操作."}]},{"ID":"20231120223902-5ururle","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120223902-5ururle","updated":"20231120223947"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (s *SyncEventBus) handleErr(ctx context.Context, errs map[Observer]error) {\n\tfor o, err := range errs {\n\t\t// 处理 publish 失败的 observer\n\t\tfmt.Printf(\"observer: %v, err: %v\", o, err)\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120224110-j7r4xjx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120224110-j7r4xjx","updated":"20231120224115"},"Children":[{"Type":"NodeText","Data":"异步模式"}]},{"ID":"20231120224116-3kolgqu","Type":"NodeParagraph","Properties":{"id":"20231120224116-3kolgqu","updated":"20231120224318"},"Children":[{"Type":"NodeText","Data":"在异步模式的实现中，通过 AsyncEventBus 实现了 EventBus 的异步通知版本，对应类图如下："}]},{"ID":"20231121002533-49xlqsp","Type":"NodeParagraph","Properties":{"id":"20231121002533-49xlqsp","updated":"20231121002533"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231121002533-92u3uzq.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231121002533-lyklnkf","Type":"NodeParagraph","Properties":{"id":"20231121002533-lyklnkf"}},{"ID":"20231121002548-m2xb9bb","Type":"NodeParagraph","Properties":{"id":"20231121002548-m2xb9bb","updated":"20231121002548"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231121002548-lw0po21.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231121002619-scgfnrw","Type":"NodeParagraph","Properties":{"id":"20231121002619-scgfnrw","updated":"20231121002619"},"Children":[{"Type":"NodeText","Data":"在异步模式下，会在 EventBus 启动之初，异步启动一个守护协程，负责对接收到的错误进行后处理."}]},{"ID":"20231121002619-wkvaemj","Type":"NodeParagraph","Properties":{"id":"20231121002619-wkvaemj","updated":"20231121002619"},"Children":[{"Type":"NodeText","Data":"在事物发生变更时，EventBus 的 Publish 方法会被调用，此时 EventBus 会并发调用 Observer.OnChange 方法对每个观察者进行通知，在这个过程中遇到的错误会通过 channel 统一汇总到 handleErr 的守护协程中进行处理."}]},{"ID":"20231121002621-srpqzfn","Type":"NodeParagraph","Properties":{"id":"20231121002621-srpqzfn"}},{"ID":"20231121002630-7omhfdg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231121002630-7omhfdg","updated":"20231121002719"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type observerWithErr struct {\n\to   Observer\n\terr error\n}\n\n\n\n\ntype AsyncEventBus struct {\n\tBaseEventBus\n\terrC chan *observerWithErr\n\tctx  context.Context\n\tstop context.CancelFunc\n}\n\n\n\n\nfunc NewAsyncEventBus() *AsyncEventBus {\n\taBus := AsyncEventBus{\n\t\tBaseEventBus: NewBaseEventBus(),\n\t}\n\taBus.ctx, aBus.stop = context.WithCancel(context.Background())\n\t// 处理处理错误的异步守护协程\n\tgo aBus.handleErr()\n\treturn \u0026aBus\n}\n\n\nfunc (a *AsyncEventBus) Stop() {\n\ta.stop()\n}\n\n\nfunc (a *AsyncEventBus) Publish(ctx context.Context, e *Event) {\n\ta.mux.RLock()\n\tsubscribers := a.observers[e.Topic]\n\tdefer a.mux.RUnlock()\n\tfor subscriber := range subscribers {\n\t\t// shadow\n\t\tsubscriber := subscriber\n\t\tgo func() {\n\t\t\tif err := subscriber.OnChange(ctx, e); err != nil {\n\t\t\t\tselect {\n\t\t\t\tcase \u003c-a.ctx.Done():\n\t\t\t\tcase a.errC \u003c- \u0026observerWithErr{\n\t\t\t\t\to:   subscriber,\n\t\t\t\t\terr: err,\n\t\t\t\t}:\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n}\n\n\nfunc (a *AsyncEventBus) handleErr() {\n\tfor {\n\t\tselect {\n\t\tcase \u003c-a.ctx.Done():\n\t\t\treturn\n\t\tcase resp := \u003c-a.errC:\n\t\t\t// 处理 publish 失败的 observer\n\t\t\tfmt.Printf(\"observer: %v, err: %v\", resp.o, resp.err)\n\t\t}\n\t}\n} \n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231121002723-ue54gnh","Type":"NodeParagraph","Properties":{"id":"20231121002723-ue54gnh"}},{"ID":"20231121002729-uglgc5a","Type":"NodeParagraph","Properties":{"id":"20231121002729-uglgc5a","updated":"20231121002937"},"Children":[{"Type":"NodeText","Data":"下面分别给出同步和异步模式下观察者模式的使用示例："}]},{"ID":"20231121002938-032re6d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231121002938-032re6d","updated":"20231121002944"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func Test_syncEventBus(t *testing.T) {\n    observerA := NewBaseObserver(\"a\")\n    observerB := NewBaseObserver(\"b\")\n    observerC := NewBaseObserver(\"c\")\n    observerD := NewBaseObserver(\"d\")\n\n\n    sbus := NewSyncEventBus()\n    topic := \"order_finish\"\n    sbus.Subscribe(topic, observerA)\n    sbus.Subscribe(topic, observerB)\n    sbus.Subscribe(topic, observerC)\n    sbus.Subscribe(topic, observerD)\n\n\n    sbus.Publish(context.Background(), \u0026Event{\n        Topic: topic,\n        Val:   \"order_id: xxx\",\n    })\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231121002945-0jgpg2s","Type":"NodeParagraph","Properties":{"id":"20231121002945-0jgpg2s","updated":"20231121002948"}},{"ID":"20231121002948-s631x8b","Type":"NodeParagraph","Properties":{"id":"20231121002948-s631x8b","updated":"20231121002952"},"Children":[{"Type":"NodeText","Data":"异步测试代码："}]},{"ID":"20231121002953-hz884vu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231121002953-hz884vu","updated":"20231121003000"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func Test_asyncEventBus(t *testing.T) {\n    observerA := NewBaseObserver(\"a\")\n    observerB := NewBaseObserver(\"b\")\n    observerC := NewBaseObserver(\"c\")\n    observerD := NewBaseObserver(\"d\")\n\n\n    abus := NewAsyncEventBus()\n    defer abus.Stop()\n\n\n    topic := \"order_finish\"\n    abus.Subscribe(topic, observerA)\n    abus.Subscribe(topic, observerB)\n    abus.Subscribe(topic, observerC)\n    abus.Subscribe(topic, observerD)\n\n\n    abus.Publish(context.Background(), \u0026Event{\n        Topic: topic,\n        Val:   \"order_id: xxx\",\n    })\n\n\n    \u003c-time.After(time.Second)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231121003008-v3buksp","Type":"NodeParagraph","Properties":{"id":"20231121003008-v3buksp"}},{"ID":"20231121003009-9g6e1l2","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231121003009-9g6e1l2","updated":"20231121003016"},"Children":[{"Type":"NodeText","Data":"工程案例"}]},{"ID":"20231121003017-bciznns","Type":"NodeParagraph","Properties":{"id":"20231121003017-bciznns","updated":"20231121003022"},"Children":[{"Type":"NodeText","Data":"本章和大家一起梳理一下在工程实践中对观察者模式的使用场景."}]},{"ID":"20231121003022-us83lz3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231121003022-us83lz3","updated":"20231121003032"},"Children":[{"Type":"NodeText","Data":"MQ 发布/订阅"}]},{"ID":"20231121003042-gzr5dv1","Type":"NodeParagraph","Properties":{"id":"20231121003042-gzr5dv1","updated":"20231121003042"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231121003042-w389g9f.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231121003049-ytog0tb","Type":"NodeParagraph","Properties":{"id":"20231121003049-ytog0tb","updated":"20231121003049"},"Children":[{"Type":"NodeText","Data":"大家耳熟能详的消息队列就是对观察者模式的一种实践，大家可以采用类比的方式在 MQ （Message Queue）架构中代入观察者模式中的每一类角色："}]},{"ID":"20231121003049-7fmullj","Type":"NodeList","ListData":{},"Properties":{"id":"20231121003049-7fmullj","updated":"20231121003049"},"Children":[{"ID":"20231121003049-iidws5f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231121003049-iidws5f","updated":"20231121003049"},"Children":[{"ID":"20231121003049-tbcz4p7","Type":"NodeParagraph","Properties":{"id":"20231121003049-tbcz4p7","updated":"20231121003049"},"Children":[{"Type":"NodeText","Data":"• EventBus：对应的是消息队列组件，为整个通信架构提供了分布式解耦、流量削峰等能力"}]}]},{"ID":"20231121003049-9ovoql9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231121003049-9ovoql9","updated":"20231121003049"},"Children":[{"ID":"20231121003049-e70iqay","Type":"NodeParagraph","Properties":{"id":"20231121003049-e70iqay","updated":"20231121003049"},"Children":[{"Type":"NodeText","Data":"• Event：对应的是消息队列中的一条消息，有明确的主题 topic，由生产者 producer 提供"}]}]},{"ID":"20231121003049-f7mwfag","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231121003049-f7mwfag","updated":"20231121003049"},"Children":[{"ID":"20231121003049-j32fv4a","Type":"NodeParagraph","Properties":{"id":"20231121003049-j32fv4a","updated":"20231121003049"},"Children":[{"Type":"NodeText","Data":"• Observer：对应的是消费者 consumer，对指定事物的动态（topic）进行订阅，并在消费到对应的变更事件后执行对应的处理逻辑"}]}]}]},{"ID":"20231121003050-o82lir7","Type":"NodeParagraph","Properties":{"id":"20231121003050-o82lir7"}},{"ID":"20231121003052-gh0wbu0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231121003052-gh0wbu0","updated":"20231121003102"},"Children":[{"Type":"NodeText","Data":"ETCD监听回调"}]},{"ID":"20231121003111-f2q7of9","Type":"NodeParagraph","Properties":{"id":"20231121003111-f2q7of9","updated":"20231121003111"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231121003111-zmjt64z.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231121003153-0dk3y5c","Type":"NodeParagraph","Properties":{"id":"20231121003153-0dk3y5c","updated":"20231121003153"},"Children":[{"Type":"NodeText","Data":"另一个践行了观察者模式的工程案例是基于 golang 编写的分布式 kv 存储组件 etcd."}]},{"ID":"20231121003153-jvf2eab","Type":"NodeParagraph","Properties":{"id":"20231121003153-jvf2eab","updated":"20231121003153"},"Children":[{"Type":"NodeText","Data":"etcd 提供了作用于指定数据范围的监听回调功能，能在对应数据状态发生变更时，将变更通知传达到每个订阅者的手中，在这个过程中："}]},{"ID":"20231121003153-wvrkytq","Type":"NodeList","ListData":{},"Properties":{"id":"20231121003153-wvrkytq","updated":"20231121003153"},"Children":[{"ID":"20231121003153-nzcpqyw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231121003153-nzcpqyw","updated":"20231121003153"},"Children":[{"ID":"20231121003153-vwoazsa","Type":"NodeParagraph","Properties":{"id":"20231121003153-vwoazsa","updated":"20231121003153"},"Children":[{"Type":"NodeText","Data":"• EventBus：对应的是 etcd 服务端的 watchableStore 监听器存储模块，该模块会负责存储用户创建的一系列监听器 watcher，并建立由监听数据 key 到监听器集合 watcherGroup 之间的映射关系. 当任意存储数据发生变化时，etcd 的数据存储模块会在一个统一的切面中调用通知方法，将这一信息传达到 watchableStore 模块，watchableStore 则会将变更数据与监听数据 key 之间进行 join，最终得到一个需要执行回调操作的 watchers 组合，顺沿 watcher 中的路径，向订阅者发送通知消息"}]}]},{"ID":"20231121003153-uzmt7ya","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231121003153-uzmt7ya","updated":"20231121003153"},"Children":[{"ID":"20231121003153-dvbkvuy","Type":"NodeParagraph","Properties":{"id":"20231121003153-dvbkvuy","updated":"20231121003153"},"Children":[{"Type":"NodeText","Data":"• Event：对应的是一条 etcd 状态机的数据变更事件，由 etcd 使用方在执行一条写数据操作时触发，在写操作真正生效后，变更事件会被传送到 watchableStore 模块执行回调处理"}]}]},{"ID":"20231121003153-aaxfyvh","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231121003153-aaxfyvh","updated":"20231121003153"},"Children":[{"ID":"20231121003153-2mi9nu7","Type":"NodeParagraph","Properties":{"id":"20231121003153-2mi9nu7","updated":"20231121003153"},"Children":[{"Type":"NodeText","Data":"• Observer：使用 etcd watch 功能对指定范围数据建立监听回调机制的使用方，在 etcd 服务端 watchableStore 模块会建立监听器实体 watcher 作为自身的代理，当变更事件真的发生后，watchableStore 会以 watcher 作为起点，沿着返回路径一路将变更事件发送到使用方手中."}]}]}]},{"ID":"20231121003153-4qzm2aa","Type":"NodeParagraph","Properties":{"id":"20231121003153-4qzm2aa","updated":"20231121003153"},"Children":[{"Type":"NodeText","Data":"想了解有关 etcd watch 机制的更多内容，可以阅读我之前发表的文章："}]},{"ID":"20231121003153-cvt2raa","Type":"NodeParagraph","Properties":{"id":"20231121003153-cvt2raa","updated":"20231121003153"},"Children":[{"Type":"NodeText","Data":"etcd watch 机制源码解析——服务端篇 以及 etcd watch 机制源码解析——客户端篇."}]},{"ID":"20231121003154-qil3kg3","Type":"NodeParagraph","Properties":{"id":"20231121003154-qil3kg3"}},{"ID":"20231121003156-l6ko3bg","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231121003156-l6ko3bg","updated":"20231121003158"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20231121003227-aoga82p","Type":"NodeParagraph","Properties":{"id":"20231121003227-aoga82p","updated":"20231121003232"},"Children":[{"Type":"NodeText","Data":"本文和大家一起探讨了设计模式中的观察者模式：\n• 观察者模式适用于多对一的订阅/发布场景，其实现思路是在观察者与被观察对象之间添加收口了发布订阅功能的中间层，核心宗旨是实现“观察者”与“被观察对象”之间的解耦\n• 通过 UML 类图结合具体代码示例，对观察者模式进行实践. 根据变更事件的通知模式，观察者模式可以分为同步和异步两种模型\n• 本文给出两个践行了观察者模式的工程案例，一个是 Message Queue 的发布订阅模式，一个是 ETCD 服务端对 watch 功能的实现思路"}]},{"ID":"20231121003232-0kdd1ba","Type":"NodeParagraph","Properties":{"id":"20231121003232-0kdd1ba"}}]}