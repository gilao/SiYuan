{"ID":"20240613143408-zmpumw7","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f34e","id":"20240613143408-zmpumw7","title":"面试题库","type":"doc","updated":"20240613143657"},"Children":[{"ID":"20240613143418-wja78yy","Type":"NodeParagraph","Properties":{"id":"20240613143418-wja78yy","updated":"20240613143418"},"Children":[{"Type":"NodeText","Data":"zset使用跳表和链表的策略是什么，"}]},{"ID":"20240613143426-2gxi24k","Type":"NodeParagraph","Properties":{"id":"20240613143426-2gxi24k","updated":"20240613143431"},"Children":[{"Type":"NodeText","Data":"说说context"}]},{"ID":"20240613143432-z99s0dv","Type":"NodeParagraph","Properties":{"id":"20240613143432-z99s0dv","updated":"20240613143435"},"Children":[{"Type":"NodeText","Data":"rabbitMq如何保证顺序执行的，"}]},{"ID":"20240613143435-g34kda0","Type":"NodeParagraph","Properties":{"id":"20240613143435-g34kda0","updated":"20240613143438"},"Children":[{"Type":"NodeText","Data":"mysql where age in and city in会发生什么"}]},{"ID":"20240613143439-5kebwsg","Type":"NodeParagraph","Properties":{"id":"20240613143439-5kebwsg","updated":"20240613143447"},"Children":[{"Type":"NodeText","Data":"如何实现优雅关机，"}]},{"ID":"20240613143447-4rqib34","Type":"NodeParagraph","Properties":{"id":"20240613143447-4rqib34","updated":"20240613143501"},"Children":[{"Type":"NodeText","Data":"不知道理解的是同一个吗？我记得go里面http server有个shutdown"}]},{"ID":"20240613143502-7y7ehh7","Type":"NodeParagraph","Properties":{"id":"20240613143502-7y7ehh7","updated":"20240613143514"},"Children":[{"Type":"NodeText","Data":"还有一个问到 map加锁，和safemap一直写入，性能有没有区别，"}]},{"ID":"20240613143515-pn52eno","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240613143515-pn52eno","updated":"20240613143652"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"在Go语言中，标准的map类型不是并发安全的，这意味着在多goroutine环境下直接对同一个map进行读写操作可能会引发数据竞争和不可预料的结果。为了在并发环境中安全地使用map，Go提供了几种方式，其中最常见的是使用sync.Map（在\"sync\"包中提供的并发安全的map）和使用sync.Mutex（互斥锁）来保护标准map。\n\n### 使用sync.Map\n\n`sdk.Map`是一个并发安全的map实现，内部已经实现了对读写的同步控制，因此在多goroutine环境下直接使用它是安全的。它通过分离读和写锁来减少锁的竞争，从而在高并发读多于写的情况下提供较好的性能。\n\n### 使用标准map + sync.Mutex\n\n如果你使用标准的map并手动添加一个`sync.Mutex`来保护它，每次读写操作都需要获取和释放锁，这在写操作频繁的场景下可能会导致较多的锁竞争，从而影响性能。\n\n### 性能比较\n\n- **写入性能**: 在高并发写入的场景下，`sync.Map`通常比标准map加Mutex有更好的性能，因为它内部的分段锁机制减少了锁的粒度，减少了锁竞争。对于读多写少的场景，这种优势更为明显。\n  \n- **内存占用**: `sync.Map`可能会比普通map加上Mutex的方案占用更多的内存，因为它需要额外的数据结构来维护分段锁和其他同步信息。\n  \n- **简单性与控制性**: 使用标准map加Mutex的方式给予开发者更多的控制权，比如你可以根据实际需要调整锁的策略，但这同时也增加了出错的可能性，需要更小心地管理锁的使用。\n\n综上所述，如果你的应用场景中map的并发写入较为频繁，使用`sync.Map`通常会带来更好的性能和安全性。但如果内存使用是关键因素，或者你需要更细粒度的控制，手动加锁的标准map可能是更合适的选择。在实际应用中，建议根据具体场景通过性能测试来决定最佳方案。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240613143657-mfr7zow","Type":"NodeParagraph","Properties":{"id":"20240613143657-mfr7zow"}}]}