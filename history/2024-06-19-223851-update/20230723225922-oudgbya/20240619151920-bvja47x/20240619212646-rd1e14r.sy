{"ID":"20240619212646-rd1e14r","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f9ae","id":"20240619212646-rd1e14r","tags":"Go-Wire","title":"Go语言官方团队推荐的依赖注入工具","type":"doc","updated":"20240619222159"},"Children":[{"ID":"20240619212646-c72j7f5","Type":"NodeParagraph","Properties":{"id":"20240619212646-c72j7f5","updated":"20240619221914"},"Children":[{"Type":"NodeText","Data":"在开发过程中，我们经常需要处理一些相互依赖的组件。例如，我们可能有一个服务需要数据库连接和一些配置信息。这种相互依赖的关系在一个大型项目中可能会变得非常复杂。无序地组织这些依赖可能会造成代码的混乱和维护困难。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"为了更好地管理依赖关系，依赖注入是一个很好的解决方案。"},{"Type":"NodeText","Data":"在Go的世界中，我们有一个强大的依赖注入框架Wire。"}]},{"ID":"20240619221934-fg897by","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240619221934-fg897by","updated":"20240619221945"},"Children":[{"Type":"NodeText","Data":"什么是依赖注入？"}]},{"ID":"20240619221945-g3zr82e","Type":"NodeParagraph","Properties":{"id":"20240619221945-g3zr82e","updated":"20240619221951"},"Children":[{"Type":"NodeText","Data":"在开始探讨Wire之前，我们先来了解一下依赖注入的概念。依赖注入是一种将组件之间的依赖关系从组件内部移到组件外部的设计模式。这样做的好处是，我们可以降低组件之间的耦合度，提高系统的可测试性和可维护性。"}]},{"ID":"20240619221952-mued079","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240619221952-mued079","updated":"20240619222050"},"Children":[{"Type":"NodeText","Data":"什么是Wire？"}]},{"ID":"20240619222050-f6wjbfw","Type":"NodeParagraph","Properties":{"id":"20240619222050-f6wjbfw","updated":"20240619222102"},"Children":[{"Type":"NodeText","Data":"Wire 是Google为Go语言开发的一款编译时依赖注入框架。Wire的安装非常简单，只需在命令行中输入以下命令："}]},{"ID":"20240619222113-z6ess0u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240619222113-z6ess0u","updated":"20240619222121"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"go get github.com/google/wire/cmd/wire\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240619222125-de9ovgj","Type":"NodeParagraph","Properties":{"id":"20240619222125-de9ovgj","updated":"20240619222125"},"Children":[{"Type":"NodeText","Data":"Wire的使用步骤也非常简洁，主要有三步："}]},{"ID":"20240619222125-2ssal3g","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240619222125-2ssal3g","updated":"20240619222125"},"Children":[{"ID":"20240619222125-y5en9s3","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240619222125-y5en9s3","updated":"20240619222125"},"Children":[{"ID":"20240619222125-7t07k1p","Type":"NodeParagraph","Properties":{"id":"20240619222125-7t07k1p","updated":"20240619222125"},"Children":[{"Type":"NodeText","Data":"定义组件：这一步主要是定义我们的服务，工厂函数等依赖对象，这些对象通常需要依赖其他对象。"}]}]},{"ID":"20240619222125-ge91bl1","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240619222125-ge91bl1","updated":"20240619222125"},"Children":[{"ID":"20240619222125-88saiwu","Type":"NodeParagraph","Properties":{"id":"20240619222125-88saiwu","updated":"20240619222125"},"Children":[{"Type":"NodeText","Data":"建立对象图：这一步定义了各个对象之间的依赖关系。"}]}]},{"ID":"20240619222125-rpizj9w","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240619222125-rpizj9w","updated":"20240619222125"},"Children":[{"ID":"20240619222125-pqr90e5","Type":"NodeParagraph","Properties":{"id":"20240619222125-pqr90e5","updated":"20240619222125"},"Children":[{"Type":"NodeText","Data":"生成代码：最后一步由Wire自动完成，Wire会生成一个初始化所有对象，并连续依赖关系的函数。"}]}]}]},{"ID":"20240619222125-hkhia7f","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240619222125-hkhia7f","updated":"20240619222125"},"Children":[{"Type":"NodeText","Data":"使用示例"}]},{"ID":"20240619222128-4nhwref","Type":"NodeParagraph","Properties":{"id":"20240619222128-4nhwref","updated":"20240619222133"},"Children":[{"Type":"NodeText","Data":"接下来我们通过一个示例来说明Wire的使用。假设我们有一个Foo服务，它需要一个Bar和一个Baz："}]},{"ID":"20240619222133-nl3q0y9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240619222133-nl3q0y9","updated":"20240619222149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Foo struct {\n    X *Bar\n    Y *Baz\n}\n\ntype Bar struct {\n    //...\n}\n\ntype Baz struct {\n    //...\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240619222159-dl68ff4","Type":"NodeParagraph","Properties":{"id":"20240619222159-dl68ff4","updated":"20240619222159"},"Children":[{"Type":"NodeText","Data":"我们需要一个函数来创建Foo，这个函数需要Bar和Baz作为参数："}]},{"ID":"20240619222159-8o9jyzc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240619222159-8o9jyzc","updated":"20240619222159"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func ProvideFoo(b *Bar, z *Baz) *Foo {\n    return \u0026Foo{X: b, Y: z}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240619222159-75dlxol","Type":"NodeParagraph","Properties":{"id":"20240619222159-75dlxol","updated":"20240619222159"},"Children":[{"Type":"NodeText","Data":"接下来，我们可以使用Wire来生成这个提供函数："}]},{"ID":"20240619222159-zlc1rhm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240619222159-zlc1rhm","updated":"20240619222159"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func InitFoo() *Foo {\n    wire.Build(\n        ProvideFoo,\n        ProvideBar,\n        ProvideBaz,\n    )\n    return \u0026Foo{}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240619222159-iteuxir","Type":"NodeParagraph","Properties":{"id":"20240619222159-iteuxir","updated":"20240619222159"},"Children":[{"Type":"NodeText","Data":"在这个例子中，Wire将会生成一个函数，这个函数根据"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ProvideFoo"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ProvideBar"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ProvideBaz"},{"Type":"NodeText","Data":"​的定义，来初始化一个Foo对象，并处理各个对象之间的依赖关系。"}]}]}