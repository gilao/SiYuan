{"ID":"20230727000850-orphcpy","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f69c","id":"20230727000850-orphcpy","tags":"Go 内存分配","title":"20. GO 内存管理","updated":"20230727000850"},"Children":[{"ID":"20230727000851-obopese","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230727000851-obopese","updated":"20230727000851"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"20. GO 内存管理"}]},{"ID":"20230727000852-c0vb2g4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000852-c0vb2g4","updated":"20230727000852"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"内存池"}]},{"ID":"20230727000853-ib0qil8","Type":"NodeParagraph","Properties":{"id":"20230727000853-ib0qil8","updated":"20230727000853"},"Children":[{"Type":"NodeText","Data":"最直接的方式是调用malloc函数，指定要分配的大小，直接向操作系统申请。问题是这种方式会涉及到用户态和内核态的切换过程，那么频繁的切换就会带来很大的性能下降，我们"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"要减少用户态和内核态的频繁切换就需要自己申请一块内存空间，将之分割成大小规格不同的内存块来供程序使用，内存池是再适合不过的组成部分。"}]},{"ID":"20230727000854-q2cs9fm","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000854-q2cs9fm","updated":"20230727000854"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"GC"}]},{"ID":"20230727000855-xisp7u1","Type":"NodeParagraph","Properties":{"id":"20230727000855-xisp7u1","updated":"20230727000855"},"Children":[{"Type":"NodeText","Data":"内存管理不光需要使用方便，还要保证内存使用过程能够节约，毕竟整个系统的内存资源是有限的，那么就"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"需要GC进行动态的垃圾回收，销毁无用的对象，释放内存来保证整个程序乃至系统运行平稳。"}]},{"ID":"20230727000856-v8pw6ea","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000856-v8pw6ea","updated":"20230727000856"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"锁"}]},{"ID":"20230727000857-j9ds4ro","Type":"NodeParagraph","Properties":{"id":"20230727000857-j9ds4ro","updated":"20230727000857"},"Children":[{"Type":"NodeText","Data":"一个应用程序内部之间存在大量的线程，线程之间资源是共享的，那么"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"要保证同一块内存使用过程不出现复用或者污染，就必须保证同一时间只能有一个线程进行申请，第一个想到的肯定是锁，对公共区域的资源一定要加锁，另一种方式就是内存隔离"},{"Type":"NodeText","Data":"，这个在golang的mcache中会有体现。"}]},{"ID":"20230727000858-0gvs0to","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000858-0gvs0to","updated":"20230727000858"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"基本概念"}]},{"ID":"20230727000859-8s2pfbr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000859-8s2pfbr","updated":"20230727000859"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"page"}]},{"ID":"20230727000860-i40jci9","Type":"NodeParagraph","Properties":{"id":"20230727000860-i40jci9","updated":"20230727000860"},"Children":[{"Type":"NodeText","Data":"操作系统内存管理中，内存的最粒度是4KB，也就是说分配内存最小4KB起。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"golang里面一个page是8KB。"}]},{"ID":"20230727000861-3l4kv7d","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000861-3l4kv7d","updated":"20230727000861"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"span"}]},{"ID":"20230727000862-6kj4puw","Type":"NodeParagraph","Properties":{"id":"20230727000862-6kj4puw","updated":"20230727000862"},"Children":[{"Type":"NodeText","Data":"span是golang内存管理的基本单位，每个span管理指定规格（以golang 中的 page为单位）的内存块，内存池分配出不同规格的内存块就是通过span体现出来的，应用程序创建对象就是通过找到对应规格的span来存储的，下面是 mspan 结构中的主要部分。"}]},{"ID":"20230727000863-pvboid4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000863-pvboid4","updated":"20230727000863"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//go\\src\\runtime\\mheap.go\n//go:notinheap\ntype mspan struct {\nnext *mspan     // next span in list, or nil if none\nprev *mspan     // previous span in list, or nil if none\n\nstartAddr uintptr // address of first byte of span aka s.base()\nnpages    uintptr // number of pages in span\n\nnelems uintptr // number of object in the span.\n\nallocCache uint64\nallocBits  *gcBits  //bitmap\ngcmarkBits *gcBits  //bitmap\n\nbaseMask    uint16        // if non-0, elemsize is a power of 2, \u0026 this will get object allocation base\nallocCount  uint16        // number of allocated objects\nspanclass   spanClass     // size class and noscan (uint8)\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000864-pq35i4f","Type":"NodeParagraph","Properties":{"id":"20230727000864-pq35i4f","updated":"20230727000864"},"Children":[{"Type":"NodeText","Data":"那么要想区分不同规格的span，我们必须要有一个标识，每个span通过spanclass标识属于哪种规格的span，golang的span规格一共有67种，具体如下："}]},{"ID":"20230727000865-4bbr38o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000865-4bbr38o","updated":"20230727000865"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//from runtime.go\\sizeclasses.go\n\n// class  bytes/obj  bytes/span  objects  tail waste  max waste\n//     1          8        8192     1024           0     87.50%\n//     2         16        8192      512           0     43.75%\n//     3         32        8192      256           0     46.88%\n//     4         48        8192      170          32     31.52%\n//     5         64        8192      128           0     23.44%\n//     6         80        8192      102          32     19.07%\n//     7         96        8192       85          32     15.95%\n//     8        112        8192       73          16     13.56%\n//     9        128        8192       64           0     11.72%\n//    10        144        8192       56         128     11.82%\n//    11        160        8192       51          32      9.73%\n//    12        176        8192       46          96      9.59%\n//    13        192        8192       42         128      9.25%\n//    14        208        8192       39          80      8.12%\n//    15        224        8192       36         128      8.15%\n//    16        240        8192       34          32      6.62%\n//    17        256        8192       32           0      5.86%\n//    18        288        8192       28         128     12.16%\n//    19        320        8192       25         192     11.80%\n//    20        352        8192       23          96      9.88%\n//    21        384        8192       21         128      9.51%\n//    22        416        8192       19         288     10.71%\n//    23        448        8192       18         128      8.37%\n//    24        480        8192       17          32      6.82%\n//    25        512        8192       16           0      6.05%\n//    26        576        8192       14         128     12.33%\n//    27        640        8192       12         512     15.48%\n//    28        704        8192       11         448     13.93%\n//    29        768        8192       10         512     13.94%\n//    30        896        8192        9         128     15.52%\n//    31       1024        8192        8           0     12.40%\n//    32       1152        8192        7         128     12.41%\n//    33       1280        8192        6         512     15.55%\n//    34       1408       16384       11         896     14.00%\n//    35       1536        8192        5         512     14.00%\n//    36       1792       16384        9         256     15.57%\n//    37       2048        8192        4           0     12.45%\n//    38       2304       16384        7         256     12.46%\n//    39       2688        8192        3         128     15.59%\n//    40       3072       24576        8           0     12.47%\n//    41       3200       16384        5         384      6.22%\n//    42       3456       24576        7         384      8.83%\n//    43       4096        8192        2           0     15.60%\n//    44       4864       24576        5         256     16.65%\n//    45       5376       16384        3         256     10.92%\n//    46       6144       24576        4           0     12.48%\n//    47       6528       32768        5         128      6.23%\n//    48       6784       40960        6         256      4.36%\n//    49       6912       49152        7         768      3.37%\n//    50       8192        8192        1           0     15.61%\n//    51       9472       57344        6         512     14.28%\n//    52       9728       49152        5         512      3.64%\n//    53      10240       40960        4           0      4.99%\n//    54      10880       32768        3         128      6.24%\n//    55      12288       24576        2           0     11.45%\n//    56      13568       40960        3         256      9.99%\n//    57      14336       57344        4           0      5.35%\n//    58      16384       16384        1           0     12.49%\n//    59      18432       73728        4           0     11.11%\n//    60      19072       57344        3         128      3.57%\n//    61      20480       40960        2           0      6.87%\n//    62      21760       65536        3         256      6.25%\n//    63      24576       24576        1           0     11.45%\n//    64      27264       81920        3         128     10.00%\n//    65      28672       57344        2           0      4.91%\n//    66      32768       32768        1           0     12.50%\n\nspanclass\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000866-ehnj5j5","Type":"NodeParagraph","Properties":{"id":"20230727000866-ehnj5j5","updated":"20230727000866"},"Children":[{"Type":"NodeText","Data":"另外上表可见最大的对象是32KB大小，超过32KB大小的由特殊的class表示，该class ID为0，每个class只包含一个对象。所以上面只有列出了1-66。"}]},{"ID":"20230727000867-v3rlmte","Type":"NodeParagraph","Properties":{"id":"20230727000867-v3rlmte","updated":"20230727000867"},"Children":[{"Type":"NodeText","Data":"下面还要三个数组，分别是："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"class_to_size"},{"Type":"NodeText","Data":"，**"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"size_to_class"},{"Type":"NodeText","Data":"**和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"**class_to_allocnpages3**个数组，对应下图上的3个箭头："}]},{"ID":"20230727000868-90lca0t","Type":"NodeParagraph","Properties":{"id":"20230727000868-90lca0t","updated":"20230727000868"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\1370746-20200707164347794-1965227304.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000869-8vtrnzy","Type":"NodeParagraph","Properties":{"id":"20230727000869-8vtrnzy","updated":"20230727000869"},"Children":[{"Type":"NodeText","Data":"比如：我们只拿第一行举例："}]},{"ID":"20230727000870-c8150o8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000870-c8150o8","updated":"20230727000870"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// class bytes/obj\tbytes/span objects tail waste max waste\n// 1\t8\t\t\t8192\t\t1024\t0\t\t87.50%\t\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000871-z5gr3po","Type":"NodeParagraph","Properties":{"id":"20230727000871-z5gr3po","updated":"20230727000871"},"Children":[{"Type":"NodeText","Data":"就是类别1的对象大小是8bytes，所以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"class_to_size[1]=8"},{"Type":"NodeText","Data":"；span大小是8KB，为1页，所以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"class_to_allocnpages[1]=1"}]},{"ID":"20230727000872-gphdz27","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000872-gphdz27","updated":"20230727000872"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"mcache"}]},{"ID":"20230727000873-6res0s3","Type":"NodeParagraph","Properties":{"id":"20230727000873-6res0s3","updated":"20230727000873"},"Children":[{"Type":"NodeText","Data":"mcache保存的是各种大小的Span，并按Span class分类，小对象(\u003c=32KB)直接从mcache分配内存，它起到了缓存的作用，并且可以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"无锁访问"},{"Type":"NodeText","Data":"。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"mcache是每个逻辑处理器（P）的本地内存线程缓存"},{"Type":"NodeText","Data":"。Go中是每个P只拥有1个mcache，所以不用加锁。另外，mcache中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"每个级别的Span有2类数组链表"},{"Type":"NodeText","Data":"，但是合在一起的(alloc成员变量)。"}]},{"ID":"20230727000874-59n60nn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000874-59n60nn","updated":"20230727000874"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// from runtime.go/mcache.go\ntype mcache struct {\n    loacl_scan uintptr // bytes of scannable heap allocated\n    tiny \tuintptr\n    tinyoffset uintptr\n    local_tinyallocs uintptr // number of tiny allocs not counted in other stats\n    \n    // The rest is not accessed on every malloc\n    \n    alloc [numSpanClasses]*mspan // numSpanClasses 为 2*67\n    stackcache [_NumStackOrders]stackfreelist // 每个G绑定的栈空间\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000875-g4jah3z","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000875-g4jah3z","updated":"20230727000875"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"mcentral"}]},{"ID":"20230727000876-uync93p","Type":"NodeParagraph","Properties":{"id":"20230727000876-uync93p","updated":"20230727000876"},"Children":[{"Type":"NodeText","Data":"它按Span class对Span分类，串联成链表，当mcache的某个级别Span的内存被分配光时，它会向mcentral申请1个当前级别的Span。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"所有线程共享的缓存，需要加锁访问"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230727000877-0rmgexf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000877-0rmgexf","updated":"20230727000877"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//from runtime.go\\mcentral.go\n\ntype mcentral struct {\n    lock      mutex\n    spanclass spanClass\n\n    // For !go115NewMCentralImpl.\n    nonempty mSpanList // list of spans with a free object, ie a nonempty free list\n    empty    mSpanList // list of spans with no free objects (or cached in an mcache)\n\n    partial [2]spanSet // list of spans with a free object\n    full    [2]spanSet // list of spans with no free objects\n    \n    nmalloc uint64\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000878-hgv5ttl","Type":"NodeParagraph","Properties":{"id":"20230727000878-hgv5ttl","updated":"20230727000878"},"Children":[{"Type":"NodeText","Data":"每个mcentral 包含两个mspanList"}]},{"ID":"20230727000879-pyy6twl","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000879-pyy6twl","updated":"20230727000879"},"Children":[{"ID":"20230727000880-8unl805","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000880-8unl805","updated":"20230727000880"},"Children":[{"ID":"20230727000881-rx9l46s","Type":"NodeParagraph","Properties":{"id":"20230727000881-rx9l46s","updated":"20230727000881"},"Children":[{"Type":"NodeText","Data":"empty：双向span链表，包括"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"没有空闲对象"},{"Type":"NodeText","Data":"的span或缓存mcache中的span。当此处的span被释放时，它将被移至non-empty span链表。"}]}]},{"ID":"20230727000882-fyra8wj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000882-fyra8wj","updated":"20230727000882"},"Children":[{"ID":"20230727000883-jv02p4x","Type":"NodeParagraph","Properties":{"id":"20230727000883-jv02p4x","updated":"20230727000883"},"Children":[{"Type":"NodeText","Data":"non-empty："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"有空闲对象"},{"Type":"NodeText","Data":"的span双向链表。当从mcentral请求新的span，mcentral将从该链表中获取span并将其移入empty span链表。"}]}]}]},{"ID":"20230727000884-smi6jce","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000884-smi6jce","updated":"20230727000884"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"mheap"}]},{"ID":"20230727000885-la080b4","Type":"NodeParagraph","Properties":{"id":"20230727000885-la080b4","updated":"20230727000885"},"Children":[{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeText","Data":"它把从OS申请出的内存页组织成Span，并保存起来。"},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]},{"Type":"NodeText","Data":"当mcentral的Span不够用时会向mheap申请，mheap的Span不够用时会向OS申请，向OS的内存申请是按页来的，然后把申请来的内存页生成Span组织起来，同样也是需要加锁访问的。大对象(\u003e32KB)直接从mheap上分配。"}]},{"ID":"20230727000886-0bux97n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000886-0bux97n","updated":"20230727000886"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//from runtime.go\\mheap.go\n\ntype mheap struct {\n// lock must only be acquired on the system stack, otherwise a g\n// could self-deadlock if its stack grows with the lock held.\nlock      mutex\npages     pageAlloc // page allocation data structure\nsweepgen  uint32    // sweep generation, see comment in mspan; written during STW\nsweepdone uint32    // all spans are swept\nsweepers  uint32    // number of active sweepone calls\n\n\nallspans []*mspan // all spans out there\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000887-l8sk48e","Type":"NodeParagraph","Properties":{"id":"20230727000887-l8sk48e","updated":"20230727000887"},"Children":[{"Type":"NodeText","Data":"mhead 的结构相对比较复杂，我们知道每个golang程序启动时候会向操作系统申请一块虚拟内存空间，仅仅是虚拟内存空间，真正需要的时候才会发生缺页中断，向系统申请真正的物理空间，在golang1.11版本以后，申请的内存空间会放在一个heapArena数组里，由arenas [1 \u003c\u003c arenaL1Bits]"},{"Type":"NodeEmphasis","Children":[{"Type":"NodeEmA6kOpenMarker","Data":"*"},{"Type":"NodeText","Data":"[1 \u003c\u003c arenaL2Bits]"},{"Type":"NodeEmA6kCloseMarker","Data":"*"}]},{"Type":"NodeText","Data":"heapArena表示，用于应用程序内存分配，根据源码公式，在64位非windows系统分配大小是64MB，windows 64位是4MB。"}]},{"ID":"20230727000888-zajgk8n","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000888-zajgk8n","updated":"20230727000888"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"内存分配过程"}]},{"ID":"20230727000889-g67av9a","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000889-g67av9a","updated":"20230727000889"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"内存分配总览图"}]},{"ID":"20230727000890-l5jcrd2","Type":"NodeParagraph","Properties":{"id":"20230727000890-l5jcrd2","updated":"20230727000890"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\1370746-20200707171222457-162760903.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000891-yyjqkwt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000891-yyjqkwt","updated":"20230727000891"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"内存关系总览图"}]},{"ID":"20230727000892-5szjlco","Type":"NodeParagraph","Properties":{"id":"20230727000892-5szjlco","updated":"20230727000892"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\1370746-20200708115648245-1474789948.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000893-sa77jyq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000893-sa77jyq","updated":"20230727000893"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"简单分配规则"}]},{"ID":"20230727000894-mrsr8oh","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000894-mrsr8oh","updated":"20230727000894"},"Children":[{"ID":"20230727000895-0s26e1g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000895-0s26e1g","updated":"20230727000895"},"Children":[{"ID":"20230727000896-n678bjb","Type":"NodeParagraph","Properties":{"id":"20230727000896-n678bjb","updated":"20230727000896"},"Children":[{"Type":"NodeText","Data":"tiny对象内存分配，直接向mcache的tiny对象分配器申请，如果空间不足，则向mcache的tinySpanClass规格的span链表申请，如果没有，则向mcentral申请对应规格mspan，依旧没有，则向mheap申请，最后都用光则向操作系统申请。"}]}]},{"ID":"20230727000897-j4nadn5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000897-j4nadn5","updated":"20230727000897"},"Children":[{"ID":"20230727000898-l2bolip","Type":"NodeParagraph","Properties":{"id":"20230727000898-l2bolip","updated":"20230727000898"},"Children":[{"Type":"NodeText","Data":"小对象内存分配，先向本线程mcache申请，发现mspan没有空闲的空间，向mcentral申请对应规格的mspan，如果mcentral对应规格没有，向mheap申请对应页初始化新的mspan，如果也没有，则向操作系统申请，分配页。"}]}]},{"ID":"20230727000899-gbnbrvr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000899-gbnbrvr","updated":"20230727000899"},"Children":[{"ID":"20230727000900-idgards","Type":"NodeParagraph","Properties":{"id":"20230727000900-idgards","updated":"20230727000900"},"Children":[{"Type":"NodeText","Data":"大对象内存分配，直接向mheap申请spanclass=0，如果没有则向操作系统申请。"}]}]}]},{"ID":"20230727000901-o4rq5w6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000901-o4rq5w6","updated":"20230727000901"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"源码分析"}]},{"ID":"20230727000902-b8u2cjf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000902-b8u2cjf","updated":"20230727000902"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"对象分配入口"}]},{"ID":"20230727000903-hcd7go8","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000903-hcd7go8","updated":"20230727000903"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Tiny 对象(\u003c16B) 的分配"}]},{"ID":"20230727000904-rv6w0zy","Type":"NodeParagraph","Properties":{"id":"20230727000904-rv6w0zy","updated":"20230727000904"},"Children":[{"Type":"NodeText","Data":"golang会通过tiny和tinyoffset组合寻找位置分配内存空间，这样可以更好的节约空间"}]},{"ID":"20230727000905-96pxy1r","Type":"NodeParagraph","Properties":{"id":"20230727000905-96pxy1r","updated":"20230727000905"},"Children":[{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"alloc Tiny Object"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000906-tn69jqn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000906-tn69jqn","updated":"20230727000906"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//from runtime.go\\malloc.go\n\n//Tiny 对象的分配过程\n//step1:先进行内存对齐\noff := c.tinyoffset\n// Align tiny pointer for required (conservative) alignment.\nif size\u00267 == 0 {\n    off = alignUp(off, 8)\n} else if size\u00263 == 0 {\n    off = alignUp(off, 4)\n} else if size\u00261 == 0 {\n    off = alignUp(off, 2)\n}\n//step2: 看 tinySpanClass 是否还可以放下当前的 Tiny 对象，如果放不下，再申请一个类型为 tinySpanClass\u0026\u0026noscan 的 span\nif off+size \u003c= maxTinySize \u0026\u0026 c.tiny != 0 {\n    // The object fits into existing tiny block.\n    x = unsafe.Pointer(c.tiny + off)\n    c.tinyoffset = off + size\n    c.local_tinyallocs++\n    mp.mallocing = 0\n    releasem(mp)\n    return x\n}else {\n    // otherwise Allocate a new maxTinySize block.\n    span = c.alloc[tinySpanClass]\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000907-n84ynfu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000907-n84ynfu","updated":"20230727000907"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"小对象[16B, 32KB]的分配"}]},{"ID":"20230727000908-6ipu4tp","Type":"NodeParagraph","Properties":{"id":"20230727000908-6ipu4tp","updated":"20230727000908"},"Children":[{"Type":"NodeText","Data":"会使用这部分span进行正常的内存分配"}]},{"ID":"20230727000909-1jqr5kg","Type":"NodeParagraph","Properties":{"id":"20230727000909-1jqr5kg","updated":"20230727000909"},"Children":[{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"alloc smallObject"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000910-r6j6vlp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000910-r6j6vlp","updated":"20230727000910"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//from runtime.go\\malloc.go\n\nvar sizeclass uint8\n//step1: 确定规格sizeClass\nif size \u003c= smallSizeMax-8 {\n    sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]\n} else {\n    sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]\n}\nsize = uintptr(class_to_size[sizeclass])\nspc := makeSpanClass(sizeclass, noscan)\n//step2: 分配对应spanClass 的 span\nspan = c.alloc[spc]\nv := nextFreeFast(span)\nif v == 0 {\n    v, span, shouldhelpgc = c.nextFree(spc)\n}\nx = unsafe.Pointer(v)\nif needzero \u0026\u0026 span.needzero != 0 {\n    memclrNoHeapPointers(unsafe.Pointer(v), size)\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000911-03p8rb1","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000911-03p8rb1","updated":"20230727000911"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"大对象(\u003e32KB)的分配"}]},{"ID":"20230727000912-ioumwp7","Type":"NodeParagraph","Properties":{"id":"20230727000912-ioumwp7","updated":"20230727000912"},"Children":[{"Type":"NodeText","Data":"直接在 mheap 上进行分配"}]},{"ID":"20230727000913-n80t4zw","Type":"NodeParagraph","Properties":{"id":"20230727000913-n80t4zw","updated":"20230727000913"},"Children":[{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"alloc bigObject"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000914-qr9cr4l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000914-qr9cr4l","updated":"20230727000914"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//from runtime.go\\malloc.go\n\nshouldhelpgc = true\nsystemstack(func() {\n    //分配大对象\n    span = largeAlloc(size, needzero, noscan)\n})\nspan.freeindex = 1\nspan.allocCount = 1\nx = unsafe.Pointer(span.base())\nsize = span.elemsize\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000915-7z7th63","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000915-7z7th63","updated":"20230727000915"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"向上级申请资源"}]},{"ID":"20230727000916-bjxyjsv","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000916-bjxyjsv","updated":"20230727000916"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"mcache 向 mcentral 申请"}]},{"ID":"20230727000917-uavexo1","Type":"NodeParagraph","Properties":{"id":"20230727000917-uavexo1","updated":"20230727000917"},"Children":[{"Type":"NodeText","Data":"调用 \\src\\runtime\\mcache.go refill 方法"}]},{"ID":"20230727000918-i5o6n8z","Type":"NodeParagraph","Properties":{"id":"20230727000918-i5o6n8z","updated":"20230727000918"},"Children":[{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"mcache apply source"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000919-44spjlp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000919-44spjlp","updated":"20230727000919"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func (c *mcache) refill(spc spanClass) {\n    // Return the current cached span to the central lists.\n    s := c.alloc[spc]\n    \n    if uintptr(s.allocCount) != s.nelems {\n    throw(\"refill of span with free space remaining\")\n    }\n    \n    // Get a new cached span from the central lists.\n    //step1: 从 mcentral 获取资源\n    s = mheap_.central[spc].mcentral.cacheSpan()\n    if s == nil {\n    throw(\"out of memory\")\n    }\n    \n    if uintptr(s.allocCount) == s.nelems {\n    throw(\"span has no free space\")\n    }\n    \n    // Indicate that this span is cached and prevent asynchronous\n    // sweeping in the next sweep phase.\n    s.sweepgen = mheap_.sweepgen + 3\n    //step2: 放入mcache 中\n    c.alloc[spc] = s\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000920-28mnb44","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000920-28mnb44","updated":"20230727000920"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"mcentral 向 mheap 申请"}]},{"ID":"20230727000921-swfd28y","Type":"NodeParagraph","Properties":{"id":"20230727000921-swfd28y","updated":"20230727000921"},"Children":[{"Type":"NodeText","Data":"调用 \\src\\runtime\\mcental.go grow方法"}]},{"ID":"20230727000922-lvsl8bd","Type":"NodeParagraph","Properties":{"id":"20230727000922-lvsl8bd","updated":"20230727000922"},"Children":[{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"mcentral apply source"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000923-yxtnit6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000923-yxtnit6","updated":"20230727000923"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// grow allocates a new empty span from the heap and initializes it for c's size class.\nfunc (c *mcentral) grow() *mspan {\n    npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])\n    size := uintptr(class_to_size[c.spanclass.sizeclass()])\n\n    s := mheap_.alloc(npages, c.spanclass, true)\n    if s == nil {\n        return nil\n    }\n\n    // Use division by multiplication and shifts to quickly compute:\n    // n := (npages \u003c\u003c _PageShift) / size\n    n := (npages \u003c\u003c _PageShift) \u003e\u003e s.divShift * uintptr(s.divMul) \u003e\u003e s.divShift2\n    s.limit = s.base() + size*n\n    heapBitsForAddr(s.base()).initSpan(s)\n    return s\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000924-a2mbce7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000924-a2mbce7","updated":"20230727000924"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"mheap 向 os 申请"}]},{"ID":"20230727000925-qf02p1a","Type":"NodeParagraph","Properties":{"id":"20230727000925-qf02p1a","updated":"20230727000925"},"Children":[{"Type":"NodeText","Data":"调用\\src\\runtime\\mheap.go grow方法、"}]},{"ID":"20230727000926-iqbdmux","Type":"NodeParagraph","Properties":{"id":"20230727000926-iqbdmux","updated":"20230727000926"},"Children":[{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"mheap apply source"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000927-6c7owrd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000927-6c7owrd","updated":"20230727000927"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// Try to add at least npage pages of memory to the heap,\n// returning whether it worked.\n//\n// h must be locked.\nfunc (h *mheap) grow(npage uintptr) bool {\n    // We must grow the heap in whole palloc chunks.\n    ask := alignUp(npage, pallocChunkPages) * pageSize\n\n    totalGrowth := uintptr(0)\n    // This may overflow because ask could be very large\n    // and is otherwise unrelated to h.curArena.base.\n    end := h.curArena.base + ask\n    nBase := alignUp(end, physPageSize)\n    if nBase \u003e h.curArena.end || /* overflow */ end \u003c h.curArena.base {\n        // Not enough room in the current arena. Allocate more\n        // arena space. This may not be contiguous with the\n        // current arena, so we have to request the full ask.\n        av, asize := h.sysAlloc(ask)\n        if av == nil {\n            print(\"runtime: out of memory: cannot allocate \", ask, \"-byte block (\", memstats.heap_sys, \" in use)\\n\")\n            return false\n        }\n\n        if uintptr(av) == h.curArena.end {\n            // The new space is contiguous with the old\n            // space, so just extend the current space.\n            h.curArena.end = uintptr(av) + asize\n        } else {\n            // The new space is discontiguous. Track what\n            // remains of the current space and switch to\n            // the new space. This should be rare.\n            if size := h.curArena.end - h.curArena.base; size != 0 {\n                h.pages.grow(h.curArena.base, size)\n                totalGrowth += size\n            }\n            // Switch to the new space.\n            h.curArena.base = uintptr(av)\n            h.curArena.end = uintptr(av) + asize\n        }\n\n        // The memory just allocated counts as both released\n        // and idle, even though it's not yet backed by spans.\n        //\n        // The allocation is always aligned to the heap arena\n        // size which is always \u003e physPageSize, so its safe to\n        // just add directly to heap_released.\n        mSysStatInc(\u0026memstats.heap_released, asize)\n        mSysStatInc(\u0026memstats.heap_idle, asize)\n\n        // Recalculate nBase.\n        // We know this won't overflow, because sysAlloc returned\n        // a valid region starting at h.curArena.base which is at\n        // least ask bytes in size.\n        nBase = alignUp(h.curArena.base+ask, physPageSize)\n    }\n\n    // Grow into the current arena.\n    v := h.curArena.base\n    h.curArena.base = nBase\n    h.pages.grow(v, nBase-v)\n    totalGrowth += nBase - v\n\n    // We just caused a heap growth, so scavenge down what will soon be used.\n    // By scavenging inline we deal with the failure to allocate out of\n    // memory fragments by scavenging the memory fragments that are least\n    // likely to be re-used.\n    if retained := heapRetained(); retained+uint64(totalGrowth) \u003e h.scavengeGoal {\n        todo := totalGrowth\n        if overage := uintptr(retained + uint64(totalGrowth) - h.scavengeGoal); todo \u003e overage {\n            todo = overage\n        }\n        h.pages.scavenge(todo, false)\n    }\n    return true\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}