{"ID":"20230724231512-69dhak1","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f9c7","id":"20230724231512-69dhak1","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230724231512-69dhak1\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230724231513-zhegkes\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231120155610-pnav15u\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230724231513-zhegkes\u0026quot;,\u0026quot;focusStart\u0026quot;:1,\u0026quot;focusEnd\u0026quot;:1\u0026#125;","tags":"公众号-小徐先生的编程世界,设计模式-观察者模式","title":"2-Go 观察者模式","updated":"20231120213612"},"Children":[{"ID":"20230724231513-zhegkes","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230724231513-zhegkes","updated":"20231120155340"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/QOXh86eX8z5Ts4O1pky44g","TextMarkTextContent":"Go 观察者模式"},{"Type":"NodeText","Data":"原理介绍"}]},{"ID":"20231120155358-pbzz5ab","Type":"NodeParagraph","Properties":{"id":"20231120155358-pbzz5ab","updated":"20231120155608"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120155358-116vk3c.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120155553-wc4q0kl","Type":"NodeParagraph","Properties":{"id":"20231120155553-wc4q0kl","updated":"20231120155601"},"Children":[{"Type":"NodeText","Data":"本期基于 go 语言和大家探讨设计模式中的观察者模式. 观察者模式适用于多对一的订阅/发布场景.\n• ”多“：指的是有多名观察者\n• ”一“：指的是有一个被观察事物\n• ”订阅“：指的是观察者时刻关注着事物的动态\n• ”发布“：指的是事物状态发生变化时是透明公开的，能够正常进入到观察者的视线"}]},{"ID":"20231120155610-pnav15u","Type":"NodeParagraph","Properties":{"id":"20231120155610-pnav15u","updated":"20231120155622"},"Children":[{"Type":"NodeText","Data":"在上述场景中，我们了解到核心对象有两类，一类是“观察者”，一类是“被观察的事物”，且两者间在数量上存在多对一的映射关系."}]},{"ID":"20231120160813-lvav3n8","Type":"NodeParagraph","Properties":{"id":"20231120160813-lvav3n8","updated":"20231120160813"},"Children":[{"Type":"NodeText","Data":"在具体作编程实现时，上述场景的实现思路可以是百花齐放的，而观察者模式只是为我们提供了一种相对规范的设计实现思路，其遵循的核心宗旨是实现“观察者”与“被观察对象”之间的解耦，并将其设计为通用的模块，便于后续的扩展和复用."}]},{"ID":"20231120160813-0f7ofpg","Type":"NodeParagraph","Properties":{"id":"20231120160813-0f7ofpg","updated":"20231120160813"},"Children":[{"Type":"NodeText","Data":"学习设计模式时，我们脑海中需要中需要明白，教条是相对刻板的，而场景和问题则是灵活多变的，在工程实践中，我们避免生搬硬套，要做到因地制宜，随机应变."}]},{"ID":"20231120161646-d3ale6e","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231120161646-d3ale6e","updated":"20231120161653"},"Children":[{"Type":"NodeText","Data":"代码实践"}]},{"ID":"20231120161953-a5tre11","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120161953-a5tre11","updated":"20231120161958"},"Children":[{"Type":"NodeText","Data":"核心角色"}]},{"ID":"20231120162029-fn5890l","Type":"NodeParagraph","Properties":{"id":"20231120162029-fn5890l","updated":"20231120210758"},"Children":[{"Type":"NodeText","Data":"在观察者模式中，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"核心的角色包含三类：\n• Observer：观察者. 指的是关注事物动态的角色\n• Event：事物的变更事件. 其中 Topic 标识了事物的身份以及变更的类型，Val 是变更详情\n• EventBus：事件总线. 位于观察者与事物之间承上启下的代理层. 负责维护管理观察者，并且在事物发生变更时，将情况同步给每个观察者."}]},{"ID":"20231120162054-ru11prc","Type":"NodeParagraph","Properties":{"id":"20231120162054-ru11prc","updated":"20231120162054"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120162054-7m21yl5.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120164103-83ayjrl","Type":"NodeParagraph","Properties":{"id":"20231120164103-83ayjrl","updated":"20231120210805"},"Children":[{"Type":"NodeText","Data":"观察者模式的核心就在于建立了 EventBus 的角色. 由于 EventBus 模块的诞生，实现了观察者与具体被观察事物之间的解耦：\n• "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"针对于观察者而言，需要向 EventBus 完成注册操作，注册时需要声明自己关心的变更事件类型（调用 EventBus 的 Subscribe 方法），不再需要直接和事物打交道\n• 针对于事物而言，在其发生变更时，只需要将变更情况向 EventBus 统一汇报即可（调用 EventBus 的 Publish 方法），不再需要和每个观察者直接交互\n• 对于 EventBus，需要提前维护好每个观察者和被关注事物之间的映射关系，保证在变更事件到达时，能找到所有的观察者逐一进行通知（调用 Observer 的 OnChange 方法）"}]},{"ID":"20231120164214-ozyrdd7","Type":"NodeParagraph","Properties":{"id":"20231120164214-ozyrdd7","updated":"20231120210745"},"Children":[{"Type":"NodeText","Data":"三类角色组织生成的UML 类图如下所示："}]},{"ID":"20231120210745-88few5z","Type":"NodeParagraph","Properties":{"id":"20231120210745-88few5z"}},{"ID":"20231120211542-ea9l4lz","Type":"NodeParagraph","Properties":{"id":"20231120211542-ea9l4lz","updated":"20231120211542"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120211542-kz8cw67.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120211554-yxrhhwy","Type":"NodeParagraph","Properties":{"id":"20231120211554-yxrhhwy","updated":"20231120211603"},"Children":[{"Type":"NodeText","Data":"对应的代码实现示例展示如下："}]},{"ID":"20231120211603-ow5nrdx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120211603-ow5nrdx","updated":"20231120211833"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Event struct {\n  Topic string \n  Val interface{} \n}\n\ntype Observer interface {\n  OnChange(ctx context.Context, e *Event) error\n}\n\ntype EventBus interface {\n  Subscribe(topic string, o Observer)\n  Unsubscibe(topic string, o Observer)\n  Publish(ctx context.Context, e *Event)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120211841-9db6zen","Type":"NodeParagraph","Properties":{"id":"20231120211841-9db6zen","updated":"20231120211841"},"Children":[{"Type":"NodeText","Data":"观察者 Observer 需要实现 OnChange 方法，用于向 EventBus 暴露出通知自己的“联系方式”，并且在方法内部实现好当关注对象发生变更时，自己需要采取的处理逻辑."}]},{"ID":"20231120211841-yh3lj22","Type":"NodeParagraph","Properties":{"id":"20231120211841-yh3lj22","updated":"20231120211841"},"Children":[{"Type":"NodeText","Data":"下面给出一个简单的观察者实现示例 BaseObserver："}]},{"ID":"20231120211842-mze8126","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120211842-mze8126","updated":"20231120213612"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type BaseObserver struct {\n  name string\n}\n\nfunc NewBaseObserver(name string)  *BaseObserver {\n  return \u0026BaseObserver{\n      name: name,\n    }\n}\n\nfunc (b *BaseObserver) OnChange(ctx context.Context, e *Event) error {\n    fmt.Printf(\"   \")\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120212018-i7kuzep","Type":"NodeParagraph","Properties":{"id":"20231120212018-i7kuzep"}}]}