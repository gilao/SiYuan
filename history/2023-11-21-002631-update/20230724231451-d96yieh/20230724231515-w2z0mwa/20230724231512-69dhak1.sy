{"ID":"20230724231512-69dhak1","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f9c7","id":"20230724231512-69dhak1","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230724231512-69dhak1\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230724231513-zhegkes\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231120155610-pnav15u\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230724231513-zhegkes\u0026quot;,\u0026quot;focusStart\u0026quot;:1,\u0026quot;focusEnd\u0026quot;:1\u0026#125;","tags":"公众号-小徐先生的编程世界,设计模式-观察者模式","title":"2-Go 观察者模式","updated":"20231121002621"},"Children":[{"ID":"20230724231513-zhegkes","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230724231513-zhegkes","updated":"20231120155340"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/QOXh86eX8z5Ts4O1pky44g","TextMarkTextContent":"Go 观察者模式"},{"Type":"NodeText","Data":"原理介绍"}]},{"ID":"20231120155358-pbzz5ab","Type":"NodeParagraph","Properties":{"id":"20231120155358-pbzz5ab","updated":"20231120155608"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120155358-116vk3c.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120155553-wc4q0kl","Type":"NodeParagraph","Properties":{"id":"20231120155553-wc4q0kl","updated":"20231120155601"},"Children":[{"Type":"NodeText","Data":"本期基于 go 语言和大家探讨设计模式中的观察者模式. 观察者模式适用于多对一的订阅/发布场景.\n• ”多“：指的是有多名观察者\n• ”一“：指的是有一个被观察事物\n• ”订阅“：指的是观察者时刻关注着事物的动态\n• ”发布“：指的是事物状态发生变化时是透明公开的，能够正常进入到观察者的视线"}]},{"ID":"20231120155610-pnav15u","Type":"NodeParagraph","Properties":{"id":"20231120155610-pnav15u","updated":"20231120155622"},"Children":[{"Type":"NodeText","Data":"在上述场景中，我们了解到核心对象有两类，一类是“观察者”，一类是“被观察的事物”，且两者间在数量上存在多对一的映射关系."}]},{"ID":"20231120160813-lvav3n8","Type":"NodeParagraph","Properties":{"id":"20231120160813-lvav3n8","updated":"20231120160813"},"Children":[{"Type":"NodeText","Data":"在具体作编程实现时，上述场景的实现思路可以是百花齐放的，而观察者模式只是为我们提供了一种相对规范的设计实现思路，其遵循的核心宗旨是实现“观察者”与“被观察对象”之间的解耦，并将其设计为通用的模块，便于后续的扩展和复用."}]},{"ID":"20231120160813-0f7ofpg","Type":"NodeParagraph","Properties":{"id":"20231120160813-0f7ofpg","updated":"20231120160813"},"Children":[{"Type":"NodeText","Data":"学习设计模式时，我们脑海中需要中需要明白，教条是相对刻板的，而场景和问题则是灵活多变的，在工程实践中，我们避免生搬硬套，要做到因地制宜，随机应变."}]},{"ID":"20231120161646-d3ale6e","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231120161646-d3ale6e","updated":"20231120161653"},"Children":[{"Type":"NodeText","Data":"代码实践"}]},{"ID":"20231120161953-a5tre11","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120161953-a5tre11","updated":"20231120161958"},"Children":[{"Type":"NodeText","Data":"核心角色"}]},{"ID":"20231120162029-fn5890l","Type":"NodeParagraph","Properties":{"id":"20231120162029-fn5890l","updated":"20231120210758"},"Children":[{"Type":"NodeText","Data":"在观察者模式中，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"核心的角色包含三类：\n• Observer：观察者. 指的是关注事物动态的角色\n• Event：事物的变更事件. 其中 Topic 标识了事物的身份以及变更的类型，Val 是变更详情\n• EventBus：事件总线. 位于观察者与事物之间承上启下的代理层. 负责维护管理观察者，并且在事物发生变更时，将情况同步给每个观察者."}]},{"ID":"20231120162054-ru11prc","Type":"NodeParagraph","Properties":{"id":"20231120162054-ru11prc","updated":"20231120162054"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120162054-7m21yl5.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120164103-83ayjrl","Type":"NodeParagraph","Properties":{"id":"20231120164103-83ayjrl","updated":"20231120210805"},"Children":[{"Type":"NodeText","Data":"观察者模式的核心就在于建立了 EventBus 的角色. 由于 EventBus 模块的诞生，实现了观察者与具体被观察事物之间的解耦：\n• "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"针对于观察者而言，需要向 EventBus 完成注册操作，注册时需要声明自己关心的变更事件类型（调用 EventBus 的 Subscribe 方法），不再需要直接和事物打交道\n• 针对于事物而言，在其发生变更时，只需要将变更情况向 EventBus 统一汇报即可（调用 EventBus 的 Publish 方法），不再需要和每个观察者直接交互\n• 对于 EventBus，需要提前维护好每个观察者和被关注事物之间的映射关系，保证在变更事件到达时，能找到所有的观察者逐一进行通知（调用 Observer 的 OnChange 方法）"}]},{"ID":"20231120164214-ozyrdd7","Type":"NodeParagraph","Properties":{"id":"20231120164214-ozyrdd7","updated":"20231120210745"},"Children":[{"Type":"NodeText","Data":"三类角色组织生成的UML 类图如下所示："}]},{"ID":"20231120210745-88few5z","Type":"NodeParagraph","Properties":{"id":"20231120210745-88few5z"}},{"ID":"20231120211542-ea9l4lz","Type":"NodeParagraph","Properties":{"id":"20231120211542-ea9l4lz","updated":"20231120211542"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120211542-kz8cw67.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120211554-yxrhhwy","Type":"NodeParagraph","Properties":{"id":"20231120211554-yxrhhwy","updated":"20231120211603"},"Children":[{"Type":"NodeText","Data":"对应的代码实现示例展示如下："}]},{"ID":"20231120211603-ow5nrdx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120211603-ow5nrdx","updated":"20231120211833"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Event struct {\n  Topic string \n  Val interface{} \n}\n\ntype Observer interface {\n  OnChange(ctx context.Context, e *Event) error\n}\n\ntype EventBus interface {\n  Subscribe(topic string, o Observer)\n  Unsubscibe(topic string, o Observer)\n  Publish(ctx context.Context, e *Event)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120211841-9db6zen","Type":"NodeParagraph","Properties":{"id":"20231120211841-9db6zen","updated":"20231120211841"},"Children":[{"Type":"NodeText","Data":"观察者 Observer 需要实现 OnChange 方法，用于向 EventBus 暴露出通知自己的“联系方式”，并且在方法内部实现好当关注对象发生变更时，自己需要采取的处理逻辑."}]},{"ID":"20231120211841-yh3lj22","Type":"NodeParagraph","Properties":{"id":"20231120211841-yh3lj22","updated":"20231120211841"},"Children":[{"Type":"NodeText","Data":"下面给出一个简单的观察者实现示例 BaseObserver："}]},{"ID":"20231120211842-mze8126","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120211842-mze8126","updated":"20231120214436"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type BaseObserver struct {\n  name string\n}\n\nfunc NewBaseObserver(name string)  *BaseObserver {\n  return \u0026BaseObserver{\n      name: name,\n    }\n}\n\nfunc (b *BaseObserver) OnChange(ctx context.Context, e *Event) error {\n    fmt.Printf(\"observer: %s, event key: %s, event val: %v\", b.name,e.Topic, e.Val)\n    // ...\n    return nil\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120212018-i7kuzep","Type":"NodeParagraph","Properties":{"id":"20231120212018-i7kuzep","updated":"20231120214452"},"Children":[{"Type":"NodeText","Data":"事件总线 EventBus 需要实现 Subscribe 和 Unsubscribe 方法暴露给观察者，用于新增或删除订阅关系，其实现示例如下："}]},{"ID":"20231120214454-vgmadie","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120214454-vgmadie","updated":"20231120215250"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type BaseEventBus struct {\n\tmux       sync.RWMutex\n\tobservers map[string]map[Observer]struct{}\n}\n\n\nfunc NewBaseEventBus() BaseEventBus {\n\treturn BaseEventBus{\n\t\tobservers: make(map[string]map[Observer]struct{}),\n\t}\n}\n\n\nfunc (b *BaseEventBus) Subscribe(topic string, o Observer) {\n\tb.mux.Lock()\n\tdefer b.mux.Unlock()\n\t_, ok := b.observers[topic]\n\tif !ok {\n\t\tb.observers[topic] = make(map[Observer]struct{})\n\t}\n\tb.observers[topic][o] = struct{}{}\n}\n\n\nfunc (b *BaseEventBus) Unsubscribe(topic string, o Observer) {\n\tb.mux.Lock()\n\tdefer b.mux.Unlock()\n\tdelete(b.observers[topic], o)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120215324-sps4ay6","Type":"NodeParagraph","Properties":{"id":"20231120215324-sps4ay6","updated":"20231120215324"},"Children":[{"Type":"NodeText","Data":"针对 EventBus 将事物变更事件同步给每个观察者的 Publish 流程，可以分为同步模式和异步模式，分别在 2.2 小节和 2.3 小节中展开介绍."}]},{"ID":"20231120215733-qmde4n0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120215733-qmde4n0","updated":"20231120215747"},"Children":[{"Type":"NodeText","Data":"同步模式"}]},{"ID":"20231120215748-k0f16em","Type":"NodeParagraph","Properties":{"id":"20231120215748-k0f16em","updated":"20231120215759"},"Children":[{"Type":"NodeText","Data":"在同步模式的实现中，通过 SyncEventBus 实现了 EventBus 的同步通知版本，对应类图如下："}]},{"ID":"20231120220857-6avf3y3","Type":"NodeParagraph","Properties":{"id":"20231120220857-6avf3y3","updated":"20231120220857"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120220857-3l61bzc.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120220902-z16sbtp","Type":"NodeParagraph","Properties":{"id":"20231120220902-z16sbtp"}},{"ID":"20231120220912-2qfr0jj","Type":"NodeParagraph","Properties":{"id":"20231120220912-2qfr0jj","updated":"20231120220912"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231120220912-5m01l9s.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231120220914-ghv0oqz","Type":"NodeParagraph","Properties":{"id":"20231120220914-ghv0oqz","updated":"20231120220920"},"Children":[{"Type":"NodeText","Data":"在同步模式下，EventBus 在接受到变更事件 Event 时，会根据事件类型 Topic 匹配到对应的观察者列表 observers，然后采用串行遍历的方式分别调用 Observer.OnChange 方法对每个观察者进行通知，并对处理流程中遇到的错误进行聚合，放到 handleErr 方法中进行统一的后处理."}]},{"ID":"20231120222115-yx1s13g","Type":"NodeParagraph","Properties":{"id":"20231120222115-yx1s13g"}},{"ID":"20231120222115-5w140dg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120222115-5w140dg","updated":"20231120223853"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type SyncEventBus struct {\n\tBaseEventBus\n}\n\nfunc NewSyncEventBus() *SyncEventBus {\n\treturn \u0026SyncEventBus{\n\t\tBaseEventBus: NewBaseEventBus(),\n\t}\n}\n\nfunc (s *SyncEventBus) Publish(ctx context.Context, e *Event) {\n\ts.mux.RLock()\n\tsubscribers := s.observers[e.Topic]\n\ts.mux.RUnlock()\n\n\terrs := make(map[Observer]error)\n\tfor subscriber := range subscribers {\n\t\tif err := subscriber.OnChange(ctx, e); err != nil {\n\t\t\terrs[subscriber] = err\n\t\t}\n\t}\n\n\ts.handleErr(ctx, errs)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120223854-8b6qs43","Type":"NodeParagraph","Properties":{"id":"20231120223854-8b6qs43","updated":"20231120223901"},"Children":[{"Type":"NodeText","Data":"此处对 handleErr 方法的实现逻辑进行建立了简化，在真实的实践场景中，可以针对遇到的错误建立更完善的后处理流程，如采取重试或告知之类的操作."}]},{"ID":"20231120223902-5ururle","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231120223902-5ururle","updated":"20231120223947"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (s *SyncEventBus) handleErr(ctx context.Context, errs map[Observer]error) {\n\tfor o, err := range errs {\n\t\t// 处理 publish 失败的 observer\n\t\tfmt.Printf(\"observer: %v, err: %v\", o, err)\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231120224110-j7r4xjx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231120224110-j7r4xjx","updated":"20231120224115"},"Children":[{"Type":"NodeText","Data":"异步模式"}]},{"ID":"20231120224116-3kolgqu","Type":"NodeParagraph","Properties":{"id":"20231120224116-3kolgqu","updated":"20231120224318"},"Children":[{"Type":"NodeText","Data":"在异步模式的实现中，通过 AsyncEventBus 实现了 EventBus 的异步通知版本，对应类图如下："}]},{"ID":"20231121002533-49xlqsp","Type":"NodeParagraph","Properties":{"id":"20231121002533-49xlqsp","updated":"20231121002533"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231121002533-92u3uzq.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231121002533-lyklnkf","Type":"NodeParagraph","Properties":{"id":"20231121002533-lyklnkf"}},{"ID":"20231121002548-m2xb9bb","Type":"NodeParagraph","Properties":{"id":"20231121002548-m2xb9bb","updated":"20231121002548"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231121002548-lw0po21.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231121002619-scgfnrw","Type":"NodeParagraph","Properties":{"id":"20231121002619-scgfnrw","updated":"20231121002619"},"Children":[{"Type":"NodeText","Data":"在异步模式下，会在 EventBus 启动之初，异步启动一个守护协程，负责对接收到的错误进行后处理."}]},{"ID":"20231121002619-wkvaemj","Type":"NodeParagraph","Properties":{"id":"20231121002619-wkvaemj","updated":"20231121002619"},"Children":[{"Type":"NodeText","Data":"在事物发生变更时，EventBus 的 Publish 方法会被调用，此时 EventBus 会并发调用 Observer.OnChange 方法对每个观察者进行通知，在这个过程中遇到的错误会通过 channel 统一汇总到 handleErr 的守护协程中进行处理."}]},{"ID":"20231121002621-srpqzfn","Type":"NodeParagraph","Properties":{"id":"20231121002621-srpqzfn"}}]}