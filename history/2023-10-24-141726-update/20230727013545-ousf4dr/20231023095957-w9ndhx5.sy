{"ID":"20231023095957-w9ndhx5","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f6fa","id":"20231023095957-w9ndhx5","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20231023095957-w9ndhx5\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231023095957-3ljmjd7\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231023101210-mzlesi6\u0026quot;,\u0026quot;scrollTop\u0026quot;:5039,\u0026quot;focusId\u0026quot;:\u0026quot;20231023101210-mzlesi6\u0026quot;,\u0026quot;focusStart\u0026quot;:88,\u0026quot;focusEnd\u0026quot;:88\u0026#125;","tags":"公众号-捡田螺的小男孩,未完成","title":"接口请求合并，效率直接加倍","updated":"20231024141302"},"Children":[{"ID":"20231023095957-3ljmjd7","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231023095957-3ljmjd7","updated":"20231023100054"},"Children":[{"Type":"NodeText","Data":"请求合并到底有什么意义呢？"}]},{"ID":"20231023100224-95lyx3b","Type":"NodeParagraph","Properties":{"id":"20231023100224-95lyx3b"},"Children":[{"Type":"NodeText","Data":"我们来看下图。"}]},{"ID":"20231023100111-4zdk7ph","Type":"NodeParagraph","Properties":{"id":"20231023100111-4zdk7ph","updated":"20231023100111"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231023100111-5ndv8sw.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231023100120-j1i4i3b","Type":"NodeParagraph","Properties":{"id":"20231023100120-j1i4i3b","updated":"20231023100134"},"Children":[{"Type":"NodeText","Data":"假设我们3个用户（用户id分别是1、2、3），现在他们都要查询自己的基本信息，请求到服务器，服务器端请求数据库，发出3次请求。我们都知道数据库连接资源是相当宝贵的，那么我们怎么尽可能节省连接资源呢？"}]},{"ID":"20231023100135-gsa73hx","Type":"NodeBlockquote","Properties":{"id":"20231023100135-gsa73hx","updated":"20231023100143"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231023100142-1jrbva9","Type":"NodeParagraph","Properties":{"id":"20231023100142-1jrbva9","updated":"20231023100143"},"Children":[{"Type":"NodeText","Data":"这里把数据库换成被调用的远程服务，也是同样的道理。"}]}]},{"ID":"20231023100144-5bvaodv","Type":"NodeParagraph","Properties":{"id":"20231023100144-5bvaodv","updated":"20231023100147"},"Children":[{"Type":"NodeText","Data":"我们改变下思路，如下图所示。"}]},{"ID":"20231023100200-paiwnw3","Type":"NodeParagraph","Properties":{"id":"20231023100200-paiwnw3","updated":"20231023100200"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231023100200-axh754c.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231023100211-jog2s1v","Type":"NodeParagraph","Properties":{"id":"20231023100211-jog2s1v","updated":"20231023100211"},"Children":[{"Type":"NodeText","Data":"我们在服务器端把请求合并，只发出一条SQL查询数据库，数据库返回后，服务器端处理返回数据，根据一个唯一请求ID，把数据分组，返回给对应用户。"}]},{"ID":"20231023100214-zdst5dg","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231023100214-zdst5dg","updated":"20231023100236"},"Children":[{"Type":"NodeText","Data":"技术手段"}]},{"ID":"20231023100237-s8kf1o2","Type":"NodeList","ListData":{},"Properties":{"id":"20231023100237-s8kf1o2","updated":"20231023213711"},"Children":[{"ID":"20231023100238-fq0b6tx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231023100238-fq0b6tx","updated":"20231023213711"},"Children":[{"ID":"20231023100238-kt46k0o","Type":"NodeParagraph","Properties":{"id":"20231023100238-kt46k0o","updated":"20231023213711"},"Children":[{"Type":"NodeText","Data":"阻塞队列"}]}]},{"ID":"20231023100304-4j7n95u","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231023100304-4j7n95u","updated":"20231023213709"},"Children":[{"ID":"20231023100304-sl6pji1","Type":"NodeParagraph","Properties":{"id":"20231023100304-sl6pji1","updated":"20231023213709"},"Children":[{"Type":"NodeText","Data":"定时任务线程池"}]}]},{"ID":"20231023100336-vtevgvb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231023100336-vtevgvb","updated":"20231023213707"},"Children":[{"ID":"20231023100336-hkc3wfz","Type":"NodeParagraph","Properties":{"id":"20231023100336-hkc3wfz","updated":"20231023213707"},"Children":[{"Type":"NodeText","Data":"阻塞机制"}]}]}]},{"ID":"20231023101210-5w6wqjd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231023101210-5w6wqjd","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20231023101210-u1we805","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-u1we805","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"查询用户的代码"}]},{"ID":"20231023101210-htfa4pt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231023101210-htfa4pt","updated":"20231024101947"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"gorm.io/gorm\"\n)\n\ntype UserService struct {\n\tdb *gorm.DB\n}\n\ntype Users struct {\n\tId int64\n}\n\ntype Request struct {\n\tUserId    int64\n\tRequestId string\n}\n\nfunc NewUserService(db *gorm.DB) *UserService {\n\treturn \u0026UserService{db: db}\n}\n\nfunc (s *UserService) QueryUserByIdBatch(userReqs []Request) (map[string]Users, error) {\n\t// 提取所有用户ID\n\tuserIds := make([]int64, len(userReqs))\n\tfor i, req := range userReqs {\n\t\tuserIds[i] = req.UserId\n\t}\n\n\t// 查询\n\tvar users []Users\n\tif err := s.db.Where(\"id IN ?\", userIds).Find(\u0026users).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\t// 构建 id 到 users 的映射\n\tidToUsers := make(map[int64]Users)\n\tfor _, user := range users {\n\t\tidToUsers[user.Id] = user\n\t}\n\n\t// 构建requestId 到 Users 的映射\n\tresult := make(map[string]Users)\n\tfor _, req := range userReqs {\n\t\tif user, ok := idToUsers[req.UserId]; ok {\n\t\t\tresult[req.RequestId] = user\n\t\t} else {\n\t\t\tresult[req.RequestId] = Users{} // 这里用零值表示没数据\n\t\t}\n\t}\n\treturn result, nil\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231023101210-mout9v8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-mout9v8","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"合并请求的实现"}]},{"ID":"20231023101210-sknmgt2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231023101210-sknmgt2","updated":"20231024113801"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type UserWrapBatchService struct {\n\tuserService UserService\n\tqueue       chan *Request\n}\n\ntype Users struct {\n\tuserId int64\n\tname   string\n}\n\ntype Request struct {\n\trequestId         string\n\tuserId            int64\n\tcompletableFuture chan *Users\n}\n\nconst MaxTaskNum = 100\n\nfunc NewUserWrapBatchService(userService UserService) *UserWrapBatchService {\n\treturn \u0026UserWrapBatchService{\n\t\tuserService: userService,\n\t\tqueue:       make(chan *Request),\n\t}\n}\n\nfunc (s *UserWrapBatchService) Init() {\n\tticker := time.NewTicker(10 * time.Millisecond)\n\tgo func() {\n\t\tfor range ticker.C {\n\t\t\tsize := len(s.queue)\n\t\t\tif size == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar list []*Request\n\t\t\tfmt.Printf(\"合并了[%d] 个请求\\n\", size)\n\t\t\tfor i := 0; i \u003c size; i++ {\n\t\t\t\tif i \u003e MaxTaskNum {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\treq := \u003c-s.queue\n\t\t\t\tlist = append(list, req)\n\t\t\t}\n\t\t\tvar userReqs []*Request\n\t\t\tfor _, req := range list {\n\t\t\t\tuserReqs = append(userReqs, req)\n\t\t\t}\n\t\t\tresponse := s.userService.QueryUserByIdBatch(userReqs)\n\t\t\tfor _, req := range list {\n\t\t\t\tresult := response[req.requestId]\n\t\t\t\treq.completableFuture \u003c- result\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc (s *UserWrapBatchService) QueryUser(userId int64) *Users {\n\trequest := \u0026Request{\n\t\trequestId:         fmt.Sprintf(\"%d\", rand.Int63()),\n\t\tuserId:            userId,\n\t\tcompletableFuture: make(chan *Users),\n\t}\n\ts.queue \u003c- request\n\treturn \u003c-request.completableFuture\n}\n\ntype UserService struct{}\n\nfunc (s *UserService) QueryUserByIdBatch(reqs []*Request) map[string]*Users {\n\tvar wg sync.WaitGroup\n\tresult := make(map[string]*Users)\n\tfor _, req := range reqs {\n\t\twg.Add(1)\n\t\tgo func(req *Request) {\n\t\t\tdefer wg.Done()\n\t\t\tuser, err := s.queryUserById(req.userId)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresult[req.requestId] = user\n\t\t}(req)\n\t}\n\twg.Wait()\n\treturn result\n}\n\nfunc (s *UserService) queryUserById(userId int64) (*Users, error) {\n\ttime.Sleep(time.Duration(rand.Intn(10)) * time.Millisecond)\n\treturn \u0026Users{\n\t\tuserId: userId,\n\t\tname:   fmt.Sprintf(\"user_%d\", userId),\n\t}, nil\n}\n\nfunc main() {\n\tuserService := \u0026UserService{}\n\tbatchService := NewUserWrapBatchService(userService)\n\tbatchService.Init()\n\n\tfor i := 0; i \u003c 10; i++ {\n\t\tgo func(i int) {\n\t\t\tfor j := 0; j \u003c 10; j++ {\n\t\t\t\tuser := batchService.QueryUser(int64(i*10 + j))\n\t\t\t\tfmt.Printf(\"查询到用户： %+v\\n\", user)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\ttime.Sleep(1 * time.Second)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231023101210-b3by49b","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-b3by49b","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"控制层调用"}]},{"ID":"20231023101210-9bfgdkz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231023101210-9bfgdkz","updated":"20231024113753"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type UserBatchService struct{}\n\ntype UserController struct {\n\tuserBatchService *UserBatchService\n}\n\ntype Users struct {\n\tuserId int64\n\tname   string\n}\n\nfunc (c *UserController) merge(userId int64) func() *Users {\n\treturn func() *Users {\n\t\treturn c.userBatchService.queryUser(userId)\n\t}\n}\n\nfunc (s *UserBatchService) queryUser(userId int64) *Users {\n\ttime.Sleep(time.Duration(100) * time.Millisecond)\n\treturn \u0026Users{\n\t\tuserId: userId,\n\t\tname:   fmt.Sprintf(\"user_%d\", userId),\n\t}\n}\n\nfunc main() {\n\tuserBatchService := \u0026UserBatchService{}\n\tuserController := \u0026UserController{userBatchService: userBatchService}\n\n\tfor i:=0;i\u003c 10;i++ {\n\t\tgo func(i int) {\n\t\t\tfor j:=0;j\u003c10;j++ {\n\t\t\t\tuser := userController.merge(int64(i*10 + j))()\n\t\t\t\tfmt.Printf(\"查询到用户： %+v\\n\",user)\t\t\t\n\t\t\t}\n\t\t}(i)\n\t}\n\n\ttime.Sleep(1 *time.Second)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231023101210-7ohor64","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-7ohor64","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"模拟高并发查询的代码"}]},{"ID":"20231023101210-mv9cwcv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231023101210-mv9cwcv","updated":"20231024141148"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"var (\n\tthreadCount    = 30\n\tCountDownLatch sync.WaitGroup\n\tClient         = http.Client{}\n)\n\nfunc main() {\n\tCountDownLatch.Add(threadCount)\n\n\tfor i := 0; i \u003c threadCount; i++ {\n\t\tgo func() {\n\t\t\tCountDownLatch.Done()\n\t\t\tCountDownLatch.Wait()\n\t\t\tfor j := 1;j \u003c= 3;j++ {\n\t\t\t\tparam := rand.Intn(4)\n\t\t\t\tif param \u003c= 0 {\n\t\t\t\t\tparam++\n\t\t\t\t}\n\t\t\t\tresponse, err := Client.Get(fmt.Sprintf(\"http://localhost:8080/asyncAnddMerge/merge?userId=%d\",param))\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Printf(\"请求失败： %v\\n\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tdefer response.Body.Close()\n\t\t\t\n\t\t\t\tbody, err := io.ReadAll(response.Body)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Printf(\"读取响应失败： %v\\n\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfmt.Printf(\"参数 %d 返回值 %s\\n\", param, string(body))\n\t\t\t}\n\t\t}()\n\t\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231023101210-umqevdu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-umqevdu","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"测试效果"}]},{"ID":"20231024141204-qq8iemm","Type":"NodeParagraph","Properties":{"id":"20231024141204-qq8iemm"}},{"ID":"20231023101210-zv6fn6t","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-zv6fn6t","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"要注意的问题"}]},{"ID":"20231023101210-uooe793","Type":"NodeList","ListData":{},"Properties":{"id":"20231023101210-uooe793","updated":"20231024141239"},"Children":[{"ID":"20231023101210-ml15a2l","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231023101210-ml15a2l","updated":"20231024141239"},"Children":[{"ID":"20231023101210-xum5gso","Type":"NodeParagraph","Properties":{"id":"20231023101210-xum5gso","updated":"20231024141239"},"Children":[{"Type":"NodeText","Data":"阻塞机制并没有 timeout 机制"}]}]},{"ID":"20231023101210-pprbswr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231023101210-pprbswr","updated":"20231023101210"},"Children":[{"ID":"20231023101210-xjrxy6n","Type":"NodeParagraph","Properties":{"id":"20231023101210-xjrxy6n","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"后面的SQL语句是有长度限制的，所以还要做限制每次批量的数量,超过最大任务数，等下次执行（本例中加了MAX_TASK_NUM判断）"}]}]}]},{"ID":"20231023101210-9xep0gi","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231023101210-9xep0gi","updated":"20231024141302"},"Children":[{"Type":"NodeText","Data":"阻塞机制并没有 timeout 机制"}]},{"ID":"20231023101210-0u7i3hi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231023101210-0u7i3hi","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"核心代码"}]},{"ID":"20231023101210-2mkqvcc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231023101210-2mkqvcc","updated":"20231023101210"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"package com.springboot.sample.service.impl;\n\nimport com.springboot.sample.bean.Users;\nimport com.springboot.sample.service.UserService;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.Resource;\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/***\n * zzq\n * 包装成批量执行的地方，使用queue解决超时问题\n * */\n@Service\npublic class UserWrapBatchQueueService {\n    @Resource\n    private UserService userService;\n\n    /**\n     * 最大任务数\n     **/\n    public static int MAX_TASK_NUM = 100;\n\n\n    /**\n     * 请求类,code为查询的共同特征,例如查询商品,通过不同id的来区分\n     * CompletableFuture将处理结果返回\n     */\n    public class Request {\n        // 请求id\n        String requestId;\n\n        // 参数\n        Long userId;\n        // 队列，这个有超时机制\n        LinkedBlockingQueue\u003cUsers\u003e usersQueue;\n\n\n        public String getRequestId() {\n            return requestId;\n        }\n\n        public void setRequestId(String requestId) {\n            this.requestId = requestId;\n        }\n\n        public Long getUserId() {\n            return userId;\n        }\n\n        public void setUserId(Long userId) {\n            this.userId = userId;\n        }\n\n        public LinkedBlockingQueue\u003cUsers\u003e getUsersQueue() {\n            return usersQueue;\n        }\n\n        public void setUsersQueue(LinkedBlockingQueue\u003cUsers\u003e usersQueue) {\n            this.usersQueue = usersQueue;\n        }\n    }\n\n    /*\n    LinkedBlockingQueue是一个阻塞的队列,内部采用链表的结果,通过两个ReenTrantLock来保证线程安全\n    LinkedBlockingQueue与ArrayBlockingQueue的区别\n    ArrayBlockingQueue默认指定了长度,而LinkedBlockingQueue的默认长度是Integer.MAX_VALUE,也就是无界队列,在移除的速度小于添加的速度时，容易造成OOM。\n    ArrayBlockingQueue的存储容器是数组,而LinkedBlockingQueue是存储容器是链表\n    两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，\n    而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，\n    也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。\n     */\n    private final Queue\u003cRequest\u003e queue = new LinkedBlockingQueue();\n\n    @PostConstruct\n    public void init() {\n        //定时任务线程池,创建一个支持定时、周期性或延时任务的限定线程数目(这里传入的是1)的线程池\n        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);\n\n        scheduledExecutorService.scheduleAtFixedRate(() -\u003e {\n            int size = queue.size();\n            //如果队列没数据,表示这段时间没有请求,直接返回\n            if (size == 0) {\n                return;\n            }\n            List\u003cRequest\u003e list = new ArrayList\u003c\u003e();\n            System.out.println(\"合并了 [\" + size + \"] 个请求\");\n            //将队列的请求消费到一个集合保存\n            for (int i = 0; i \u003c size; i++) {\n                // 后面的SQL语句是有长度限制的，所以还要做限制每次批量的数量,超过最大任务数，等下次执行\n                if (i \u003c MAX_TASK_NUM) {\n                    list.add(queue.poll());\n                }\n            }\n            //拿到我们需要去数据库查询的特征,保存为集合\n            List\u003cRequest\u003e userReqs = new ArrayList\u003c\u003e();\n            for (Request request : list) {\n                userReqs.add(request);\n            }\n            //将参数传入service处理, 这里是本地服务，也可以把userService 看成RPC之类的远程调用\n            Map\u003cString, Users\u003e response = userService.queryUserByIdBatchQueue(userReqs);\n            for (Request userReq : userReqs) {\n                // 这里再把结果放到队列里\n                Users users = response.get(userReq.getRequestId());\n                userReq.usersQueue.offer(users);\n            }\n\n        }, 100, 10, TimeUnit.MILLISECONDS);\n        //scheduleAtFixedRate是周期性执行 schedule是延迟执行 initialDelay是初始延迟 period是周期间隔 后面是单位\n        //这里我写的是 初始化后100毫秒后执行，周期性执行10毫秒执行一次\n    }\n\n    public Users queryUser(Long userId) {\n        Request request = new Request();\n        // 这里用UUID做请求id\n        request.requestId = UUID.randomUUID().toString().replace(\"-\", \"\");\n        request.userId = userId;\n        LinkedBlockingQueue\u003cUsers\u003e usersQueue = new LinkedBlockingQueue\u003c\u003e();\n        request.usersQueue = usersQueue;\n        //将对象传入队列\n        queue.offer(request);\n        //取出元素时，如果队列为空，给定阻塞多少毫秒再队列取值，这里是3秒\n        try {\n            return usersQueue.poll(3000,TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n...省略..\n\n    @Override\n    public Map\u003cString, Users\u003e queryUserByIdBatchQueue(List\u003cUserWrapBatchQueueService.Request\u003e userReqs) {\n        // 全部参数\n        List\u003cLong\u003e userIds = userReqs.stream().map(UserWrapBatchQueueService.Request::getUserId).collect(Collectors.toList());\n        QueryWrapper\u003cUsers\u003e queryWrapper = new QueryWrapper\u003c\u003e();\n        // 用in语句合并成一条SQL，避免多次请求数据库的IO\n        queryWrapper.in(\"id\", userIds);\n        List\u003cUsers\u003e users = usersMapper.selectList(queryWrapper);\n        Map\u003cLong, List\u003cUsers\u003e\u003e userGroup = users.stream().collect(Collectors.groupingBy(Users::getId));\n        HashMap\u003cString, Users\u003e result = new HashMap\u003c\u003e();\n        // 数据分组\n        userReqs.forEach(val -\u003e {\n            List\u003cUsers\u003e usersList = userGroup.get(val.getUserId());\n            if (!CollectionUtils.isEmpty(usersList)) {\n                result.put(val.getRequestId(), usersList.get(0));\n            } else {\n                // 表示没数据 , 这里要new，不然加入队列会空指针\n                result.put(val.getRequestId(), new Users());\n            }\n        });\n        return result;\n    }\n\n...省略...\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231023101210-m3haon0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231023101210-m3haon0","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"小结"}]},{"ID":"20231023101210-mzlesi6","Type":"NodeParagraph","Properties":{"id":"20231023101210-mzlesi6","updated":"20231023101210"},"Children":[{"Type":"NodeText","Data":"请求合并，批量的办法能大幅节省被调用系统的连接资源，本例是以数据库为例，其他RPC调用也是类似的道理。缺点就是请求的时间在执行实际的逻辑之前增加了等待时间，不适合低并发的场景。"}]}]}