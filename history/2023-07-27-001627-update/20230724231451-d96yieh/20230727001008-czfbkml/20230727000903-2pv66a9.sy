{"ID":"20230727000903-2pv66a9","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230727000903-2pv66a9","title":"13. 并发安全和锁","updated":"20230727000903"},"Children":[{"ID":"20230727000904-sii6i4e","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230727000904-sii6i4e","updated":"20230727000904"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"13. 并发安全和锁"}]},{"ID":"20230727000905-vvy52c4","Type":"NodeParagraph","Properties":{"id":"20230727000905-vvy52c4","updated":"20230727000905"},"Children":[{"Type":"NodeText","Data":"有时候我们的代码中可能会存在多个 goroutine 同时操作一个资源（临界区）的情况，这种情况下就会发生"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"竞态问题"},{"Type":"NodeText","Data":"（数据竞态）。这就好比现实生活中十字路口被各个方向的汽车竞争，还有火车上的卫生间被车厢里的人竞争。"}]},{"ID":"20230727000906-9gr7ums","Type":"NodeParagraph","Properties":{"id":"20230727000906-9gr7ums","updated":"20230727000906"},"Children":[{"Type":"NodeText","Data":"我们用下面的代码演示一个数据竞争的示例。"}]},{"ID":"20230727000907-xtw2i88","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000907-xtw2i88","updated":"20230727000907"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar (\n\tx int64\n\n\twg sync.WaitGroup // 等待组\n)\n\n// add 对全局变量x执行5000次加1操作\nfunc add() {\n\tfor i := 0; i \u003c 5000; i++ {\n\t\tx = x + 1\n\t}\n\twg.Done()\n}\n\nfunc main() {\n\twg.Add(2)\n\n\tgo add()\n\tgo add()\n\n\twg.Wait()\n\tfmt.Println(x)\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000908-kpjboxb","Type":"NodeParagraph","Properties":{"id":"20230727000908-kpjboxb","updated":"20230727000908"},"Children":[{"Type":"NodeText","Data":"我们将上面的代码编译后执行，不出意外每次执行都会输出诸如9537、5865、6527等不同的结果。这是为什么呢？"}]},{"ID":"20230727000909-fxzumz3","Type":"NodeParagraph","Properties":{"id":"20230727000909-fxzumz3","updated":"20230727000909"},"Children":[{"Type":"NodeText","Data":"在上面的示例代码片中，我们开启了两个 goroutine 分别执行 add 函数，这两个 goroutine 在访问和修改全局的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":"变量时就会存在数据竞争，某个 goroutine 中对全局变量"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":"的修改可能会覆盖掉另一个 goroutine 中的操作，所以导致最后的结果与预期不符。"}]},{"ID":"20230727000910-v0sap6b","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000910-v0sap6b","updated":"20230727000910"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"互斥锁"}]},{"ID":"20230727000911-8s2q9w4","Type":"NodeParagraph","Properties":{"id":"20230727000911-8s2q9w4","updated":"20230727000911"},"Children":[{"Type":"NodeText","Data":"互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go 语言中使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync"},{"Type":"NodeText","Data":"包中提供的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"类型来实现互斥锁。"}]},{"ID":"20230727000912-pflf7qu","Type":"NodeParagraph","Properties":{"id":"20230727000912-pflf7qu","updated":"20230727000912"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ync.Mutex"},{"Type":"NodeText","Data":"提供了两个方法供我们使用。"}]},{"ID":"20230727000913-c1ve5wz","Type":"NodeTable","Data":"|          方法名          |    功能    |\n| :----------------------: | :--------: |\n|  func (m *Mutex) Lock()  | 获取互斥锁 |\n| func (m *Mutex) Unlock() | 释放互斥锁 |","TableAligns":[2,2],"Properties":{"id":"20230727000913-c1ve5wz","updated":"20230727000913"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"方法名"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"功能"}]}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (m *Mutex) Lock()"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"获取互斥锁"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (m *Mutex) Unlock()"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"释放互斥锁"}]}]}]},{"ID":"20230727000914-381ij7f","Type":"NodeParagraph","Properties":{"id":"20230727000914-381ij7f","updated":"20230727000914"},"Children":[{"Type":"NodeText","Data":"我们在下面的示例代码中使用互斥锁限制每次只有一个 goroutine 才能修改全局变量"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":"，从而修复上面代码中的问题。"}]},{"ID":"20230727000915-2dixrdk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000915-2dixrdk","updated":"20230727000915"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// sync.Mutex\n\nvar (\n\tx int64\n\n\twg sync.WaitGroup // 等待组\n\n\tm sync.Mutex // 互斥锁\n)\n\n// add 对全局变量x执行5000次加1操作\nfunc add() {\n\tfor i := 0; i \u003c 5000; i++ {\n\t\tm.Lock() // 修改x前加锁\n\t\tx = x + 1\n\t\tm.Unlock() // 改完解锁\n\t}\n\twg.Done()\n}\n\nfunc main() {\n\twg.Add(2)\n\n\tgo add()\n\tgo add()\n\n\twg.Wait()\n\tfmt.Println(x)\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000916-205f44f","Type":"NodeParagraph","Properties":{"id":"20230727000916-205f44f","updated":"20230727000916"},"Children":[{"Type":"NodeText","Data":"将上面的代码编译后多次执行，每一次都会得到预期中的结果——10000。"}]},{"ID":"20230727000917-yfsrmna","Type":"NodeParagraph","Properties":{"id":"20230727000917-yfsrmna","updated":"20230727000917"},"Children":[{"Type":"NodeText","Data":"使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，唤醒的策略是随机的。"}]},{"ID":"20230727000918-f3xbop8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000918-f3xbop8","updated":"20230727000918"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"读写互斥锁"}]},{"ID":"20230727000919-rr3aakv","Type":"NodeParagraph","Properties":{"id":"20230727000919-rr3aakv","updated":"20230727000919"},"Children":[{"Type":"NodeText","Data":"互斥锁是完全互斥的，但是实际上有很多场景是读多写少的，当我们并发的去读取一个资源而不涉及资源修改的时候是没有必要加互斥锁的，这种场景下使用读写锁是更好的一种选择。读写锁在 Go 语言中使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync"},{"Type":"NodeText","Data":"包中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RWMutex"},{"Type":"NodeText","Data":"类型。"}]},{"ID":"20230727000920-k6rku0x","Type":"NodeParagraph","Properties":{"id":"20230727000920-k6rku0x","updated":"20230727000920"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.RWMutex"},{"Type":"NodeText","Data":"提供了以下5个方法。"}]},{"ID":"20230727000921-265km6u","Type":"NodeTable","Data":"|               方法名                |              功能              |\n| :---------------------------------: | :----------------------------: |\n|      func (rw *RWMutex) Lock()      |            获取写锁            |\n|     func (rw *RWMutex) Unlock()     |            释放写锁            |\n|     func (rw *RWMutex) RLock()      |            获取读锁            |\n|    func (rw *RWMutex) RUnlock()     |            释放读锁            |\n| func (rw *RWMutex) RLocker() Locker | 返回一个实现Locker接口的读写锁 |","TableAligns":[2,2],"Properties":{"id":"20230727000921-265km6u","updated":"20230727000921"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"方法名"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"功能"}]}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (rw *RWMutex) Lock()"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"获取写锁"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (rw *RWMutex) Unlock()"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"释放写锁"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (rw *RWMutex) RLock()"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"获取读锁"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (rw *RWMutex) RUnlock()"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"释放读锁"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (rw *RWMutex) RLocker() Locker"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回一个实现Locker接口的读写锁"}]}]}]},{"ID":"20230727000922-4nmurtk","Type":"NodeParagraph","Properties":{"id":"20230727000922-4nmurtk","updated":"20230727000922"},"Children":[{"Type":"NodeText","Data":"读写锁分为两种：读锁和写锁。当一个 goroutine 获取到读锁之后，其他的 goroutine 如果是获取读锁会继续获得锁，如果是获取写锁就会等待；而当一个 goroutine 获取写锁之后，其他的 goroutine 无论是获取读锁还是写锁都会等待。"}]},{"ID":"20230727000923-jh2dsgu","Type":"NodeParagraph","Properties":{"id":"20230727000923-jh2dsgu","updated":"20230727000923"},"Children":[{"Type":"NodeText","Data":"下面我们使用代码构造一个读多写少的场景，然后分别使用互斥锁和读写锁查看它们的性能差异。"}]},{"ID":"20230727000924-aj6nuj7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000924-aj6nuj7","updated":"20230727000924"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"var (\n\tx       int64\n\twg      sync.WaitGroup\n\tmutex   sync.Mutex\n\trwMutex sync.RWMutex\n)\n\n// writeWithLock 使用互斥锁的写操作\nfunc writeWithLock() {\n\tmutex.Lock() // 加互斥锁\n\tx = x + 1\n\ttime.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒\n\tmutex.Unlock()                    // 解互斥锁\n\twg.Done()\n}\n\n// readWithLock 使用互斥锁的读操作\nfunc readWithLock() {\n\tmutex.Lock()                 // 加互斥锁\n\ttime.Sleep(time.Millisecond) // 假设读操作耗时1毫秒\n\tmutex.Unlock()               // 释放互斥锁\n\twg.Done()\n}\n\n// writeWithLock 使用读写互斥锁的写操作\nfunc writeWithRWLock() {\n\trwMutex.Lock() // 加写锁\n\tx = x + 1\n\ttime.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒\n\trwMutex.Unlock()                  // 释放写锁\n\twg.Done()\n}\n\n// readWithRWLock 使用读写互斥锁的读操作\nfunc readWithRWLock() {\n\trwMutex.RLock()              // 加读锁\n\ttime.Sleep(time.Millisecond) // 假设读操作耗时1毫秒\n\trwMutex.RUnlock()            // 释放读锁\n\twg.Done()\n}\n\nfunc do(wf, rf func(), wc, rc int) {\n\tstart := time.Now()\n\t// wc个并发写操作\n\tfor i := 0; i \u003c wc; i++ {\n\t\twg.Add(1)\n\t\tgo wf()\n\t}\n\n\t//  rc个并发读操作\n\tfor i := 0; i \u003c rc; i++ {\n\t\twg.Add(1)\n\t\tgo rf()\n\t}\n\n\twg.Wait()\n\tcost := time.Since(start)\n\tfmt.Printf(\"x:%v cost:%v\\n\", x, cost)\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000925-cl92klt","Type":"NodeParagraph","Properties":{"id":"20230727000925-cl92klt","updated":"20230727000925"},"Children":[{"Type":"NodeText","Data":"我们假设每一次读操作都会耗时1ms，而每一次写操作会耗时10ms，我们分别测试使用互斥锁和读写互斥锁执行10次并发写和1000次并发读的耗时数据"}]},{"ID":"20230727000926-bakijg3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000926-bakijg3","updated":"20230727000926"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 使用互斥锁，10并发写，1000并发读\ndo(writeWithLock, readWithLock, 10, 1000) // x:10 cost:1.466500951s\n\n// 使用读写互斥锁，10并发写，1000并发读\ndo(writeWithRWLock, readWithRWLock, 10, 1000) // x:10 cost:117.207592ms\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000927-min9nyv","Type":"NodeParagraph","Properties":{"id":"20230727000927-min9nyv","updated":"20230727000927"},"Children":[{"Type":"NodeText","Data":"从最终的执行结果可以看出，使用读写互斥锁在读多写少的场景下能够极大地提高程序的性能。不过需要注意的是如果一个程序中的读操作和写操作数量级差别不大，那么读写互斥锁的优势就发挥不出来。"}]},{"ID":"20230727000928-w90sy2c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000928-w90sy2c","updated":"20230727000928"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"sync.WaitGroup"}]},{"ID":"20230727000929-x2tc5nx","Type":"NodeParagraph","Properties":{"id":"20230727000929-x2tc5nx","updated":"20230727000929"},"Children":[{"Type":"NodeText","Data":"在代码中生硬的使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"time.Sleep"},{"Type":"NodeText","Data":"肯定是不合适的，Go语言中可以使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.WaitGroup"},{"Type":"NodeText","Data":"来实现并发任务的同步。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.WaitGroup"},{"Type":"NodeText","Data":"有以下几个方法："}]},{"ID":"20230727000930-szh8vdh","Type":"NodeTable","Data":"|                方法名                |        功能         |\n| :----------------------------------: | :-----------------: |\n| func (wg * WaitGroup) Add(delta int) |    计数器+delta     |\n|        (wg *WaitGroup) Done()        |      计数器-1       |\n|        (wg *WaitGroup) Wait()        | 阻塞直到计数器变为0 |","TableAligns":[2,2],"Properties":{"id":"20230727000930-szh8vdh","updated":"20230727000930"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"方法名"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"功能"}]}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (wg * WaitGroup) Add(delta int)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"计数器+delta"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"(wg *WaitGroup) Done()"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"计数器-1"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"(wg *WaitGroup) Wait()"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"阻塞直到计数器变为0"}]}]}]},{"ID":"20230727000931-zo1a3qx","Type":"NodeParagraph","Properties":{"id":"20230727000931-zo1a3qx","updated":"20230727000931"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.WaitGroup"},{"Type":"NodeText","Data":"内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 Done 方法将计数器减1。通过调用 Wait 来等待并发任务执行完，当计数器值为 0 时，表示所有并发任务已经完成。"}]},{"ID":"20230727000932-myjnp5d","Type":"NodeParagraph","Properties":{"id":"20230727000932-myjnp5d","updated":"20230727000932"},"Children":[{"Type":"NodeText","Data":"我们利用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.WaitGroup"},{"Type":"NodeText","Data":"将上面的代码优化一下："}]},{"ID":"20230727000933-kqir8tu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000933-kqir8tu","updated":"20230727000933"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"var wg sync.WaitGroup\n\nfunc hello() {\n\tdefer wg.Done()\n\tfmt.Println(\"Hello Goroutine!\")\n}\nfunc main() {\n\twg.Add(1)\n\tgo hello() // 启动另外一个goroutine去执行hello函数\n\tfmt.Println(\"main goroutine done!\")\n\twg.Wait()\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000934-gm37mdd","Type":"NodeParagraph","Properties":{"id":"20230727000934-gm37mdd","updated":"20230727000934"},"Children":[{"Type":"NodeText","Data":"需要注意"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.WaitGroup"},{"Type":"NodeText","Data":"是一个结构体，进行参数传递的时候要传递指针。"}]},{"ID":"20230727000935-5l6wlw6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000935-5l6wlw6","updated":"20230727000935"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"sync.Once"}]},{"ID":"20230727000936-4sgg0m3","Type":"NodeParagraph","Properties":{"id":"20230727000936-4sgg0m3","updated":"20230727000936"},"Children":[{"Type":"NodeText","Data":"在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。"}]},{"ID":"20230727000937-cuugklt","Type":"NodeParagraph","Properties":{"id":"20230727000937-cuugklt","updated":"20230727000937"},"Children":[{"Type":"NodeText","Data":"Go 语言中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync"},{"Type":"NodeText","Data":"包中提供了一个针对只执行一次场景的解决方案——"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.Once"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.Once"},{"Type":"NodeText","Data":"只有一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Do"},{"Type":"NodeText","Data":"方法，其签名如下："}]},{"ID":"20230727000938-nas3jl6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000938-nas3jl6","updated":"20230727000938"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func (o *Once) Do(f func())\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000939-ras5h8i","Type":"NodeParagraph","Properties":{"id":"20230727000939-ras5h8i","updated":"20230727000939"},"Children":[{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeText","Data":"注意："},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]},{"Type":"NodeText","Data":"如果要执行的函数"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"f"},{"Type":"NodeText","Data":"需要传递参数就需要搭配闭包来使用。"}]},{"ID":"20230727000940-mg9dv92","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000940-mg9dv92","updated":"20230727000940"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"加载配置文件示例"}]},{"ID":"20230727000941-lm32x0l","Type":"NodeParagraph","Properties":{"id":"20230727000941-lm32x0l","updated":"20230727000941"},"Children":[{"Type":"NodeText","Data":"延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子："}]},{"ID":"20230727000942-46i3rmp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000942-46i3rmp","updated":"20230727000942"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"var icons map[string]image.Image\n\nfunc loadIcons() {\n\ticons = map[string]image.Image{\n\t\t\"left\":  loadIcon(\"left.png\"),\n\t\t\"up\":    loadIcon(\"up.png\"),\n\t\t\"right\": loadIcon(\"right.png\"),\n\t\t\"down\":  loadIcon(\"down.png\"),\n\t}\n}\n\n// Icon 被多个goroutine调用时不是并发安全的\nfunc Icon(name string) image.Image {\n\tif icons == nil {\n\t\tloadIcons()\n\t}\n\treturn icons[name]\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000943-5wm1x0v","Type":"NodeParagraph","Properties":{"id":"20230727000943-5wm1x0v","updated":"20230727000943"},"Children":[{"Type":"NodeText","Data":"多个 goroutine 并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个 goroutine 都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果："}]},{"ID":"20230727000944-48fu7dt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000944-48fu7dt","updated":"20230727000944"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func loadIcons() {\n\ticons = make(map[string]image.Image)\n\ticons[\"left\"] = loadIcon(\"left.png\")\n\ticons[\"up\"] = loadIcon(\"up.png\")\n\ticons[\"right\"] = loadIcon(\"right.png\")\n\ticons[\"down\"] = loadIcon(\"down.png\")\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000945-8u49prb","Type":"NodeParagraph","Properties":{"id":"20230727000945-8u49prb","updated":"20230727000945"},"Children":[{"Type":"NodeText","Data":"在这种情况下就会出现即使判断了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"icons"},{"Type":"NodeText","Data":"不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"icons"},{"Type":"NodeText","Data":"的时候不会被其他的 goroutine 操作，但是这样做又会引发性能问题。"}]},{"ID":"20230727000946-lz8b962","Type":"NodeParagraph","Properties":{"id":"20230727000946-lz8b962","updated":"20230727000946"},"Children":[{"Type":"NodeText","Data":"使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.Once"},{"Type":"NodeText","Data":"改造的示例代码如下："}]},{"ID":"20230727000947-ytv81pj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000947-ytv81pj","updated":"20230727000947"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"var icons map[string]image.Image\n\nvar loadIconsOnce sync.Once\n\nfunc loadIcons() {\n\ticons = map[string]image.Image{\n\t\t\"left\":  loadIcon(\"left.png\"),\n\t\t\"up\":    loadIcon(\"up.png\"),\n\t\t\"right\": loadIcon(\"right.png\"),\n\t\t\"down\":  loadIcon(\"down.png\"),\n\t}\n}\n\n// Icon 是并发安全的\nfunc Icon(name string) image.Image {\n\tloadIconsOnce.Do(loadIcons)\n\treturn icons[name]\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000948-simjmcd","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230727000948-simjmcd","updated":"20230727000948"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"并发安全的单例模式"}]},{"ID":"20230727000949-t11thtq","Type":"NodeParagraph","Properties":{"id":"20230727000949-t11thtq","updated":"20230727000949"},"Children":[{"Type":"NodeText","Data":"下面是借助"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.Once"},{"Type":"NodeText","Data":"实现的并发安全的单例模式："}]},{"ID":"20230727000950-4mh40qp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000950-4mh40qp","updated":"20230727000950"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package singleton\n\nimport (\n    \"sync\"\n)\n\ntype singleton struct {}\n\nvar instance *singleton\nvar once sync.Once\n\nfunc GetInstance() *singleton {\n    once.Do(func() {\n        instance = \u0026singleton{}\n    })\n    return instance\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000951-etrqu21","Type":"NodeParagraph","Properties":{"id":"20230727000951-etrqu21","updated":"20230727000951"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.Once"},{"Type":"NodeText","Data":"其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。"}]},{"ID":"20230727000952-eixag2t","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000952-eixag2t","updated":"20230727000952"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"sync.Map"}]},{"ID":"20230727000953-kgf1osy","Type":"NodeParagraph","Properties":{"id":"20230727000953-kgf1osy","updated":"20230727000953"},"Children":[{"Type":"NodeText","Data":"Go 语言中内置的 map 不是并发安全的，请看下面这段示例代码。"}]},{"ID":"20230727000954-008sjcl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000954-008sjcl","updated":"20230727000954"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"sync\"\n)\n\nvar m = make(map[string]int)\n\nfunc get(key string) int {\n\treturn m[key]\n}\n\nfunc set(key string, value int) {\n\tm[key] = value\n}\n\nfunc main() {\n\twg := sync.WaitGroup{}\n\tfor i := 0; i \u003c 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(n int) {\n\t\t\tkey := strconv.Itoa(n)\n\t\t\tset(key, n)\n\t\t\tfmt.Printf(\"k=:%v,v:=%v\\n\", key, get(key))\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\twg.Wait()\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000955-kwa3v99","Type":"NodeParagraph","Properties":{"id":"20230727000955-kwa3v99","updated":"20230727000955"},"Children":[{"Type":"NodeText","Data":"将上面的代码编译后执行，会报出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fatal error: concurrent map writes"},{"Type":"NodeText","Data":"错误。我们不能在多个 goroutine 中并发对内置的 map 进行读写操作，否则会存在数据竞争问题。"}]},{"ID":"20230727000956-hg2w3cn","Type":"NodeParagraph","Properties":{"id":"20230727000956-hg2w3cn","updated":"20230727000956"},"Children":[{"Type":"NodeText","Data":"像这种场景下就需要为 map 加锁来保证并发的安全性了，Go语言的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync"},{"Type":"NodeText","Data":"包中提供了一个开箱即用的并发安全版 map——"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.Map"},{"Type":"NodeText","Data":"。开箱即用表示其不用像内置的 map 一样使用 make 函数初始化就能直接使用。同时"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.Map"},{"Type":"NodeText","Data":"内置了诸如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Store"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Load"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LoadOrStore"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Delete"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Range"},{"Type":"NodeText","Data":"等操作方法。"}]},{"ID":"20230727000957-upvr1gg","Type":"NodeTable","Data":"|                            方法名                            |              功能               |\n| :----------------------------------------------------------: | :-----------------------------: |\n|         func (m *Map) Store(key, value interface{})          |        存储key-value数据        |\n| func (m *Map) Load(key interface{}) (value interface{}, ok bool) |       查询key对应的value        |\n| func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) |    查询或存储key对应的value     |\n| func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool) |          查询并删除key          |\n|            func (m *Map) Delete(key interface{})             |             删除key             |\n|   func (m *Map) Range(f func(key, value interface{}) bool)   | 对map中的每个key-value依次调用f |","TableAligns":[2,2],"Properties":{"id":"20230727000957-upvr1gg","updated":"20230727000957"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"方法名"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"功能"}]}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (m *Map) Store(key, value interface{})"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"存储key-value数据"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (m *Map) Load(key interface{}) (value interface{}, ok bool)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"查询key对应的value"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"查询或存储key对应的value"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"查询并删除key"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (m *Map) Delete(key interface{})"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"删除key"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func (m *Map) Range(f func(key, value interface{}) bool)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"对map中的每个key-value依次调用f"}]}]}]},{"ID":"20230727000958-j8i27wo","Type":"NodeParagraph","Properties":{"id":"20230727000958-j8i27wo","updated":"20230727000958"},"Children":[{"Type":"NodeText","Data":"下面的代码示例演示了并发读写"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.Map"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230727000959-mcvtn1b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000959-mcvtn1b","updated":"20230727000959"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"sync\"\n)\n\n// 并发安全的map\nvar m = sync.Map{}\n\nfunc main() {\n\twg := sync.WaitGroup{}\n\t// 对m执行20个并发的读写操作\n\tfor i := 0; i \u003c 20; i++ {\n\t\twg.Add(1)\n\t\tgo func(n int) {\n\t\t\tkey := strconv.Itoa(n)\n\t\t\tm.Store(key, n)         // 存储key-value\n\t\t\tvalue, _ := m.Load(key) // 根据key取值\n\t\t\tfmt.Printf(\"k=:%v,v:=%v\\n\", key, value)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\twg.Wait()\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000960-an5pjl2","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000960-an5pjl2","updated":"20230727000960"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"原子操作"}]},{"ID":"20230727000961-10i3zm4","Type":"NodeParagraph","Properties":{"id":"20230727000961-10i3zm4","updated":"20230727000961"},"Children":[{"Type":"NodeText","Data":"针对整数数据类型（int32、uint32、int64、uint64）我们还可以使用原子操作来保证并发安全，通常直接使用原子操作比使用锁操作效率更高。Go语言中原子操作由内置的标准库"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync/atomic"},{"Type":"NodeText","Data":"提供。"}]},{"ID":"20230727000962-9b7j5zt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000962-9b7j5zt","updated":"20230727000962"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"atomic包"}]},{"ID":"20230727000963-fg711sd","Type":"NodeTable","Data":"|                             方法                             |      解释      |\n| :----------------------------------------------------------: | :------------: |\n| func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer) |    读取操作    |\n| func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer) |    写入操作    |\n| func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) |    修改操作    |\n| func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer) |    交换操作    |\n| func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool) | 比较并交换操作 |","TableAligns":[2,2],"Properties":{"id":"20230727000963-fg711sd","updated":"20230727000963"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"方法"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"解释"}]}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"读取操作"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"写入操作"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"修改操作"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"交换操作"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"比较并交换操作"}]}]}]},{"ID":"20230727000964-empu2vp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000964-empu2vp","updated":"20230727000964"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"示例"}]},{"ID":"20230727000965-h6j5uvf","Type":"NodeParagraph","Properties":{"id":"20230727000965-h6j5uvf","updated":"20230727000965"},"Children":[{"Type":"NodeText","Data":"我们填写一个示例来比较下互斥锁和原子操作的性能。"}]},{"ID":"20230727000966-kdryki4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000966-kdryki4","updated":"20230727000966"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype Counter interface {\n\tInc()\n\tLoad() int64\n}\n\n// 普通版\ntype CommonCounter struct {\n\tcounter int64\n}\n\nfunc (c CommonCounter) Inc() {\n\tc.counter++\n}\n\nfunc (c CommonCounter) Load() int64 {\n\treturn c.counter\n}\n\n// 互斥锁版\ntype MutexCounter struct {\n\tcounter int64\n\tlock    sync.Mutex\n}\n\nfunc (m *MutexCounter) Inc() {\n\tm.lock.Lock()\n\tdefer m.lock.Unlock()\n\tm.counter++\n}\n\nfunc (m *MutexCounter) Load() int64 {\n\tm.lock.Lock()\n\tdefer m.lock.Unlock()\n\treturn m.counter\n}\n\n// 原子操作版\ntype AtomicCounter struct {\n\tcounter int64\n}\n\nfunc (a *AtomicCounter) Inc() {\n\tatomic.AddInt64(\u0026a.counter, 1)\n}\n\nfunc (a *AtomicCounter) Load() int64 {\n\treturn atomic.LoadInt64(\u0026a.counter)\n}\n\nfunc test(c Counter) {\n\tvar wg sync.WaitGroup\n\tstart := time.Now()\n\tfor i := 0; i \u003c 1000; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tc.Inc()\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n\tend := time.Now()\n\tfmt.Println(c.Load(), end.Sub(start))\n}\n\nfunc main() {\n\tc1 := CommonCounter{} // 非并发安全\n\ttest(c1)\n\tc2 := MutexCounter{} // 使用互斥锁实现并发安全\n\ttest(\u0026c2)\n\tc3 := AtomicCounter{} // 并发安全且比互斥锁效率更高\n\ttest(\u0026c3)\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000967-2npaw19","Type":"NodeParagraph","Properties":{"id":"20230727000967-2npaw19","updated":"20230727000967"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"atomic"},{"Type":"NodeText","Data":"包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者 sync 包的函数/类型实现同步更好。"}]}]}