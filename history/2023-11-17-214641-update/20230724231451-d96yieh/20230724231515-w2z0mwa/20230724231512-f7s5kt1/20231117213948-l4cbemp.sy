{"ID":"20231117213948-l4cbemp","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f306","id":"20231117213948-l4cbemp","tags":"公众号-Golang语言开发栈","title":"Go 语言实现创建型设计模式-工厂模式","updated":"20231117214108"},"Children":[{"ID":"20231117214028-y0ywopu","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231117214028-y0ywopu","updated":"20231117214031"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20231117214044-r6ozkbw","Type":"NodeParagraph","Properties":{"id":"20231117214044-r6ozkbw","updated":"20231117214044"},"Children":[{"Type":"NodeText","Data":"工厂模式是一种创建型设计模式，包含三种类型，分别是简单工厂、工厂方法和抽象工厂。"}]},{"ID":"20231117214044-4etj0wr","Type":"NodeParagraph","Properties":{"id":"20231117214044-4etj0wr","updated":"20231117214044"},"Children":[{"Type":"NodeText","Data":"在《设计模式》"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[1]"},{"Type":"NodeText","Data":"一书中，因为 GoF"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[2]"},{"Type":"NodeText","Data":" 认为简单工厂是工厂方法的一种特例，所以 GoF 把工厂模式分为两种类型，分别是工厂方法和抽象工厂。"}]},{"ID":"20231117214044-kh0qwwb","Type":"NodeParagraph","Properties":{"id":"20231117214044-kh0qwwb","updated":"20231117214044"},"Children":[{"Type":"NodeText","Data":"本文我们使用第一种分类方式，分别介绍一下工厂模式的三种类型。"}]},{"ID":"20231117214046-j488395","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231117214046-j488395","updated":"20231117214051"},"Children":[{"Type":"NodeText","Data":"使用场景"}]},{"ID":"20231117214105-ahi8o1w","Type":"NodeParagraph","Properties":{"id":"20231117214105-ahi8o1w","updated":"20231117214105"},"Children":[{"Type":"NodeText","Data":"在介绍工厂模式的使用场景之前，我们需要先简单了解工厂模式的组成结构，一般分为抽象产品、具体产品、抽象工厂和具体工厂。"}]},{"ID":"20231117214105-u650tlf","Type":"NodeBlockquote","Properties":{"id":"20231117214105-u650tlf","updated":"20231117214105"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231117214105-scgaweh","Type":"NodeParagraph","Properties":{"id":"20231117214105-scgaweh","updated":"20231117214105"},"Children":[{"Type":"NodeText","Data":"注意：简单工厂模式，不区分抽象工厂和具体工厂。"}]}]},{"ID":"20231117214105-kijoagq","Type":"NodeParagraph","Properties":{"id":"20231117214105-kijoagq","updated":"20231117214105"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"简单工厂"}]},{"ID":"20231117214105-wv792hj","Type":"NodeParagraph","Properties":{"id":"20231117214105-wv792hj","updated":"20231117214105"},"Children":[{"Type":"NodeText","Data":"简单工厂适用于具体产品较少，且不会频繁添加具体产品的场景。因为每多一个具体产品，在工厂中就多一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"if"},{"Type":"NodeText","Data":"​ 分支。"}]},{"ID":"20231117214105-wy29igu","Type":"NodeParagraph","Properties":{"id":"20231117214105-wy29igu","updated":"20231117214105"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"工厂方法"}]},{"ID":"20231117214105-15za05h","Type":"NodeParagraph","Properties":{"id":"20231117214105-15za05h","updated":"20231117214105"},"Children":[{"Type":"NodeText","Data":"工厂方法适用于具体产品较多，且需要频繁添加具体产品的场景。使用工厂方法可以避免使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"if"},{"Type":"NodeText","Data":"​ 分支，当我们需要添加具体产品时，只需创建新的具体产品和具体工厂，符合开闭原则和单一职责原则。"}]},{"ID":"20231117214105-dxb81g5","Type":"NodeParagraph","Properties":{"id":"20231117214105-dxb81g5","updated":"20231117214105"},"Children":[{"Type":"NodeText","Data":"而且还可以将每个具体产品的创建逻辑拆分到不同的工厂中，避免使用一个工厂导致的代码过于复杂。"}]},{"ID":"20231117214105-rkv2lg7","Type":"NodeBlockquote","Properties":{"id":"20231117214105-rkv2lg7","updated":"20231117214105"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231117214105-sd1gvqb","Type":"NodeParagraph","Properties":{"id":"20231117214105-sd1gvqb","updated":"20231117214105"},"Children":[{"Type":"NodeText","Data":"注意：拆分多个工厂，则需要维护多个工厂的代码。"}]}]},{"ID":"20231117214105-0s1jlug","Type":"NodeParagraph","Properties":{"id":"20231117214105-0s1jlug","updated":"20231117214105"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"抽象工厂"}]},{"ID":"20231117214105-ijhhje0","Type":"NodeParagraph","Properties":{"id":"20231117214105-ijhhje0","updated":"20231117214105"},"Children":[{"Type":"NodeText","Data":"抽象工厂适用于一个具体工厂需要负责生产多个不同产品，并且工厂的职责不会继续增加的场景（即抽象工厂定义的一组方法不会继续增加）。"}]},{"ID":"20231117214105-hdv83qr","Type":"NodeParagraph","Properties":{"id":"20231117214105-hdv83qr","updated":"20231117214105"},"Children":[{"Type":"NodeText","Data":"否则，不仅所有具体工厂都需要修改，抽象产品和具体产品也需要修改，违反开闭原则。"}]},{"ID":"20231117214108-1ia1wu2","Type":"NodeParagraph","Properties":{"id":"20231117214108-1ia1wu2"}},{"ID":"20231117213948-87foa41","Type":"NodeParagraph","Properties":{"id":"20231117213948-87foa41","updated":"20231117213948"}}]}