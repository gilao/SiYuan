{"ID":"20230723215240-d0zgd1a","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f41d","id":"20230723215240-d0zgd1a","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230723215240-d0zgd1a\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230723215313-6m74v4s\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230723215313-4mt5y8z\u0026quot;,\u0026quot;scrollTop\u0026quot;:302\u0026#125;","tags":"动态规划,go代码,动态规划解题方法","title":"图解动态规划的解题四步骤","updated":"20230723215313"},"Children":[{"ID":"20230723215313-6m74v4s","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230723215313-6m74v4s","updated":"20230723215313"},"Children":[{"Type":"NodeText","Data":"小偷问题"}]},{"ID":"20230723215313-khudq2v","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230723215313-khudq2v","updated":"20230723215313"},"Children":[{"Type":"NodeText","Data":"问题"}]},{"ID":"20230723215313-c6jp4if","Type":"NodeParagraph","Properties":{"id":"20230723215313-c6jp4if","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，****如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230723215313-rse9eeh","Type":"NodeParagraph","Properties":{"id":"20230723215313-rse9eeh","updated":"20230723215313"},"Children":[{"Type":"NodeText","Data":"**给定一个代表每个房屋存放金额的非负整数数组，计算你 **"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"不触动警报装置的情况下"},{"Type":"NodeText","Data":" ，一夜之内能够偷窃到的最高金额。"}]},{"ID":"20230723215313-iw6mkjd","Type":"NodeParagraph","Properties":{"id":"20230723215313-iw6mkjd","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例 1："}]},{"ID":"20230723215313-ags81ep","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230723215313-ags81ep","updated":"20230723215313"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230723215313-2xrr6tv","Type":"NodeParagraph","Properties":{"id":"20230723215313-2xrr6tv","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例 2："}]},{"ID":"20230723215313-mwo5try","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230723215313-mwo5try","updated":"20230723215313"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"输入：[2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230723215313-udxbs94","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230723215313-udxbs94","updated":"20230723215313"},"Children":[{"Type":"NodeText","Data":"解题思路"}]},{"ID":"20230723215313-53q4ibj","Type":"NodeParagraph","Properties":{"id":"20230723215313-53q4ibj","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"动态规划的四个解题步骤是："}]},{"ID":"20230723215313-zdt2idp","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20230723215313-zdt2idp","updated":"20230723215313"},"Children":[{"ID":"20230723215313-95mntuc","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20230723215313-95mntuc","updated":"20230723215313"},"Children":[{"ID":"20230723215313-awdo5ot","Type":"NodeParagraph","Properties":{"id":"20230723215313-awdo5ot","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"定义子问题"}]}]},{"ID":"20230723215313-vxlakoe","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20230723215313-vxlakoe","updated":"20230723215313"},"Children":[{"ID":"20230723215313-odcs1wv","Type":"NodeParagraph","Properties":{"id":"20230723215313-odcs1wv","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"写出子问题的递推关系"}]}]},{"ID":"20230723215313-5xn9a94","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20230723215313-5xn9a94","updated":"20230723215313"},"Children":[{"ID":"20230723215313-zobh8mq","Type":"NodeParagraph","Properties":{"id":"20230723215313-zobh8mq","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"确定DP数组的计算顺序"}]}]},{"ID":"20230723215313-8qkimmb","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20230723215313-8qkimmb","updated":"20230723215313"},"Children":[{"ID":"20230723215313-2m0ox00","Type":"NodeParagraph","Properties":{"id":"20230723215313-2m0ox00","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"空间优化"}]}]}]},{"ID":"20230723215313-hpqcjfa","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230723215313-hpqcjfa","updated":"20230723215313"},"Children":[{"Type":"NodeText","Data":"步骤一、定义子问题"}]},{"ID":"20230723215313-32i4nc1","Type":"NodeParagraph","Properties":{"id":"20230723215313-32i4nc1","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"什么是子问题？子问题就是和原问题相似，但规模比较小的问题。"}]},{"ID":"20230723215313-1ce4w77","Type":"NodeParagraph","Properties":{"id":"20230723215313-1ce4w77","updated":"20230723215313"},"Children":[{"Type":"NodeText","Data":"**例如这道小偷问题，原问题为：”从全部房子中能偷到的最大金额”，将问题的规模缩小，子问题就是 “从k个房子中能偷到的最大金额”，用 **"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"f(k)"},{"Type":"NodeText","Data":"​ 表示。"}]},{"ID":"20230723215313-9rne5ee","Type":"NodeParagraph","Properties":{"id":"20230723215313-9rne5ee","updated":"20230723215313"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image-20230704001146852"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file://E:/Typora%20picture/image-20230704001146852.png?lastModify=1690120385"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230723215313-nu7kc8h","Type":"NodeParagraph","Properties":{"id":"20230723215313-nu7kc8h","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"可以看到，子问题是参数化的，我们定义的子问题中有参数k。假设一共有 n 个房子的话，就一共有n个子问题。"}]},{"ID":"20230723215313-puu4sj3","Type":"NodeParagraph","Properties":{"id":"20230723215313-puu4sj3","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"动态规划实际上就是通过求这一堆子问题的解，来求出原问题的解。"}]},{"ID":"20230723215313-oliq8i4","Type":"NodeParagraph","Properties":{"id":"20230723215313-oliq8i4","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这要求子问题需要具备两个性质："}]},{"ID":"20230723215313-1lqugsp","Type":"NodeList","ListData":{},"Properties":{"id":"20230723215313-1lqugsp","updated":"20230723215313"},"Children":[{"ID":"20230723215313-nk5ez8s","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230723215313-nk5ez8s","updated":"20230723215313"},"Children":[{"ID":"20230723215313-0wh9odz","Type":"NodeParagraph","Properties":{"id":"20230723215313-0wh9odz","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"原问题要能由子问题表示。例如这道小偷问题中，k=n 时实际上就是原问题。否则，解了半天子问题还是解不出原问题，那子问题岂不是白解了。"}]}]},{"ID":"20230723215313-qmpk0pb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230723215313-qmpk0pb","updated":"20230723215313"},"Children":[{"ID":"20230723215313-miqscv9","Type":"NodeParagraph","Properties":{"id":"20230723215313-miqscv9","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"一个子问题的解"}]}]},{"ID":"20230723215313-tmezh00","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230723215313-tmezh00","updated":"20230723215313"},"Children":[{"ID":"20230723215313-9eq2zye","Type":"NodeParagraph","Properties":{"id":"20230723215313-9eq2zye","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"要能通过其他子问题的解求出。例如这道小偷问题中，f(k) 可以由 f(k−1) 和 f(k−2) 求出，具体原理后面会解释。这个性质就是教科书中所说的“最优子结构”。如果定义不出这样的子问题，那么这道题实际上没法用动态规划解。"},{"Type":"NodeText","Data":"\n"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"小偷问题由于比较简单，定义子问题实际上是很直观的。一些比较难的动态规划题目可能需要一些定义子问题的技巧。"}]}]}]},{"ID":"20230723215313-jde3lut","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230723215313-jde3lut","updated":"20230723215313"},"Children":[{"Type":"NodeText","Data":"步骤二、写出子问题的递推关系"}]},{"ID":"20230723215313-xb5u4ec","Type":"NodeParagraph","Properties":{"id":"20230723215313-xb5u4ec","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这一步是求解动态规划问题最关键的一步。然而，这一步也是最无法在代码中体现出来的一步。在做题的时候，最好把这一步的思路用注释的形式写下来。做动态规划题目不要求快，而要确保无误。否则，写代码五分钟，找 bug 半小时，岂不美哉？"}]},{"ID":"20230723215313-pudn4nw","Type":"NodeParagraph","Properties":{"id":"20230723215313-pudn4nw","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"我们来分析一下这道小偷问题的递推关系："}]},{"ID":"20230723215313-64reyrc","Type":"NodeParagraph","Properties":{"id":"20230723215313-64reyrc","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"假设一共有 n 个房子，每个房子的金额分别时 H"},{"Type":"NodeTextMark","TextMarkType":"sub","TextMarkTextContent":"0"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，H"},{"Type":"NodeTextMark","TextMarkType":"sub","TextMarkTextContent":"1"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，...，H"},{"Type":"NodeTextMark","TextMarkType":"sub","TextMarkTextContent":"n-1"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，子问题 f(k)表示从前k个房子(即H"},{"Type":"NodeTextMark","TextMarkType":"sub","TextMarkTextContent":"0"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，H"},{"Type":"NodeTextMark","TextMarkType":"sub","TextMarkTextContent":"1"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，...，H"},{"Type":"NodeTextMark","TextMarkType":"sub","TextMarkTextContent":"k-1"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":")中能偷到的最大金额。那么，偷k个房子有两种偷法："}]},{"ID":"20230723215313-i960auk","Type":"NodeParagraph","Properties":{"id":"20230723215313-i960auk","updated":"20230723215313"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image-20230704003435099"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file://E:/Typora%20picture/image-20230704003435099.png?lastModify=1690120385"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230723215313-6y2er55","Type":"NodeParagraph","Properties":{"id":"20230723215313-6y2er55","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"k个房子中最后一个房子是 H"},{"Type":"NodeTextMark","TextMarkType":"sub","TextMarkTextContent":"k-1"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"。如果不偷这个房子，那么问题就变成在前 k-1 个房子中偷到最大的金额，也就是子问题 f(k-1)。如果偷这个房子，那么前一个房子 H"},{"Type":"NodeTextMark","TextMarkType":"sub","TextMarkTextContent":"k-2"},{"Type":"NodeText","Data":"显然不能偷，其他房子不受影响。那么问题就变成在前 k-2 个房子中偷到的最大的金额。两种情况中，选择金额较大的一个种结果。"}]},{"ID":"20230723215313-sd6l2wj","Type":"NodeParagraph","Properties":{"id":"20230723215313-sd6l2wj","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"f(k) = max{f(k-1),H"},{"Type":"NodeTextMark","TextMarkType":"sub","TextMarkTextContent":"k-1"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"+f(k-2)}"}]},{"ID":"20230723215313-izlkqa5","Type":"NodeParagraph","Properties":{"id":"20230723215313-izlkqa5","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在写递推关系的时候，要注意写上 k = 0 和 k = 1 的基本情况："}]},{"ID":"20230723215313-jsn31dj","Type":"NodeList","ListData":{},"Properties":{"id":"20230723215313-jsn31dj","updated":"20230723215313"},"Children":[{"ID":"20230723215313-reiowcm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230723215313-reiowcm","updated":"20230723215313"},"Children":[{"ID":"20230723215313-yzdo3h6","Type":"NodeParagraph","Properties":{"id":"20230723215313-yzdo3h6","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"当k = 0 时，没有房子，所以 f(0) = 0"}]}]},{"ID":"20230723215313-xny87bo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230723215313-xny87bo","updated":"20230723215313"},"Children":[{"ID":"20230723215313-sfutvwz","Type":"NodeParagraph","Properties":{"id":"20230723215313-sfutvwz","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"当 k = 1时，只有一个房子，偷这个房子即可，所以 f(1) = H"},{"Type":"NodeTextMark","TextMarkType":"sub","TextMarkTextContent":"0"}]}]}]},{"ID":"20230723215313-gmyy4b2","Type":"NodeParagraph","Properties":{"id":"20230723215313-gmyy4b2","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这样才能构成完整的递推关系，后面写代码也不容易在边界条件上出错。"}]},{"ID":"20230723215313-1w9zwgc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230723215313-1w9zwgc","updated":"20230723215313"},"Children":[{"Type":"NodeText","Data":"步骤三：确定DP 数组的计算顺序"}]},{"ID":"20230723215313-ty8q9h7","Type":"NodeParagraph","Properties":{"id":"20230723215313-ty8q9h7","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在确定了子问题的递推关系之后，下一步就是依次计算出这些子问题了。在很多教程中都会写，动态规划有两种计算顺序，一种是自顶向下的、使用备忘录的递归方法，一种是自底向上的、使用 dp 数组的循环方法。不过在普通的动态规划题目中，99% 的情况我们都不需要用到备忘录方法，所以我们最好坚持用自底向上的 dp 数组。"}]},{"ID":"20230723215313-lx1p814","Type":"NodeParagraph","Properties":{"id":"20230723215313-lx1p814","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"DP 数组也可以叫”子问题数组”，因为 DP 数组中的每一个元素都对应一个子问题。如下图所示，dp[k] 对应子问题 f(k)，即偷前 k 间房子的最大金额。"}]},{"ID":"20230723215313-vpluuxo","Type":"NodeParagraph","Properties":{"id":"20230723215313-vpluuxo","updated":"20230723215313"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image-20230704010003087"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file://E:/Typora%20picture/image-20230704010003087.png?lastModify=1690120385"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230723215313-14g1g6w","Type":"NodeParagraph","Properties":{"id":"20230723215313-14g1g6w","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"那么，只要搞清楚了子问题的计算顺序，就可以确定DP数组的计算顺序。对于小偷问题，我们分析子问题的依赖关系，发现每个 f(k) 依赖 f(k-1) 和 f(k-2)。也就是说，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"dp[k]"},{"Type":"NodeText","Data":"​ 依赖 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"dp[k-1]"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"dp[k-2]"},{"Type":"NodeText","Data":"​ ，如下图所示。"}]},{"ID":"20230723215313-revh43a","Type":"NodeParagraph","Properties":{"id":"20230723215313-revh43a","updated":"20230723215313"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image-20230704010344086"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file://E:/Typora%20picture/image-20230704010344086.png?lastModify=1690120385"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230723215313-gbk6a11","Type":"NodeParagraph","Properties":{"id":"20230723215313-gbk6a11","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"那么，既然 DP 数组中的依赖关系都是向右指的，DP 数组的计算顺序就是从左向右。这样我们可以保证，计算一个子问题的时候，它所依赖的那些子问题已经计算出来了。"}]},{"ID":"20230723215313-ixumfer","Type":"NodeParagraph","Properties":{"id":"20230723215313-ixumfer","updated":"20230723215313"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"确定了 DP 数组的计算顺序之后，我们就可以写出题解代码了："}]},{"ID":"20230723215313-4mt5y8z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230723215313-4mt5y8z","updated":"20230723215313"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func rob(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    // 子问题\n    // f(k) = 偷 [0..k)房间中的最大金额\n    \n    // f(0) = 0 \n    // f(1) = nums[0]\n    // f(k) = max{rob(k-1),nums[k-1]+rob(k-2)}\n    N := len(nums)\n    var dp int[N+1]\n    dp[0] = 0\n    dp[1] = nums[0];\n    for k:=2;k\u003c=N;k++ {\n        dp[k] = max(dp[k-1],nums[k-1]+dp[k-2])\n    }\n    retu\n}\n\nfunc max(a,b int) int {\n    if a \u003e b {\n        return a\n    } else {\n        return b\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}