{"ID":"20231117222034-1fbuwl6","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f9e1","id":"20231117222034-1fbuwl6","tags":"公众号-小徐先生的编程世界","title":"Golang 设计模式之工厂模式","updated":"20231117222606"},"Children":[{"ID":"20231117222034-ik9da67","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231117222034-ik9da67","updated":"20231117222209"},"Children":[{"Type":"NodeText","Data":"前言"}]},{"ID":"20231117222222-924pkgl","Type":"NodeParagraph","Properties":{"id":"20231117222222-924pkgl","updated":"20231117222222"},"Children":[{"Type":"NodeText","Data":"本期会基于 Go 语言，和大家一起聊聊设计模式中的工厂模式. 本期分享内容包含如下几个部分："}]},{"ID":"20231117222222-qnsocpq","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222222-qnsocpq","updated":"20231117222222"},"Children":[{"ID":"20231117222222-btatzlv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222222-btatzlv","updated":"20231117222222"},"Children":[{"ID":"20231117222222-jw6b39h","Type":"NodeParagraph","Properties":{"id":"20231117222222-jw6b39h","updated":"20231117222238"},"Children":[{"Type":"NodeText","Data":"工厂模式的使用背景"}]}]},{"ID":"20231117222222-79h5zki","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222222-79h5zki","updated":"20231117222222"},"Children":[{"ID":"20231117222222-1g2a88z","Type":"NodeParagraph","Properties":{"id":"20231117222222-1g2a88z","updated":"20231117222243"},"Children":[{"Type":"NodeText","Data":"简单工厂模式"}]}]},{"ID":"20231117222222-2il6qgw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222222-2il6qgw","updated":"20231117222222"},"Children":[{"ID":"20231117222222-s4kbdl6","Type":"NodeParagraph","Properties":{"id":"20231117222222-s4kbdl6","updated":"20231117222244"},"Children":[{"Type":"NodeText","Data":"工厂方法模式"}]}]},{"ID":"20231117222222-qu22324","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222222-qu22324","updated":"20231117222222"},"Children":[{"ID":"20231117222222-3mdtj9w","Type":"NodeParagraph","Properties":{"id":"20231117222222-3mdtj9w","updated":"20231117222245"},"Children":[{"Type":"NodeText","Data":"抽象工厂模式"}]}]},{"ID":"20231117222222-o3okmfl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222222-o3okmfl","updated":"20231117222222"},"Children":[{"ID":"20231117222222-link61b","Type":"NodeParagraph","Properties":{"id":"20231117222222-link61b","updated":"20231117222246"},"Children":[{"Type":"NodeText","Data":"容器工厂模式"}]}]}]},{"ID":"20231117222248-taorn5i","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231117222248-taorn5i","updated":"20231117222300"},"Children":[{"Type":"NodeText","Data":"使用背景"}]},{"ID":"20231117222604-yk9u80b","Type":"NodeParagraph","Properties":{"id":"20231117222604-yk9u80b"}},{"ID":"20231117222606-92gbptd","Type":"NodeParagraph","Properties":{"id":"20231117222606-92gbptd","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"Go 语言中没有针对类的构造器方法定义统一的规范，倘若每次需要创建类的实例时，都需要在业务方法中事无俱细地执行实例初始化的细节，那么会存在缺陷的包括："}]},{"ID":"20231117222606-j2uv649","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-j2uv649","updated":"20231117222606"},"Children":[{"ID":"20231117222606-wza42ru","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-wza42ru","updated":"20231117222606"},"Children":[{"ID":"20231117222606-wr8rb4h","Type":"NodeParagraph","Properties":{"id":"20231117222606-wr8rb4h","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 业务方法和组件类之间产生过高的耦合度，需要了解到组件类的过多细节"}]}]},{"ID":"20231117222606-5cv46rl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-5cv46rl","updated":"20231117222606"},"Children":[{"ID":"20231117222606-8wdb5r4","Type":"NodeParagraph","Properties":{"id":"20231117222606-8wdb5r4","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 倘若组件类的定义发生变更，那么散落在各处业务方法中对类的构造流程都需要配合改动"}]}]}]},{"ID":"20231117222606-u4q7ars","Type":"NodeParagraph","Properties":{"id":"20231117222606-u4q7ars","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"那么如何解决上述问题呢？在编程世界中，相当的一部分问题都可以通过增加一个中间层加以解决. 我们在此处遵循工厂模式的设计思路，在业务方法和类之间添加一个防腐中间层——工厂类，这样做能够带来的好处是："}]},{"ID":"20231117222606-77yyh42","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-77yyh42","updated":"20231117222606"},"Children":[{"ID":"20231117222606-n9xt25s","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-n9xt25s","updated":"20231117222606"},"Children":[{"ID":"20231117222606-qpnb947","Type":"NodeParagraph","Properties":{"id":"20231117222606-qpnb947","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 实现类和业务方法之间的解耦，如果类的构造过程发生变更，可以统一收口在工厂类中进行处理，从而对业务方法屏蔽相关细节"}]}]},{"ID":"20231117222606-1z74515","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-1z74515","updated":"20231117222606"},"Children":[{"ID":"20231117222606-mdivpsm","Type":"NodeParagraph","Properties":{"id":"20231117222606-mdivpsm","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 倘若有多个类都聚拢在工厂类中进行构造，这样各个类的构造流程中就天然形成了一个公共的切面，可以进行一些公共逻辑的执行"}]}]}]},{"ID":"20231117222606-dguc67p","Type":"NodeParagraph","Properties":{"id":"20231117222606-dguc67p","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/sz_mmbiz_png/3ic3aBqT2ibZvqxoRqdFZ7Ecg3BpSibXcSum5EJkAUMtU5pLsnh8HJasCJ9OxaMGWa5PJET0eUya41IWaFVtouM7Q/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231117222606-5nv91qd","Type":"NodeParagraph","Properties":{"id":"20231117222606-5nv91qd","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"工厂模式属于设计模式中的一种，在实现上，又可以进一步细分为：简单工厂模式、工厂方法模式和抽象工厂模式三种类型，这三种类型我们会在本文的2-4章中进行逐一介绍. 除开上面提到的三种经典类型外，本文还会在第5章中额外和大家介绍一种比较另类的容器工厂模式."}]},{"ID":"20231117222606-0m15igi","Type":"NodeParagraph","Properties":{"id":"20231117222606-0m15igi","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/sz_mmbiz_png/3ic3aBqT2ibZvqxoRqdFZ7Ecg3BpSibXcSuwSSpoJfchLHMvQAcNm95fbMYuzMYZsJFCGLRUUXqtvwzp9S39vjjbA/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231117222606-vbtcsac","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231117222606-vbtcsac","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"2 简单工厂模式"}]},{"ID":"20231117222606-71d4npt","Type":"NodeParagraph","Properties":{"id":"20231117222606-71d4npt","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"首先和大家聊聊简单工厂模式. 设计模式中的内容都相对抽象，我这里先不作具体的概念定义，而是通过具体的实例和大家一起进行设计过程的推演，最后再对简单工厂模式的内容进行小结."}]},{"ID":"20231117222606-19ld4n6","Type":"NodeParagraph","Properties":{"id":"20231117222606-19ld4n6","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"假设现在有这样一个编程场景："}]},{"ID":"20231117222606-o4bekei","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-o4bekei","updated":"20231117222606"},"Children":[{"ID":"20231117222606-8xh7r8n","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-8xh7r8n","updated":"20231117222606"},"Children":[{"ID":"20231117222606-nzgyikx","Type":"NodeParagraph","Properties":{"id":"20231117222606-nzgyikx","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 水果 Fruit 是一个抽象的 interface，水果的共性是都可以食用水果，这里我们不纠结主被动的语义，赋以 Fruit 一个 Eat 方法"}]}]},{"ID":"20231117222606-u1z9dz1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-u1z9dz1","updated":"20231117222606"},"Children":[{"ID":"20231117222606-5102xzr","Type":"NodeParagraph","Properties":{"id":"20231117222606-5102xzr","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 有三个具体的水果实现类，橘子 Orange、草莓 Strawberry、樱桃 cherry，分别实现了 Fruit 对应的 Eat 方法"}]}]},{"ID":"20231117222606-jfifvra","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-jfifvra","updated":"20231117222606"},"Children":[{"ID":"20231117222606-r9o5hin","Type":"NodeParagraph","Properties":{"id":"20231117222606-r9o5hin","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 有一个具体的水果工厂类 FruitFactory，专门用于水果的生产工作，对应的生产方法为 CreateFruit 方法，可以按照用户指定的水果类型，生产出对应的水果"}]}]}]},{"ID":"20231117222606-azytj4d","Type":"NodeParagraph","Properties":{"id":"20231117222606-azytj4d","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"上面聊到的几个类之间形成的 UML 类图如下所示："}]},{"ID":"20231117222606-84iyc8p","Type":"NodeParagraph","Properties":{"id":"20231117222606-84iyc8p","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/sz_mmbiz_png/3ic3aBqT2ibZvqxoRqdFZ7Ecg3BpSibXcSuuKhEGabP5MEVG0z2R0jt6rISocc4CUBBUyb0XHK7icYc1RgIgcYImFw/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231117222606-b2fstvl","Type":"NodeParagraph","Properties":{"id":"20231117222606-b2fstvl","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"下面进行代码展示. 水果 Fruit interface 实现如下："}]},{"ID":"20231117222606-hoa431y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-hoa431y","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type Fruit interface {\n    Eat()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-syj5sni","Type":"NodeParagraph","Properties":{"id":"20231117222606-syj5sni","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"橘子 Orange、草莓 Strawberry、樱桃 Cherry 三种水果的具体实现类如下："}]},{"ID":"20231117222606-0pea6ny","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-0pea6ny","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type Orange struct {\n    name string\n}\n\n\nfunc NewOrange(name string) Fruit {\n    return \u0026Orange{\n        name: name,\n    }\n}\n\n\nfunc (o *Orange) Eat() {\n    fmt.Printf(\"i am orange: %s, i am about to be eaten...\", o.name)\n}\n\n\ntype Strawberry struct {\n    name string\n}\n\n\nfunc NewStrawberry(name string) Fruit {\n    return \u0026Strawberry{\n        name: name,\n    }\n}\n\n\nfunc (s *Strawberry) Eat() {\n    fmt.Printf(\"i am strawberry: %s, i am about to be eaten...\", s.name)\n}\n\n\ntype Cherry struct {\n    name string\n}\n\n\nfunc NewCherry(name string) Fruit {\n    return \u0026Cherry{\n        name: name,\n    }\n}\n\n\nfunc (c *Cherry) Eat() {\n    fmt.Printf(\"i am cherry: %s, i am about to be eaten...\", c.name)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-vvii1zf","Type":"NodeParagraph","Properties":{"id":"20231117222606-vvii1zf","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"下面是关于生产水果的工厂类 FruitFactory 的定义，其中 CreateFruit 方法是用于生产水果的核心方法："}]},{"ID":"20231117222606-w8lbv8z","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-w8lbv8z","updated":"20231117222606"},"Children":[{"ID":"20231117222606-gl2mrl1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-gl2mrl1","updated":"20231117222606"},"Children":[{"ID":"20231117222606-hm7wse7","Type":"NodeParagraph","Properties":{"id":"20231117222606-hm7wse7","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 利用工厂生产三类时存在的公共切面，进行随机数的取值，用来给生产出来的水果命名"}]}]},{"ID":"20231117222606-bigcb06","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-bigcb06","updated":"20231117222606"},"Children":[{"ID":"20231117222606-ea30r3p","Type":"NodeParagraph","Properties":{"id":"20231117222606-ea30r3p","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 根据使用方传入的水果类型 typ，调用对应水果类型的构造器方法，并将生产出来的水果进行返回"}]}]},{"ID":"20231117222606-aqimauo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-aqimauo","updated":"20231117222606"},"Children":[{"ID":"20231117222606-3wtnun3","Type":"NodeParagraph","Properties":{"id":"20231117222606-3wtnun3","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 如果使用方法传入的水果类型 typ 非法，则对外抛出错误"}]}]}]},{"ID":"20231117222606-ua2659x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-ua2659x","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type FruitFactory struct {\n}\n\n\nfunc NewFruitFactory() *FruitFactory {\n    return \u0026FruitFactory{}\n}\n\n\nfunc (f *FruitFactory) CreateFruit(typ string) (Fruit, error) {\n    src := rand.NewSource(time.Now().UnixNano())\n    rander := rand.New(src)\n    name := strconv.Itoa(rander.Int())\n\n\n    switch typ {\n    case \"orange\":\n        return NewOrange(name), nil\n    case \"strawberry\":\n        return NewStrawberry(name), nil\n    case \"cherry\":\n        return NewCherry(name), nil\n    default:\n        return nil, fmt.Errorf(\"fruit typ: %s is not supported yet\", typ)\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-jzo05pf","Type":"NodeParagraph","Properties":{"id":"20231117222606-jzo05pf","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"上述实现代码实现起来的直观明了，这正是简单工厂模式的优势所在，然而我们同样需要注意到其中存在的局限性——不利于实现类的扩展："}]},{"ID":"20231117222606-kkr9lmz","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-kkr9lmz","updated":"20231117222606"},"Children":[{"ID":"20231117222606-4lvxa6v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-4lvxa6v","updated":"20231117222606"},"Children":[{"ID":"20231117222606-0c4doxb","Type":"NodeParagraph","Properties":{"id":"20231117222606-0c4doxb","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 每当有新的水果实现类需要支持时，需要在 FruitFactory 生产水果的 CreateFruit 方法中进行修改，在 switch case 中增加新的分支，这样做是不符合代码设计规范中的开闭原则的（开闭原则：面向扩展开放，面向修改关闭）"}]}]},{"ID":"20231117222606-zbcyg1h","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-zbcyg1h","updated":"20231117222606"},"Children":[{"ID":"20231117222606-yad1kxl","Type":"NodeParagraph","Properties":{"id":"20231117222606-yad1kxl","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 此外，当需要支持的水果类型 typ 数量提升时，这个 CreateFruit 方法会存在方法圈复杂度过高的问题"}]}]}]},{"ID":"20231117222606-egcwg0m","Type":"NodeParagraph","Properties":{"id":"20231117222606-egcwg0m","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"针对于第一个问题，是简单工厂模式的固有硬伤，需要切换到本文第 3 章中介绍到的工厂方法模式才能予以解决."}]},{"ID":"20231117222606-82v3lpb","Type":"NodeParagraph","Properties":{"id":"20231117222606-82v3lpb","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"针对于存在的第二个问题，可以采用表驱动替代 switch case 分支映射的方式进行优化："}]},{"ID":"20231117222606-7fw4aki","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-7fw4aki","updated":"20231117222606"},"Children":[{"ID":"20231117222606-9x9980d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-9x9980d","updated":"20231117222606"},"Children":[{"ID":"20231117222606-70uy49h","Type":"NodeParagraph","Properties":{"id":"20231117222606-70uy49h","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 将水果构造器函数定义为一个类型 fruitCreator"}]}]},{"ID":"20231117222606-hz8747s","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-hz8747s","updated":"20231117222606"},"Children":[{"ID":"20231117222606-2bknz4j","Type":"NodeParagraph","Properties":{"id":"20231117222606-2bknz4j","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 在水果构造工厂 FruitFactory 中，内置一个 map creators，根据水果类型映射到具体的构造器方法 fruitCreator"}]}]},{"ID":"20231117222606-49x7zu3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-49x7zu3","updated":"20231117222606"},"Children":[{"ID":"20231117222606-kajukud","Type":"NodeParagraph","Properties":{"id":"20231117222606-kajukud","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 在水果构造工厂的构造器方法中，完成 creators map 的初始化"}]}]},{"ID":"20231117222606-56xxdd2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-56xxdd2","updated":"20231117222606"},"Children":[{"ID":"20231117222606-83jnsyr","Type":"NodeParagraph","Properties":{"id":"20231117222606-83jnsyr","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 在 FruitFactory.CreateFruit 方法中，根据水果类型映射到对应的构造器方法 fruitCreator，然后进行水果的构造"}]}]}]},{"ID":"20231117222606-vqolr1u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-vqolr1u","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type fruitCreator func(name string) Fruit\n\n\ntype FruitFactory struct {\n    creators map[string]fruitCreator\n}\n\n\nfunc NewFruitFactory() *FruitFactory {\n    return \u0026FruitFactory{\n        creators: map[string]fruitCreator{\n            \"orange\":     NewOrange,\n            \"strawberry\": NewStrawberry,\n            \"cherry\":     NewCherry,\n        },\n    }\n}\n\n\nfunc (f *FruitFactory) CreateFruit(typ string) (Fruit, error) {\n    fruitCreator, ok := f.creators[typ]\n    if !ok {\n        return nil, fmt.Errorf(\"fruit typ: %s is not supported yet\", typ)\n    }\n\n\n    src := rand.NewSource(time.Now().UnixNano())\n    rander := rand.New(src)\n    name := strconv.Itoa(rander.Int())\n    return fruitCreator(name), nil\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-m0rbbhj","Type":"NodeParagraph","Properties":{"id":"20231117222606-m0rbbhj","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"下面通过一段单测代码，给出简单工厂模式的使用示例："}]},{"ID":"20231117222606-yrafpcl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-yrafpcl","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func Test_factory(t *testing.T) {\n    // 构造工厂\n    fruitFactory := NewFruitFactory()\n\n\n    // 尝个橘子\n    orange, _ := fruitFactory.CreateFruit(\"orange\")\n    orange.Eat()\n\n\n    // 来颗樱桃\n    cherry, _ := fruitFactory.CreateFruit(\"cherry\")\n    cherry.Eat()\n\n\n    // 来个西瓜，因为未实现会报错\n    watermelon, err := fruitFactory.CreateFruit(\"watermelon\")\n    if err != nil {\n        t.Error(err)\n        return\n    }\n    watermelon.Eat()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-vrz4r8e","Type":"NodeParagraph","Properties":{"id":"20231117222606-vrz4r8e","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"下面对简单工厂模式做个小结："}]},{"ID":"20231117222606-f40o1im","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-f40o1im","updated":"20231117222606"},"Children":[{"ID":"20231117222606-yo6j7nx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-yo6j7nx","updated":"20231117222606"},"Children":[{"ID":"20231117222606-jgt1ozw","Type":"NodeParagraph","Properties":{"id":"20231117222606-jgt1ozw","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 对于拟构造的组件，需要依据其共性，抽离出一个公共 interface"}]}]},{"ID":"20231117222606-wqi1slj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-wqi1slj","updated":"20231117222606"},"Children":[{"ID":"20231117222606-u7isco3","Type":"NodeParagraph","Properties":{"id":"20231117222606-u7isco3","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 每个具体的组件类型对 interface 加以实现"}]}]},{"ID":"20231117222606-2z47z9p","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-2z47z9p","updated":"20231117222606"},"Children":[{"ID":"20231117222606-i2rn84c","Type":"NodeParagraph","Properties":{"id":"20231117222606-i2rn84c","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 定义一个具体的工厂类，在构造器方法接受具体的组件类型，完成对应类型组件的构造"}]}]}]},{"ID":"20231117222606-xvwzo0z","Type":"NodeParagraph","Properties":{"id":"20231117222606-xvwzo0z","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"简单工厂模式的优势包括："}]},{"ID":"20231117222606-41sacva","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-41sacva","updated":"20231117222606"},"Children":[{"ID":"20231117222606-qil2o6a","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-qil2o6a","updated":"20231117222606"},"Children":[{"ID":"20231117222606-1fqpi6q","Type":"NodeParagraph","Properties":{"id":"20231117222606-1fqpi6q","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 属于工厂模式最为简单直观的一种类型"}]}]},{"ID":"20231117222606-x0fei58","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-x0fei58","updated":"20231117222606"},"Children":[{"ID":"20231117222606-51c7smm","Type":"NodeParagraph","Properties":{"id":"20231117222606-51c7smm","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 构造各类组件时的聚拢收口效果最好，提供的公共切面最全面到位"}]}]}]},{"ID":"20231117222606-8qd1t0o","Type":"NodeParagraph","Properties":{"id":"20231117222606-8qd1t0o","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"存在的劣势为："}]},{"ID":"20231117222606-ly98d0d","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-ly98d0d","updated":"20231117222606"},"Children":[{"ID":"20231117222606-vw4a6nq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-vw4a6nq","updated":"20231117222606"},"Children":[{"ID":"20231117222606-qcq62m3","Type":"NodeParagraph","Properties":{"id":"20231117222606-qcq62m3","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 组件类扩展时，需要直接修改工厂的组件构造方法，不符合开闭原则"}]}]}]},{"ID":"20231117222606-zm5wo0c","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231117222606-zm5wo0c","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"3 工厂方法模式"}]},{"ID":"20231117222606-w100w5a","Type":"NodeParagraph","Properties":{"id":"20231117222606-w100w5a","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"为了解决简单工厂模式中存在的问题，我们对设计流程进行修改："}]},{"ID":"20231117222606-hwjz73h","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-hwjz73h","updated":"20231117222606"},"Children":[{"ID":"20231117222606-jz6bfdy","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-jz6bfdy","updated":"20231117222606"},"Children":[{"ID":"20231117222606-dpvpfk3","Type":"NodeParagraph","Properties":{"id":"20231117222606-dpvpfk3","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 关于组件的定义模式不变. 一个抽象的 Fruit interface，多个具体的水果实现 Orange、Strawberry、Cherry"}]}]},{"ID":"20231117222606-57gxy5k","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-57gxy5k","updated":"20231117222606"},"Children":[{"ID":"20231117222606-0cxcbhm","Type":"NodeParagraph","Properties":{"id":"20231117222606-0cxcbhm","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 将工厂类 FruitFactory 由具体的实现类改为抽象的 interface"}]}]},{"ID":"20231117222606-13byv7a","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-13byv7a","updated":"20231117222606"},"Children":[{"ID":"20231117222606-sdhcwu7","Type":"NodeParagraph","Properties":{"id":"20231117222606-sdhcwu7","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 针对每类水果，提供出一个具体的工厂实现类，如 OrangeFactory、StrawberryFactory、CherryFactory"}]}]}]},{"ID":"20231117222606-f39n4yx","Type":"NodeParagraph","Properties":{"id":"20231117222606-f39n4yx","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"对应的UML类图如下："}]},{"ID":"20231117222606-isojbbb","Type":"NodeParagraph","Properties":{"id":"20231117222606-isojbbb","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/sz_mmbiz_png/3ic3aBqT2ibZvqxoRqdFZ7Ecg3BpSibXcSuZHib4KI5kGMyydkf7xEIeJniaIpNxmFqcUwyRc9KrQIR6ia8QmystP5fQ/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231117222606-zv4voxd","Type":"NodeParagraph","Properties":{"id":"20231117222606-zv4voxd","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"在工厂方法模式中，对抽象组件 Fruit interface 以及几个具体实现类 Orange、Strawberry 和 Cherry 的定义和简单工厂模式如出一辙，这里不再重复展示代码."}]},{"ID":"20231117222606-dckqv03","Type":"NodeParagraph","Properties":{"id":"20231117222606-dckqv03","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"与简单工厂模式有所区别的是， 水果工厂类 FruitFactory 在此处变成一个抽象的 interface，且针对每种具体的水果实现类需要对应地声明一种工厂实现类，包括 OrangeFactory、StrawberryFactory、CherryFactory，具体的实现代码如下："}]},{"ID":"20231117222606-2ilrhcv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-2ilrhcv","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type FruitFactory interface {\n    CreateFruit() Fruit\n}\n\n\ntype OrangeFactory struct {\n}\n\n\nfunc NewOrangeFactory() FruitFactory {\n    return \u0026OrangeFactory{}\n}\n\n\nfunc (o *OrangeFactory) CreateFruit() Fruit {\n    return NewOrange(\"\")\n}\n\n\ntype StrawberryFactory struct {\n}\n\n\nfunc NewStrawberryFactory() FruitFactory {\n    return \u0026StrawberryFactory{}\n}\n\n\nfunc (s *StrawberryFactory) CreateFruit() Fruit {\n    return NewStrawberry(\"\")\n}\n\n\ntype CherryFactory struct {\n}\n\n\nfunc NewCherryFactory() FruitFactory {\n    return \u0026CherryFactory{}\n}\n\n\nfunc (c *CherryFactory) CreateFruit() Fruit {\n    return NewCherry(\"\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-y9yna4r","Type":"NodeParagraph","Properties":{"id":"20231117222606-y9yna4r","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"这样的设计模式下，即便后续有频繁扩展水果实现类的需求，也无须对老模块的代码进行修改，而是需要扩展实现一个水果 Fruit 的实现类以及对应的水果工厂实现类即可，比如，倘若此处我们需要在水果列表中扩展一个“西瓜”的话，那么需要新增的代码如下："}]},{"ID":"20231117222606-l3gi5x3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-l3gi5x3","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type Watermelon struct {\n    name string\n}\n\n\nfunc NewWatermelon(name string) Fruit {\n    return \u0026Watermelon{\n        name: name,\n    }\n}\n\n\nfunc (w *Watermelon) Eat() {\n    fmt.Printf(\"i am watermelon: %s, i am about to be eaten...\", w.na\n\n\ntype WatermelonFactory struct {\n}\n\n\nfunc NewWatermelon() FruitFactory {\n    return \u0026WatermelonFactory{}\n}\n\n\nfunc (w *WatermelonFactory) CreateFruit() Fruit {\n    return NewWatermelon(\"\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-o3wv3qh","Type":"NodeParagraph","Properties":{"id":"20231117222606-o3wv3qh","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"下面是使用到工厂方法模式的单测代码示例："}]},{"ID":"20231117222606-f0onib5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-f0onib5","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func Test_factory(t *testing.T) {\n    // 尝个橘子\n    orangeFactory := NewOrangeFactory()\n    orange := orangeFactory.CreateFruit()\n    orange.Eat()\n\n\n    // 来颗樱桃\n    cherryFactory := NewCherryFactory()\n    cherry := cherryFactory.CreateFruit()\n    cherry.Eat()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-dtqxc99","Type":"NodeParagraph","Properties":{"id":"20231117222606-dtqxc99","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"工厂方法模式相较于简单工厂模式而言，解决了扩展水果类不满足开闭原则的问题，然而工厂方法模式也有其固有的缺陷："}]},{"ID":"20231117222606-4xica4u","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-4xica4u","updated":"20231117222606"},"Children":[{"ID":"20231117222606-nwzfwe9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-nwzfwe9","updated":"20231117222606"},"Children":[{"ID":"20231117222606-w5dagd8","Type":"NodeParagraph","Properties":{"id":"20231117222606-w5dagd8","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 需要为每个水果单独实现一个工厂类,代码冗余度较高"}]}]},{"ID":"20231117222606-1996n0d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-1996n0d","updated":"20231117222606"},"Children":[{"ID":"20231117222606-x8yokhq","Type":"NodeParagraph","Properties":{"id":"20231117222606-x8yokhq","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 原本构造多个水果类时存在的公共切面不复存在，一些通用的逻辑需要在每个水果工厂实现类中重复声明一遍"}]}]}]},{"ID":"20231117222606-6sabt5f","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231117222606-6sabt5f","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"4 抽象工厂模式"}]},{"ID":"20231117222606-k5xbfm9","Type":"NodeParagraph","Properties":{"id":"20231117222606-k5xbfm9","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/sz_mmbiz_png/3ic3aBqT2ibZvqxoRqdFZ7Ecg3BpSibXcSurbsuL0NAwWJh7helBY61tibcz8251JmWncKibVialJVIaZ7Oa8w5YEqxA/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231117222606-9a44ibz","Type":"NodeParagraph","Properties":{"id":"20231117222606-9a44ibz","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"接下来，我们进行抽象工厂模式的介绍. 这里，针对工厂需要构造的组件，我们通过两个维度进行拆解："}]},{"ID":"20231117222606-o2wn11m","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-o2wn11m","updated":"20231117222606"},"Children":[{"ID":"20231117222606-u6nex7l","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-u6nex7l","updated":"20231117222606"},"Children":[{"ID":"20231117222606-haewxzy","Type":"NodeParagraph","Properties":{"id":"20231117222606-haewxzy","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 我们假设水果 Fruit 中仅包含两种具体的水果：草莓 strawberry 和柠檬 lemon"}]}]},{"ID":"20231117222606-6m19eqs","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-6m19eqs","updated":"20231117222606"},"Children":[{"ID":"20231117222606-mrvs3r1","Type":"NodeParagraph","Properties":{"id":"20231117222606-mrvs3r1","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 我们把每种具体的水果实现类称为一个产品等级，strawberry 是一个产品等级，lemon 也是一个产品等级"}]}]},{"ID":"20231117222606-hay173q","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-hay173q","updated":"20231117222606"},"Children":[{"ID":"20231117222606-g3kxvaj","Type":"NodeParagraph","Properties":{"id":"20231117222606-g3kxvaj","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 在同一个水果实现类中，我们额外新增一个品牌的维度，成为产品族. 例如 strawberry 和 lemon 可以由不同品牌的厂商进行生产，比如水果品牌佳农 GoodFarmer 生产的草莓为 GoodFarmerStrawberry，生产的柠檬为 GoodFarmerLemon；水果品牌 Dole都乐生产的草莓为 DoleStrawberry，生产的柠檬为 DoleLemon"}]}]}]},{"ID":"20231117222606-qcnblmz","Type":"NodeParagraph","Properties":{"id":"20231117222606-qcnblmz","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"基于上述的两个维度，我们尝试对简单工厂模式和厂方法模式中优势进行聚拢："}]},{"ID":"20231117222606-mukdqg6","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-mukdqg6","updated":"20231117222606"},"Children":[{"ID":"20231117222606-03i05if","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-03i05if","updated":"20231117222606"},"Children":[{"ID":"20231117222606-mv7rvvn","Type":"NodeParagraph","Properties":{"id":"20231117222606-mv7rvvn","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 首先，我们把种类相对稳定，不需要频繁扩展变更的维度定义为产品等级. 比如上述例子中的 Fruit，我们需要固定明确后续 Fruit 只包含草莓 strawberry 和柠檬 lemon 两类，没有频繁扩展的诉求"}]}]},{"ID":"20231117222606-uglb11m","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-uglb11m","updated":"20231117222606"},"Children":[{"ID":"20231117222606-dqukv4p","Type":"NodeParagraph","Properties":{"id":"20231117222606-dqukv4p","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 针对于种类需要频繁变更的维度，我们将其定义为产品族. 比如上述例子中的品牌，我们目前支持了佳农 GoodFarmer 和都乐 Dole，后续还可以继续扩展支持更丰富的水果品牌，如 佳沛 Zespri、佳沃 JOYVIO 等"}]}]},{"ID":"20231117222606-zgoc3fu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-zgoc3fu","updated":"20231117222606"},"Children":[{"ID":"20231117222606-lsdv1nc","Type":"NodeParagraph","Properties":{"id":"20231117222606-lsdv1nc","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 每次需要扩展产品族时，都需要实现对应产品族的工厂 factory 实现类，而无需对老的实现方法直接进行修改，符合开闭原则"}]}]},{"ID":"20231117222606-m91e6pq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-m91e6pq","updated":"20231117222606"},"Children":[{"ID":"20231117222606-5jmmbul","Type":"NodeParagraph","Properties":{"id":"20231117222606-5jmmbul","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 针对于不频繁变动的产品等级，如草莓 strawberry 与柠檬 lemon，每个品牌都会有一个具体的 factory 工厂实现类. 其中会统一声明对应于每种水果的构造方法，此时具备实现公共切面的能力"}]}]}]},{"ID":"20231117222606-xx9t3ng","Type":"NodeParagraph","Properties":{"id":"20231117222606-xx9t3ng","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"按照上述思路，抽象工厂模式我们定义的 UML 类图如下："}]},{"ID":"20231117222606-jiu4k9d","Type":"NodeParagraph","Properties":{"id":"20231117222606-jiu4k9d","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/sz_mmbiz_png/3ic3aBqT2ibZvqxoRqdFZ7Ecg3BpSibXcSup8wCFarSqqrK4rHicmTqCaueLxhzbkGwRmYdF4ctvXLv5bHDwBzOfRw/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231117222606-4x1nc61","Type":"NodeParagraph","Properties":{"id":"20231117222606-4x1nc61","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"在抽象工厂模式下，我们需要将每种水果类型定义为一个抽象的 interface，包括草莓 strawberry 和柠檬 lemon. 其中 strawberry 包含一个方法 SweetAttack：当草莓被食用时，它会发起一轮甜蜜攻势；柠檬 Lemon 包含的方法为 AcidAttack，食用它时需要承受一轮酸劲攻势."}]},{"ID":"20231117222606-mespq0j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-mespq0j","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type Strawberry interface {\n    SweetAttack()\n}\n\n\ntype Lemon interface {\n    AcidAttack()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-wekb2h3","Type":"NodeParagraph","Properties":{"id":"20231117222606-wekb2h3","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"下面定义一个抽象的水果工厂 FruitFactory，其中分别声明了用于生产草莓的 CreateStrawberry 方法以及创建柠檬的 CreateLemon 方法："}]},{"ID":"20231117222606-efoiqtw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-efoiqtw","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type FruitFactory interface {\n    CreateStrawberry() Strawberry\n    CreateLemon() Lemon\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-zy6oepa","Type":"NodeParagraph","Properties":{"id":"20231117222606-zy6oepa","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"下面，针对每种水果类型，进行不同品牌下的具体实现. 比如草莓 strawberry 可以实现为 佳农生产的 GoodFarmerStrawberry 和都乐生产的 DoleStrawberry："}]},{"ID":"20231117222606-j5hukcq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-j5hukcq","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type GoodfarmerStrawberry struct {\n    brand string\n    Strawberry\n}\n\n\n\n\nfunc (g *GoodfarmerStrawberry) SweetAttack() {\n    fmt.Printf(\"sweet attack from %s, \", g.brand)\n}\n\n\n\n\ntype GoodfarmerLemon struct {\n    brand string\n    Lemon\n}\n\n\n\n\nfunc (g *GoodfarmerLemon) AcidAttack() {\n    fmt.Printf(\"acid attack from %s, \", g.brand)\n}\n\n\n\n\ntype DoleStrawberry struct {\n    brand string\n    Strawberry\n}\n\n\n\n\nfunc (d *DoleStrawberry) SweetAttack() {\n    fmt.Printf(\"sweet attack from %s, \", d.brand)\n}\n\n\n\n\ntype DoleLemon struct {\n    brand string\n    Lemon\n}\n\n\n\n\nfunc (d *DoleLemon) AcidAttack() {\n    fmt.Printf(\"acid attack from %s,\", d.brand)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-h1rwzbm","Type":"NodeParagraph","Properties":{"id":"20231117222606-h1rwzbm","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"针对每个品牌，声明一个水果工厂实现类： GoodFarmerFactory 和 DoleFactory，展示如下："}]},{"ID":"20231117222606-8785f4j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-8785f4j","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type GoodfarmerFactory struct{}\n\n\nfunc (g *GoodfarmerFactory)myAspect(){\n   fmt.Println(\"good farmer aspect...\")\n}\n\n\nfunc (g *GoodfarmerFactory) CreateStrawberry() Strawberry {\n    // 同一个产品族可以插入一个切面\n    g.myAspect()\n    defer g.myAspect()\n    return \u0026GoodfarmerStrawberry{\n        brand: \"goodfarmer\",\n    }\n}\nfunc (g *GoodfarmerFactory) CreateLemon() Lemon {\n    // 同一个产品族可以插入一个切面\n    g.myAspect()\n    defer g.myAspect()\n    return \u0026GoodfarmerLemon{\n        brand: \"goodfarmer\",\n    }\n}\n\n\ntype DoleFactory struct{}\n\n\nfunc (d *DoleFactory)myAspect(){\n   fmt.Println(\"dole aspect...\")\n}\n\n\nfunc (d *DoleFactory) CreateStrawberry() Strawberry {\n    // 同一个产品族可以插入一个切面\n    d.myAspect()\n    defer d.Myspect()\n    return \u0026DoleStrawberry{\n        brand: \"dole\",\n    }\n}\nfunc (d *DoleFactory) CreateLemon() Lemon {\n    // 同一个产品族可以插入一个切面\n    d.myAspect()\n    defer d.Myspect()\n    return \u0026DoleLemon{\n        brand: \"dole\",\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-w8eqxya","Type":"NodeParagraph","Properties":{"id":"20231117222606-w8eqxya","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"此时，倘若我们需要额外扩展一个新的水果品牌，比如佳沛 Zespri，此时需要额外新增如下代码："}]},{"ID":"20231117222606-3ma8a91","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-3ma8a91","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type ZespriStrawberry struct {\n    brand string\n    Strawberry\n}\n\n\nfunc (z *ZespriStrawberry) SweetAttack() {\n    fmt.Printf(\"sweet attack from %s, \", z.brand)\n}\n\n\ntype ZespriLemon struct {\n    brand string\n    Lemon\n}\n\n\nfunc (z *ZespriLemon) AcidAttack() {\n    fmt.Printf(\"acid attack from %s, \", z.brand)\n}\n\n\ntype ZespriFactory struct{}\n\n\n\n\nfunc (z *ZespriFactory)myAspect(){\n   fmt.Println(\"dole aspect...\")\n}\n\n\n\n\nfunc (z *ZespriFactory) CreateStrawberry() Strawberry {\n    // 同一个产品族可以插入一个切面\n    z.myAspect()\n    defer z.Myspect()\n    return \u0026ZespriStrawberry{\n        brand: \"zespri\",\n    }\n}\nfunc (z *ZespriFactory) CreateLemon() Lemon {\n    // 同一个产品族可以插入一个切面\n    z.myAspect()\n    defer z.Myspect()\n    return \u0026ZespriLemon{\n        brand: \"zespri\",\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-3wsq882","Type":"NodeParagraph","Properties":{"id":"20231117222606-3wsq882","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"需要注意，抽象工厂模式，倘若需要扩展产品等级，对应的代价是很高昂的. 大家在此处不妨可以尝试一下扩展一类水果，看看涉及到的代码改动包括哪些内容."}]},{"ID":"20231117222606-h7zsdr2","Type":"NodeParagraph","Properties":{"id":"20231117222606-h7zsdr2","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"下面给出一个针对于抽象工厂模式的测试代码示例："}]},{"ID":"20231117222606-4gxuznj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-4gxuznj","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func Test_factory(t *testing.T) {\n    // 尝尝佳农品牌的水果\n    goodfarmerFactory := GoodfarmerFactory{}\n    goodfarmerStrawberry := goodfarmerFactory.CreateStrawberry()\n    goodfarmerStrawberry.SweetAttack()\n\n\n    goodfarmerLemon := goodfarmerFactory.CreateLemon()\n    goodfarmerLemon.AcidAttack()\n\n\n    // 尝尝都乐品牌的水果\n    doleFactory := DoleFactory{}\n    doleStrawberry := doleFactory.CreateStrawberry()\n    doleStrawberry.SweetAttack()\n\n\n    doleLemon := doleFactory.CreateLemon()\n    doleLemon.AcidAttack()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-q4sk6ut","Type":"NodeParagraph","Properties":{"id":"20231117222606-q4sk6ut","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"抽象工厂模式通过将组件拆分为产品族和产品等级的维度，将需要频繁扩展的维度和相对稳定的维度进行拆分，尝试兼具简单工厂模式和工厂方法模式的优势，在使用过程中我们需要注意，在模块设计之初，就需要明确产品族和产品等级的维度定义，倘若这部分定义出现偏差，这种设计模式就会产生事与愿违的负面效果."}]},{"ID":"20231117222606-8ose9gt","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231117222606-8ose9gt","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"5 容器工厂模式"}]},{"ID":"20231117222606-72bmkb5","Type":"NodeParagraph","Properties":{"id":"20231117222606-72bmkb5","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"最后再给大家介绍另类的工厂模式——容器工厂. 这种模式的思路是，将工厂的改造为一个组件交易市场，每个组件的构造工作不再统一由工厂完成，取而代之的是，工厂会对外暴露一个统一的入口，所有组件的提供方通过这个入口完成组件的注入. 后续组件的使用方通过工厂这个中介提供的统一出口,进行对应组件的获取."}]},{"ID":"20231117222606-6y01plk","Type":"NodeParagraph","Properties":{"id":"20231117222606-6y01plk","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/sz_mmbiz_png/3ic3aBqT2ibZvqxoRqdFZ7Ecg3BpSibXcSua9vyw6dOXc5FAzgWlx7qqw1J8gFGefKGcWAGdZ8WUc5Q8lWEXw8Q1w/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231117222606-q1z4wli","Type":"NodeParagraph","Properties":{"id":"20231117222606-q1z4wli","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"实现这种容器工厂模式，需要依赖到第三方依赖注入框架的能力. 这边笔者使用到的是 golang 开源 ioc 框架 dig：https://github.com/uber-go/dig."}]},{"ID":"20231117222606-5eq389l","Type":"NodeParagraph","Properties":{"id":"20231117222606-5eq389l","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"在实现时，我们声明一个全局工厂类 factory ，同时 factory 中内嵌一个 dig container 的容器实例："}]},{"ID":"20231117222606-4cngq20","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-4cngq20","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type Factory struct {\n    container *dig.Container\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-xa2r0uu","Type":"NodeParagraph","Properties":{"id":"20231117222606-xa2r0uu","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"factory 需要对外暴露两个方法：Inject 和 Invoke 方法，分别作为注入组件的入口方法和获取组件的出口方法："}]},{"ID":"20231117222606-dm9if69","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-dm9if69","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func (f *Factory) Inject(constructor interface{}) error {\n    return f.container.Provide(constructor)\n}\n\n\nfunc (f *Factory) Invoke(invoker interface{}) error {\n    return f.container.Invoke(invoker)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-onz9511","Type":"NodeParagraph","Properties":{"id":"20231117222606-onz9511","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"接下来我们实现好一个工厂类的单例对象，方便让各处的组件提供方和组件使用方能够快速地获取到相同容器工厂实例. （此处涉及到单例模式的设计思路并用到了golang 标准库提供的单例工具 sync.Once，大家对更细节的内容感兴趣的话，可以阅读我之前发表的文章——Golang 设计模式之单例模式）"}]},{"ID":"20231117222606-bagsi1r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-bagsi1r","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"package factory\n\n\nvar (\n    once    sync.Once\n    factory *Factory\n)\n\n\nfunc GetFactory() *Factory {\n    once.Do(func() {\n        factory = newFactory(dig.New())\n    })\n    return factory\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-zy7kpei","Type":"NodeParagraph","Properties":{"id":"20231117222606-zy7kpei","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"各处的组件提供方，可以通过 GetFactory 方法快速获取到工厂单例 factory，并调用 Factory.Inject 方法，完成将组件注入到容器工厂的操作. （dig 采用组件懒加载的方式，此处注入组件实际上注入的是组件的构造器方法，组件真正的构造时机处于其第一次被真正使用到时）"}]},{"ID":"20231117222606-kzi4o6a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-kzi4o6a","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func init() {\n    f := factory.GetFactory()\n    f.Inject(NewComponentX)\n}\n\n\ntype ComponentX struct{}\n\n\nfunc NewComponentX() *ComponentX{\n    return \u0026ComponentX{}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-1nzjllo","Type":"NodeParagraph","Properties":{"id":"20231117222606-1nzjllo","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"当需要通过工厂获取组件时，用户可以在任意位置调用 GetFactory 方法获取到工厂单例 factory，然后通过 Invoke 方法闭包注入组件的提取函数，容器工厂会对闭包函数的入参进行反射，映射到对应的组件实例，然后将其闭包传值返回"}]},{"ID":"20231117222606-3tr3mbd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117222606-3tr3mbd","updated":"20231117222606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func GetComponentX()(*ComponentX,error){\n    f := factory.GetFactory()  \n    var componentX *ComponentX\n    return componentX, f.Invoke(func(_x *ComponentX){\n        componentX = _x\n    })\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117222606-f95826g","Type":"NodeParagraph","Properties":{"id":"20231117222606-f95826g","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"倘若大家对于 golang 依赖注入框架 dig 的更多细节内容感兴趣的话，可以阅读我之前发表的文章——低配 Spring—Golang IOC 框架 dig 原理解析."}]},{"ID":"20231117222606-gb9wlvi","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231117222606-gb9wlvi","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"6 总结"}]},{"ID":"20231117222606-0aa07f5","Type":"NodeParagraph","Properties":{"id":"20231117222606-0aa07f5","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"本期通过 Go 语言和大家分享了设计模式中的工厂模式："}]},{"ID":"20231117222606-8f91xks","Type":"NodeParagraph","Properties":{"id":"20231117222606-8f91xks","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"工厂模式的优势是，通过在组件类和使用方之间添加一个工厂类中间层，实现了代码的防腐和解耦，同时为一部分组件类的构造流程提供出公共切面."}]},{"ID":"20231117222606-o4vssds","Type":"NodeParagraph","Properties":{"id":"20231117222606-o4vssds","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"工厂模式可以进一步细分为:"}]},{"ID":"20231117222606-o5o1k9e","Type":"NodeList","ListData":{},"Properties":{"id":"20231117222606-o5o1k9e","updated":"20231117222606"},"Children":[{"ID":"20231117222606-371df2t","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-371df2t","updated":"20231117222606"},"Children":[{"ID":"20231117222606-xu402cr","Type":"NodeParagraph","Properties":{"id":"20231117222606-xu402cr","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 简单工厂模式: 工厂模式中最简单直观的实现方式,有很好的切面效果,但是在组件类扩展时无法满足开闭原则"}]}]},{"ID":"20231117222606-h2gkhx3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-h2gkhx3","updated":"20231117222606"},"Children":[{"ID":"20231117222606-vm2pbed","Type":"NodeParagraph","Properties":{"id":"20231117222606-vm2pbed","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 工厂方法模式: 一个组件类对应一个工厂类, 存在一定的代码冗余以及对公共切面的削弱，但是能够在组件类扩展时满足开闭原则"}]}]},{"ID":"20231117222606-nan4vd0","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231117222606-nan4vd0","updated":"20231117222606"},"Children":[{"ID":"20231117222606-u3xmutu","Type":"NodeParagraph","Properties":{"id":"20231117222606-u3xmutu","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"• 抽象工厂模式: 通过两个维度对组件类进行拆解. 需要保证易于扩展、灵活可变的维度需要定义为产品族；相对稳定、不易于扩展维度需要定义为产品等级. 这样能同时保证产品族维度的扩展灵活性以及产品等级维度的切面能力."}]}]}]},{"ID":"20231117222606-nbryloc","Type":"NodeParagraph","Properties":{"id":"20231117222606-nbryloc","updated":"20231117222606"},"Children":[{"Type":"NodeText","Data":"此外，本文还额外介绍了一种另类的容器工厂模式，底层需要基于依赖注入框架实现，让组件提供能够在各处方便地完成组件类的注入操作，而组件的使用方，则通过容器工厂的统一出口进行组件的获取."}]}]}