{"ID":"20231116160509-z8eopry","Spec":"1","Type":"NodeDocument","Properties":{"icon":"3297","id":"20231116160509-z8eopry","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20231116160509-z8eopry\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231116160520-55lfp8g\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231116160509-0dmdc2w\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20231116160520-55lfp8g\u0026quot;,\u0026quot;focusStart\u0026quot;:27,\u0026quot;focusEnd\u0026quot;:27\u0026#125;","title":"1-Gin 框架如何处理 painc","updated":"20231117104515"},"Children":[{"ID":"20231116215158-py4ihe3","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231116215158-py4ihe3","updated":"20231116215207"},"Children":[{"Type":"NodeText","Data":"painc 的发生："}]},{"ID":"20231116215054-bont0pw","Type":"NodeParagraph","Properties":{"id":"20231116215054-bont0pw","updated":"20231116215149"},"Children":[{"Type":"NodeText","Data":"在golang中，如果在子协程中遇到 panic，那么主协程也会被终止。"}]},{"ID":"20231116215150-79jmmrp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231116215150-79jmmrp","updated":"20231116215313"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n    // 在子协程中引起panic，主协程也会退出\n\tgo func() {\n\t\tpanic(\"hello world\")\n\t}()\n  \n\t// Listen and Server in 0.0.0.0:8080\n\tr.Run(\":8080\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231116215329-8z4ydof","Type":"NodeParagraph","Properties":{"id":"20231116215329-8z4ydof","updated":"20231116220052"},"Children":[{"Type":"NodeText","Data":"panic被描述为不可处理的错误。在web服务中就是服务会崩溃。当然，这在生产环境下是不可接受的。那么，如何能够做到发生panic时技能捕获该panic又能让服务继续健康运行呢？"}]},{"ID":"20231116220104-68731az","Type":"NodeParagraph","Properties":{"id":"20231116220104-68731az","updated":"20231116220127"},"Children":[{"Type":"NodeText","Data":"这就是golang中提供的recover函数了。"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-font-background3); color: var(--b3-card-warning-color);"},"TextMarkType":"text strong","TextMarkTextContent":"recover函数能够捕获Panic错误并恢复程序的正常运行。 "},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-font-background3); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeText","Data":"接下来，我们看下recover函数在gin框架中是如何应用的。"}]},{"ID":"20231116220323-a6ohn6n","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231116220323-a6ohn6n","updated":"20231117103028"},"Children":[{"Type":"NodeText","Data":"Gin Recovery 中间件"}]},{"ID":"20231116220451-ungncn3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231116220451-ungncn3","updated":"20231116221123"},"Children":[{"Type":"NodeText","Data":"Gin.Default"}]},{"ID":"20231116220106-6opdhnz","Type":"NodeParagraph","Properties":{"id":"20231116220106-6opdhnz","updated":"20231116220200"},"Children":[{"Type":"NodeText","Data":"首先，要提到的就是gin框架中的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"recovery中间件"},{"Type":"NodeText","Data":"。在gin中，是通过使用该中间件来捕获panic，并保证服务不down机的。 "},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-font-background6);"},"TextMarkType":"text","TextMarkTextContent":"如果使用gin.Default()函数进行构建gin对象，那么默认就注册了Recovery中间件。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-font-background6);\"}"}]},{"ID":"20231116220211-37ndhwp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231116220211-37ndhwp","updated":"20231116220253"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func Default() *Engine {\n\tdebugPrintWARNINGDefault()\n\tengine := New()\n    //  注册了Recovery中间件\n\tengine.Use(Logger(), Recovery())\n\treturn engine\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231116221126-kjbniuz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231116221126-kjbniuz","updated":"20231116221138"},"Children":[{"Type":"NodeText","Data":"Recovery() "}]},{"ID":"20231116221153-nvxnxpq","Type":"NodeParagraph","Properties":{"id":"20231116221153-nvxnxpq","updated":"20231116221155"},"Children":[{"Type":"NodeText","Data":"我们来看下Recovery()中间件都做了些什么。"}]},{"ID":"20231116221153-okoj3ep","Type":"NodeParagraph","Properties":{"id":"20231116221153-okoj3ep","updated":"20231116221153"},"Children":[{"Type":"NodeText","Data":"Recovery()函数定义如下："}]},{"ID":"20231116221158-w8vc6b5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231116221158-w8vc6b5","updated":"20231116221227"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func Recovery() HandlerFunc {\n\treturn RecoveryWithWriter(DefaultErrorWriter)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231116221245-rr9f4i3","Type":"NodeParagraph","Properties":{"id":"20231116221245-rr9f4i3","updated":"20231116221245"},"Children":[{"Type":"NodeText","Data":"这里的DefaultErrorWriter是默认的输出端，即os.Stderr。即指错误的输出到什么地方。"}]},{"ID":"20231116221245-ztn5rbq","Type":"NodeParagraph","Properties":{"id":"20231116221245-ztn5rbq","updated":"20231116221245"},"Children":[{"Type":"NodeText","Data":"接下来看RecoveryWithWriter函数中的实现"}]},{"ID":"20231116221247-qgi4qn9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231116221247-qgi4qn9","updated":"20231116221409"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// RecoveryWithWriter returns a middleware for a given writer that recovers from any panics and writes a 500 if there was one.\nfunc RecoveryWithWriter(out io.Writer, recovery ...RecoveryFunc) HandlerFunc {\n\tif len(recovery) \u003e 0 {\n\t\treturn CustomRecoveryWithWriter(out, recovery[0])\n\t}\n\treturn CustomRecoveryWithWriter(out, defaultHandleRecovery)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231116221426-de5aazr","Type":"NodeParagraph","Properties":{"id":"20231116221426-de5aazr","updated":"20231116221433"},"Children":[{"Type":"NodeText","Data":"这里有一个参数是defaultHandleRecovery，我们看下它的实现："}]},{"ID":"20231116221435-srudq4u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231116221435-srudq4u","updated":"20231116221457"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func defaultHandleRecovery(c *Context, err any) {\n\tc.AbortWithStatus(http.StatusInternalServerError)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231116221900-5lsac05","Type":"NodeParagraph","Properties":{"id":"20231116221900-5lsac05","updated":"20231116221900"},"Children":[{"Type":"NodeText","Data":"就是写入了一个代表内部服务器错误的状态码500，并结束了本次请求。"}]},{"ID":"20231116221900-02yoly1","Type":"NodeParagraph","Properties":{"id":"20231116221900-02yoly1","updated":"20231116221900"},"Children":[{"Type":"NodeText","Data":"这里关键点是CustomRecoveryWithWriter的实现，代码很长，我们分段来看。如下："}]},{"ID":"20231116221902-zd1xixk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231116221902-zd1xixk","updated":"20231116222446"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// CustomRecoveryWithWriter returns a middleware for a given writer that recovers from any panics and calls the provided handle func to handle it.\n// CustomRecoveryWithWriter为给定的编写器返回一个中间件，该编写器可以从任何死机中恢复，并调用提供的句柄函数来处理它。\nfunc CustomRecoveryWithWriter(out io.Writer, handle RecoveryFunc) HandlerFunc {\n\tvar logger *log.Logger\n\tif out != nil {\n\t\tlogger = log.New(out, \"\\n\\n\\x1b[31m\", log.LstdFlags)\n\t}\n\treturn func(c *Context) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\t// Check for a broken connection, as it is not really a\n\t\t\t\t// condition that warrants a panic stack trace.\n\t\t\t\tvar brokenPipe bool\n\t\t\t\tif ne, ok := err.(*net.OpError); ok {\n\t\t\t\t\tvar se *os.SyscallError\n\t\t\t\t\tif errors.As(ne, \u0026se) {\n\t\t\t\t\t\tseStr := strings.ToLower(se.Error())\n\t\t\t\t\t\tif strings.Contains(seStr, \"broken pipe\") ||\n\t\t\t\t\t\t\tstrings.Contains(seStr, \"connection reset by peer\") {\n\t\t\t\t\t\t\tbrokenPipe = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif logger != nil {\n\t\t\t\t\tstack := stack(3)\n\t\t\t\t\thttpRequest, _ := httputil.DumpRequest(c.Request, false)\n\t\t\t\t\theaders := strings.Split(string(httpRequest), \"\\r\\n\")\n\t\t\t\t\tfor idx, header := range headers {\n\t\t\t\t\t\tcurrent := strings.Split(header, \":\")\n\t\t\t\t\t\tif current[0] == \"Authorization\" {\n\t\t\t\t\t\t\theaders[idx] = current[0] + \": *\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theadersToStr := strings.Join(headers, \"\\r\\n\")\n\t\t\t\t\tif brokenPipe {\n\t\t\t\t\t\tlogger.Printf(\"%s\\n%s%s\", err, headersToStr, reset)\n\t\t\t\t\t} else if IsDebugging() {\n\t\t\t\t\t\tlogger.Printf(\"[Recovery] %s panic recovered:\\n%s\\n%s\\n%s%s\",\n\t\t\t\t\t\t\ttimeFormat(time.Now()), headersToStr, err, stack, reset)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.Printf(\"[Recovery] %s panic recovered:\\n%s\\n%s%s\",\n\t\t\t\t\t\t\ttimeFormat(time.Now()), err, stack, reset)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif brokenPipe {\n\t\t\t\t\t// If the connection is dead, we can't write a status to it.\n\t\t\t\t\tc.Error(err.(error)) //nolint: errcheck\n\t\t\t\t\tc.Abort()\n\t\t\t\t} else {\n\t\t\t\t\thandle(c, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tc.Next()\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231116223422-2p85crf","Type":"NodeParagraph","Properties":{"id":"20231116223422-2p85crf","updated":"20231116223431"},"Children":[{"Type":"NodeText","Data":"主要分为三部分："}]},{"ID":"20231116223432-iwty68g","Type":"NodeList","ListData":{},"Properties":{"id":"20231116223432-iwty68g","updated":"20231116223434"},"Children":[{"ID":"20231116223434-tomsmvn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231116223434-tomsmvn","updated":"20231116223434"},"Children":[{"ID":"20231116223434-nxgqlb8","Type":"NodeParagraph","Properties":{"id":"20231116223434-nxgqlb8","updated":"20231116223517"},"Children":[{"Type":"NodeText","Data":"将日志输出到out中，这里是上述提到的 DefaultErrorWriter， 即 os.Stderr。"}]}]},{"ID":"20231116223517-8tvgcy9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231116223517-8tvgcy9"},"Children":[{"ID":"20231116223517-94x6jmo","Type":"NodeParagraph","Properties":{"id":"20231116223517-94x6jmo","updated":"20231116223547"},"Children":[{"Type":"NodeText","Data":"defer 延迟执行部分。"}]}]},{"ID":"20231116223547-4bnggh6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231116223547-4bnggh6"},"Children":[{"ID":"20231116223547-eu0jo4d","Type":"NodeParagraph","Properties":{"id":"20231116223547-eu0jo4d","updated":"20231116223624"},"Children":[{"Type":"NodeText","Data":"c.Next() 正常请求处理器部分。"}]}]}]},{"ID":"20231116223624-ue0vkor","Type":"NodeParagraph","Properties":{"id":"20231116223624-ue0vkor"}},{"ID":"20231116223626-mzy41bj","Type":"NodeParagraph","Properties":{"id":"20231116223626-mzy41bj","updated":"20231116223637"},"Children":[{"Type":"NodeText","Data":"这里需要注意的点是："}]},{"ID":"20231116223650-n4axfo0","Type":"NodeList","ListData":{},"Properties":{"id":"20231116223650-n4axfo0","updated":"20231116223650"},"Children":[{"ID":"20231116223650-jy0ymda","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231116223650-jy0ymda","updated":"20231116223650"},"Children":[{"ID":"20231116223650-ejsdlfy","Type":"NodeParagraph","Properties":{"id":"20231116223650-ejsdlfy","updated":"20231116223650"},"Children":[{"Type":"NodeText","Data":"recover函数需要再defer中调用。因为defer是在函数返回时才调用，所以当发生panic时会导致函数返回，这样才能捕获panic。"}]}]},{"ID":"20231116223650-617zjri","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231116223650-617zjri","updated":"20231116223650"},"Children":[{"ID":"20231116223650-3j43p8q","Type":"NodeParagraph","Properties":{"id":"20231116223650-3j43p8q","updated":"20231116223650"},"Children":[{"Type":"NodeText","Data":"作为中间件运行，说明每次请求的处理器都被中间件包装了，也就相当于每个请求处理器都有这个defer函数。"}]}]},{"ID":"20231116223650-vf9t8oe","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231116223650-vf9t8oe","updated":"20231116223650"},"Children":[{"ID":"20231116223650-g8wop2e","Type":"NodeParagraph","Properties":{"id":"20231116223650-g8wop2e","updated":"20231116223650"},"Children":[{"Type":"NodeText","Data":"在defer函数中，如果捕获了panic，则将panic的详细详细记录下来，可以发送到指定的输出中，即函数中指定的out参数（默认是os.Stderr），也可以指定其他的文件或Sentry等。"}]}]}]},{"ID":"20231116223650-5cuuyf6","Type":"NodeParagraph","Properties":{"id":"20231116223650-5cuuyf6","updated":"20231116223805"},"Children":[{"Type":"NodeText","Data":"在gin中，正是该中间件的应用，确保了web服务的健壮性。当然，其他的web框架也有同样的机制，实现原理也是一样的。"}]},{"ID":"20231117102804-cqi2812","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231117102804-cqi2812","updated":"20231117103108"},"Children":[{"Type":"NodeText","Data":"如何实现自定义 recovery 中间件"}]},{"ID":"20231117103109-1zsbyci","Type":"NodeParagraph","Properties":{"id":"20231117103109-1zsbyci","updated":"20231117103120"},"Children":[{"Type":"NodeText","Data":"如果使用 gin 框架的话，就非常简单了，因为 gin 提供了完善的中间件功能，遵守 gin 的要求实现满足自己项目的功能就可以了，简单示例代码如下："}]},{"ID":"20231117103122-lxh19i5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117103122-lxh19i5","updated":"20231117104442"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func Recovery() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tconst size = 64 \u003c\u003c 10 // 1024\n\t\t\t\tstack := make([]byte, size)\n\t\t\t\tstack = stack[:runtime.Stack(stack, false)]\n\t\t\t\tlog.Printf(\"[GinPanic] %s\\n\", string(stack))\n\t\t\t\tc.JSON(http.StatusOK, struct {\n\t\t\t\t\tCode int         `json:\"code\"`\n\t\t\t\t\tData interface{} `json:\"data\"`\n\t\t\t\t\tMsg  string      `json:\"msg\"`\n\t\t\t\t}{\n\t\t\t\t\tCode: -1,\n\t\t\t\t\tData: nil,\n\t\t\t\t\tMsg:  \"server panic\",\n\t\t\t\t})\n\t\t\t\tc.Abort()\n\t\t\t\t// 在 Gin 框架中，c.Abort() 是一个用于终止请求处理的方法。它用于提前结束当前请求的处理，并返回一个 HTTP 状态码和相应的响应。\n\t\t\t\t//\n\t\t\t\t//c.Abort() 方法的调用会立即停止当前的请求处理流程，不会执行后续的中间件或路由处理逻辑。它返回一个 *gin.Context 类型的值，该值包含 HTTP 状态码、响应头和响应体等信息。\n\t\t\t\t//\n\t\t\t\t//通常，c.Abort() 方法在以下情况下使用：\n\t\t\t\t//\n\t\t\t\t//当请求处理过程中发生错误或异常时，可以使用 c.Abort() 中止请求处理并返回错误信息或响应。\n\t\t\t\t//在某些中间件或路由处理逻辑中，如果满足特定条件，可以使用 c.Abort() 提前结束请求处理而不执行后续逻辑。\n\t\t\t\t//需要注意的是，c.Abort() 方法并不会终止请求处理的程序或应用程序的执行。它只会中止当前请求的处理流程。\n\t\t\t\t//Abort阻止调用挂起的处理程序。请注意，这不会停止当前处理程序。假设您有一个授权中间件来验证当前请求是否已被授权。如果授权失败（例如：密码不匹配），请调用Abort以确保不会调用此请求的其余处理程序。\n\t\t\t}\n\t\t}()\n\t\tc.Next()\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117104445-5sqkwcz","Type":"NodeParagraph","Properties":{"id":"20231117104445-5sqkwcz","updated":"20231117104451"},"Children":[{"Type":"NodeText","Data":"使用示例如下："}]},{"ID":"20231117104452-0aayuhq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231117104452-0aayuhq","updated":"20231117104512"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n \nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"runtime\"\n)\n \nfunc main() {\n\tr := gin.New()\n\tr.Use(Recovery())\n\tr.GET(\"/test\", func(c *gin.Context) {\n\t\tpanic(\"Oops! Something went wrong.\")\n\t})\n\tr.Run(\":8080\")\n}"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231117104515-cd99cky","Type":"NodeParagraph","Properties":{"id":"20231117104515-cd99cky"}}]}