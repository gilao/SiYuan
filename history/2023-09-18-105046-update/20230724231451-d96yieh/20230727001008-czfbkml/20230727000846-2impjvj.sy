{"ID":"20230727000846-2impjvj","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f943","id":"20230727000846-2impjvj","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230727000846-2impjvj\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230727000847-u5vbswr\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230727000927-84yunsp\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230727000847-u5vbswr\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","tags":"goroutine,协程,sync.WaitGroup,Channel","title":"11. goroutine","updated":"20230727000846"},"Children":[{"ID":"20230727000847-u5vbswr","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230727000847-u5vbswr","updated":"20230727000847"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"11. goroutine"}]},{"ID":"20230727000848-ke5uv9r","Type":"NodeParagraph","Properties":{"id":"20230727000848-ke5uv9r","updated":"20230727000848"},"Children":[{"Type":"NodeText","Data":"Goroutine 是 Go 语言支持并发的核心，在一个Go程序中同时创建成百上千个goroutine是非常普遍的，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。区别于操作系统线程由系统内核进行调度， goroutine 是由Go运行时（runtime）负责调度。例如Go运行时会智能地将 m个goroutine 合理地分配给n个操作系统线程，实现类似m:n的调度机制，不再需要Go开发者自行在代码层面维护一个线程池。"}]},{"ID":"20230727000849-vropfci","Type":"NodeParagraph","Properties":{"id":"20230727000849-vropfci","updated":"20230727000849"},"Children":[{"Type":"NodeText","Data":"Goroutine 是 Go 程序中最基本的并发执行单元。每一个 Go 程序都至少包含一个 goroutine——main goroutine，当 Go 程序启动时它会自动创建。"}]},{"ID":"20230727000850-6pehr4i","Type":"NodeParagraph","Properties":{"id":"20230727000850-6pehr4i","updated":"20230727000850"},"Children":[{"Type":"NodeText","Data":"在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能——goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个 goroutine 去执行这个函数就可以了，就是这么简单粗暴。"}]},{"ID":"20230727000851-8q5z9t4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000851-8q5z9t4","updated":"20230727000851"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"go 关键字"}]},{"ID":"20230727000852-85ik0nu","Type":"NodeParagraph","Properties":{"id":"20230727000852-85ik0nu","updated":"20230727000852"},"Children":[{"Type":"NodeText","Data":"o语言中使用 goroutine 非常简单，只需要在函数或方法调用前加上"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"go"},{"Type":"NodeText","Data":"关键字就可以创建一个 goroutine ，从而让该函数或方法在新创建的 goroutine 中执行。"}]},{"ID":"20230727000853-0yzon10","Type":"NodeParagraph","Properties":{"id":"20230727000853-0yzon10","updated":"20230727000853"},"Children":[{"Type":"NodeText","Data":"匿名函数也支持使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"go"},{"Type":"NodeText","Data":"关键字创建 goroutine 去执行"}]},{"ID":"20230727000854-kmzbpku","Type":"NodeParagraph","Properties":{"id":"20230727000854-kmzbpku","updated":"20230727000854"},"Children":[{"Type":"NodeText","Data":"一个 goroutine 必定对应一个函数/方法，可以创建多个goroutine 去执行相同的函数/方法"}]},{"ID":"20230727000855-5jyu0nn","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000855-5jyu0nn","updated":"20230727000855"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"启动单个的goroutine"}]},{"ID":"20230727000856-oigodjn","Type":"NodeParagraph","Properties":{"id":"20230727000856-oigodjn","updated":"20230727000856"},"Children":[{"Type":"NodeText","Data":"启动 goroutine 的方式非常简单，只需要在调用函数（普通函数和匿名函数）前加上一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"go"},{"Type":"NodeText","Data":"关键字。"}]},{"ID":"20230727000857-cgjpkpn","Type":"NodeParagraph","Properties":{"id":"20230727000857-cgjpkpn","updated":"20230727000857"},"Children":[{"Type":"NodeText","Data":"我们先来看一个在 main 函数中执行普通函数调用的示例。"}]},{"ID":"20230727000858-tftqpxa","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000858-tftqpxa","updated":"20230727000858"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc hello() {\n\tfmt.Println(\"hello\")\n}\n\nfunc main() {\n\thello()\n\tfmt.Println(\"你好\")\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000859-ilqyazi","Type":"NodeParagraph","Properties":{"id":"20230727000859-ilqyazi","updated":"20230727000859"},"Children":[{"Type":"NodeText","Data":"将上面的代码编译后执行，得到的结果如下："}]},{"ID":"20230727000860-b038e8c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000860-b038e8c","updated":"20230727000860"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"hello\n你好\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000861-rpn8cn0","Type":"NodeParagraph","Properties":{"id":"20230727000861-rpn8cn0","updated":"20230727000861"},"Children":[{"Type":"NodeText","Data":"代码中 hello 函数和其后面的打印语句是串行的。"}]},{"ID":"20230727000862-r1mmx3j","Type":"NodeParagraph","Properties":{"id":"20230727000862-r1mmx3j","updated":"20230727000862"},"Children":[{"Type":"NodeText","Data":"接下来我们在调用 hello 函数前面加上关键字"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"go"},{"Type":"NodeText","Data":"，也就是启动一个 goroutine 去执行 hello 这个函数。"}]},{"ID":"20230727000863-tsy1q32","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000863-tsy1q32","updated":"20230727000863"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func main() {\n\tgo hello() // 启动另外一个goroutine去执行hello函数\n\tfmt.Println(\"main goroutine done!\")\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000864-sqgcfzi","Type":"NodeParagraph","Properties":{"id":"20230727000864-sqgcfzi","updated":"20230727000864"},"Children":[{"Type":"NodeText","Data":"将上述代码重新编译后执行，得到输出结果如下。"}]},{"ID":"20230727000865-vzarsn8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000865-vzarsn8","updated":"20230727000865"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"你好\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000866-u0vsavr","Type":"NodeParagraph","Properties":{"id":"20230727000866-u0vsavr","updated":"20230727000866"},"Children":[{"Type":"NodeText","Data":"这一次的执行结果只在终端打印了”你好”，并没有打印 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hello"},{"Type":"NodeText","Data":"。这是为什么呢？"}]},{"ID":"20230727000867-b0lb2ca","Type":"NodeParagraph","Properties":{"id":"20230727000867-b0lb2ca","updated":"20230727000867"},"Children":[{"Type":"NodeText","Data":"其实在 Go 程序启动时，Go 程序就会为 main 函数创建一个默认的 goroutine 。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"在上面的代码中我们"},{"Type":"NodeText","Data":"在 main 函数中使用 go 关键字创建了另外一个 goroutine 去执行 hello 函数，而此时 main goroutine 还在继续往下执行，我们的程序中此时存在两个并发执行的 goroutine。当 main 函数结束时整个程序也就结束了，同时 main goroutine 也结束了，所有由 main goroutine 创建的 goroutine 也会一同退出。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"也就是说我们的 main 函数退出太快，另外一个 goroutine 中的函数还未执行完程序就退出了，导致未打印出“hello”。"}]},{"ID":"20230727000868-ld4q49r","Type":"NodeParagraph","Properties":{"id":"20230727000868-ld4q49r","updated":"20230727000868"},"Children":[{"Type":"NodeText","Data":"所以我们要想办法让 main 函数‘“等一等”将在另一个 goroutine 中运行的 hello 函数。其中最简单粗暴的方式就是在 main 函数中“time.Sleep”一秒钟了（这里的1秒钟只是我们为了保证新的 goroutine 能够被正常创建和执行而设置的一个值）。"}]},{"ID":"20230727000869-j6capkx","Type":"NodeParagraph","Properties":{"id":"20230727000869-j6capkx","updated":"20230727000869"},"Children":[{"Type":"NodeText","Data":"按如下方式修改我们的代码"}]},{"ID":"20230727000870-70sjg8l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000870-70sjg8l","updated":"20230727000870"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc hello() {\n\tfmt.Println(\"hello\")\n}\n\nfunc main() {\n\tgo hello()\n\tfmt.Println(\"你好\")\n\ttime.Sleep(time.Second)\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000871-32z9xqm","Type":"NodeParagraph","Properties":{"id":"20230727000871-32z9xqm","updated":"20230727000871"},"Children":[{"Type":"NodeText","Data":"将我们的程序重新编译后再次执行，程序会在终端输出如下结果，并且会短暂停顿一会儿。"}]},{"ID":"20230727000872-j6pursq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000872-j6pursq","updated":"20230727000872"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"你好\nhello\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000873-lxjaqfi","Type":"NodeParagraph","Properties":{"id":"20230727000873-lxjaqfi","updated":"20230727000873"},"Children":[{"Type":"NodeText","Data":"为什么会先打印"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"你好"},{"Type":"NodeText","Data":"呢？"}]},{"ID":"20230727000874-8xz0xpy","Type":"NodeParagraph","Properties":{"id":"20230727000874-8xz0xpy","updated":"20230727000874"},"Children":[{"Type":"NodeText","Data":"这是因为在程序中创建 goroutine 执行函数需要一定的开销，而与此同时 main 函数所在的 goroutine 是继续执行的。"}]},{"ID":"20230727000875-hg3r7cc","Type":"NodeParagraph","Properties":{"id":"20230727000875-hg3r7cc","updated":"20230727000875"},"Children":[{"Type":"NodeText","Data":"Go 语言中通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync"},{"Type":"NodeText","Data":"包为我们提供了一些常用的并发原语，我们会在后面的小节单独介绍"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync"},{"Type":"NodeText","Data":"包中的内容。在这一小节，我们会先介绍一下 sync 包中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WaitGroup"},{"Type":"NodeText","Data":"。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当你并不关心并发操作的结果或者有其它方式收集并发操作的结果时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"WaitGroup"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是实现等待一组并发操作完成的好方法。"}]},{"ID":"20230727000876-3vr506n","Type":"NodeParagraph","Properties":{"id":"20230727000876-3vr506n","updated":"20230727000876"},"Children":[{"Type":"NodeText","Data":"下面的示例代码中我们在 main goroutine 中使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.WaitGroup"},{"Type":"NodeText","Data":"来等待 hello goroutine 完成后再退出"}]},{"ID":"20230727000877-0ja9s9o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000877-0ja9s9o","updated":"20230727000877"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// 声明全局等待组变量\nvar wg sync.WaitGroup\n\nfunc hello() {\n\tfmt.Println(\"hello\")\n\twg.Done() // 告知当前goroutine完成\n}\n\nfunc main() {\n\twg.Add(1) // 登记1个goroutine\n\tgo hello()\n\tfmt.Println(\"你好\")\n\twg.Wait() // 阻塞等待登记的goroutine完成\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000878-dv2do4f","Type":"NodeParagraph","Properties":{"id":"20230727000878-dv2do4f","updated":"20230727000878"},"Children":[{"Type":"NodeText","Data":"将代码编译后再执行，得到的输出结果和之前的一致，但是不会有多余的停顿，hello goroutine 执行完毕后程序直接退出。"}]},{"ID":"20230727000879-sv63t84","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000879-sv63t84","updated":"20230727000879"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"启动多个goroutine"}]},{"ID":"20230727000880-it504gm","Type":"NodeParagraph","Properties":{"id":"20230727000880-it504gm","updated":"20230727000880"},"Children":[{"Type":"NodeText","Data":"在 Go 语言中实现并发就是这样简单，我们还可以启动多个 goroutine 。让我们再来看一个新的代码示例。这里同样使用了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.WaitGroup"},{"Type":"NodeText","Data":"来实现 goroutine 的同步"}]},{"ID":"20230727000881-yxlg5no","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000881-yxlg5no","updated":"20230727000881"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar wg sync.WaitGroup\n\nfunc hello(i int) {\n\tdefer wg.Done() // goroutine结束就登记-1\n\tfmt.Println(\"hello\", i)\n}\nfunc main() {\n\tfor i := 0; i \u003c 10; i++ {\n\t\twg.Add(1) // 启动一个goroutine就登记+1\n\t\tgo hello(i)\n\t}\n\twg.Wait() // 等待所有登记的goroutine都结束\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000882-ab6gwlx","Type":"NodeParagraph","Properties":{"id":"20230727000882-ab6gwlx","updated":"20230727000882"},"Children":[{"Type":"NodeText","Data":"多次执行上面的代码会发现每次终端上打印数字的顺序都不一致。这是因为10个 goroutine 是并发执行的，而 goroutine 的调度是随机的。"}]},{"ID":"20230727000883-gtzlkjn","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000883-gtzlkjn","updated":"20230727000883"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"结束 goroutine的方式"}]},{"ID":"20230727000884-l4jy6sp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000884-l4jy6sp","updated":"20230727000884"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"自然结束"}]},{"ID":"20230727000885-i4asc3j","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000885-i4asc3j","updated":"20230727000885"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"定时退出"}]},{"ID":"20230727000886-0271ek0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000886-0271ek0","updated":"20230727000886"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"通过channel传递信号"}]},{"ID":"20230727000887-m9oe895","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000887-m9oe895","updated":"20230727000887"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"context.Context"}]},{"ID":"20230727000888-h40094w","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000888-h40094w","updated":"20230727000888"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"sync.WaitGroup"}]},{"ID":"20230727000889-15j54td","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000889-15j54td","updated":"20230727000889"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"goroutine 之间的通信"}]},{"ID":"20230727000890-218noqi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000890-218noqi","updated":"20230727000890"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"共享内存"}]},{"ID":"20230727000891-n10ji4f","Type":"NodeParagraph","Properties":{"id":"20230727000891-n10ji4f","updated":"20230727000891"},"Children":[{"Type":"NodeText","Data":"通过在多个goroutine之间共享内存变量来进行通信。可以使用互斥锁（mutex）或读写锁（RWMutex）来保证多个goroutine对共享变量的安全访问。"}]},{"ID":"20230727000892-gaueqla","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000892-gaueqla","updated":"20230727000892"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"WaitGroup"}]},{"ID":"20230727000893-4opryz1","Type":"NodeParagraph","Properties":{"id":"20230727000893-4opryz1","updated":"20230727000893"},"Children":[{"Type":"NodeText","Data":"用于等待一组goroutine执行完成的同步原语。可以使用WaitGroup的Add()方法增加计数器，使用Done()方法减少计数器，使用Wait()方法等待计数器归零。"}]},{"ID":"20230727000894-8iy3y5x","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000894-8iy3y5x","updated":"20230727000894"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"原子操作"}]},{"ID":"20230727000895-45hvyu4","Type":"NodeParagraph","Properties":{"id":"20230727000895-45hvyu4","updated":"20230727000895"},"Children":[{"Type":"NodeText","Data":"使用原子操作可以提供对共享变量的原子读写操作，避免竞态条件。Go语言提供了atomic包，其中包含了一些原子操作函数。"}]},{"ID":"20230727000896-llg63b3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000896-llg63b3","updated":"20230727000896"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"全局变量与共享数据结构"}]},{"ID":"20230727000897-zgcrjgy","Type":"NodeParagraph","Properties":{"id":"20230727000897-zgcrjgy","updated":"20230727000897"},"Children":[{"Type":"NodeText","Data":"多个goroutine之间可以通过访问和修改共享的全局变量或数据结构来进行通信。这种方式需要保证对共享数据的访问是线程安全的，需要使用互斥锁等同步机制来保护共享数据的一致性。"}]},{"ID":"20230727000898-2ny45dd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000898-2ny45dd","updated":"20230727000898"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"动态栈"}]},{"ID":"20230727000899-6uwksmw","Type":"NodeParagraph","Properties":{"id":"20230727000899-6uwksmw","updated":"20230727000899"},"Children":[{"Type":"NodeText","Data":"操作系统的线程一般都有固定的栈内存（通常为2MB）,而 Go 语言中的 goroutine 非常轻量级，一个 goroutine 的初始栈空间很小（一般为2KB），所以在 Go 语言中一次创建数万个 goroutine 也是可能的。并且 goroutine 的栈不是固定的，可以根据需要动态地增大或缩小， Go 的 runtime 会自动为 goroutine 分配合适的栈空间。"}]},{"ID":"20230727000900-4avltfb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000900-4avltfb","updated":"20230727000900"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"goroutine调度"}]},{"ID":"20230727000901-mbcujrt","Type":"NodeParagraph","Properties":{"id":"20230727000901-mbcujrt","updated":"20230727000901"},"Children":[{"Type":"NodeText","Data":"操作系统内核在调度时会挂起当前正在执行的线程并将寄存器中的内容保存到内存中，然后选出接下来要执行的线程并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。从一个线程切换到另一个线程需要完整的上下文切换。因为可能需要多次内存访问，索引这个切换上下文的操作开销较大，会增加运行的cpu周期。"}]},{"ID":"20230727000902-eneb5i9","Type":"NodeParagraph","Properties":{"id":"20230727000902-eneb5i9","updated":"20230727000902"},"Children":[{"Type":"NodeText","Data":"区别于操作系统内核调度操作系统线程，goroutine 的调度是Go语言运行时（runtime）层面的实现，是完全由 Go 语言本身实现的一套调度系统——go scheduler。它的作用是按照一定的规则将所有的 goroutine 调度到操作系统线程上执行。"}]},{"ID":"20230727000903-ms62isv","Type":"NodeParagraph","Properties":{"id":"20230727000903-ms62isv","updated":"20230727000903"},"Children":[{"Type":"NodeText","Data":"在经历数个版本的迭代之后，目前 Go 语言的调度器采用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"GPM"},{"Type":"NodeText","Data":" 调度模型。"}]},{"ID":"20230727000904-rmncwj7","Type":"NodeParagraph","Properties":{"id":"20230727000904-rmncwj7","updated":"20230727000904"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"a23f016f1da5de3bdb253db2a07bc4a","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\a23f016f1da5de3bdb253db2a07bc4a.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000905-d7purmp","Type":"NodeParagraph","Properties":{"id":"20230727000905-d7purmp","updated":"20230727000905"},"Children":[{"Type":"NodeText","Data":"其中："}]},{"ID":"20230727000906-cy1qig0","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000906-cy1qig0","updated":"20230727000906"},"Children":[{"ID":"20230727000907-bajsspp","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000907-bajsspp","updated":"20230727000907"},"Children":[{"ID":"20230727000908-ux84hxj","Type":"NodeParagraph","Properties":{"id":"20230727000908-ux84hxj","updated":"20230727000908"},"Children":[{"Type":"NodeText","Data":"G：表示goroutine，每执行一次  "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"go f()"},{"Type":"NodeText","Data":"就创建一个 G，包含要执行的函数和上下文信息。"}]}]},{"ID":"20230727000909-rpwb157","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000909-rpwb157","updated":"20230727000909"},"Children":[{"ID":"20230727000910-t2bgmuj","Type":"NodeParagraph","Properties":{"id":"20230727000910-t2bgmuj","updated":"20230727000910"},"Children":[{"Type":"NodeText","Data":"全局队列（Global Queue）：存放等待运行的 G。"}]}]},{"ID":"20230727000911-u5ctxzl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000911-u5ctxzl","updated":"20230727000911"},"Children":[{"ID":"20230727000912-lui68hh","Type":"NodeParagraph","Properties":{"id":"20230727000912-lui68hh","updated":"20230727000912"},"Children":[{"Type":"NodeText","Data":"P：表示 goroutine 执行所需的资源，最多有 GOMAXPROCS 个。"}]}]},{"ID":"20230727000913-5highsw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000913-5highsw","updated":"20230727000913"},"Children":[{"ID":"20230727000914-pi7hq4l","Type":"NodeParagraph","Properties":{"id":"20230727000914-pi7hq4l","updated":"20230727000914"},"Children":[{"Type":"NodeText","Data":"P 的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建 G 时，G 优先加入到 P 的本地队列，如果本地队列满了会批量移动部分 G 到全局队列。"}]}]},{"ID":"20230727000915-0fwmgsw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000915-0fwmgsw","updated":"20230727000915"},"Children":[{"ID":"20230727000916-ulc33zx","Type":"NodeParagraph","Properties":{"id":"20230727000916-ulc33zx","updated":"20230727000916"},"Children":[{"Type":"NodeText","Data":"M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P 的本地队列为空时，M 也会尝试从全局队列或其他 P 的本地队列获取 G。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。"}]}]},{"ID":"20230727000917-yo9d4vt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000917-yo9d4vt","updated":"20230727000917"},"Children":[{"ID":"20230727000918-0xudov8","Type":"NodeParagraph","Properties":{"id":"20230727000918-0xudov8","updated":"20230727000918"},"Children":[{"Type":"NodeText","Data":"Goroutine 调度器和操作系统调度器是通过 M 结合起来的，每个 M 都代表了1个内核线程，操作系统调度器负责把内核线程分配到 CPU 的核上执行。"}]}]}]},{"ID":"20230727000919-j5m5por","Type":"NodeParagraph","Properties":{"id":"20230727000919-j5m5por","updated":"20230727000919"},"Children":[{"Type":"NodeText","Data":"单从线程调度讲，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的"},{"Type":"NodeText","Data":"， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。"}]},{"ID":"20230727000920-xe70yth","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000920-xe70yth","updated":"20230727000920"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"GOMAXPROCS"}]},{"ID":"20230727000921-hk27q8p","Type":"NodeParagraph","Properties":{"id":"20230727000921-hk27q8p","updated":"20230727000921"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Go运行时的调度器使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"GOMAXPROCS"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数"},{"Type":"NodeText","Data":"。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"runtime.GOMAXPROCS"},{"Type":"NodeText","Data":"函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部的CPU 逻辑核心数。）"}]},{"ID":"20230727000922-uqc0fmr","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000922-uqc0fmr","updated":"20230727000922"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"channel"}]},{"ID":"20230727000923-exsi3ym","Type":"NodeParagraph","Properties":{"id":"20230727000923-exsi3ym","updated":"20230727000923"},"Children":[{"Type":"NodeText","Data":"单纯的将函数并发执行 是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。"}]},{"ID":"20230727000924-2ve0mm1","Type":"NodeParagraph","Properties":{"id":"20230727000924-2ve0mm1","updated":"20230727000924"},"Children":[{"Type":"NodeText","Data":"虽然可以使用共享内存进行数据交换，但是 共享内存在不同的 goroutine 中容易发生竞态问题。为了保证数据交换的正确性，很多并发模型中必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。"}]},{"ID":"20230727000925-yfxj51k","Type":"NodeParagraph","Properties":{"id":"20230727000925-yfxj51k","updated":"20230727000925"},"Children":[{"Type":"NodeText","Data":"Go语言采用的并发模型是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CSP（Communicating Sequential Processes）"},{"Type":"NodeText","Data":"，提倡"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"通过通信共享内存"},{"Type":"NodeText","Data":"而不是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"通过共享内存而实现通信"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230727000926-vsarbf6","Type":"NodeParagraph","Properties":{"id":"20230727000926-vsarbf6","updated":"20230727000926"},"Children":[{"Type":"NodeText","Data":"如果说 goroutine 是Go程序并发的执行体，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"就是它们之间的连接。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"channel"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。"}]},{"ID":"20230727000927-84yunsp","Type":"NodeParagraph","Properties":{"id":"20230727000927-84yunsp","updated":"20230727000927"},"Children":[{"Type":"NodeText","Data":"Go 语言中的通道（channel）是一种特殊的类型"},{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeText","Data":"。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。"},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]}]}]}