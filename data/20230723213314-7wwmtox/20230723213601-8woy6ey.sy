{"ID":"20230723213601-8woy6ey","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f440","id":"20230723213601-8woy6ey","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230723213601-8woy6ey\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230723213625-rlxqtxg\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230723213601-b9rjfgf\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230723213625-rlxqtxg\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","tags":"C语言代码,RT-thread,串口","title":"Rt-thread串口代码","updated":"20230723213709"},"Children":[{"ID":"20230723213625-rlxqtxg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230723213625-rlxqtxg","updated":"20230723213709"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"/*\n * COPYRIGHT (C) 2012-2021, Shanghai Real-Thread Technology Co., Ltd\n */ \n#include \"rtthread.h\"\n#include \"rtdevice.h\"\n\n#define VLOG_TAG \"GREEDEV_IMPL\"\n\n/* bes2300 */\ntypedef struct re_err_t re_err_t;\n\n#include \"beswifi.h\"\n#include \"app_utils.h\"\n// #include \"drv_clock.h\"\n\n/* rtt audio + player */ \n#include \"raf.h\"\n#include \"player.h\"\n#include \"codec_helixmp3.h\"\n#include \"codec_helixaac.h\"\n#include \"format_mp4ff.h\"\n\n__attribute__((weak)) void rt_main_post_hook(void)\n{\n}\n\nstatic int set_volume(char *name, int volume)\n{\n    struct rt_audio_caps caps;\n    rt_device_t device; \n\n    device = rt_device_find(name);\n    if (device == RT_NULL)\n    {\n        rt_kprintf(\"Volume setting failed. %s driver not found!\\n\", name); \n        return (-RT_EIO);\n    }\n\n    if(strstr(name, \"sound\"))\n    {\n        caps.main_type   = AUDIO_TYPE_MIXER;\n        caps.sub_type    = AUDIO_MIXER_VOLUME; \n        caps.udata.value = volume;\n    }\n    else\n    {\n        caps.main_type   = AUDIO_TYPE_MIXER;\n        caps.sub_type    = AUDIO_MIXER_VITURAL;  \n        caps.udata.value = volume;\n    }\n\n    rt_kprintf(\"Set %s device volume = %d!\\n\", name, volume); \n    return rt_device_control(device, AUDIO_CTL_CONFIGURE, \u0026caps); \n}\n\n\n/*********************************************/\n#ifdef BSP_USING_GREE_DEVICE_HUB\n\n#include \"rt_gree_main.h\"\n\n#ifdef BSP_USING_MAGIC_CUBE\n#include \"magic_cube.h\"\n#endif\n\n#ifdef BSP_USING_UDS_DEMO\n#include \"uds_phony_app.h\"\n#endif\n\n#endif\n/*********************************************/\n\n#include \"wifi_config.h\"\n#include \"stdbool.h\"\n\n/* 串口接收消息结构*/\nstruct rx_msg\n{\n    rt_device_t dev;\n    rt_size_t size;\n};\n\n/* 串口设备句柄 */\nstatic rt_device_t serial;\nstatic struct serial_configure config = RT_SERIAL_CONFIG_DEFAULT;  /* 初始化配置参数 */\n//static volatile int flg_tc = 1;\n/* 消息队列控制块 */\nstatic struct rt_messagequeue rx_mq;\n\n/* 接收数据回调函数 */\nstatic rt_err_t uart_input(rt_device_t dev,rt_size_t size)\n{\n    struct rx_msg msg;\n    rt_err_t result;\n    msg.dev = dev;\n    msg.size = size;\n\n    result = rt_mq_send(\u0026rx_mq, \u0026msg, sizeof(msg));\n    if (result == -RT_EFULL)\n    {\n        rt_kprintf(\"uart1 message queue full!\\n\");\n    }\n    rt_kprintf(\"uart_input-send mq success\\n\");\n    return  result;\n}\n\nstatic void serial_thread_entry(void *parameter)\n{\n    rt_kprintf(\"start new tread \\n\");\n    struct rx_msg msg;\n    rt_err_t result;\n    rt_uint32_t rx_length;\n    static char rx_buffer[RT_SERIAL_RB_BUFSZ + 1];\n    while (1)\n    {\n        rt_memset(\u0026msg, 0, sizeof(msg));     // 将 msg变量所在的内存全部清零\n        result = rt_mq_recv(\u0026rx_mq, \u0026msg, sizeof(msg), RT_WAITING_FOREVER);  // 从消息队列中接收消息\n        rt_kprintf(\"rt_mq_recv port result:%d\\n\",result);\n        if (result == RT_EOK)\n        {\n            rt_kprintf(\"we get mq\\n\");\n            /* 从串口读取数据*/\n            rx_length = rt_device_read(msg.dev, 0, rx_buffer, msg.size);\n            rx_buffer[rx_length] = '\\0';\n            if (rx_length \u003e 0)\n            {\n                rt_kprintf(\"Read %d bytes from UART: %s\\r\\n\", rx_length, rx_buffer);\n            } else  {\n                rt_kprintf(\"Read fail!\\n\");\n            }\n            /* 通过串口设备 serial 输出读取到的消息 */\n            rt_device_write(serial, 0, rx_buffer, rx_length);\n            rt_kprintf(\"write end!!!\\n\");\n            /* 打印数据 */\n            rt_kprintf(\"%s\\n\",rx_buffer);\n        }\n        rt_kprintf(\"end a tread \\n\");\n    }\n}\n\nint rt_main(int argc, char **argv)\n{\n    rt_uint8_t prio = 1;\n\n#ifdef BSP_USING_GREE_DEVICE_HUB\n    rt_tick_t t0,t1;\n    rt_err_t err;\n    char macbuf[6+2];\n#endif\n    // extern int at_server_init(void);\n    // at_server_init();\n\n    /* rtt fal init */\n    fal_init();\n    mnt_init();\n    easyflash_init();\n\n    app_sysfreq_req(APP_SYSFREQ_USER_APP_2, APP_SYSFREQ_390M);\n\n    /* necessary action */\n    rt_thread_control(rt_thread_find(\"audio_flinger\"),\n        RT_THREAD_CTRL_CHANGE_PRIORITY, (void *)\u0026prio);\n\n    /* Create a virtual sound card on sound0 device */\n    pcm_create(\"pcm0\", \"sound0\");\n    pcm_create(\"pcm1\", \"sound0\");\n    raf_init();\n\n    /* intitial wavplayer sample player */\n    // wavplayer_init();\n\tplayer_bt_set_device_name(\"pcm1\");\n\n    /* intitial libplayer2 */\n    player_codec_helixmp3_register();\n    player_codec_helixaac_register();\n    player_format_mp4ff_register();\n    player_set_device_name(\"pcm0\");\n    player_system_init();\n    player_set_volume(60);\n    set_volume(\"sound0\", 60);\n\n    /* wifi init */\n    int ret = bes_wifi_init();\n    if (ret)\n    {\n        rt_kprintf(\"BES wifi init fail!\\n\");\n    }\n    /*start wifi monitor task */\n    bwifi_trans_stat_en(1, 10);\n    /*support wifi recovery*/\n    bwifi_recovery_enable(true);\n    /* intitial wifi deviece */\n    rthw_wifi_low_init();\n    /* initial wlan auto connect */\n#ifdef RT_WLAN_CFG_ENABLE\n    wlan_autoconnect_init();\n    rt_wlan_config_autoreconnect(RT_TRUE);\n#endif\n\n    /* bt init */\n    bes_bt_init();\n\n    rt_main_post_hook();\n\n    rt_kprintf(\"startup time: %dms\\n\", rt_tick_get());\n    rt_kprintf(\"compile time: %s %s\\n\", __DATE__, __TIME__);\n\n#ifdef BSP_USING_GREE_DEVICE_HUB\n\trt_kprintf(\"====wait wlan ready====\\r\\n\");\n    t0 = rt_tick_get();\n    while(1) {\n        err = rt_wlan_get_mac(macbuf);\n        if(err != RT_EOK) {\n            rt_thread_mdelay(50);\n        }else {\n            t1 = rt_tick_get();\n            rt_kprintf(\"t0:%d, t1:%d, t1-t0:%dms\\r\\n\", t0, t1, (t1-t0)*1000/RT_TICK_PER_SECOND);\n            rt_kprintf(\"====wlan ready====\\r\\n\");\n            break;\n        }\n    }\n\n//    gree_device_hub_main();\n\n    #ifdef BSP_USING_MAGIC_CUBE\n//    magic_cube_main();\n    #endif\n\n    #ifdef BSP_USING_UDS_DEMO\n    // uds_phony_app_main();\n    #endif\n#endif\n    rt_kprintf(\"Start sending information over the serial port.\\n\");\n\n    char uart_name[RT_NAME_MAX];\n    static char msg_pool[256];\n    char str[] = \"hello RT_Thread!\\r\\n\";\n    // 用于复制指定长度的字符串。\n    rt_strncpy(uart_name, \"uart1\", RT_NAME_MAX);\n\n    rt_kprintf(\"Success Initialization\\n\");\n\n//    rt_err_t err;\n    /* 初始化消息队列的函数，用于初始化一个空的、可用的消息队列。 */\n    rt_mq_init(\u0026rx_mq, \"rx_mq\",\n               msg_pool,    /* 存放消息缓冲区 */\n               sizeof(struct rx_msg), /* 一条消息的最大长度 */\n               sizeof(msg_pool),     /* 存放消息的缓冲区大小 */\n               RT_IPC_FLAG_FIFO);   /* 如果有多个线程等待，按照先来先得到的方法分配消息 */\n\n\n    rt_kprintf(\"Success rq_mq_init\\n\");\n\n    /* step1: 查找系统中的串口设备 */\n    serial = rt_device_find(uart_name);\n    if (!serial) {\n        rt_kprintf(\"find %s failed!\\n\",uart_name);\n        return -1;\n    }\n\n    rt_kprintf(\"Success find dev\\n\");\n\n    /* step2: 修改串口配置参数 */\n    config.baud_rate = BAUD_RATE_4800;  //修改波特率为 4800\n    config.data_bits = DATA_BITS_8;           //数据位 8\n    config.stop_bits = STOP_BITS_1;           //停止位 1\n    config.bufsz     = 128;                   //修改缓冲区 buff size 为 128\n    config.parity    = PARITY_EVEN;           //无奇偶校验位\n\n    rt_kprintf(\"Success find dev\\n\");\n\n    /* step3：控制串口设备。通过控制接口传入命令控制字，与控制参数 */\n    err = rt_device_control(serial, RT_DEVICE_CTRL_CONFIG, \u0026config);\n\n    rt_kprintf(\"rt_device_control port ret:%d\\n\", err);\n\n//     // 设置发送回调函数\n//    err = rt_device_set_tx_complete(serial, uart_tx_callbak);\n\n    rt_kprintf(\"rt_device_set_tx_complete port ret:%d\\n\", err);\n    /* 设置接收回调函数 */\n    err = rt_device_set_rx_indicate(serial, uart_input);\n\n    rt_kprintf(\"rt_device_set_rx_complete port ret:%d\\n\", err);\n\n    /* 以 DMA 接收及轮询发送方式打开串口设备 */\n  err =  rt_device_open(serial, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_DMA_RX  | RT_DEVICE_FLAG_DMA_TX);\n//    if(err != RT_EOK) {\n//        return -1;\n//    }\n    rt_kprintf(\"rt_device_open port ret:%d\\n\", err);\n\n    /* 发送字符串 */\n    rt_kprintf(\"start write\\n\");\n    rt_device_write(serial, 0, str, (sizeof(str) - 1));\n//    if (res == 0)\n//    {\n//        rt_kprintf(\"re_device_write fail!\\n\");\n//    } else {\n//        rt_kprintf(\"re_device_write Success!\\n\");\n//    }\n    rt_kprintf(\"end write\\n\");\n    struct rx_msg msg;\n    rt_err_t result;\n    msg.dev = serial;\n    msg.size = sizeof(struct rx_msg);\n\n    result = rt_mq_send(\u0026rx_mq, \u0026msg, sizeof(msg));\n    if (result == -RT_EFULL)\n    {\n        rt_kprintf(\"uart1 message queue full!\\n\");\n    }\n    rt_kprintf(\"1-uart_input-send mq success\\n\");\n    rt_uint32_t rx_length;\n    static char rx_buffer[RT_SERIAL_RB_BUFSZ + 1];\n    while (1)\n    {\n        rt_memset(\u0026msg, 0, sizeof(msg));     // 将 msg变量所在的内存全部清零\n        result = rt_mq_recv(\u0026rx_mq, \u0026msg, sizeof(msg), RT_WAITING_FOREVER);  // 从消息队列中接收消息\n        rt_kprintf(\"1-rt_mq_recv port result:%d\\n\",result);\n        if (result == RT_EOK)\n        {\n            rt_kprintf(\"1-we get mq\\n\");\n            /* 从串口读取数据*/\n            rx_length = rt_device_read(msg.dev, 0, rx_buffer, msg.size);\n            rx_buffer[rx_length] = '\\0';\n            if (rx_length \u003e 0)\n            {\n                rt_kprintf(\"1-Read %d bytes from UART: %s\\r\\n\", rx_length, rx_buffer);\n            } else  {\n                rt_kprintf(\"1-Read fail!\\n\");\n            }\n            /* 通过串口设备 serial 输出读取到的消息 */\n            rt_device_write(serial, 0, rx_buffer, rx_length);\n            rt_kprintf(\"1-write end!!!\\n\");\n            /* 打印数据 */\n            rt_kprintf(\"1- data %s\\n\",rx_buffer);\n        }\n        rt_kprintf(\"1-end a tread \\n\");\n    }\n///* 创建 serial 线程 */\n//    rt_thread_t thread = rt_thread_create(\"serial\", serial_thread_entry, RT_NULL, 1024, 25, 10);\n//    /* 创建成功则启动线程 */\n//    if (thread != RT_NULL)\n//    {\n//        rt_thread_startup(thread);  // 启动线程\n//        rt_kprintf(\"thread start up success!\\n\");\n//    }\n//    else\n//    {\n//        return -1;\n//    }\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230723213601-b9rjfgf","Type":"NodeParagraph","Properties":{"id":"20230723213601-b9rjfgf","updated":"20230723213601"}}]}