{"ID":"20231226103004-5rb0wsv","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f999","id":"20231226103004-5rb0wsv","tags":"Go-Benchmark,Go-profile,Go-trace,Go-interface,Go-reflect,需要仔细看,Go-高性能编程,Go-性能优化","title":"☆☆☆ Golang 高性能编程实践","updated":"20231227093746"},"Children":[{"ID":"20231226103004-mmfukkm","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231226103004-mmfukkm","updated":"20231226164548"},"Children":[{"Type":"NodeText","Data":"1. 为什么要进行性能优化"}]},{"ID":"20231226103209-mwgo9as","Type":"NodeParagraph","Properties":{"id":"20231226103209-mwgo9as","updated":"20231226103209"},"Children":[{"Type":"NodeText","Data":"服务上线前，为什么要进行压测和性能的优化？"}]},{"ID":"20231226103209-c9r45b9","Type":"NodeParagraph","Properties":{"id":"20231226103209-c9r45b9","updated":"20231226103209"},"Children":[{"Type":"NodeText","Data":"一个例子，content-service 在压测的时候发现过一个问题: 旧逻辑为了简化编码，在进行协议转换前，会对某些字段做一个 DeepCopy，因为转换过程需要原始数据，但我们完全可以通过一些处理逻辑的调整，比如调整先后顺序等移除 DeepCopy。优化前后性能对比如下："}]},{"ID":"20231226103209-fel7cx3","Type":"NodeTable","TableAligns":[0,0,0,0,0],"Properties":{"colgroup":"||||","id":"20231226103209-fel7cx3","updated":"20231226103209"},"Children":[{"Type":"NodeTableHead","Data":"thead","Children":[{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"阶段"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"AVG(ms)"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"P95(ms)"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"P99(ms)"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"CPU/MEM"}]}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"优化前"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"67.96"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"153.59"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"212.85"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"100%/34%"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"优化后"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"9.12"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"23.22"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"38.98"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"84%/34%"}]}]}]},{"ID":"20231226103209-u15eur8","Type":"NodeParagraph","Properties":{"id":"20231226103209-u15eur8","updated":"20231226103209"},"Children":[{"Type":"NodeText","Data":"性能有 7 倍左右提升，改动很小，但折算到成本上的收益是巨大的。"}]},{"ID":"20231226103209-1069qhl","Type":"NodeBlockquote","Properties":{"id":"20231226103209-1069qhl","updated":"20231226103209"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226103209-8cjhp02","Type":"NodeParagraph","Properties":{"id":"20231226103209-8cjhp02","updated":"20231226103209"},"Children":[{"Type":"NodeText","Data":"在性能优化上任何微小的投入，都可能会带来巨大的收益"}]}]},{"ID":"20231226103209-9jp9buj","Type":"NodeParagraph","Properties":{"id":"20231226103209-9jp9buj","updated":"20231226103209"},"Children":[{"Type":"NodeText","Data":"那么，如何对 go 程序的性能进行度量和分析？"}]},{"ID":"20231226103257-g3zibwt","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231226103257-g3zibwt","updated":"20231226164552"},"Children":[{"Type":"NodeText","Data":"2. 度量和分析工具"}]},{"ID":"20231226103306-yrc5bym","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226103306-yrc5bym","updated":"20231226164557"},"Children":[{"Type":"NodeText","Data":"2.1 Benchmark"}]},{"ID":"20231226103313-f5hqyki","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231226103313-f5hqyki","updated":"20231226164606"},"Children":[{"Type":"NodeText","Data":"2.1.1 Benchmark 示例"}]},{"ID":"20231226103324-n5vjd2f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226103324-n5vjd2f","updated":"20231226103535"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func BenchmarkConverReflect(b *testing.B) {\n  var v interface{} = int32(64)\n  for i := 0;i\u003c b.N;i++ {\n    f := reflect.ValueOf(v).Int()\n    if f != int64(64) {\n      b.Error(\"error\")\n    }  \n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226103538-yclrdc9","Type":"NodeParagraph","Properties":{"id":"20231226103538-yclrdc9","updated":"20231226103547"},"Children":[{"Type":"NodeText","Data":"函数固定以 Benchmark 开头，其位于_test.go 文件中，入参为 testing.B 业务逻辑应放在 for 循环中，因为 b.N 会依次取值 1, 2, 3, 5, 10, 20, 30, 50,100.........，直至执行时间超过 1s"}]},{"ID":"20231226103548-q9kq0sx","Type":"NodeParagraph","Properties":{"id":"20231226103548-q9kq0sx","updated":"20231226103632"},"Children":[{"Type":"NodeText","Data":"可通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"go test --bench"},{"Type":"NodeText","Data":"​ 命令执行 benchmark， 其结果如下："}]},{"ID":"20231226103632-wal6s3i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226103632-wal6s3i","updated":"20231226103640"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"➜  gotest666 go test --bench='BenchmarkConvertReflect' -run=none\ngoos: darwin\ngoarch: amd64\npkg: gotest666\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkConvertReflect-12      520200014            2.291 ns/op\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226103641-cc010r1","Type":"NodeBlockquote","Properties":{"id":"20231226103641-cc010r1","updated":"20231226103647"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226103646-qn2byhb","Type":"NodeParagraph","Properties":{"id":"20231226103646-qn2byhb","updated":"20231226103647"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"--bench='BenchmarkConvertReflect'"},{"Type":"NodeText","Data":"​， 要执行的 benchmark。需注意:该参数支持模糊匹配，如--bench='Get|Set' ，支持./..."},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-run=none"},{"Type":"NodeText","Data":"​，只进行 Benchmark，不执行单测"}]}]},{"ID":"20231226103648-n6jic4q","Type":"NodeParagraph","Properties":{"id":"20231226103648-n6jic4q","updated":"20231226103655"},"Children":[{"Type":"NodeText","Data":"BenchmarkConvertReflect, 在 1s 内执行了 520200014 次，每次约 2.291ns"}]},{"ID":"20231226103656-u7hlzpr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231226103656-u7hlzpr","updated":"20231226164621"},"Children":[{"Type":"NodeText","Data":"2.1.2 高级用法"}]},{"ID":"20231226103703-lbs0tog","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226103703-lbs0tog","updated":"20231226103718"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"➜  gotest666 go test --bench='Convert' -run=none -benchtime=2s -count=3 -benchmem -cpu='2,4' -cpuprofile=cpu.profile -memprofile=mem.profile -trace=xxx -gcflags=all=-l\ngoos: darwin\ngoarch: amd64\npkg: gotest666\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkConvertReflect-2       1000000000           2.286 ns/op           0 B/op          0 allocs/op\nBenchmarkConvertReflect-2       1000000000           2.302 ns/op           0 B/op          0 allocs/op\nBenchmarkConvertReflect-2       1000000000           2.239 ns/op           0 B/op          0 allocs/op\nBenchmarkConvertReflect-4       1000000000           2.244 ns/op           0 B/op          0 allocs/op\nBenchmarkConvertReflect-4       1000000000           2.236 ns/op           0 B/op          0 allocs/op\nBenchmarkConvertReflect-4       1000000000           2.247 ns/op           0 B/op          0 allocs/op\nPASS\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226103731-6zmqa9z","Type":"NodeBlockquote","Properties":{"id":"20231226103731-6zmqa9z","updated":"20231226103733"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226103732-j75iquf","Type":"NodeParagraph","Properties":{"id":"20231226103732-j75iquf","updated":"20231226103733"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-benchtime=2s'"},{"Type":"NodeText","Data":"​， 依次递增 b.N 直至运行时间超过 2s"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-count=3"},{"Type":"NodeText","Data":"​，执行 3 轮"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-benchmem,b.ReportAllocs"},{"Type":"NodeText","Data":"​，展示堆分配信息，0 B/op, 0 allos/op 分别代表每次分配了多少空间，每个 op 有多少次空间分配"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-cpu='2,4'"},{"Type":"NodeText","Data":"​，依次在 2 核、4 核下进行测试"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-cpuprofile=xxxx -memprofile=xxx -trace=trace.out"},{"Type":"NodeText","Data":"​，benmark 时生成 profile、trace 文件"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-gcflags=all=-l"},{"Type":"NodeText","Data":"​，停止编译器的内联优化"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"b.ResetTimer, b.StartTimer/b.StopItmer"},{"Type":"NodeText","Data":"​，重置定时器"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"b.SetParallelism、b.RunParallel"},{"Type":"NodeText","Data":"​， 并发执行，设置并发的协程数"}]}]},{"ID":"20231226103735-3uysmfh","Type":"NodeParagraph","Properties":{"id":"20231226103735-3uysmfh","updated":"20231226103801"},"Children":[{"Type":"NodeText","Data":"目前对 go 性能进行分析的主要工具包含:profile、trace，以下是对二者的介绍"}]},{"ID":"20231226103801-005gf4y","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226103801-005gf4y","updated":"20231226164626"},"Children":[{"Type":"NodeText","Data":"2.2 profile"}]},{"ID":"20231226104033-80cf7yw","Type":"NodeParagraph","Properties":{"id":"20231226104033-80cf7yw","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"目前 go 中 profile 包括: cpu、heap、mutex、goroutine。要在 go 中启用 profile 主要有以下几种方式:"}]},{"ID":"20231226104033-xoz9vef","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231226104033-xoz9vef","updated":"20231226104033"},"Children":[{"ID":"20231226104033-pnt33qc","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231226104033-pnt33qc","updated":"20231226104033"},"Children":[{"ID":"20231226104033-2oe5wvi","Type":"NodeParagraph","Properties":{"id":"20231226104033-2oe5wvi","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"运行时函数，如 pprof.StartCPUProfile、pprof.WriteHeapProfile 等"}]}]},{"ID":"20231226104033-1ljfrie","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231226104033-1ljfrie","updated":"20231226104033"},"Children":[{"ID":"20231226104033-61ee7vq","Type":"NodeParagraph","Properties":{"id":"20231226104033-61ee7vq","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"导入 net/http/pprof 包"}]}]},{"ID":"20231226104033-xrv2nhf","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20231226104033-xrv2nhf","updated":"20231226104033"},"Children":[{"ID":"20231226104033-difrwps","Type":"NodeParagraph","Properties":{"id":"20231226104033-difrwps","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"go test 中使用-cpuprofile、-memprofile"}]}]}]},{"ID":"20231226104033-pv7y436","Type":"NodeParagraph","Properties":{"id":"20231226104033-pv7y436","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"go 中提供了 pprof 工具对 profile 进行解析，以 cpuprofile 为例，如下："}]},{"ID":"20231226104033-18pnqnu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226104033-18pnqnu","updated":"20231226104033"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"go tool pprofile cpu.profile\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226104033-5egxeax","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226104033-5egxeax","updated":"20231226104033"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"(pprof) top 15\nShowing nodes accounting for 14680ms, 99.46% of 14760ms total\nDropped 30 nodes (cum \u003c= 73.80ms)\n      flat  flat%   sum%        cum   cum%\n    2900ms 19.65% 19.65%     4590ms 31.10%  reflect.unpackEface (inline)\n    2540ms 17.21% 36.86%    13280ms 89.97%  gotest666.BenchmarkConvertReflect\n    1680ms 11.38% 48.24%     1680ms 11.38%  reflect.(*rtype).Kind (inline)\n\n(pprof) list gotest666.BenchmarkConvertReflect\nTotal: 14.76s\nROUTINE ======================== gotest666.BenchmarkConvertReflect in /Users/zhangyuxin/go/src/gotest666/a_test.go\n     2.54s     13.28s (flat, cum) 89.97% of Total\n         .          .      8:func BenchmarkConvertReflect(b *testing.B) {\n         .          .      9:   var v interface{} = int32(64)\n     1.30s      1.41s     10:   for i:=0;i\u003cb.N;i++{\n         .     10.63s     11:       f := reflect.ValueOf(v).Int()\n     1.24s      1.24s     12:       if f != int64(64){\n         .          .     13:           b.Error(\"errror\")\n         .          .     14:       }\n         .          .     15:   }\n         .          .     16:}\n         .          .     17:\n(pprof)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226104033-df2d9r3","Type":"NodeBlockquote","Properties":{"id":"20231226104033-df2d9r3","updated":"20231226104033"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226104033-o7udt2t","Type":"NodeParagraph","Properties":{"id":"20231226104033-o7udt2t","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"flat,cum"},{"Type":"NodeText","Data":"​ 分别代表了当前函数、当前函数调用函数的统计信息"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"top、list、tree"},{"Type":"NodeText","Data":"​是用的最多的命令"}]}]},{"ID":"20231226104033-mtr7r8p","Type":"NodeParagraph","Properties":{"id":"20231226104033-mtr7r8p","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"go 也提供了 web 界面用以对各种调用进行图像化展示，可以通过-http 打开内置的 http 服务，该服务可以展示包含调用图、火焰图等信息"}]},{"ID":"20231226104033-de7sv2y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226104033-de7sv2y","updated":"20231226104033"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"go tool pprof -http=\":8081\" cpu.profile\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226104033-9co8g7j","Type":"NodeBlockquote","Properties":{"id":"20231226104033-9co8g7j","updated":"20231226104033"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226104033-e2i2f4z","Type":"NodeParagraph","Properties":{"id":"20231226104033-e2i2f4z","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"对于调用图，边框、字体的颜色越深，代表消耗资源越多。实线代表直接调用，虚线代表非直接调用（中间还有其他调用） 火焰图代表了调用层级，函数调用栈越长，火焰越高。同一层级，框越长、颜色越深占用资源越多 profile 是通过采样实现，存在精度问题、且会对性能有影响(比如 go routine 的 profile 采样会导致 STW)"}]}]},{"ID":"20231226104033-6825q1h","Type":"NodeParagraph","Properties":{"id":"20231226104033-6825q1h","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"此外，目前 123 中已经有 profile 相关的插件，具体可搜索:"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"查看火焰图、GoMemProfile"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231226104033-18kqxpg","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226104033-18kqxpg","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"2.3 trace"}]},{"ID":"20231226104033-4h6rrr9","Type":"NodeParagraph","Properties":{"id":"20231226104033-4h6rrr9","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"profile 可以通过采样，确定系统运行中的热点，但其基于采样的处理也有精度等问题。 因此，go 提供了 trace 工具，其基于事件的统计为解决问题提供了更详细的数据，此外 go trace 还把 P、G、Heap 等相关信息聚合在一起按照时间进行展示，如下图："}]},{"ID":"20231226104033-f1d0h6d","Type":"NodeParagraph","Properties":{"id":"20231226104033-f1d0h6d","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/sz_mmbiz_jpg/j3gficicyOvatxkZFK6e6gcOZkc27GXbks3cNlNkh8IxHY3f1Kp3QXJCkajiakd4JEg6mT1JuRhNkyZ1m0UxKNO2w/640?wx_fmt=other\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231226104033-neq3ocs","Type":"NodeParagraph","Properties":{"id":"20231226104033-neq3ocs","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"go 中启用 trace，可以通过以下方式："}]},{"ID":"20231226104033-v7tf2i5","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231226104033-v7tf2i5","updated":"20231226104033"},"Children":[{"ID":"20231226104033-134ck0r","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231226104033-134ck0r","updated":"20231226104033"},"Children":[{"ID":"20231226104033-2eckqps","Type":"NodeParagraph","Properties":{"id":"20231226104033-2eckqps","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"通过 runtime/trace 包中相应函数，主要是 trace.Start、trace.Stop"}]}]},{"ID":"20231226104033-bl4m63n","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231226104033-bl4m63n","updated":"20231226104033"},"Children":[{"ID":"20231226104033-gy7bcfq","Type":"NodeParagraph","Properties":{"id":"20231226104033-gy7bcfq","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"通过导入 net/http/pprof"}]}]},{"ID":"20231226104033-4lcc2ov","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20231226104033-4lcc2ov","updated":"20231226104033"},"Children":[{"ID":"20231226104033-3zst8ab","Type":"NodeParagraph","Properties":{"id":"20231226104033-3zst8ab","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"通过 go test 中 trace 参数"}]}]}]},{"ID":"20231226104033-dy2fy64","Type":"NodeParagraph","Properties":{"id":"20231226104033-dy2fy64","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"以 runtime/trace 为例，如下："}]},{"ID":"20231226104033-d770wx8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226104033-d770wx8","updated":"20231226104033"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"import (\n    \"os\"\n    \"runtime/trace\"\n)\n\nfunc main() {\n    f, _ := os.Create(\"trace.out\")\n    trace.Start(f)\n    defer trace.Stop()\n\n    ch := make(chan string)\n    go func() {\n        ch \u003c- \"EDDYCJY\"\n    }()\n\n    \u003c-ch\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226104033-wns3eav","Type":"NodeParagraph","Properties":{"id":"20231226104033-wns3eav","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"go tool trace trace.out"},{"Type":"NodeText","Data":"​，会打开页面，结果包含如下信息："}]},{"ID":"20231226104033-ftulls1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226104033-ftulls1","updated":"20231226104033"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"View trace // 按照时间查看thread、goroutine分析、heap等相关信息\nGoroutine analysis // goroutine相关分析\nSyscall blocking profile // syscall 相关\nScheduler latency profile // 调度相关\n........\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226104033-vm9vfm9","Type":"NodeParagraph","Properties":{"id":"20231226104033-vm9vfm9","updated":"20231226104033"},"Children":[{"Type":"NodeText","Data":"实际中经常先通过 Goroutine analysis、Scheduler latency profile 等查找可能的问题点，再通过 View trace 进行全面分析。"}]},{"ID":"20231226111708-mbrb0or","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231226111708-mbrb0or","updated":"20231226164641"},"Children":[{"Type":"NodeText","Data":"3. 常用类型和结构"}]},{"ID":"20231226111716-cc562j5","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226111716-cc562j5","updated":"20231226164647"},"Children":[{"Type":"NodeText","Data":"3.1 interface、reflect"}]},{"ID":"20231226111724-3liki41","Type":"NodeParagraph","Properties":{"id":"20231226111724-3liki41","updated":"20231226111822"},"Children":[{"Type":"NodeText","Data":"通常 go 中较多的 interface、reflect 会对性能有一定的影响，interface、reflect 为什么会对性能有影响"}]},{"ID":"20231226111822-gletyda","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231226111822-gletyda","updated":"20231226164654"},"Children":[{"Type":"NodeText","Data":"3.1.1 interface 和 eface"}]},{"ID":"20231226111836-z53x07b","Type":"NodeParagraph","Properties":{"id":"20231226111836-z53x07b","updated":"20231226112008"},"Children":[{"Type":"NodeText","Data":"go 中interface 包含2种， eface、iface。eface 用于表示不含方法的 interface，iface 用于标识带方法的 interface，其相关机制不在本文的介绍方位。"}]},{"ID":"20231226112043-ez74emt","Type":"NodeParagraph","Properties":{"id":"20231226112043-ez74emt","updated":"20231226112110"},"Children":[{"Type":"NodeText","Data":"eface 的定位位于 runtime2.go、type.go，其定义如下："}]},{"ID":"20231226112110-tozu7o2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226112110-tozu7o2","updated":"20231226112313"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type eface struct {\n  _type *_type  // 类型消息\n  data unsafe.Pointer // 数据 \n}\ntype _type struct {\n  size uintptr // 大小信息\n  ......\n  hash uint32 // 类型信息\n  tflag tflag\n  align uint8 // 对齐信息\n  ......\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226112150-6mvzmvb","Type":"NodeParagraph","Properties":{"id":"20231226112150-6mvzmvb","updated":"20231226112530"},"Children":[{"Type":"NodeText","Data":"因为同时包含类型、数据，go中所有类型都可以转换为interface。go 中为 interface 赋值的过程，即为 eface 变量生成的过程，通过汇编可以发现，其主要通过 convT* 完成位于 iface.go，具体分发逻辑位于 convert.go。 以指针类型为例，其转化逻辑如下："}]},{"ID":"20231226112531-s1d5w0g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226112531-s1d5w0g","updated":"20231226113835"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// dataWordFuncName returns the name of the function used to convert a value of type \"from\"\n// to the data word of an interface.\n// dataWordfuncName 函数的主要作用是根据输入的类型 from，返回用于将该类型值转换为接口数据部分的函数名、参数类型以及是否需要地址。这个函数通过判断 from 类型的大小、对齐和是否包含指针来确定相应的转换函数。\nfunc dataWordFuncName(from *types.Type) (fnname string, argType *types.Type, needsaddr bool) {\n    .............\n    switch {\n    case from.Size() == 2 \u0026amp;\u0026amp; uint8(from.Alignment()) == 2:\n        return \"convT16\", types.Types[types.TUINT16], false\n    case from.Size() == 4 \u0026amp;\u0026amp; uint8(from.Alignment()) == 4 \u0026amp;\u0026amp; !from.HasPointers():\n        return \"convT32\", types.Types[types.TUINT32], false\n    case from.Size() == 8 \u0026amp;\u0026amp; uint8(from.Alignment()) == uint8(types.Types[types.TUINT64].Alignment()) \u0026amp;\u0026amp; !from.HasPointers():\n        return \"convT64\", types.Types[types.TUINT64], false\n    }\n\n    .............\n    if from.HasPointers() {\n        return \"convT\", types.Types[types.TUNSAFEPTR], true\n    }\n    return \"convTnoptr\", types.Types[types.TUNSAFEPTR], true\n}\n\n// convT converts a value of type t, which is pointed to by v, to a pointer that can\n// be used as the second word of an interface value.\n// convT 函数的主要作用是将输入的类型t的值转化为可以作为接口值的第二字 data word 的指针，\nfunc convT(t *_type, elem unsafe.Pointer) (e eface) {\n    .....\n    x := mallocgc(t.size, t, true)  // 空间的分配\n    typedmemmove(t, x, elem)                // memove\n    e._type = t\n    e.data = x\n    return\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226112726-65d10kb","Type":"NodeBlockquote","Properties":{"id":"20231226112726-65d10kb","updated":"20231226112902"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226112727-6t7g3c1","Type":"NodeParagraph","Properties":{"id":"20231226112727-6t7g3c1","updated":"20231226112902"},"Children":[{"Type":"NodeText","Data":"很多对 interface 类型的赋值（并非所有），都会导致空间的分配和拷贝，这也是 interface 函数为什么可能会导致逃逸的原因，go这么做的主要原因：逃逸分析位于编译阶段，对于不确定的类型在堆上分配最为合适"}]}]},{"ID":"20231226112926-n9069se","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231226112926-n9069se","updated":"20231226164707"},"Children":[{"Type":"NodeText","Data":"3.1.2 Reflect.Value"}]},{"ID":"20231226113957-aqnv3zu","Type":"NodeParagraph","Properties":{"id":"20231226113957-aqnv3zu","updated":"20231226114139"},"Children":[{"Type":"NodeText","Data":"go 中 reflect 机制涉及到2 个类型， reflect.Type 和 reflect.Value, reflect.Type 是一个 Interface，其不在本章介绍范围内。"}]},{"ID":"20231226114139-6zgqi0o","Type":"NodeParagraph","Properties":{"id":"20231226114139-6zgqi0o","updated":"20231226114215"},"Children":[{"Type":"NodeText","Data":"reflect.Value 定义位于 value.go、type.go,其定义与 eface 类似："}]},{"ID":"20231226114215-2zin4sz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226114215-2zin4sz","updated":"20231226114356"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Value struct {\n  typ *rtype // type._type\n  ptr unsafe.Pointer\n  flag\n}\n\n//rtypt must be kept in sync with ../runtime/type.go:/^type._type.\ntype rtype struct {\n  ....\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226114124-s7glgoy","Type":"NodeBlockquote","Properties":{"id":"20231226114124-s7glgoy","updated":"20231226114500"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226114401-my0qr5x","Type":"NodeParagraph","Properties":{"id":"20231226114401-my0qr5x","updated":"20231226114500"},"Children":[{"Type":"NodeText","Data":"相似的实现，即为 interface 和reflect 可以相互转化的原因"}]}]},{"ID":"20231226114412-obj2xvi","Type":"NodeParagraph","Properties":{"id":"20231226114412-obj2xvi","updated":"20231226141238"},"Children":[{"Type":"NodeText","Data":"reflect.Value 是通过 reflect.ValueOf 获得， reflect.ValueOf 也会导致数据逃逸 （interface 接口），其定义位于 value.go中，如下："}]},{"ID":"20231226141239-yqhnh9a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226141239-yqhnh9a","updated":"20231226141246"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func ValueOf(i interface{}) Value {\n    if i == nil {\n        return Value{}\n    }\n    // TODO: Maybe allow contents of a Value to live on the stack.\n    // For now we make the contents always escape to the heap.\n  // .....\n    escapes(i) // 此处没有逃逸\n    return unpackEface(i) // 转换eface为emtpyInterface\n}\n\n// go1.18中，dummy.b没有赋值操作\nfunc escapes(x any) {\n    if dummy.b {\n        dummy.x = x\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226141250-bzua2q6","Type":"NodeBlockquote","Properties":{"id":"20231226141250-bzua2q6","updated":"20231226141330"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226141251-u3r3fzl","Type":"NodeParagraph","Properties":{"id":"20231226141251-u3r3fzl","updated":"20231226141330"},"Children":[{"Type":"NodeText","Data":"reflect.ValueOf 仍然会导致逃逸，但其逃逸还是由 interface 的入参导致"}]}]},{"ID":"20231226141331-kyv9mfd","Type":"NodeParagraph","Properties":{"id":"20231226141331-kyv9mfd","updated":"20231226142340"},"Children":[{"Type":"NodeText","Data":"一个简单的例子："}]},{"ID":"20231226142340-g6wylzb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226142340-g6wylzb","updated":"20231226142415"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n  var x = \"xxxx\"\n  _ = reflect.ValueOf(x)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226143008-4c3gudw","Type":"NodeParagraph","Properties":{"id":"20231226143008-4c3gudw","updated":"20231226143019"},"Children":[{"Type":"NodeText","Data":"结果如下："}]},{"ID":"20231226143019-1bgbpy4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226143019-1bgbpy4","updated":"20231226143026"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"➜  gotest666 go build -gcflags=-m main.go\n# command-line-arguments\n./main.go:26:21: inlining call to reflect.ValueOf\n./main.go:26:21: inlining call to reflect.escapes\n./main.go:26:21: inlining call to reflect.unpackEface\n./main.go:26:21: inlining call to reflect.(*rtype).Kind\n./main.go:26:21: inlining call to reflect.ifaceIndir\n./main.go:26:22: x escapes to heap\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226143037-f28ndk2","Type":"NodeBlockquote","Properties":{"id":"20231226143037-f28ndk2","updated":"20231226143040"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226143039-an6fidn","Type":"NodeParagraph","Properties":{"id":"20231226143039-an6fidn","updated":"20231226143040"},"Children":[{"Type":"NodeText","Data":"需要注意，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"x会逃逸到堆上"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20231226143042-ee4sinx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231226143042-ee4sinx","updated":"20231226164717"},"Children":[{"Type":"NodeText","Data":"3.1.3 类型的选择：interface、强类型如何选"}]},{"ID":"20231226143132-55c3l6d","Type":"NodeParagraph","Properties":{"id":"20231226143132-55c3l6d","updated":"20231226143141"},"Children":[{"Type":"NodeText","Data":"为降低不必要的空间分配、拷贝，建议只在必要情况下使用 interface、reflect，针对函数定义，测试如下："}]},{"ID":"20231226143141-i1kqeva","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226143141-i1kqeva","updated":"20231226143153"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type testStruct struct {\n    Data [4096]byte\n}\n\nfunc StrongType(t testStruct) {\n    t.Data[0] = 1\n}\n\nfunc InterfaceType(ti interface{}) {\n    ts := ti.(testStruct)\n    ts.Data[0] = 1\n}\n\nfunc BenchmarkTypeStrong(b *testing.B) {\n    t := testStruct{}\n    t.Data[0] = 2\n    for i := 0; i \u003c b.N; i++ {\n        StrongType(t)\n    }\n}\n\nfunc BenchmarkTypeInterface(b *testing.B) {\n    t := testStruct{}\n    t.Data[0] = 2\n    for i := 0; i \u003c b.N; i++ {\n        InterfaceType(t)\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226143114-i3mgqi0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226143114-i3mgqi0","updated":"20231226143308"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"➜  test go test --bench='Type' -run=none -benchmem\ngoos: darwin\ngoarch: amd64\npkg: gotest666/test\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkTypeStrong-12          1000000000           0.2550 ns/op          0 B/op          0 allocs/op\nBenchmarkTypeInterface-12        1722150           709.0 ns/op      4096 B/op          1 allocs/op\nPASS\nok      gotest666/test  2.714s\n需要注意，当入参参数占用空间不大时(比如基础类型)，二者性能对比并不十分明显\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226143319-ijf63h4","Type":"NodeParagraph","Properties":{"id":"20231226143319-ijf63h4","updated":"20231226143319"},"Children":[{"Type":"NodeText","Data":"强类型函数调用性能远优于基于 interface 的调用，优化后 content-service 只使用了少量的 interface。"}]},{"ID":"20231226143319-x5p8u6w","Type":"NodeParagraph","Properties":{"id":"20231226143319-x5p8u6w","updated":"20231226143319"},"Children":[{"Type":"NodeText","Data":"目前一些常用的基于 interface(可能会导致逃逸)的函数:"}]},{"ID":"20231226143319-h4eswu0","Type":"NodeTable","TableAligns":[0,0],"Properties":{"colgroup":"|","id":"20231226143319-h4eswu0","updated":"20231226143319"},"Children":[{"Type":"NodeTableHead","Data":"thead","Children":[{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"函数"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"功能"}]}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"fmt 系列，包括:fmt.Sprinf、fmt.Sprint 等"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"数据转换、格式处理"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"binary.Read/binary.Write"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"二级制数据读写"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"json.Marshal/json.Unmarshal"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"json 的序列化、反序列化"}]}]}]},{"ID":"20231226143339-upmtlhn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231226143339-upmtlhn","updated":"20231226164728"},"Children":[{"Type":"NodeText","Data":"3.1.4 类型转换：强转 vs 断言 vs reflect"}]},{"ID":"20231226143410-6vqsdnf","Type":"NodeParagraph","Properties":{"id":"20231226143410-6vqsdnf","updated":"20231226143437"},"Children":[{"Type":"NodeText","Data":"目前 go中 数据类型转换，存在以下几种方式："}]},{"ID":"20231226143437-48mmmut","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231226143437-48mmmut","updated":"20231226143440"},"Children":[{"ID":"20231226143440-kye18cb","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231226143440-kye18cb","updated":"20231226143440"},"Children":[{"ID":"20231226143440-i14h7l9","Type":"NodeParagraph","Properties":{"id":"20231226143440-i14h7l9","updated":"20231226143550"},"Children":[{"Type":"NodeText","Data":"强转，如 int 转 int64，可用 int64(intData)。强转是对底层数据进行语义上的重新解释"}]}]},{"ID":"20231226143551-g3jqutq","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231226143551-g3jqutq"},"Children":[{"ID":"20231226143551-ampu2xd","Type":"NodeParagraph","Properties":{"id":"20231226143551-ampu2xd","updated":"20231226143714"},"Children":[{"Type":"NodeText","Data":"断言（interface），根据已有信息，对变量类型进行断言，如 interfaceData.(int64)，会利用 eface.type 中相关信息，对类型进行校验，转换。"}]}]},{"ID":"20231226143714-z3nbnwp","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20231226143714-z3nbnwp"},"Children":[{"ID":"20231226143714-s3t8t85","Type":"NodeParagraph","Properties":{"id":"20231226143714-s3t8t85","updated":"20231226143806"},"Children":[{"Type":"NodeText","Data":"reflect 相关函数，如 reflect.Valueof(intData).Int()，其中 intData 可以为各种 int 相关类型，具有较大的灵活性。"}]}]}]},{"ID":"20231226143806-1o58784","Type":"NodeParagraph","Properties":{"id":"20231226143806-1o58784","updated":"20231226143826"},"Children":[{"Type":"NodeText","Data":"针对此的测试如下："}]},{"ID":"20231226143826-cf73uvu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226143826-cf73uvu","updated":"20231226144553"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type testStruct struct {\n  Data [4096]\n}\n\nfunc BenchmarkConvertForce(b *testing.B) {\n  for i:=0;i \u003c b.N;i++ {\n    var v = int32(64)\n    f := int64(v)\n    if f != int64(64) {\n      b.Error(\"error\")\n    }\n  }\n}\n\nfunc BenchmarkConvertReflect(b *testing.B) {\n  for i:=0;i\u003c b.N;i++ {\n    var v = int32(64)\n    f := reflect.ValueOf(v).Int()\n    if f != int64(64) {\n      b.Error(\"error\")\n    }\n  }\n}\n\nfunc BenchmarkConvertAssert(b *testing.B) {\n  for i:=0;i \u003c b.N;i++ {\n    var v interface{} = int32(64)\n    f := v.(int32)\n    if f != int32(64) {\n      b.Error(\"error\")\n    }\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226144746-qhzihb6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226144746-qhzihb6","updated":"20231226144746"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"➜  test go test --bench='Convert' -run=none -benchmem -gcflags=all=-l\ngoos: darwin\ngoarch: amd64\npkg: gotest666/test\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkConvertForce-12            1000000000           0.2843 ns/op          0 B/op          0 allocs/op\nBenchmarkConvertReflect-12          84957760            13.66 ns/op        0 B/op          0 allocs/op\nBenchmarkConvertAssert-12           1000000000           0.2586 ns/op          0 B/op          0 allocs/op\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226144746-731yav4","Type":"NodeBlockquote","Properties":{"id":"20231226144746-731yav4","updated":"20231226144746"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226144746-ci07mg7","Type":"NodeParagraph","Properties":{"id":"20231226144746-ci07mg7","updated":"20231226144746"},"Children":[{"Type":"NodeText","Data":"可以看出性能上：强类型转换/assert\u003ereflect 没有逃逸的原因参见:"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/golang/go/blob/dev.boringcrypto.go1.18/src/runtime/iface.go#L365","TextMarkTextContent":"iface.go"}]}]},{"ID":"20231226144750-a3ucpnr","Type":"NodeParagraph","Properties":{"id":"20231226144750-a3ucpnr","updated":"20231226144902"},"Children":[{"Type":"NodeText","Data":"content-service 中已经不再使用reflect 相关的转换处理"}]},{"ID":"20231226144904-lm0ggbi","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226144904-lm0ggbi","updated":"20231226164738"},"Children":[{"Type":"NodeText","Data":"3.2 常见 map"}]},{"ID":"20231226144909-cqwcgbs","Type":"NodeParagraph","Properties":{"id":"20231226144909-cqwcgbs","updated":"20231226150859"},"Children":[{"Type":"NodeText","Data":"go 中常用的 map 包含，runtime.map、sync.map 和第三方的 ConcurrentMap，go 中 map 的定义位于"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/golang/go/blob/release-branch.go1.18/src/runtime/map.go#L116","TextMarkTextContent":"map.go"},{"Type":"NodeText","Data":"，典型的基于 bucket 的 map 的实现，如下："}]},{"ID":"20231226150900-85itl86","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226150900-85itl86","updated":"20231226150906"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type hmap struct {\n    ......\n    B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)\n    hash0     uint32 // hash seed\n\n    buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.\n    oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing\n  ......\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226150907-3h60x2x","Type":"NodeParagraph","Properties":{"id":"20231226150907-3h60x2x","updated":"20231226150917"},"Children":[{"Type":"NodeText","Data":"其查找、删除、rehash 机制参见https://juejin.cn/post/7056290831182856205"}]},{"ID":"20231226150925-xfefrih","Type":"NodeParagraph","Properties":{"id":"20231226150925-xfefrih","updated":"20231226150937"},"Children":[{"Type":"NodeText","Data":"sync.map 定义位于"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/golang/go/blob/release-branch.go1.18/src/sync/map.go#L27","TextMarkTextContent":"map.go"},{"Type":"NodeText","Data":"中，其是典型的以空间换时间的处理，具体如下:"}]},{"ID":"20231226150938-ofizodc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226150938-ofizodc","updated":"20231226150944"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type readOnly struct {\n    m       map[interface{}]*entry\n    amended bool // true if the dirty map contains some key not in m.\n}\n\ntype entry struct {\n    p unsafe.Pointer // *interface{}\n}\n\ntype Map struct {\n    mu Mutex\n    read atomic.Value // readOnly数据\n    dirty map[interface{}]*entry\n    misses int\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226151001-2srdbm5","Type":"NodeParagraph","Properties":{"id":"20231226151001-2srdbm5","updated":"20231226151001"},"Children":[{"Type":"NodeText","Data":"read 中存储的是 dirty 数据的一个副本(通过指针)，在读多写少的情况下，基本可以实现无锁的数据读取。"}]},{"ID":"20231226151010-ujysbsw","Type":"NodeParagraph","Properties":{"id":"20231226151010-ujysbsw","updated":"20231226151010"},"Children":[{"Type":"NodeText","Data":"Sync.map 相关机制参见:https://juejin.cn/post/6844903895227957262"}]},{"ID":"20231226151025-wk5clm0","Type":"NodeParagraph","Properties":{"id":"20231226151025-wk5clm0","updated":"20231226151026"},"Children":[{"Type":"NodeText","Data":"go 中还有一个第三方的 ConcurrentMap，其采用分段锁的原理，通过降低锁的粒度提升性能，参见:"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/golang/go/blob/dev.boringcrypto.go1.18/src/reflect/value.go#L39","TextMarkTextContent":"current-map"}]},{"ID":"20231226151033-rybzl53","Type":"NodeParagraph","Properties":{"id":"20231226151033-rybzl53","updated":"20231226151033"},"Children":[{"Type":"NodeText","Data":"针对 map、sync.map、ConcurrentMap 的测试如下："}]},{"ID":"20231226151034-g6qsl1j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226151034-g6qsl1j","updated":"20231226151056"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"const mapCnt = 20 \nfunc BenchmarkStdMapGetSet(b *testing.B) {\n    mp := map[string]string{}\n    keys := []string{\"a\", \"b\", \"c\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"}\n    for i := range keys {\n        mp[keys[i]] = keys[i]\n    }\n    var m sync.Mutex\n    b.ResetTimer()\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            for i := 0; i \u003c mapCnt; i++ {\n                for j := range keys {\n                    m.Lock()\n                    _ = mp[keys[j]]\n                    m.Unlock()\n                }\n            }\n\n            m.Lock()\n            mp[\"d\"] = \"d\"\n            m.Unlock()\n        }\n    })\n}\n\nfunc BenchmarkSyncMapGetSet(b *testing.B) {\n    var mp sync.Map\n    keys := []string{\"a\", \"b\", \"c\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"}\n    for i := range keys {\n        mp.Store(keys[i], keys[i])\n    }\n    b.ResetTimer()\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            for i := 0; i \u003c mapCnt; i++ {\n                for j := range keys {\n                    _, _ = mp.Load(keys[j])\n                }\n            }\n\n            mp.Store(\"d\", \"d\")\n        }\n    })\n}\n\nfunc BenchmarkConcurrentMapGetSet(b *testing.B) {\n    m := cmap.New[string]()\n    keys := []string{\"a\", \"b\", \"c\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"}\n    for i := range keys {\n        m.Set(keys[i], keys[i])\n    }\n    b.ResetTimer()\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            for i := 0; i \u003c mapCnt; i++ {\n                for j := range keys {\n                    _, _ = m.Get(keys[j])\n                }\n            }\n\n            m.Set(\"d\", \"d\")\n        }\n    })\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226152022-w2d7dmy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226152022-w2d7dmy","updated":"20231226152023"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\n➜  test go test --bench='GetSet' -run=none -benchmem\ngoos: darwin\ngoarch: amd64\npkg: gotest666/test\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkStdMapGetSet-12               49065         24976 ns/op           0 B/op          0 allocs/op\nBenchmarkSyncMapGetSet-12             722704          1756 ns/op          16 B/op          1 allocs/op\nBenchmarkConcurrentMapGetSet-12       227001          5206 ns/op           0 B/op          0 allocs/op\nPASS\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226152030-s2w9c7q","Type":"NodeBlockquote","Properties":{"id":"20231226152030-s2w9c7q","updated":"20231226152059"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226152034-v3qdovx","Type":"NodeParagraph","Properties":{"id":"20231226152034-v3qdovx","updated":"20231226152059"},"Children":[{"Type":"NodeText","Data":"需要注意此测试，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"读写并发比 20:1 读多写少，建议使用 sync.Map。如果业务场景中，很明确只有对 map 的读操作，建议使用 runtime.Map"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]}]},{"ID":"20231226152059-1warb8u","Type":"NodeParagraph","Properties":{"id":"20231226152059-1warb8u","updated":"20231226152105"},"Children":[{"Type":"NodeText","Data":"目前 content-service 中 runtime.map、sync.map 都有涉及"}]},{"ID":"20231226152106-juraoy6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226152106-juraoy6","updated":"20231226164746"},"Children":[{"Type":"NodeText","Data":"3.3 hash 的实现： index vs map"}]},{"ID":"20231226152120-qqj8ei2","Type":"NodeParagraph","Properties":{"id":"20231226152120-qqj8ei2","updated":"20231226152220"},"Children":[{"Type":"NodeText","Data":"在使用到 hash 的场景，除了 map，我们还可以基于 slice  或者 数组的索引，content-service 基于此实现另外一种 map。其性能对比如下："}]},{"ID":"20231226152220-203i5mk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226152220-203i5mk","updated":"20231226152230"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func BenchmarkHashIdx(b *testing.B) {\n    var data = [10]int{0: 1, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}\n    for i := 0; i \u003c b.N; i++ {\n        tmp := data[b.N%10]\n        _ = tmp\n    }\n}\nfunc BenchmarkHashMap(b *testing.B) {\n    var data = map[int]int{0: 1, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}\n    for i := 0; i \u003c b.N; i++ {\n        tmp := data[b.N%10]\n        _ = tmp\n    }\n}\n➜  test go test --bench='Hash' -run=none -benchmem\ngoos: darwin\ngoarch: amd64\npkg: gotest666/test\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkHashIdx-12     1000000000           1.003 ns/op           0 B/op          0 allocs/op\nBenchmarkHashMap-12     196543544            7.665 ns/op           0 B/op          0 allocs/op\nPASS\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226152234-tgos7wi","Type":"NodeParagraph","Properties":{"id":"20231226152234-tgos7wi","updated":"20231226152234"},"Children":[{"Type":"NodeText","Data":"性能有 5 倍左右提升，content-service 在解析正排数据时，即采用此种处理。"}]},{"ID":"20231226152451-vc1yrks","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226152451-vc1yrks","updated":"20231226164754"},"Children":[{"Type":"NodeText","Data":"3.4 string 和 slice"}]},{"ID":"20231226152538-8gznll9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231226152538-8gznll9","updated":"20231226164758"},"Children":[{"Type":"NodeText","Data":"3.4.1 string 和 slice 的定义"}]},{"ID":"20231226152555-52ges30","Type":"NodeParagraph","Properties":{"id":"20231226152555-52ges30","updated":"20231226152555"},"Children":[{"Type":"NodeText","Data":"在 go 中 string、slice 都是基于 buf、len 的定义，二者定义都位于"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/golang/go/blob/release-branch.go1.18/src/reflect/value.go#L2590","TextMarkTextContent":"value.go"},{"Type":"NodeText","Data":"中:"}]},{"ID":"20231226152555-rrqwvw0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226152555-rrqwvw0","updated":"20231226152555"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type StringHeader struct\n    Data uintptr\n    Len  int\n}\n\ntype SliceHeader struct {\n    Data uintptr\n    Len  int\n    Cap  int\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226152555-tb8cvsa","Type":"NodeParagraph","Properties":{"id":"20231226152555-tb8cvsa","updated":"20231226152555"},"Children":[{"Type":"NodeText","Data":"通过二者定义可以得出："}]},{"ID":"20231226152555-2svnmyo","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231226152555-2svnmyo","updated":"20231226152603"},"Children":[{"ID":"20231226152555-by9lr9w","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231226152555-by9lr9w","updated":"20231226152603"},"Children":[{"ID":"20231226152555-fhzklni","Type":"NodeParagraph","Properties":{"id":"20231226152555-fhzklni","updated":"20231226152603"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在值拷贝背景下，string、slice 的赋值操作代价都不大，最多有 24Byte"}]}]},{"ID":"20231226152555-2t3eho8","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231226152555-2t3eho8","updated":"20231226152555"},"Children":[{"ID":"20231226152555-lkfmsx8","Type":"NodeParagraph","Properties":{"id":"20231226152555-lkfmsx8","updated":"20231226152555"},"Children":[{"Type":"NodeText","Data":"slice 因为涉及到 cap，会涉及到预分配、惰性删除，其具体位于"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/golang/go/blob/release-branch.go1.18/src/runtime/slice.go#L166","TextMarkTextContent":"slice.go"}]}]}]},{"ID":"20231226152611-j60i0cv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231226152611-j60i0cv","updated":"20231226164806"},"Children":[{"Type":"NodeText","Data":"3.4.2 string、[]byte 转换"}]},{"ID":"20231226152628-yps3cnl","Type":"NodeParagraph","Properties":{"id":"20231226152628-yps3cnl","updated":"20231226153948"},"Children":[{"Type":"NodeText","Data":"go 中 string 和 []byte 间相互转换包含2种："}]},{"ID":"20231226153948-0aocz5t","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231226153948-0aocz5t","updated":"20231226153949"},"Children":[{"ID":"20231226153949-z86rfcn","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231226153949-z86rfcn","updated":"20231226153949"},"Children":[{"ID":"20231226153949-fzsaah9","Type":"NodeParagraph","Properties":{"id":"20231226153949-fzsaah9","updated":"20231226154014"},"Children":[{"Type":"NodeText","Data":"采用原生机制，比如 string 转 slice 可采用，[]byte(strData)"}]}]},{"ID":"20231226154015-b7wr5ol","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231226154015-b7wr5ol"},"Children":[{"ID":"20231226154015-d8p2wio","Type":"NodeParagraph","Properties":{"id":"20231226154015-d8p2wio","updated":"20231226154032"},"Children":[{"Type":"NodeText","Data":"基于对底层数据结构重新解释"}]}]}]},{"ID":"20231226154033-a34pk89","Type":"NodeParagraph","Properties":{"id":"20231226154033-a34pk89","updated":"20231226154118"},"Children":[{"Type":"NodeText","Data":"以 string 转换为 byte 为例，原生转换的转换会进行如下操作，其位于 string.go 中："}]},{"ID":"20231226154119-d0too20","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226154119-d0too20","updated":"20231226162946"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func stringtoslicebyte(buf *tmpBuf, s string) []byte {\n  var b [] byte\n  if buf != nil \u0026amp;\u0026amp; len(s) \u003c= len(buf) {\n    *buf = tmpBuf{}\n     b = buf[:len(s)]\n  } else {\n    b = rawbyteslice(len(s)) // 如果32字节不够存储数据，则调用 mallocgc 分配空间\n  }\n  copy(b,s) // 数据拷贝\n  return b\n}\n\n// rawbyteslice allocates a new byte slice, The byte slice is not zeroed\nfunc rawbyteslice(size int) (b []byte) {\n  cap := roundupsize(uintptr(size))\n  p := mallocgc(cap, nil, false) // 空间分配\n  if cap != uintptr(size) {\n    memclrNoHeapPointers(add(p,uintptr(size)), cap-uintptr(size))\n  }\n  \n  *(*slice)(unsafe.Pointer(\u0026amp.b) = slice{p, size, int(cap)}\n  return\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226153945-sfi873n","Type":"NodeBlockquote","Properties":{"id":"20231226153945-sfi873n","updated":"20231226163042"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226162951-am8j025","Type":"NodeParagraph","Properties":{"id":"20231226162951-am8j025","updated":"20231226163042"},"Children":[{"Type":"NodeText","Data":"其中 tmpBuf 定义为 type tmpBuf[32]byte。当长度超过 32 字节时，会进行空间的分配、拷贝。"}]}]},{"ID":"20231226163348-4omfrgu","Type":"NodeParagraph","Properties":{"id":"20231226163348-4omfrgu","updated":"20231226163348"},"Children":[{"Type":"NodeText","Data":"同理，byte 转换为 string，原生处理位于 slicebytetostring 函数，也位于"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/golang/go/blob/release-branch.go1.18/src/runtime/string.go#L81","TextMarkTextContent":"string.go"},{"Type":"NodeText","Data":"中"}]},{"ID":"20231226163348-s8cmrqg","Type":"NodeParagraph","Properties":{"id":"20231226163348-s8cmrqg","updated":"20231226163348"},"Children":[{"Type":"NodeText","Data":"针对多余的空间分配、拷贝问题，content-service 对此进行了封装，具体参见"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://git.woa.com/ForwardIndex/content-service/blob/master/pkg/tools/tools.go","TextMarkTextContent":"tools.go"},{"Type":"NodeText","Data":"，该实现通过对底层数据重新解释进行，具有较高的效率。"}]},{"ID":"20231226163348-43e3jmg","Type":"NodeParagraph","Properties":{"id":"20231226163348-43e3jmg","updated":"20231226163348"},"Children":[{"Type":"NodeText","Data":"以 byteToString 为例，相关 benchMark 如下："}]},{"ID":"20231226163358-3kd13gt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226163358-3kd13gt","updated":"20231226163411"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func BenchmarkByteToStringRaw(b *testing.B) {\n   bytes := getByte(34)\n   b.ResetTimer()\n   for i := 0; i \u003c b.N; i++ {\n      v := string(bytes)\n      if len(v) \u003c= 0 {\n         b.Error(\"error\")\n      }\n   }\n}\n// 认为对底层数据进行重新解释\nfunc Bytes2String(b []byte) string {\n   x := (*[3]uintptr)(unsafe.Pointer(\u0026amp;b))\n   s := [2]uintptr{x[0], x[1]}\n   return *(*string)(unsafe.Pointer(\u0026amp;s))\n}\n\nfunc BenchmarkByteToStringPointer(b *testing.B) {\n   bytes := getByte(34)\n   b.ResetTimer()\n   for i := 0; i \u003c b.N; i++ {\n      v := Bytes2String(bytes)\n      if len(v) \u003c= 0 {\n         b.Error(\"error\")\n      }\n   }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226163358-nj02oi4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226163358-nj02oi4","updated":"20231226163415"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"➜  gotest666 go test --bench='ByteToString' -run=none -benchmem\ngoos: darwin\ngoarch: amd64\npkg: gotest666\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkByteToStringRaw-12         47646651            23.37 ns/op       48 B/op          1 allocs/op\nBenchmarkByteToStringPointer-12     1000000000           0.7539 ns/op          0 B/op          0 allocs/op\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226163358-erfsb8s","Type":"NodeBlockquote","Properties":{"id":"20231226163358-erfsb8s","updated":"20231226163515"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226163358-fg4mcbn","Type":"NodeParagraph","Properties":{"id":"20231226163358-fg4mcbn","updated":"20231226163515"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"其性能有较大提升，"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"code strong text","TextMarkTextContent":"性能提升的主要原因，0 gc 0拷贝"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"需要注意，本处理只针对转换，不涉及 append 等可能引起扩容的处理"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]}]},{"ID":"20231226163516-kd5jhhr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231226163516-kd5jhhr","updated":"20231226164816"},"Children":[{"Type":"NodeText","Data":"3.4.3 string 的拼接"}]},{"ID":"20231226163705-dzxqzio","Type":"NodeParagraph","Properties":{"id":"20231226163705-dzxqzio","updated":"20231226163728"},"Children":[{"Type":"NodeText","Data":"当前 Golang 中字符串拼接方式，主要包含："}]},{"ID":"20231226163728-g030gaz","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231226163728-g030gaz","updated":"20231226163729"},"Children":[{"ID":"20231226163729-ibc1h1w","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231226163729-ibc1h1w","updated":"20231226163729"},"Children":[{"ID":"20231226163729-tro88tm","Type":"NodeParagraph","Properties":{"id":"20231226163729-tro88tm","updated":"20231226163743"},"Children":[{"Type":"NodeText","Data":"使用 + 连接字符串"}]}]},{"ID":"20231226163743-w6zz7aj","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231226163743-w6zz7aj"},"Children":[{"ID":"20231226163743-karcnz3","Type":"NodeParagraph","Properties":{"id":"20231226163743-karcnz3","updated":"20231226163749"},"Children":[{"Type":"NodeText","Data":"使用 fmt.Sprinf"}]}]},{"ID":"20231226163750-oveomr8","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20231226163750-oveomr8"},"Children":[{"ID":"20231226163750-9wffrsm","Type":"NodeParagraph","Properties":{"id":"20231226163750-9wffrsm","updated":"20231226163815"},"Children":[{"Type":"NodeText","Data":"使用运行时工具类，strings.Builder 或者 bytes.Buffer"}]}]},{"ID":"20231226163815-gtd8lll","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20231226163815-gtd8lll"},"Children":[{"ID":"20231226163815-sx4ptsy","Type":"NodeParagraph","Properties":{"id":"20231226163815-sx4ptsy","updated":"20231226163820"},"Children":[{"Type":"NodeText","Data":"预分配机制"}]}]}]},{"ID":"20231226163821-60nxdxj","Type":"NodeParagraph","Properties":{"id":"20231226163821-60nxdxj","updated":"20231226163826"},"Children":[{"Type":"NodeText","Data":"目前对+的处理，其处理函数位于"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/golang/go/blob/release-branch.go1.18/src/runtime/string.go#L25","TextMarkTextContent":"string.go"},{"Type":"NodeText","Data":"，当要连接的字符串长度\u003e32 时，每次会进行空间的分配和拷贝处理，其处理如下："}]},{"ID":"20231226163828-u95tr4y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226163828-u95tr4y","updated":"20231226163838"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func concatstrings(buf *tmpBuf, a []string) string {\n    idx := 0\n    l := 0\n    count := 0\n    for i, x := range a {  // 计算+链接字符的长度\n        n := len(x)\n        if n == 0 {\n            continue\n        }\n        if l+n \u003c l {\n            throw(\"string concatenation too long\")\n        }\n        l += n\n        count++\n        idx = i\n    }\n    if count == 0 {\n        return \"\"\n    }\n    .....\n  s, b := rawstringtmp(buf, l) // 如果长度小于len(buf)(32)，则分配空间，否则使用buf\n    for _, x := range a {\n        copy(b, x)\n        b = b[len(x):]\n    }\n    return s\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226163839-2p0ntj9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226163839-2p0ntj9","updated":"20231226163852"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type tmpBuf [32]byte\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226163858-8zl48ns","Type":"NodeParagraph","Properties":{"id":"20231226163858-8zl48ns","updated":"20231226163858"},"Children":[{"Type":"NodeText","Data":"fmt.Sprinf，涉及大量的 interface 相关操作，会导致逃逸。"}]},{"ID":"20231226163858-3fl2tko","Type":"NodeParagraph","Properties":{"id":"20231226163858-3fl2tko","updated":"20231226163858"},"Children":[{"Type":"NodeText","Data":"针对+、fmt.Sprintf 等的对比测试如下："}]},{"ID":"20231226163858-s5o1czs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226163858-s5o1czs","updated":"20231226163908"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func BenchmarkStringJoinAdd(b *testing.B) {\n   var s string\n   for i := 0; i \u003c b.N; i++ {\n      for i := 0; i \u003c count; i++ {\n         s += \"10\"\n      }\n   }\n}\n\nfunc BenchmarkStringJoinSprintf(b *testing.B) {\n   var s string\n   for i := 0; i \u003c b.N; i++ {\n      for i := 0; i \u003c count; i++ {\n         s = fmt.Sprintf(\"%s%s\", s, \"10\")\n      }\n   }\n}\n\nfunc BenchmarkStringJoinStringBuilder(b *testing.B) {\n   var sb strings.Builder\n   sb.Grow(count * 2) // 预分配了空间\n   b.ResetTimer()\n\n   for i := 0; i \u003c b.N; i++ {\n      for i := 0; i \u003c count; i++ {\n         sb.WriteString(\"10\")\n      }\n   }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226163922-6m3opc1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226163922-6m3opc1","updated":"20231226163926"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"➜  gotest666 go test --bench='StringJoin' -run=none -benchmem\ngoos: darwin\ngoarch: amd64\npkg: gotest666\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkStringJoinAdd-12                    124      11992891 ns/op    127697864 B/op      1006 allocs/op\nBenchmarkStringJoinSprintf-12                100      19413234 ns/op    195832744 B/op      2808 allocs/op\nBenchmarkStringJoinStringBuilder-12       189568          7335 ns/op       12392 B/op          0 allocs/op\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226163922-d0klal8","Type":"NodeParagraph","Properties":{"id":"20231226163922-d0klal8","updated":"20231226163922"},"Children":[{"Type":"NodeText","Data":"可以看出，空间预分配拥有非常高的性能指标。目前，Content-service 中都采用了空间预分配的方式，其他的一些测试参见："},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://geektutu.com/post/hpg-string-concat.html","TextMarkTextContent":"string 连接"}]},{"ID":"20231226163928-v0yixvn","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226163928-v0yixvn","updated":"20231226164831"},"Children":[{"Type":"NodeText","Data":"3.5 循环的处理： for vs range"}]},{"ID":"20231226164200-mrs8jzt","Type":"NodeParagraph","Properties":{"id":"20231226164200-mrs8jzt","updated":"20231226164200"},"Children":[{"Type":"NodeText","Data":"go 中常用的循环有 2 种 for 和 range,如下："}]},{"ID":"20231226164200-jz7izuv","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231226164200-jz7izuv","updated":"20231226164200"},"Children":[{"ID":"20231226164200-olj5dsq","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231226164200-olj5dsq","updated":"20231226164200"},"Children":[{"ID":"20231226164200-bjoerob","Type":"NodeParagraph","Properties":{"id":"20231226164200-bjoerob","updated":"20231226164200"},"Children":[{"Type":"NodeText","Data":"按位置进行遍历，for 和 range 都支持，如 for i:=range a{}， for i:=0;i\u003clen(a);i++"}]}]},{"ID":"20231226164200-0pcwh4b","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231226164200-0pcwh4b","updated":"20231226164200"},"Children":[{"ID":"20231226164200-9mp115k","Type":"NodeParagraph","Properties":{"id":"20231226164200-9mp115k","updated":"20231226164200"},"Children":[{"Type":"NodeText","Data":"同时对位置、值进行遍历，range 支持，如 for i,v := range a {}"}]}]}]},{"ID":"20231226164200-orcs2l5","Type":"NodeParagraph","Properties":{"id":"20231226164200-orcs2l5","updated":"20231226164200"},"Children":[{"Type":"NodeText","Data":"go 中循环经过一系列的编译、优化后，伪代码如下："}]},{"ID":"20231226164203-kapolba","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226164203-kapolba","updated":"20231226164208"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"ta := a     // 容器的拷贝\ni := 0\nl := len(ta) // 获取长度\nfor ; i \u003c l; i++ {\n    v := ta[i]  // 容器中元素的拷贝\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226164213-oc4ga72","Type":"NodeParagraph","Properties":{"id":"20231226164213-oc4ga72","updated":"20231226164213"},"Children":[{"Type":"NodeText","Data":"此处理可能会导致以下问题："}]},{"ID":"20231226164213-sacrahb","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231226164213-sacrahb","updated":"20231226164213"},"Children":[{"ID":"20231226164213-655j4tj","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231226164213-655j4tj","updated":"20231226164213"},"Children":[{"ID":"20231226164213-xzuk2nf","Type":"NodeParagraph","Properties":{"id":"20231226164213-xzuk2nf","updated":"20231226164213"},"Children":[{"Type":"NodeText","Data":"遍历前，会进行值的拷贝，如果是数组，会有大量数据拷贝，slice 和 map 等引用的拷贝较少"}]}]},{"ID":"20231226164213-cky3sp9","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231226164213-cky3sp9","updated":"20231226164213"},"Children":[{"ID":"20231226164213-juhl2eb","Type":"NodeParagraph","Properties":{"id":"20231226164213-juhl2eb","updated":"20231226164213"},"Children":[{"Type":"NodeText","Data":"for range value 在遍历中存在对容器元素的拷贝"}]}]},{"ID":"20231226164213-zn055o7","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20231226164213-zn055o7","updated":"20231226164213"},"Children":[{"ID":"20231226164213-4xlcb4k","Type":"NodeParagraph","Properties":{"id":"20231226164213-4xlcb4k","updated":"20231226164213"},"Children":[{"Type":"NodeText","Data":"遍历开始，已经确定了容器长度，中间添加的数据，不会遍历到"}]}]}]},{"ID":"20231226164213-89bvs5e","Type":"NodeParagraph","Properties":{"id":"20231226164213-89bvs5e","updated":"20231226164213"},"Children":[{"Type":"NodeText","Data":"针对此测试如下："}]},{"ID":"20231226164233-del90hb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226164233-del90hb","updated":"20231226164240"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Item struct {\n    id  int\n    val [4096]byte\n}\n\nfunc BenchmarkLoopFor(b *testing.B) {\n    var items [1024]Item\n    for i := 0; i \u003c b.N; i++ {\n        length := len(items)\n        var tmp int\n        for k := 0; k \u003c length; k++ {\n            tmp = items[k].id\n        }\n        _ = tmp\n    }\n}\n\nfunc BenchmarkLoopRangeIndex(b *testing.B) {\n    var items [1024]Item\n    for i := 0; i \u003c b.N; i++ {\n        var tmp int\n        for k := range items {\n            tmp = items[k].id\n        }\n        _ = tmp\n    }\n}\n\nfunc BenchmarkLoopRangeValue(b *testing.B) {\n    var items [1024]Item\n    for i := 0; i \u003c b.N; i++ {\n        var tmp int\n        for _, item := range items {\n            tmp = item.id\n        }\n        _ = tmp\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226164233-uha7wui","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226164233-uha7wui","updated":"20231226164236"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"➜  test go test --bench='Loop' -run=none -benchmem\ngoos: darwin\ngoarch: amd64\npkg: gotest666/test\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkLoopFor-12              4334842           270.8 ns/op         0 B/op          0 allocs/op\nBenchmarkLoopRangeIndex-12       4436786           272.7 ns/op         0 B/op          0 allocs/op\nBenchmarkLoopRangeValue-12          7310        211009 ns/op           0 B/op          0 allocs/op\nPASS\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226164233-os5yafq","Type":"NodeBlockquote","Properties":{"id":"20231226164233-os5yafq","updated":"20231226164327"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226164233-iwubp3z","Type":"NodeParagraph","Properties":{"id":"20231226164233-iwubp3z","updated":"20231226164327"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"注意，对于所需空间较小，如指针类型数组等此问题并不严重 在需要较大存储空间、元素需要较大存储空间时，建议不要采用 range value 的方式"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]}]},{"ID":"20231226164327-ltbooom","Type":"NodeParagraph","Properties":{"id":"20231226164327-ltbooom","updated":"20231226164334"},"Children":[{"Type":"NodeText","Data":"content_service 中目前基本都是基于 for index、range index 的处理"}]},{"ID":"20231226164335-re4wg7v","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226164335-re4wg7v","updated":"20231226164844"},"Children":[{"Type":"NodeText","Data":"3.6 重载"}]},{"ID":"20231226164343-bfc3yqr","Type":"NodeParagraph","Properties":{"id":"20231226164343-bfc3yqr","updated":"20231226164905"},"Children":[{"Type":"NodeText","Data":"目前 go 中重载的实现包含 2 种，泛型(1.18)、基于 interface 的定义"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"泛型的优点在于预编译，即编译期间即可确定类型，对比基于 interface 的逃逸会有一定收益"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeText","Data":"，具体测试如下："}]},{"ID":"20231226164401-a7ima1u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226164401-a7ima1u","updated":"20231226164401"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func AddGeneric[T int | int16 | int32 | int64](a, b T) T {\n    return a + b\n}\n\nfunc AddInterface(a, b interface{}) interface{} {\n    switch a.(type) {\n    case int:\n        return a.(int) + b.(int)\n    case int32:\n        return a.(int32) + b.(int32)\n    case int64:\n        return a.(int64) + b.(int64)\n    }\n    return 0\n}\n\nfunc BenchmarkOverLoadGeneric(b *testing.B) {\n    for i := 0; i \u003c b.N; i++ {\n        x := AddGeneric(i, i)\n        _ = x\n    }\n}\nfunc BenchmarkOverLoadInterface(b *testing.B) {\n    for i := 0; i \u003c b.N; i++ {\n        x := AddInterface(i, i)\n        _ = x.(int)\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226164401-pt1xs4f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226164401-pt1xs4f","updated":"20231226164401"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"➜  test go test --bench='OverLoad' -run=none -benchmem\ngoos: darwin\ngoarch: amd64\npkg: gotest666/test\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkOverLoadGeneric-12         1000000000           0.2778 ns/op          0 B/op          0 allocs/op\nBenchmarkOverLoadInterface-12       954258690            1.248 ns/op           0 B/op          0 allocs/op\nPASS\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226164401-ld4lm20","Type":"NodeParagraph","Properties":{"id":"20231226164401-ld4lm20","updated":"20231226164401"},"Children":[{"Type":"NodeText","Data":"对比 interface 类型的处理，泛型有一定的性能的提升，目前在 content-service 中已经得到了大量的使用。"}]},{"ID":"20231226164528-od9pn5m","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231226164528-od9pn5m","updated":"20231226164923"},"Children":[{"Type":"NodeText","Data":"4. 空间与布局"}]},{"ID":"20231226164923-9whtb6v","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226164923-9whtb6v","updated":"20231226164936"},"Children":[{"Type":"NodeText","Data":"4.1 栈与堆空间的分配"}]},{"ID":"20231226164936-52yvqyb","Type":"NodeParagraph","Properties":{"id":"20231226164936-52yvqyb","updated":"20231226164956"},"Children":[{"Type":"NodeText","Data":"在栈上分配空间为什么会比堆上快？"}]},{"ID":"20231226164957-6aq479n","Type":"NodeParagraph","Properties":{"id":"20231226164957-6aq479n","updated":"20231226165019"},"Children":[{"Type":"NodeText","Data":"通过汇编，可观察栈空间分配机制，如下："}]},{"ID":"20231226165019-6hwp059","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226165019-6hwp059","updated":"20231226165041"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nfunc test(a, b int) int {\n  return a + b\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226165048-5fz3gv4","Type":"NodeParagraph","Properties":{"id":"20231226165048-5fz3gv4","updated":"20231226165048"},"Children":[{"Type":"NodeText","Data":"其对应汇编代码如下："}]},{"ID":"20231226165048-1e6szg9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226165048-1e6szg9","updated":"20231226165052"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"main.test STEXT nosplit size=49 args=0x10 locals=0x10 funcid=0x0 align=0x0\n        0x0000 00000 (/Users/zhangyuxin/go/src/gotest666/test.go:3)     TEXT    main.test(SB), NOSPLIT|ABIInternal, $16-16\n        0x0000 00000 (/Users/zhangyuxin/go/src/gotest666/test.go:3)     SUBQ    $16, SP         // 栈扩容\n                ......\n        0x002c 00044 (/Users/zhangyuxin/go/src/gotest666/test.go:4)     ADDQ    $16, SP         // 栈释放\n        0x0030 00048 (/Users/zhangyuxin/go/src/gotest666/test.go:4)     RET\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226165048-9be1n38","Type":"NodeParagraph","Properties":{"id":"20231226165048-9be1n38","updated":"20231226165048"},"Children":[{"Type":"NodeText","Data":"在 go 中栈的扩容、释放只涉及到了 SUBQ、ADDQ 2 条指令。"}]},{"ID":"20231226165253-rymyrcv","Type":"NodeParagraph","Properties":{"id":"20231226165253-rymyrcv","updated":"20231226165434"},"Children":[{"Type":"NodeText","Data":"对应的基于堆的内存分配，位于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"malloc.go"},{"Type":"NodeText","Data":"​ 中的mallocgc 函数，p 的定义、 mheap 的定义分别位于 runtime2.go、mcache.go、mheap.go,其分配的流程具体如下（\u003c32K, \u003e8B）:"}]},{"ID":"20231226165452-hp0be6f","Type":"NodeParagraph","Properties":{"id":"20231226165452-hp0be6f","updated":"20231226165452"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231226165452-me87mdk.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231226165459-k8upt2q","Type":"NodeParagraph","Properties":{"id":"20231226165459-k8upt2q","updated":"20231226165526"},"Children":[{"Type":"NodeText","Data":"其中，直接从 p.mcache 获取空间不需要加锁（单协程），mheap.mcentral 获取空间需要加锁(全局变量)、mmap 需要系统调用。此外，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"堆上分配还需要考虑 gc 导致的 stw 等的影响，因此建议所需空间不是特别大时还是在栈上进行空间的分配。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20231226165528-e5vl5aw","Type":"NodeParagraph","Properties":{"id":"20231226165528-e5vl5aw","updated":"20231226211419"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"content-service 开发中有一个共识: 能在栈上处理的数据，不会放到堆上"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20231226165517-gwjwfy7","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226165517-gwjwfy7","updated":"20231226165547"},"Children":[{"Type":"NodeText","Data":"Zero GC"}]},{"ID":"20231226165606-p1js2cp","Type":"NodeParagraph","Properties":{"id":"20231226165606-p1js2cp","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"Zero GC 能够避免 gc 带来的扫描、STW 等，具有一定的性能收益。"}]},{"ID":"20231226165606-1c2a5k4","Type":"NodeParagraph","Properties":{"id":"20231226165606-1c2a5k4","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"当前 zero gc 的处理，主要包含 2 种："}]},{"ID":"20231226165606-8jqmdr6","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231226165606-8jqmdr6","updated":"20231226165606"},"Children":[{"ID":"20231226165606-s09hdsv","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231226165606-s09hdsv","updated":"20231226165606"},"Children":[{"ID":"20231226165606-jj1q4sa","Type":"NodeParagraph","Properties":{"id":"20231226165606-jj1q4sa","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"无 gc，通过 mmap 或者 cgo.malloc 分配空间，绕过 go 的内存分配机制，如 fastcache 的实现"}]}]},{"ID":"20231226165606-pvh5fmu","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231226165606-pvh5fmu","updated":"20231226165606"},"Children":[{"ID":"20231226165606-ovj4fh4","Type":"NodeParagraph","Properties":{"id":"20231226165606-ovj4fh4","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"避免或者减少 gc，通过[]byte 等避免因为指针导致的扫描、stw，bigCache 的实现即为此。"}]}]}]},{"ID":"20231226165606-hl3i3p7","Type":"NodeParagraph","Properties":{"id":"20231226165606-hl3i3p7","updated":"20231226213733"},"Children":[{"Type":"NodeText","Data":"Zero GC 的优点在于，避免了 go gc 处理带来的标记扫描、STW 等，相对于常规堆上数据分配，其性能有较大提升。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"content-service 在重构中，使用了大量的基于 0 gc 的库，比如 fastcache，对一些常用函数、机制，如 strings.split 也进行了 0 gc 的优化，其实现如下："},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20231226165606-93nhrs7","Type":"NodeParagraph","Properties":{"id":"20231226165606-93nhrs7","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"在 content-service 中其实现位于"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://git.woa.com/ForwardIndex/content-service/blob/master/pkg/tools/string_util.go#L105","TextMarkTextContent":"string_util.go"},{"Type":"NodeText","Data":"，如下:"}]},{"ID":"20231226165606-987kxen","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226165606-987kxen","updated":"20231226211312"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type StringSplitter struct {\n    Idx [8]int  // 存储splitter对应的位置信息\n    src string\n    cnt int\n}\n\n// Split 分割\nfunc (s *StringSplitter) Split(str string, sep byte) bool {\n    s.src = str\n    for i := 0; i \u003c len(str); i++ {\n        if str[i] == sep {\n            s.Idx[s.cnt] = i\n            s.cnt++\n\n            // 超过Idx数据长度则返回空\n            if int(s.cnt) \u003e= len(s.Idx) {\n                return false\n            }\n        }\n    }\n\n    return true\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226165606-di5gyej","Type":"NodeParagraph","Properties":{"id":"20231226165606-di5gyej","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"与常规 strings.split 对比如下，其性能有近 4 倍左右提升："}]},{"ID":"20231226165606-9xfjcds","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226165606-9xfjcds","updated":"20231226211319"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"➜  test go test --bench='Split' -run=none -benchmem\ngoos: darwin\ngoarch: amd64\npkg: gotest666/test\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkQSplitRaw-12       13455728            76.43 ns/op       64 B/op          1 allocs/op\nBenchmarkQSplit-12          59633916            20.08 ns/op        0 B/op          0 allocs/op\nPASS\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226165606-dxoobd0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226165606-dxoobd0","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"4.3 GC 的优化"}]},{"ID":"20231226165606-2e50htn","Type":"NodeParagraph","Properties":{"id":"20231226165606-2e50htn","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"gc 优化相关，主要涉及 GOGC、GOMEMLIMIT，参见："},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://km.woa.com/articles/show/585408","TextMarkTextContent":"Golang 垃圾回收介绍及参数调整"}]},{"ID":"20231226165606-bx0qixt","Type":"NodeBlockquote","Properties":{"id":"20231226165606-bx0qixt","updated":"20231226165606"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231226165606-kglhuom","Type":"NodeParagraph","Properties":{"id":"20231226165606-kglhuom","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"需要注意，此机制只在 1.20 以上版本生效"}]}]},{"ID":"20231226165606-bdpvlhd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231226165606-bdpvlhd","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"4.4 逃逸"}]},{"ID":"20231226165606-h5x8z8u","Type":"NodeParagraph","Properties":{"id":"20231226165606-h5x8z8u","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"对于一些处理比较复杂操作，go 在编译器会在编译期间将相关变量逃逸至堆上。目前可能导致逃逸的机制包含:"}]},{"ID":"20231226165606-rdoc6e4","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231226165606-rdoc6e4","updated":"20231226165606"},"Children":[{"ID":"20231226165606-roquzna","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231226165606-roquzna","updated":"20231226165606"},"Children":[{"ID":"20231226165606-4jzc8ad","Type":"NodeParagraph","Properties":{"id":"20231226165606-4jzc8ad","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"基于指针的逃逸"}]}]},{"ID":"20231226165606-64xlysd","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231226165606-64xlysd","updated":"20231226165606"},"Children":[{"ID":"20231226165606-yav65ju","Type":"NodeParagraph","Properties":{"id":"20231226165606-yav65ju","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"栈空间不足，超过了 os 的限制 8M"}]}]},{"ID":"20231226165606-nhqfje4","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20231226165606-nhqfje4","updated":"20231226165606"},"Children":[{"ID":"20231226165606-vothcw0","Type":"NodeParagraph","Properties":{"id":"20231226165606-vothcw0","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"闭包"}]}]},{"ID":"20231226165606-4xvf0i0","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20231226165606-4xvf0i0","updated":"20231226165606"},"Children":[{"ID":"20231226165606-ebo52vf","Type":"NodeParagraph","Properties":{"id":"20231226165606-ebo52vf","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"动态类型"}]}]}]},{"ID":"20231226165606-ahg7fpu","Type":"NodeParagraph","Properties":{"id":"20231226165606-ahg7fpu","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"目前逃逸分析，可采用-gcflags=-m 进行查看，如下:"}]},{"ID":"20231226165606-bye1t3t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226165606-bye1t3t","updated":"20231226211326"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type test1 struct {\n    a int32\n    b int\n    c int32\n}\n\ntype test2 struct {\n    a int32\n    c int32\n    b int\n}\n\nfunc getData() *int {\n    a := 10\n    return \u0026amp;a\n}\n\nfunc main() {\n    fmt.Println(unsafe.Sizeof(test1{}))\n    fmt.Println(unsafe.Sizeof(test2{}))\n    getData()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226165606-db1npdn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226165606-db1npdn","updated":"20231226211332"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"➜  gotest666 go build -gcflags=-m main.go\n# command-line-arguments\n./main.go:20:6: can inline getData\n./main.go:26:13: inlining call to fmt.Println\n./main.go:27:13: inlining call to fmt.Println\n./main.go:28:9: inlining call to getData\n./main.go:21:2: moved to heap: a        // 返回指针导致逃逸\n./main.go:26:13: ... argument does not escape\n./main.go:26:27: unsafe.Sizeof(test1{}) escapes to heap // 动态类型导致逃逸\n./main.go:27:13: ... argument does not escape\n./main.go:27:27: unsafe.Sizeof(test2{}) escapes to heap // 动态类型导致逃逸\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226165606-g83hp7m","Type":"NodeParagraph","Properties":{"id":"20231226165606-g83hp7m","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"在日常业务处理过程中，建议尽量避免逃逸到堆上的情况"}]},{"ID":"20231226165606-syywlcq","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231226165606-syywlcq","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"4.5 数据的对齐"}]},{"ID":"20231226165606-alj753r","Type":"NodeParagraph","Properties":{"id":"20231226165606-alj753r","updated":"20231227093522"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"go 中同样存在数据对齐，适当的布局调整，能够节省大量的空间"},{"Type":"NodeText","Data":"，具体如下："}]},{"ID":"20231226165606-83smqyc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226165606-83smqyc","updated":"20231226211337"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type test1 struct {\n    a int32\n    b int\n    c int32\n}\n\ntype test2 struct {\n    a int32\n    c int32\n    b int\n}\n\nfunc main() {\n    fmt.Println(unsafe.Alignof(test1{}))\n    fmt.Println(unsafe.Alignof(test2{}))\n    fmt.Println(unsafe.Sizeof(test1{}))\n    fmt.Println(unsafe.Sizeof(test2{}))\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226165606-7lx0h0y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226165606-7lx0h0y","updated":"20231227093648"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"➜  gotest666 go run main.go\n8\n8\n24\n16\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226165606-lybh3lv","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231226165606-lybh3lv","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"4.6 空间预分配"}]},{"ID":"20231226165606-fn3e6dp","Type":"NodeParagraph","Properties":{"id":"20231226165606-fn3e6dp","updated":"20231227093532"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"空间预分配，可以避免大量不必要的空间分配、拷贝，目前 slice、map、strings.Builder、byte.Builder 等都涉及到预分配机制。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20231226165606-m81w85h","Type":"NodeParagraph","Properties":{"id":"20231226165606-m81w85h","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"以 map 为例，测试结果如下："}]},{"ID":"20231226165606-zom1c02","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226165606-zom1c02","updated":"20231226211342"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func BenchmarkConcurrentMapAlloc(b *testing.B) {\n    m := map[int]int{}\n    b.ResetTimer()\n    for i := 0; i \u003c b.N; i++ {\n        m[i] = i\n    }\n}\n\nfunc BenchmarkConcurrentMapPreAlloc(b *testing.B) {\n    m := make(map[int]int, b.N)\n    b.ResetTimer()\n    for i := 0; i \u003c b.N; i++ {\n        m[i] = i\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226165606-lzoi0mm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226165606-lzoi0mm","updated":"20231226211347"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"➜  test go test --bench='Alloc' -run=none -benchmem\ngoos: darwin\ngoarch: amd64\npkg: gotest666/test\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkConcurrentMapAlloc-12           6027334           186.0 ns/op        60 B/op          0 allocs/op\nBenchmarkConcurrentMapPreAlloc-12       15499568            89.68 ns/op        0 B/op          0 allocs/op\nPASS\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226165606-2c43zi8","Type":"NodeParagraph","Properties":{"id":"20231226165606-2c43zi8","updated":"20231226165606"},"Children":[{"Type":"NodeText","Data":"预分配能够极大提升，相关性能， 建议在使用时都进行空间的预分配。content-service 在开发中基本都做到了空间的预分配。"}]},{"ID":"20231226205205-evz1jtc","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231226205205-evz1jtc","updated":"20231227093605"},"Children":[{"Type":"NodeText","Data":"5. 并发编程"}]},{"ID":"20231227093558-qx8dekm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231227093558-qx8dekm","updated":"20231227093612"},"Children":[{"Type":"NodeText","Data":"5.1 锁"}]},{"ID":"20231227093634-94chkut","Type":"NodeParagraph","Properties":{"id":"20231227093634-94chkut","updated":"20231227093634"},"Children":[{"Type":"NodeText","Data":"golang 中 mutex 定义位于"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/golang/go/blob/release-branch.go1.18/src/sync/mutex.go#L25","TextMarkTextContent":"mutex.go"},{"Type":"NodeText","Data":"，其定义如下："}]},{"ID":"20231227093634-lngmnjk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231227093634-lngmnjk","updated":"20231227093640"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Mutex struct {\n    state int32         // 状态字，标识锁是否被锁定、是否starving等\n    sema  uint32        // 信号量\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231227093634-hnvyxip","Type":"NodeParagraph","Properties":{"id":"20231227093634-hnvyxip","updated":"20231227093634"},"Children":[{"Type":"NodeText","Data":"golang 的读写锁基于 mutex，其定义位于"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/golang/go/blob/release-branch.go1.18/src/sync/rwmutex.go#L28","TextMarkTextContent":"rwmutex.go"},{"Type":"NodeText","Data":", 其定义如下:"}]},{"ID":"20231227093634-nq6ybvf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231227093634-nq6ybvf","updated":"20231227093657"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type RWMutex struct {\n    w           Mutex  // 用于阻塞写协程\n    writerSem   uint32 // 写信号量，用于实现写阻塞队列\n    readerSem   uint32 // 读信号量，用于实现读阻塞队列\n    readerCount int32  // 当前正在读操作的个数\n    readerWait  int32  // 防止写操作被饿死，标记排在写操作前读操作的个数\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231227093634-uxjn8co","Type":"NodeParagraph","Properties":{"id":"20231227093634-uxjn8co","updated":"20231227093634"},"Children":[{"Type":"NodeText","Data":"RWMutex 基于 Mutex 实现，在加写锁上，RWMutex 性能略差于 Mutex。但在读操作较多情况下，RWMutex 性能是优于 Mutex 的，因为 RWMutex 对于读的操作只是通过 readerCount 计数进行， 其相关处理位于"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/golang/go/blob/dev.boringcrypto.go1.18/src/sync/rwmutex.go#L56","TextMarkTextContent":"rwmutex.go"},{"Type":"NodeText","Data":"，如下:"}]},{"ID":"20231227093634-en0h5za","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231227093634-en0h5za","updated":"20231227093708"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (rw *RWMutex) RLock() {\n    if race.Enabled {\n        _ = rw.w.state\n        race.Disable()\n    }\n    if rw.readerCount.Add(1) \u003c 0 {  // readCount \u003c 0，表示有写操作正在进行\n        runtime_SemacquireRWMutexR(\u0026amp;rw.readerSem, false, 0)\n    }\n    if race.Enabled {\n        race.Enable()\n        race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem))\n    }\n}\n\nfunc (rw *RWMutex) Lock() {\n    if race.Enabled {\n        _ = rw.w.state\n        race.Disable()\n    }\n\n    rw.w.Lock()                                                                         // 加写锁\n    r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders // 统计当前读操作的个数，\n    if r != 0 \u0026amp;\u0026amp; rw.readerWait.Add(r) != 0 {                                                // 并等待读操作\n        runtime_SemacquireRWMutex(\u0026amp;rw.writerSem, false, 0)\n    }\n    if race.Enabled {\n        race.Enable()\n        race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem))\n        race.Acquire(unsafe.Pointer(\u0026amp;rw.writerSem))\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231227093634-jfvo5r6","Type":"NodeParagraph","Properties":{"id":"20231227093634-jfvo5r6","updated":"20231227093634"},"Children":[{"Type":"NodeText","Data":"按照读写比例的不同，进行了如下测试："}]},{"ID":"20231227093634-2lap41e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231227093634-2lap41e","updated":"20231227093714"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"var mut sync.Mutex\nvar rwMut sync.RWMutex\nvar t int\n\nconst cost = time.Microsecond\n\nfunc WRead() {\n    mut.Lock()\n    _ = t\n    time.Sleep(cost)\n    mut.Unlock()\n}\n\nfunc WWrite() {\n    mut.Lock()\n    t++\n    time.Sleep(cost)\n    mut.Unlock()\n}\n\nfunc RWRead() {\n    rwMut.RLock()\n    _ = t\n    time.Sleep(cost)\n    rwMut.RUnlock()\n}\n\nfunc RWWrite() {\n    rwMut.Lock()\n    t++\n    time.Sleep(cost)\n    rwMut.Unlock()\n}\n\nfunc benchmark(b *testing.B, readFunc, writeFunc func(), read, write int) {\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            var wg sync.WaitGroup\n            for k := 0; k \u003c read*100; k++ {\n                wg.Add(1)\n                go func() {\n                    readFunc()\n                    wg.Done()\n                }()\n            }\n            for k := 0; k \u003c write*100; k++ {\n                wg.Add(1)\n                go func() {\n                    writeFunc()\n                    wg.Done()\n                }()\n            }\n            wg.Wait()\n        }\n    })\n}\n\nfunc BenchmarkReadMore(b *testing.B)         { benchmark(b, WRead, WWrite, 9, 1) }\nfunc BenchmarkReadMoreRW(b *testing.B)       { benchmark(b, RWRead, RWWrite, 9, 1) }\nfunc BenchmarkWriteMore(b *testing.B)        { benchmark(b, WRead, WWrite, 1, 9) }\nfunc BenchmarkWriteMoreRW(b *testing.B)      { benchmark(b, RWRead, RWWrite, 1, 9) }\nfunc BenchmarkReadWriteEqual(b *testing.B)   { benchmark(b, WRead, WWrite, 5, 5) }\nfunc BenchmarkReadWriteEqualRW(b *testing.B) { benchmark(b, RWRead, RWWrite, 5, 5) }\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231227093634-kfjq8a1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231227093634-kfjq8a1","updated":"20231227093720"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"➜  test go test --bench='Read|Write' -run=none -benchmem\ngoos: darwin\ngoarch: amd64\npkg: gotest666/test\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkReadMore-12                     207       5713542 ns/op      114190 B/op       2086 allocs/op\nBenchmarkReadMoreRW-12                  1237        904307 ns/op      104683 B/op       2007 allocs/op\nBenchmarkWriteMore-12                    211       5799927 ns/op      110360 B/op       2067 allocs/op\nBenchmarkWriteMoreRW-12                  222       5490282 ns/op      110666 B/op       2070 allocs/op\nBenchmarkReadWriteEqual-12               213       5752311 ns/op      111017 B/op       2065 allocs/op\nBenchmarkReadWriteEqualRW-12             386       3088603 ns/op      106810 B/op       2030 allocs/op\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231227093634-rj4d0ls","Type":"NodeParagraph","Properties":{"id":"20231227093634-rj4d0ls","updated":"20231227093634"},"Children":[{"Type":"NodeText","Data":"在读写比例为 9:1 时，RWMute 性能约为 Mutex 的 6 倍。"}]},{"ID":"20231227093722-i0yvdni","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231227093722-i0yvdni","updated":"20231227093739"},"Children":[{"Type":"NodeText","Data":"6. 其他"}]},{"ID":"20231227093746-lrulgef","Type":"NodeParagraph","Properties":{"id":"20231227093746-lrulgef","updated":"20231227093746"},"Children":[{"Type":"NodeText","Data":"需要注意："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"语言层面只能解决单点的性能问题，良好的架构设计才能从全局解决问题"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231227093746-ehso5yt","Type":"NodeParagraph","Properties":{"id":"20231227093746-ehso5yt","updated":"20231227093746"},"Children":[{"Type":"NodeText","Data":"本文所有 benchmark、源码都是基于 1.18。"}]},{"ID":"20231227093746-ryfs0fr","Type":"NodeParagraph","Properties":{"id":"20231227093746-ryfs0fr"}}]}