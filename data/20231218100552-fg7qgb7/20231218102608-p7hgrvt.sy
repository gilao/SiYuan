{"ID":"20231218102608-p7hgrvt","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f961","id":"20231218102608-p7hgrvt","tags":"Go-连接池,gRPC连接池,gRPC,需要仔细看","title":"golang工程——grpc 连接池简单实现","updated":"20231218103004"},"Children":[{"ID":"20231218102608-8gq5oed","Type":"NodeParagraph","Properties":{"id":"20231218102608-8gq5oed","updated":"20231218102656"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://blog.csdn.net/qq_43058348/article/details/133578198","TextMarkTextContent":"golang工程——grpc 连接池简单实现"}]},{"ID":"20231218102657-tyer52h","Type":"NodeParagraph","Properties":{"id":"20231218102657-tyer52h","updated":"20231218102709"},"Children":[{"Type":"NodeText","Data":"grpc client 连接池"}]},{"ID":"20231218102646-ockhc7p","Type":"NodeParagraph","Properties":{"id":"20231218102646-ockhc7p","updated":"20231218102814"},"Children":[{"Type":"NodeText","Data":"grpc连接池可以采用sync.Pool实现。 可以有效减少重复创建grpc连接的资源消耗。"}]},{"ID":"20231218102814-9wb514p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231218102814-9wb514p","updated":"20231218102929"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package client_pool\n\nimport (\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/connectivity\"\n\t\"log\"\n\t\"sync\"\n)\n\n// 用sync.pool实现\n\nvar p sync.Pool\n\ntype ClientPool interface {\n\tGet() *grpc.ClientConn\n\tPut(conn *grpc.ClientConn)\n}\n\ntype clientPool struct {\n\tpool sync.Pool\n}\n\nfunc GetPool(target string, opts ...grpc.DialOption)(ClientPool, error) {\n\treturn \u0026clientPool{\n\t\tpool: sync.Pool{\n\t\t\tNew: func() any {\n\t\t\t\tconn, err := grpc.Dial(target, opts...)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(err)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn conn\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\nfunc (c *clientPool) Get() *grpc.ClientConn {\n\tconn := c.pool.Get().(*grpc.ClientConn)\n\t// 如果连接关闭或者失败\n\tif conn.GetState() == connectivity.Shutdown || conn.GetState() == connectivity.TransientFailure {\n\t\tconn.Close()\n\t\tconn = c.pool.New().(*grpc.ClientConn)\n\t}\n\n\treturn conn\n}\n\nfunc (c *clientPool) Put(conn *grpc.ClientConn) {\n\tif conn.GetState() == connectivity.Shutdown || conn.GetState() == connectivity.TransientFailure {\n\t\tconn.Close()\n\t\tconn = c.pool.New().(*grpc.ClientConn)\n\t}\n\tc.pool.Put(conn)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231218102810-n3a1ls2","Type":"NodeParagraph","Properties":{"id":"20231218102810-n3a1ls2","updated":"20231218102916"},"Children":[{"Type":"NodeText","Data":"在使用的时候，由于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"sync.Pool"},{"Type":"NodeText","Data":"​ Get 方法会pop处集合中的资源，使用完后需要Put回去；"}]},{"ID":"20231218102917-iv8mj16","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231218102917-iv8mj16","updated":"20231218102925"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (p *Pool) Get() any {\n\tif race.Enabled {\n\t\trace.Disable()\n\t}\n\tl, pid := p.pin()\n\tx := l.private\n\tl.private = nil\n\tif x == nil {\n\t\t// Try to pop the head of the local shard. We prefer\n\t\t// the head over the tail for temporal locality of\n\t\t// reuse.\n\t\tx, _ = l.shared.popHead()\n\t\tif x == nil {\n\t\t\tx = p.getSlow(pid)\n\t\t}\n\t}\n\truntime_procUnpin()\n\tif race.Enabled {\n\t\trace.Enable()\n\t\tif x != nil {\n\t\t\trace.Acquire(poolRaceAddr(x))\n\t\t}\n\t}\n\tif x == nil \u0026\u0026 p.New != nil {\n\t\tx = p.New()\n\t}\n\treturn x\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231218102940-902scif","Type":"NodeParagraph","Properties":{"id":"20231218102940-902scif","updated":"20231218102948"},"Children":[{"Type":"NodeText","Data":"main.go"}]},{"ID":"20231218102948-90zid33","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231218102948-90zid33","updated":"20231218102955"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    flag.Parse()\n\n\n    //conn, err := grpc.Dial(*addr, getDiaOption()...)\n\n    // 根据协议+服务名 通过服务名称解析 访问服务器\n    pool, err := client_pool.GetPool(*addr, getDiaOption()...)\n\n    if err != nil {\n        log.Fatal(err)\n    }\n    conn := pool.Get()\n    // 重复使用连接，不用关闭\n    defer pool.Put(conn)\n    c := echo.NewEchoClient(conn)\n    // grpc调用\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231218103004-yqeh5dz","Type":"NodeParagraph","Properties":{"id":"20231218103004-yqeh5dz","updated":"20231218103004"},"Children":[{"Type":"NodeText","Data":"最后，连接池里的对象只是临时的，golang gc的时候也会释放掉一些不用的对象，连接池的对象也并不是一直存在的。"}]}]}