{"ID":"20231229104323-csr5anp","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f6f4","id":"20231229104323-csr5anp","tags":"Go-熔断","title":"Golang 使用熔断器提高你的系统健壮性","updated":"20231229104426"},"Children":[{"ID":"20231229104426-xtbq53q","Type":"NodeParagraph","Properties":{"id":"20231229104426-xtbq53q","updated":"20231229104426"},"Children":[{"Type":"NodeText","Data":"应用程序在执行访问远程资源和服务的操作时，这些操作可能会由于暂时性故障（例如网络连接速度慢、超时或资源过载或暂时不可用）而失败。这些错误通常会在短时间内自行纠正，并且应准备好使用诸如重试模式所述的策略来处理这些错误。"}]},{"ID":"20231229104426-lnwsm4o","Type":"NodeParagraph","Properties":{"id":"20231229104426-lnwsm4o","updated":"20231229104426"},"Children":[{"Type":"NodeText","Data":"但是，也可能存在以下情况：故障是由于不太容易预测的意外事件引起的，并且可能需要更长的时间来纠正。这些故障的严重程度从部分连接中断到服务完全失败不等。在这些情况下，应用程序不断重试执行不太可能成功的操作可能毫无意义，相反，应用程序应快速接受操作已失败并相应地处理此失败。"}]},{"ID":"20231229104426-6aa4o2p","Type":"NodeParagraph","Properties":{"id":"20231229104426-6aa4o2p","updated":"20231229105152"},"Children":[{"Type":"NodeText","Data":"此外，如果服务非常繁忙，系统某一部分的故障可能会导致级联故障。例如，调用服务的操作配置了超时，如果服务在此时间段内无法响应，则回复失败消息。但是，"},{"Type":"NodeTextMark","TextMarkType":"u","TextMarkTextContent":"此策略可能会导致对同一操作的许多并发请求被阻止，直到超时期限到期。这些被阻止的请求可能包含关键的系统资源，如内存、线程、数据库连接等。因此，这些资源可能会耗尽，从而导致系统中其他可能不相关的部分出现故障，这些部分需要使用相同的资源。在这些情况下，操作最好立即失败，并且仅在可能成功时才尝试调用服务。"},{"Type":"NodeText","Data":"请注意，设置较短的超时可能有助于解决此问题，但超时不应太短，以至于操作在大多数时间都失败，即使对服务的请求最终会成功也是如此。"}]},{"ID":"20231229104426-6fpiw34","Type":"NodeParagraph","Properties":{"id":"20231229104426-6fpiw34","updated":"20231229105327"},"Children":[{"Type":"NodeText","Data":"有没有好的解决方案呢？"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"strong text","TextMarkTextContent":"断路器模式可以防止应用程序重复尝试执行可能失败的操作，从而允许应用程序继续执行而无需等待故障得到纠正或在确定故障时浪费 CPU 。断路器模式还使应用程序能够检测故障是否已解决。如果问题似乎已得到纠正，则应用程序可以尝试调用该操作。断路器充当可能失败的操作的代理。代理应监视最近发生的失败数，然后使用此信息来决定是允许操作继续，还是立即返回异常。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20231229111215-wub6huh","Type":"NodeParagraph","Properties":{"id":"20231229111215-wub6huh","updated":"20231229111215"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231229111215-7n5y73o.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231229111217-w3muzb3","Type":"NodeParagraph","Properties":{"id":"20231229111217-w3muzb3","updated":"20231229111246"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"断路器闭合时，应用正常工作，当在指定的时间间隔内发生指定数量的故障，断路器转换为打开状态，断路器打开时，应用立即返回失败，当指定的超时器到期时，断路器转为半打开状态，当断路器半打开时，可以接受新的请求，如果新入的请求成功，则断路器转为闭合状态，如果新入的请求失败，则断路器转为打开状态。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeText","Data":"使用断路器模式可以提供系统的稳定性和弹性。"}]},{"ID":"20231229111248-ezovkmp","Type":"NodeParagraph","Properties":{"id":"20231229111248-ezovkmp","updated":"20231229111316"},"Children":[{"Type":"NodeText","Data":"gobreaker 是 golang 实现的熔断器。它的使用很简单，先导入"}]},{"ID":"20231229111317-rlose6j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231229111317-rlose6j","updated":"20231229111331"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"go get github.com/sony/gobreaker\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231229111342-pafz7e7","Type":"NodeParagraph","Properties":{"id":"20231229111342-pafz7e7","updated":"20231229111342"},"Children":[{"Type":"NodeText","Data":"该结构CircuitBreaker是一个状态机，用于防止发送可能失败的请求。该函数NewCircuitBreaker创建一个新的CircuitBreaker。"}]},{"ID":"20240102091736-cve3yw8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240102091736-cve3yw8","updated":"20240102091813"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func NewCircuitBreaker(st Settings) *CircuitBreaker\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240102091827-iku0z8y","Type":"NodeParagraph","Properties":{"id":"20240102091827-iku0z8y","updated":"20240102091857"},"Children":[{"Type":"NodeText","Data":"您可以通过结构Setting 进行配置CircuitBreaker："}]},{"ID":"20240102091857-1s5gj22","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240102091857-1s5gj22","updated":"20240102092452"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Setting struct {\n  Name string\n  MaxRequests uint32\n  Interval time.Duration\n  Timeout time.Duration\n  ReadyToTrip func(counts Counts) bool\n  OnStateChange func(name string, from State, to State)\n  IsSuccessful func (err error) bool\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240102092503-sx7pz2j","Type":"NodeList","ListData":{},"Properties":{"id":"20240102092503-sx7pz2j","updated":"20240102092503"},"Children":[{"ID":"20240102092503-v87duf3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102092503-v87duf3","updated":"20240102092503"},"Children":[{"ID":"20240102092503-fjzgo98","Type":"NodeParagraph","Properties":{"id":"20240102092503-fjzgo98","updated":"20240102092503"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Name"},{"Type":"NodeText","Data":"​是CircuitBreaker的名称。"}]}]},{"ID":"20240102092503-i6tkl59","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102092503-i6tkl59","updated":"20240102092503"},"Children":[{"ID":"20240102092503-pz6c7ex","Type":"NodeParagraph","Properties":{"id":"20240102092503-pz6c7ex","updated":"20240102092503"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MaxRequests"},{"Type":"NodeText","Data":"​是CircuitBreaker半开状态允许通过的最大请求数 。如果MaxRequests为0，CircuitBreaker只允许 1 个请求。"}]}]},{"ID":"20240102092503-a9h554n","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102092503-a9h554n","updated":"20240102092503"},"Children":[{"ID":"20240102092503-rvm34mn","Type":"NodeParagraph","Properties":{"id":"20240102092503-rvm34mn","updated":"20240102092503"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Interval"},{"Type":"NodeText","Data":"​是CircuitBreaker闭合状态下多长周期清除内部Counts，如果Interval为 0，CircuitBreaker在关闭状态下不清除内部Counts。"}]}]},{"ID":"20240102092503-d7imsqu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102092503-d7imsqu","updated":"20240102092503"},"Children":[{"ID":"20240102092503-ed9rodz","Type":"NodeParagraph","Properties":{"id":"20240102092503-ed9rodz","updated":"20240102092503"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Timeout"},{"Type":"NodeText","Data":"​是CircuitBreaker开放状态下多长周期超时之后，状态变为半开放状态。如果Timeout为0，CircuitBreaker超时值设置为 60 秒。"}]}]},{"ID":"20240102092503-sj4n0a8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102092503-sj4n0a8","updated":"20240102092503"},"Children":[{"ID":"20240102092503-uysk96o","Type":"NodeParagraph","Properties":{"id":"20240102092503-uysk96o","updated":"20240102092503"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ReadyToTrip"},{"Type":"NodeText","Data":"​在关闭状态下当请求失败时进行调用。如果ReadyToTrip返回 true，CircuitBreaker则将置于打开状态。如果ReadyToTrip返回nil， 将使用默认的ReadyToTrip。ReadyToTrip默认值在连续失败次数超过 5 时返回 true。"}]}]},{"ID":"20240102092503-lm6ianx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102092503-lm6ianx","updated":"20240102092503"},"Children":[{"ID":"20240102092503-29805l2","Type":"NodeParagraph","Properties":{"id":"20240102092503-29805l2","updated":"20240102092503"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"OnStateChange"},{"Type":"NodeText","Data":"​每当CircuitBreaker状态发生变化时调用。"}]}]},{"ID":"20240102092503-ose60f3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102092503-ose60f3","updated":"20240102092503"},"Children":[{"ID":"20240102092503-azp68kq","Type":"NodeParagraph","Properties":{"id":"20240102092503-azp68kq","updated":"20240102092503"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"IsSuccessful请求返回时调用"},{"Type":"NodeText","Data":"​。如果IsSuccessful返回 true，则错误计为成功。否则，错误将计为失败。如果IsSuccessful为nil， 默认的IsSuccessful将被使用，它对所有非 nil 错误返回 false。"}]}]}]},{"ID":"20240102092522-vsmmf3q","Type":"NodeParagraph","Properties":{"id":"20240102092522-vsmmf3q","updated":"20240102092555"},"Children":[{"Type":"NodeText","Data":"该结构Counts 保存请求数及其成功/失败："}]},{"ID":"20240102092555-owghb3b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240102092555-owghb3b","updated":"20240102092736"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Counts struct{\n  Requests uint32\n  TotalSuccesses uint32\n  TotalFailures uint32\n  ConsecutiveSuccesses uint32\n  ConsecutiveFailures uint32 \n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240102093115-a04yotr","Type":"NodeParagraph","Properties":{"id":"20240102093115-a04yotr","updated":"20240102093128"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"CircuitBreaker"},{"Type":"NodeText","Data":"​ 在状态更改时或在关闭状态时清除Counts。清除Counts前忽略发送的请求的结果。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"CircuitBreaker"},{"Type":"NodeText","Data":"​可以包装任何函数来发送请求："}]},{"ID":"20240102093129-ss4e3c6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240102093129-ss4e3c6","updated":"20240102093224"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (cb *CircuitBreaker) Execute(req func (interface{}, error)) (interface{}, error)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240102093327-9exgpzk","Type":"NodeParagraph","Properties":{"id":"20240102093327-9exgpzk","updated":"20240102093328"},"Children":[{"Type":"NodeText","Data":"该Execute方法在CircuitBreaker接受给定请求时Execute运行给定请求。如果CircuitBreaker拒绝请求，则立即返回错误。否则，Execute返回请求的结果。如果请求中出现panic，CircuitBreaker则将其作为错误处理 并再次引起同样的恐慌。"}]},{"ID":"20240102100755-fs44a67","Type":"NodeParagraph","Properties":{"id":"20240102100755-fs44a67","updated":"20240102100755"},"Children":[{"Type":"NodeText","Data":"这个例子，是对一个请求进行了断路器封装，它可以提供这个请求的健壮性，特别是当大批量的请求到达时。如果内部的请求返回错误达到熔断时机时，断路器将直接打开，返回客户端失败，而不会让客户端等待超时，然后重试，这样可以保护服务器资源不被快速的消耗，导致更恶劣的连锁反应。断路器在一定时间后，将转为半打开状态，接收新的请求，如果请求能够成功，则断路器将转为关闭状态，服务器将提供正常流量的服务，这样就避免了因为资源不可用导致服务直接宕机。"}]},{"ID":"20240102100801-8ycgx7a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240102100801-8ycgx7a","updated":"20240102101210"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"var cb *breaker.CircuitBreaker\nfunc Get(url string) ([]byte, error) {\n  body, err := cb.Execute(func() (interface{}, error) {\n    resp, err := http.Get(url)\n    if err != nil  {\n      return nil, err\n    }\n\n    defer resp.Body.Close()\n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n      return nil, err\n    }\n    return body, nil\n  })\n  if err != nil {\n    return nil, err\n  }\n  return body.([]byte),nil\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240102101219-45g17i4","Type":"NodeParagraph","Properties":{"id":"20240102101219-45g17i4","updated":"20240102101219"},"Children":[{"Type":"NodeText","Data":"总结如下："}]},{"ID":"20240102101219-x1iddlq","Type":"NodeParagraph","Properties":{"id":"20240102101219-x1iddlq","updated":"20240102101219"},"Children":[{"Type":"NodeText","Data":"默认是闭合状态，当失败次数超过阈值时，熔断器打开，此时应用不再提供服务，当超时器到达后，熔断器半打开，提供服务，当执行请求失败后，重新切换到打开状态，如果请求成功，并且达到成功次数阈值时，熔断器完全闭合，继续执行服务。您可以为你的关键服务提供断路器模式。可提高系统的稳定性和弹性，在系统从故障中恢复时提供稳定性，并将此故障对性能的影响降至最低。它可以通过快速拒绝对可能失败的操作的请求来帮助维护系统的响应时间，而不是等待操作超时（或永远不会返回）。如果断路器每次更改状态时都会引发事件，则此信息可用于监视受断路器保护的系统部分的运行状况，或在断路器跳闸到打开状态时提醒管理员。"}]}]}