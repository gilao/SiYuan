{"ID":"20231223221226-v58i2g1","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f981","id":"20231223221226-v58i2g1","title":"sync.Once 保证运行期间的某段代码之会执行一次","updated":"20231224114113"},"Children":[{"ID":"20231223221255-p3g1s6v","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231223221255-p3g1s6v","updated":"20231223221343"},"Children":[{"Type":"NodeText","Data":"出入门径"}]},{"ID":"20231223221403-l6qzf8c","Type":"NodeParagraph","Properties":{"id":"20231223221403-l6qzf8c","updated":"20231223221403"},"Children":[{"Type":"NodeText","Data":"sync.Once提供了保证某个操作只被执行一次的功能,其最常应用于单例模式之下,例如初始化系统配置、保持数据库唯一连接,以及并发访问只需要初始化一次的共享资源。"}]},{"ID":"20231223221403-hekdibs","Type":"NodeParagraph","Properties":{"id":"20231223221403-hekdibs","updated":"20231223221403"},"Children":[{"Type":"NodeText","Data":"单例模式有"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"懒汉模式"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"饿汉模式"},{"Type":"NodeText","Data":"两种"}]},{"ID":"20231223221403-ugn9kcj","Type":"NodeBlockquote","Properties":{"id":"20231223221403-ugn9kcj","updated":"20231223221403"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231223221403-lihtsf6","Type":"NodeParagraph","Properties":{"id":"20231223221403-lihtsf6","updated":"20231223221403"},"Children":[{"Type":"NodeText","Data":"饿汉模式 顾名思义就是比较饥饿，所以一上来(服务启动时)就初始化。\n懒汉模式 顾名思义就是偷懒，在获取实例的时候在进行初始化，但懒汉模式会有并发问题:有可能多个 goruntine 同时获取 对象都是 nil ，然后都开始创建了实例，就不满足单例模式了。解决办法是加锁"}]}]},{"ID":"20231223221403-tya2gr0","Type":"NodeParagraph","Properties":{"id":"20231223221403-tya2gr0","updated":"20231223221437"},"Children":[{"Type":"NodeText","Data":"sync.Once 就是懒汉模式"}]},{"ID":"20231223221437-i1nvzv3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231223221437-i1nvzv3","updated":"20231223221833"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar once sync.Once\n\tfunc1 := func() {\n\t\tfmt.Println(\"一只老虎\")\n\t}\n\tonce.Do(func1)\n\tfunc2 := func() {\n\t\tfmt.Println(\"两只老虎\")\n\t}\n\n\tonce.Do(func2)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231223221830-wbvw45a","Type":"NodeParagraph","Properties":{"id":"20231223221830-wbvw45a","updated":"20231223221838"},"Children":[{"Type":"NodeText","Data":"输出为："}]},{"ID":"20231223221838-pilgpog","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231223221838-pilgpog","updated":"20231223221842"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"一只老虎\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231223221844-j3aufdq","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231223221844-j3aufdq","updated":"20231223221854"},"Children":[{"Type":"NodeText","Data":"并发调用 Do()"}]},{"ID":"20231223221855-oskuhey","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231223221855-oskuhey","updated":"20231223222513"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar once sync.Once\n\tfor i := 0;i \u003c 5;i++ {\n\t\tgo func(i int) {\n\t\t\tfunc1 := func() {\n\t\t\t\tfmt.Printf(\"i:=%d\\n\",i)\n\t\t\t}\n\t\t\tonce.Do(func1)\n\t\t}(i)\n\t}\n\n\t// 为防止主goroutine 直接运行完，什么都看不到\n\ttime.Sleep(50 * time.Millisecond)\n}                                   \n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231223222548-mxf8r36","Type":"NodeParagraph","Properties":{"id":"20231223222548-mxf8r36","updated":"20231223222548"},"Children":[{"Type":"NodeText","Data":"在上面这段代码里,开启了5个并发的 goroutine ，不管执行多少次, 始终只打印一次.  至于 i 是多少,就看先执行的是哪个 g 了。"}]},{"ID":"20231223222548-e7ktu0w","Type":"NodeParagraph","Properties":{"id":"20231223222548-e7ktu0w","updated":"20231223223410"},"Children":[{"Type":"NodeText","Data":"Once 保证只有第一次调用 Do() 方法时, 传 递的 f (无参数无返回值的函数) 才会执行,并且之后不管调用的参数是否改变了,也不管f执行时是否发生了panic,之后都不再执行。"}]},{"ID":"20231223222548-g4bw05s","Type":"NodeParagraph","Properties":{"id":"20231223222548-g4bw05s","updated":"20231224002627"},"Children":[{"Type":"NodeText","Data":"这是官方Demo："}]},{"ID":"20231224002628-etvnvn3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231224002628-etvnvn3","updated":"20231224002635"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":" package main\n\n import (\n     \"fmt\"\n    \"sync\"\n )\n \n func main() {\n     var once sync.Once\n    onceBody := func() {\n        fmt.Println(\"Only once\")\n    }\n    done := make(chan bool)\n    for i := 0; i \u003c 10; i++ {\n        go func() {\n            once.Do(onceBody)\n            done \u003c- true\n        }()\n    }\n    for i := 0; i \u003c 10; i++ {\n        \u003c-done\n    }\n}\n// 结果只打印一次：only once\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231224002637-upuopd3","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231224002637-upuopd3","updated":"20231224002645"},"Children":[{"Type":"NodeText","Data":"源码实现"}]},{"ID":"20231224002646-jidttcn","Type":"NodeParagraph","Properties":{"id":"20231224002646-jidttcn","updated":"20231224002655"},"Children":[{"Type":"NodeText","Data":"其代码实现很简洁, 从头到尾加注释不超过 70 行. 对外暴露了一个唯一接口 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Do(f func())"},{"Type":"NodeText","Data":"​, 使用起来也很简单,可以多次调用,但是只有第一次调用Do方法时f参数才会执行,这里的f是一个无参数无返回值的函数。"}]},{"ID":"20231224002656-gqzjy7q","Type":"NodeParagraph","Properties":{"id":"20231224002656-gqzjy7q","updated":"20231224002706"},"Children":[{"Type":"NodeText","Data":"源码："}]},{"ID":"20231224002706-jvc8pmv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231224002706-jvc8pmv","updated":"20231224002707"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage sync\n\nimport (\n\t\"sync/atomic\"\n)\n\n// Once is an object that will perform exactly one action.\ntype Once struct {\n\t// done indicates whether the action has been performed.\n\t// It is first in the struct because it is used in the hot path.\n\t// The hot path is inlined at every call site.\n\t// Placing done first allows more compact instructions on some architectures (amd64/x86),\n\t// and fewer instructions (to calculate offset) on other architectures.\n\n    // done用来表示当前的操作是否已经被执行, 0表示还没有执行过, 1表示已经执行\n    // done属性放在结构体的第一位,是因为它在hot path中使用\n    // hot path在每个调用点会被内联\n    // 将done放在结构体首位,像amd64/386等架构上可以允许更多的压缩指令,且在其他架构上更少的指令去计算偏移量\n\tdone uint32\n\tm    Mutex\n}\n\n// Do calls the function f if and only if Do is being called for the\n// first time for this instance of Once. In other words, given\n// \tvar once Once\n// if once.Do(f) is called multiple times, only the first call will invoke f,\n// even if f has a different value in each invocation. A new instance of\n// Once is required for each function to execute.\n//\n// Do is intended for initialization that must be run exactly once. Since f\n// is niladic, it may be necessary to use a function literal to capture the\n// arguments to a function to be invoked by Do:\n// \tconfig.once.Do(func() { config.init(filename) })\n//\n// Because no call to Do returns until the one call to f returns, if f causes\n// Do to be called, it will deadlock.\n//\n// If f panics, Do considers it to have returned; future calls of Do return\n// without calling f.\n//\n\n// Do的作用主要是针对初始化且有且只能执行一次的场景。因为Do直到f返回才返回，`\n// 所以如果f内再调用Do则会导致死锁\n// 如果f执行过程中panic了 那么Do任务f已经执行完毕 未来再次调用不会再执行f\n\nfunc (o *Once) Do(f func()) {\n\t// Note: Here is an incorrect implementation of Do:\n\t//\n\t//\tif atomic.CompareAndSwapUint32(\u0026o.done, 0, 1) {\n\t//\t\tf()\n\t//\t}\n\t//\n\t// Do guarantees that when it returns, f has finished.\n\t// This implementation would not implement that guarantee:\n\t// given two simultaneous calls, the winner of the cas would\n\t// call f, and the second would return immediately, without\n\t// waiting for the first's call to f to complete.\n\t// This is why the slow path falls back to a mutex, and why\n\t// the atomic.StoreUint32 must be delayed until after f returns.\n\n\tif atomic.LoadUint32(\u0026o.done) == 0 {\n\t\t// Outlined slow-path to allow inlining of the fast-path.\n        // 原子获取 done 的值，判断 done 值是否为 0，如果为 0 就调用 doSlow 方法，进行二次检查。\n        // 可能会存在并发 进入slow-path\n\t\to.doSlow(f)\n\t}\n}\n\nfunc (o *Once) doSlow(f func()) {\n    // 二次检查时，持有互斥锁，保证只有一个 goroutine 执行。\n\to.m.Lock()\n\tdefer o.m.Unlock()\n\tif o.done == 0 { //二次判断f是否已经被执行\n         // 二次检查，如果 done 的值仍为 0，则认为是第一次执行，执行参数 f，并将 done 的值设置为 1。\n\n         //即使此时有多个 goroutine 同时进入了 doSlow 方法,因为双检查的机制,后续的 goroutine 会看到 o.done 的值为 1,也不会再次执行 f\n\t\tdefer atomic.StoreUint32(\u0026o.done, 1)\n\t\tf()\n\t}\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231224002801-77dymy6","Type":"NodeParagraph","Properties":{"id":"20231224002801-77dymy6","updated":"20231224002801"},"Children":[{"Type":"NodeText","Data":"Once 结构体中包含两个字段, 分别是 uint32 类型的 done 和 Mutex 类型的 m."}]},{"ID":"20231224002801-xw01uex","Type":"NodeParagraph","Properties":{"id":"20231224002801-xw01uex","updated":"20231224002801"},"Children":[{"Type":"NodeText","Data":"Once 实现了两个方法, 分别是 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Do"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"doSlow"},{"Type":"NodeText","Data":"。其中 doSlow 是一个非可导出方法,只能在内部被 Do 方法调用."}]},{"ID":"20231224002801-8gzzpw4","Type":"NodeParagraph","Properties":{"id":"20231224002801-8gzzpw4","updated":"20231224002801"},"Children":[{"Type":"NodeText","Data":"Done 方法先原子获取 done 的值,如果 done 的值为 0,则调用 doSlow 方法进行二次检查,二次检查时,持有互斥锁,保证只有一个 goroutine 执行操作.如果二次检查的结果为 0,则认为是第一次执行,程序执行函数类型的参数 f,然后将 done 的值设置为 1."}]},{"ID":"20231224002801-we7teyd","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231224002801-we7teyd","updated":"20231224002831"},"Children":[{"Type":"NodeText","Data":"注意事项"}]},{"ID":"20231224002832-6471v7p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231224002832-6471v7p","updated":"20231224112241"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\n\tpanicDo()\n\n\t//nestedDo()\n\tnestedDo2()\n\n}\n// 这段代码的逻辑是通过sync.Once确保某个代码块只执行一次。在函数中，首先创建了一个sync.Once类型的变量once。然后通过defer语句，在函数返回之前判断是否发生了panic，并调用once.Do()方法。在once.Do()方法中，会执行传入的匿名函数，并且只有第一次调用时生效。最后，通过once.Do()方法触发panic，并在recover时输出\"run in recover\"。  \n// 这段代码的逻辑是正确的，但是实际上并不会打印\"run in recover\"。原因是defer语句的作用域是在当前函数退出时才执行，而在这个函数中并没有发生函数退出的情况，只是触发了panic并进行了recover，所以once.Do()中的匿名函数并没有被执行。因此，这段代码不会有任何输出。\nfunc panicDo() {\n\tonce := \u0026sync.Once{}\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tonce.Do(func() {\n\t\t\t\tfmt.Println(\"run in recover\")\n\t\t\t})\n\t\t}\n\t}()\n\tonce.Do(func() {\n\t\tpanic(\"panic i=0\")\n\t})\n}\n\nfunc nestedDo() {\n\tonce := \u0026sync.Once{}\n\tonce.Do(func() {\n\t\tonce.Do(func() {\n\t\t\tfmt.Println(\"test nestedDo\")\n\t\t})\n\t})\n}\n\nfunc nestedDo2() {\n\tonce1 := \u0026sync.Once{}\n\tonce2 := \u0026sync.Once{}\n\tonce1.Do(func() {\n\t\tonce2.Do(func() {\n\t\t\tfmt.Println(\"test nestedDo\")\n\t\t})\n\t})\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231224003337-2wu5gfh","Type":"NodeParagraph","Properties":{"id":"20231224003337-2wu5gfh","updated":"20231224003338"}},{"ID":"20231224003338-aazoc7p","Type":"NodeParagraph","Properties":{"id":"20231224003338-aazoc7p","updated":"20231224003338"},"Children":[{"Type":"NodeText","Data":"(1). sync.Once()方法中传入的函数发生了panic，重复传入还会执行吗？"}]},{"ID":"20231224003338-04vj9em","Type":"NodeBlockquote","Properties":{"id":"20231224003338-04vj9em","updated":"20231224003338"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231224003338-uw5dan7","Type":"NodeParagraph","Properties":{"id":"20231224003338-uw5dan7","updated":"20231224003338"},"Children":[{"Type":"NodeText","Data":"执行panicDo方法,不会打印任何东西. sync.Once.Do 方法中传入的函数只会被执行一次,哪怕函数中发生了 panic；"}]}]},{"ID":"20231224003338-wyv7ope","Type":"NodeParagraph","Properties":{"id":"20231224003338-wyv7ope","updated":"20231224003338"},"Children":[{"Type":"NodeText","Data":"(2). sync.Once()方法传入的函数中再次调用sync.Once()方法会有什么问题吗？"}]},{"ID":"20231224003338-mb5m9fg","Type":"NodeBlockquote","Properties":{"id":"20231224003338-mb5m9fg","updated":"20231224003338"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231224003338-r9320mr","Type":"NodeParagraph","Properties":{"id":"20231224003338-r9320mr","updated":"20231224003338"},"Children":[{"Type":"NodeText","Data":"会发生死锁! 执行nestedDo方法,会报 fatal error: all goroutines are asleep - deadlock!  根据源码实现,可知在第二个do方法会一直等doshow()中锁的释放导致发生了死锁;"}]}]},{"ID":"20231224003338-6v2j7y6","Type":"NodeParagraph","Properties":{"id":"20231224003338-6v2j7y6","updated":"20231224003338"},"Children":[{"Type":"NodeText","Data":"(3). 执行nestedDo2,会输出什么?"}]},{"ID":"20231224003338-d13qh3v","Type":"NodeBlockquote","Properties":{"id":"20231224003338-d13qh3v","updated":"20231224003338"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231224003338-3zmd2wn","Type":"NodeParagraph","Properties":{"id":"20231224003338-3zmd2wn","updated":"20231224003338"},"Children":[{"Type":"NodeText","Data":"会打印出 test nestedDo. once1，once2是两个对象,互不影响. 所以sync.Once是使方法只执行一次对象的实现。"}]}]},{"ID":"20231224003338-ttiqof8","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231224003338-ttiqof8","updated":"20231224112315"},"Children":[{"Type":"NodeText","Data":"官方库或知名项目中的使用"}]},{"ID":"20231224112315-qwtlugr","Type":"NodeParagraph","Properties":{"id":"20231224112315-qwtlugr","updated":"20231224112547"},"Children":[{"Type":"NodeText","Data":"net 包， 系统的网络配置就是存放在一个变量里，用 sync.Once 控制读写"}]},{"ID":"20231224112548-phn2oxu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231224112548-phn2oxu","updated":"20231224112845"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"var (\n  confOnce sync.Once \n  confVal = \u0026conf{goos: runtime.GOOS}\n)\n// systemConf returns the machine's network configuration\nfunc systemConf() *conf {\n  confOnce.Do(initConfVal)\n  return confVal\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231224114113-lmthm2g","Type":"NodeParagraph","Properties":{"id":"20231224114113-lmthm2g","updated":"20231224114113"},"Children":[{"Type":"NodeText","Data":"当且仅当第一次读某个变量时，进行初始化（写操作）"}]},{"ID":"20231224114113-qksduk0","Type":"NodeParagraph","Properties":{"id":"20231224114113-qksduk0","updated":"20231224114113"},"Children":[{"Type":"NodeText","Data":"变量被初始化过程中，所有读都被阻塞（读操作；当变量初始化完成后，读操作继续进行"}]},{"ID":"20231224114113-mzl9f7z","Type":"NodeParagraph","Properties":{"id":"20231224114113-mzl9f7z","updated":"20231224114113"},"Children":[{"Type":"NodeText","Data":"变量仅初始化一次，初始化完成后驻留在内存里"}]}]}