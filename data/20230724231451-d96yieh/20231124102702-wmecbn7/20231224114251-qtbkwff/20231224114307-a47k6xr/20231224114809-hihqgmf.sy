{"ID":"20231224114809-hihqgmf","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231224114809-hihqgmf","title":"深入源码分析 golang 之 sync.Once ","updated":"20231225090614"},"Children":[{"ID":"20231224114829-7ulagd9","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231224114829-7ulagd9","updated":"20231224114845"},"Children":[{"Type":"NodeText","Data":"什么是 sync.Once"}]},{"ID":"20231224114845-d9y100f","Type":"NodeParagraph","Properties":{"id":"20231224114845-d9y100f","updated":"20231224115017"},"Children":[{"Type":"NodeText","Data":"官方文档对它的描述是：一个对象将完全执行一次，不得复制。常常用来单例对象的初始化场景，或者并发访问只需要初始化一次的共享资源。sync.Once只暴露了一个方法Do，可以多次调用，但是只有第一次调用Do方法时f参数才会执行，这里的f是一个无参数无返回值的函数。下面来看下官方给出来的demo："}]},{"ID":"20231224115018-xphs7rc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231224115018-xphs7rc","updated":"20231224121649"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func nestedDo3() {\n\tvar once sync.Once\n\tonceBody := func() {\n\t\tfmt.Println(\"Only once\")\n\t}\n\tdone := make(chan bool)\n\tfor i := 0; i \u003c 10; i++ {\n\t\tgo func() {\n\t\t\tonce.Do(onceBody)\n\t\t\tdone \u003c- true\n\t\t}()\n\t}\n\tfor i := 0; i \u003c 10; i++ {\n\t\t\u003c-done\n\t}\n}\n// 结果只打印一次： only once\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231224114809-1rpza15","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231224114809-1rpza15","updated":"20231224121658"},"Children":[{"Type":"NodeText","Data":"源码分析"}]},{"ID":"20231224121703-o8ojhzs","Type":"NodeParagraph","Properties":{"id":"20231224121703-o8ojhzs","updated":"20231224121740"},"Children":[{"Type":"NodeText","Data":"sync.Once 的源代码还很少的，直接在代码里面做分析"}]},{"ID":"20231224121740-lohzuqw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231224121740-lohzuqw","updated":"20231224125338"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package sync \n\nimport (\n  \"sync/atomic\"\n)\ntype Once struct {\n  done uint32 // 初始值为0表示还未执行过，1表示已经执行过\n  m Mutex // m 为互斥锁\n}\n\nfunc (o *Once) Do(f func()) {\n  // 判断done 是否为0，若为0，表示未执行过，调用doSlow 方法\n  if atomic.LoadUint32(\u0026o.done) == 0 {\n    o.doSlow(f)\n  }\n}\n\nfunc (o *Once) doSlow(f func()) {\n  // 互斥锁加锁解锁\n  o.m.Lock()\n  defer o.m.Unlock()\n  // 加锁判断done 是否为0\n  if o.done == 0 {\n    // 执行完f() 函数后，将done值设置为1\n    defer atomic.StoreUint32(\u0026o.done,1)\n    f()\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231224123449-gavqyy3","Type":"NodeParagraph","Properties":{"id":"20231224123449-gavqyy3","updated":"20231224125355"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Do方法流程图:"}]},{"ID":"20231224125402-lrlw07r","Type":"NodeParagraph","Properties":{"id":"20231224125402-lrlw07r","updated":"20231224125402"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231224125402-vtwb8vf.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231224125404-sxlv34o","Type":"NodeParagraph","Properties":{"id":"20231224125404-sxlv34o","updated":"20231224125445"}},{"ID":"20231224125445-7l8qgv2","Type":"NodeParagraph","Properties":{"id":"20231224125445-7l8qgv2","updated":"20231224125445"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"疑问1：为什么在do方法的时候没有用到cas原子判断？"}]},{"ID":"20231224125445-z8tb25n","Type":"NodeParagraph","Properties":{"id":"20231224125445-z8tb25n","updated":"20231224125603"},"Children":[{"Type":"NodeText","Data":"在do方法源码注释中的时候有这么一段话，说"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果是使用 atomic.CompareAndSwapUint32(\u0026amp;o.done, 0, 1）此方法不会保证实现f函数调用完成。"},{"Type":"NodeText","Data":"为什么会这么说，同时进行两次调用，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"cas的获胜者将调用f函数，失败者将立即返回，而无需等待第一个对f的调用完成。此时f函数还在执行过程中，你就已经回复了once.Do成功了，此时全局变量还没有创建出来，行为是无法定义的。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeText","Data":"那么怎么解决呢？有以下两个思路："}]},{"ID":"20231224125445-0mphsjl","Type":"NodeParagraph","Properties":{"id":"20231224125445-0mphsjl","updated":"20231224125644"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"text","TextMarkTextContent":"1）热路径：用原子读done的值，保证竞态条件正确；"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20231224125445-at9kze5","Type":"NodeParagraph","Properties":{"id":"20231224125445-at9kze5","updated":"20231224125653"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"text","TextMarkTextContent":"2）加锁：既然不能用cas原子操作，那就用加锁的方式来保证原子性，如果done==0，那么走慢路径，先加锁，然后在执行f函数，最后将done设置为1，并解锁。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20231224125445-peviio6","Type":"NodeParagraph","Properties":{"id":"20231224125445-peviio6","updated":"20231224125445"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"重点"},{"Type":"NodeTextMark","TextMarkType":"strong strong strong","TextMarkTextContent":"："},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"千万不要把同一sync.Once用在嵌套结构中，这样非常容易形成死锁！"}]},{"ID":"20231224125712-6xbzq0g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231224125712-6xbzq0g","updated":"20231225090053"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func once() {\n  once := \u0026sync.Once{}\n  once.Do(func() {\n    once.Do(func () {\n      fmt.Println(\"test nestedDo\")\n    })\n  })\n  // 输出： fatal error: all goroutines are sleep =deadlock!\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231225090057-w9b26u1","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231225090057-w9b26u1","updated":"20231225090113"},"Children":[{"Type":"NodeText","Data":"sync.Once 实现单例模式"}]},{"ID":"20231225090113-6s62g88","Type":"NodeParagraph","Properties":{"id":"20231225090113-6s62g88","updated":"20231225090154"},"Children":[{"Type":"NodeText","Data":"单例模式可以说是设计模式里面最简单的了，Go 可以借助sync.Once 来实现，代码如下："}]},{"ID":"20231225090154-mp68hig","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231225090154-mp68hig","updated":"20231225090614"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\nimport (\n  \"fmt\"\n  \"sync\"\n)\n\ntype Singleton struct{}\n\nvar (\n  singleton *Singleton\n  once sync.Once\n)\n\nfunc GetSingleton() *Singleton {\n  once.Do(func() {\n    fmt.Println(\"Create Obj\")\n    singleton = new(Singleton)\n  })\n  return singleton\n\nfunc main() {\n  var wg sync.WaitGroup\n  for i:=0;i\u003c5;i++ {\n    wg.Add(1)\n    go func() {\n      obj := GetSingleton()\n      fmt.Printf(\"%p\\n\",obj)\n      wg.Done()\n    }()\n  }\n  wg.Wait()\n  // 只打印一次 Create Obj\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}