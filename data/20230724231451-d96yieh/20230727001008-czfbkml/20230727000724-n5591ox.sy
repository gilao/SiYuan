{"ID":"20230727000724-n5591ox","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f984","id":"20230727000724-n5591ox","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230727000724-n5591ox\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230727000725-5sj4vzk\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230727000862-q9doizw\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230727000725-5sj4vzk\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","tags":"锁","title":"23. golang 读写锁的实现和核心原理分析","updated":"20230727000724"},"Children":[{"ID":"20230727000725-5sj4vzk","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230727000725-5sj4vzk","updated":"20230727000725"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"23. golang 读写锁的实现和核心原理分析"}]},{"ID":"20230727000726-lin6d0p","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000726-lin6d0p","updated":"20230727000726"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"一、锁的基本知识"}]},{"ID":"20230727000727-s3xa6wj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000727-s3xa6wj","updated":"20230727000727"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"1. 互斥量/互斥锁"}]},{"ID":"20230727000728-6q6j5zt","Type":"NodeParagraph","Properties":{"id":"20230727000728-6q6j5zt","updated":"20230727000728"},"Children":[{"Type":"NodeText","Data":"互斥量（Mutex）， 又称为互斥锁， 是一种用来保护临界区的特殊变量， 它可以处于锁定（locked） 状态， 也可以处于解锁（unlocked） 状态。"}]},{"ID":"20230727000729-r51iy1q","Type":"NodeParagraph","Properties":{"id":"20230727000729-r51iy1q","updated":"20230727000729"},"Children":[{"Type":"NodeText","Data":"在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"每个对象都对应于一个可称为\u0026quot; 互斥锁\u0026quot; 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。"}]},{"ID":"20230727000730-h1g4p19","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000730-h1g4p19","updated":"20230727000730"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2. CAS (compare and swap)"}]},{"ID":"20230727000731-dwgox1t","Type":"NodeParagraph","Properties":{"id":"20230727000731-dwgox1t","updated":"20230727000731"},"Children":[{"Type":"NodeText","Data":"解决多线程并行情况下使用锁造成性能损耗的一种机制，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)"},{"Type":"NodeText","Data":"。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。\""}]},{"ID":"20230727000732-vb3ktgh","Type":"NodeParagraph","Properties":{"id":"20230727000732-vb3ktgh","updated":"20230727000732"},"Children":[{"Type":"NodeText","Data":"CAS机制执行流程："}]},{"ID":"20230727000733-uwhdlcp","Type":"NodeParagraph","Properties":{"id":"20230727000733-uwhdlcp","updated":"20230727000733"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\webp.webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000734-1wp78vg","Type":"NodeParagraph","Properties":{"id":"20230727000734-1wp78vg","updated":"20230727000734"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CAS存在的问题"},{"Type":"NodeText","Data":"："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1. ABA问题"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化就更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了 —\u003e 这就是所谓的ABA问题。"}]},{"ID":"20230727000735-vh0erqj","Type":"NodeParagraph","Properties":{"id":"20230727000735-vh0erqj","updated":"20230727000735"},"Children":[{"Type":"NodeText","Data":"ABA问题的解决思路其实也很简单，就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A了。"}]},{"ID":"20230727000736-z2kl5uz","Type":"NodeParagraph","Properties":{"id":"20230727000736-z2kl5uz","updated":"20230727000736"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2. 循环时间长开销大"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销"}]},{"ID":"20230727000737-hppmoje","Type":"NodeParagraph","Properties":{"id":"20230727000737-hppmoje","updated":"20230727000737"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3. 只能保证一个共享变量的原子操作"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。"}]},{"ID":"20230727000738-3cspp38","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000738-3cspp38","updated":"20230727000738"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3. 自旋锁"}]},{"ID":"20230727000739-d1vvvx9","Type":"NodeParagraph","Properties":{"id":"20230727000739-d1vvvx9","updated":"20230727000739"},"Children":[{"Type":"NodeText","Data":"自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。"},{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeText","Data":"无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，"},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁"},{"Type":"NodeMark2CloseMarker","Data":"=="}]},{"Type":"NodeText","Data":"，\"自旋\"一词就是因此而得名。"},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]}]},{"ID":"20230727000740-6goxf7j","Type":"NodeParagraph","Properties":{"id":"20230727000740-6goxf7j","updated":"20230727000740"},"Children":[{"Type":"NodeText","Data":"自旋锁可能存在的2个问题："}]},{"ID":"20230727000741-jfszxyf","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20230727000741-jfszxyf","updated":"20230727000741"},"Children":[{"ID":"20230727000742-heejlqy","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20230727000742-heejlqy","updated":"20230727000742"},"Children":[{"ID":"20230727000743-k50cymg","Type":"NodeParagraph","Properties":{"id":"20230727000743-k50cymg","updated":"20230727000743"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"试图递归地获得自旋锁必然会引起死锁"},{"Type":"NodeText","Data":"：递归程序的持有实例在第二个实例循环，以试图获得相同自旋锁时，不会释放此自旋锁。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"在递归程序中使用自旋锁应遵守下列策略：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。"}]}]},{"ID":"20230727000744-4lo6dsh","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20230727000744-4lo6dsh","updated":"20230727000744"},"Children":[{"ID":"20230727000745-yyunl6n","Type":"NodeParagraph","Properties":{"id":"20230727000745-yyunl6n","updated":"20230727000745"},"Children":[{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeText","Data":"过多占用cpu资源。"},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]},{"Type":"NodeText","Data":"如果不加限制，由于申请者一直在循环等待，因此自旋锁在锁定的时候,如果不成功,不会睡眠,会持续的尝试,单cpu的时候自旋锁会让其它process动不了. 因此，一般自旋锁实现会有一个参数限定最多持续尝试次数. 超出后, 自旋锁放弃当前time slice. 等下一次机会。"}]}]}]},{"ID":"20230727000746-7hw2al7","Type":"NodeParagraph","Properties":{"id":"20230727000746-7hw2al7","updated":"20230727000746"},"Children":[{"Type":"NodeText","Data":"由此可见，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"自旋锁比较适用于锁使用者保持锁时间比较短的情况"},{"Type":"NodeText","Data":"。正是由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。"}]},{"ID":"20230727000747-29azjs4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000747-29azjs4","updated":"20230727000747"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4. 读写锁"}]},{"ID":"20230727000748-lwt5h30","Type":"NodeParagraph","Properties":{"id":"20230727000748-lwt5h30","updated":"20230727000748"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。"}]},{"ID":"20230727000749-zn6qy9e","Type":"NodeParagraph","Properties":{"id":"20230727000749-zn6qy9e","updated":"20230727000749"},"Children":[{"Type":"NodeText","Data":"这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。"}]},{"ID":"20230727000750-n97b87t","Type":"NodeParagraph","Properties":{"id":"20230727000750-n97b87t","updated":"20230727000750"},"Children":[{"Type":"NodeText","Data":"在读写锁保持期间也是抢占失效的。"}]},{"ID":"20230727000751-cv7xwsq","Type":"NodeParagraph","Properties":{"id":"20230727000751-cv7xwsq","updated":"20230727000751"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。"}]},{"ID":"20230727000752-zt00ww0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000752-zt00ww0","updated":"20230727000752"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"5. 乐观锁 \u0026 悲观锁"}]},{"ID":"20230727000753-wi25jin","Type":"NodeParagraph","Properties":{"id":"20230727000753-wi25jin","updated":"20230727000753"},"Children":[{"Type":"NodeText","Data":"乐观锁其实主要就是一种思想，因为乐观锁的操作过程中其实没有没有任何锁的参与，乐观锁只是和悲观锁相对，严格的说乐观锁不能称之为锁。"}]},{"ID":"20230727000754-enyo41s","Type":"NodeParagraph","Properties":{"id":"20230727000754-enyo41s","updated":"20230727000754"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"悲观锁"},{"Type":"NodeText","Data":"：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞，直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"乐观锁"},{"Type":"NodeText","Data":"：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，只在更新的时候会判断一下在此期间别人有没有去更新这个数据。"}]},{"ID":"20230727000755-6j7393c","Type":"NodeParagraph","Properties":{"id":"20230727000755-6j7393c","updated":"20230727000755"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"乐观锁适用于写比较少的情况下（多读场景）"},{"Type":"NodeText","Data":"，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能"},{"Type":"NodeText","Data":"，所以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一般多写的场景下用悲观锁就比较合适。"}]},{"ID":"20230727000756-jmyh5l6","Type":"NodeParagraph","Properties":{"id":"20230727000756-jmyh5l6","updated":"20230727000756"},"Children":[{"Type":"NodeText","Data":"乐观锁常见的两种实现方式："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1. 版本号机制"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"CAS机制保证了在更新数据的时候没有被修改为其他数据的同步机制，版本机制就保证了没有被修改过的同步机制"}]},{"ID":"20230727000757-s1nvl3h","Type":"NodeParagraph","Properties":{"id":"20230727000757-s1nvl3h","updated":"20230727000757"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2. CAS机制"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败。"}]},{"ID":"20230727000758-i8ifg70","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000758-i8ifg70","updated":"20230727000758"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"6. 死锁"}]},{"ID":"20230727000759-x1nmg4m","Type":"NodeParagraph","Properties":{"id":"20230727000759-x1nmg4m","updated":"20230727000759"},"Children":[{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeText","Data":"死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。"},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]},{"Type":"NodeText","Data":"此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。"}]},{"ID":"20230727000760-y6gt2dn","Type":"NodeParagraph","Properties":{"id":"20230727000760-y6gt2dn","updated":"20230727000760"},"Children":[{"Type":"NodeText","Data":"虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"死锁的发生必须具备以下四个必要条件"},{"Type":"NodeText","Data":"："}]},{"ID":"20230727000761-l0r23qe","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000761-l0r23qe","updated":"20230727000761"},"Children":[{"ID":"20230727000762-0ff82mr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000762-0ff82mr","updated":"20230727000762"},"Children":[{"ID":"20230727000763-n0oasgz","Type":"NodeParagraph","Properties":{"id":"20230727000763-n0oasgz","updated":"20230727000763"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"互斥条件"},{"Type":"NodeText","Data":"：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。"}]}]},{"ID":"20230727000764-tn1xv68","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000764-tn1xv68","updated":"20230727000764"},"Children":[{"ID":"20230727000765-qx15ttg","Type":"NodeParagraph","Properties":{"id":"20230727000765-qx15ttg","updated":"20230727000765"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"请求和保持条件"},{"Type":"NodeText","Data":"：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。"}]}]},{"ID":"20230727000766-bvd3e5i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000766-bvd3e5i","updated":"20230727000766"},"Children":[{"ID":"20230727000767-hy1bjx9","Type":"NodeParagraph","Properties":{"id":"20230727000767-hy1bjx9","updated":"20230727000767"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不剥夺条件"},{"Type":"NodeText","Data":"：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。"}]}]},{"ID":"20230727000768-p1fcctb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000768-p1fcctb","updated":"20230727000768"},"Children":[{"ID":"20230727000769-b29uyyl","Type":"NodeParagraph","Properties":{"id":"20230727000769-b29uyyl","updated":"20230727000769"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"环路等待条件"},{"Type":"NodeText","Data":"：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。"}]}]}]},{"ID":"20230727000770-6moiyzm","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230727000770-6moiyzm","updated":"20230727000770"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"二、go中锁机制"}]},{"ID":"20230727000771-ryiqwbk","Type":"NodeParagraph","Properties":{"id":"20230727000771-ryiqwbk","updated":"20230727000771"},"Children":[{"Type":"NodeText","Data":"在 Golang 里有专门的方法来实现锁，就是 sync 包，这个包有两个很重要的锁类型。一个叫 Mutex， 利用它可以实现互斥锁。一个叫 RWMutex，利用它可以实现读写锁。"}]},{"ID":"20230727000772-n61ibiy","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000772-n61ibiy","updated":"20230727000772"},"Children":[{"ID":"20230727000773-02e7qe4","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000773-02e7qe4","updated":"20230727000773"},"Children":[{"ID":"20230727000774-0z0xp0f","Type":"NodeParagraph","Properties":{"id":"20230727000774-0z0xp0f","updated":"20230727000774"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.Mutex"},{"Type":"NodeText","Data":" 的锁只有一种锁："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock()"},{"Type":"NodeText","Data":"，它是互斥锁，同一时间只能有一个锁。"}]}]},{"ID":"20230727000775-fzotfq0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000775-fzotfq0","updated":"20230727000775"},"Children":[{"ID":"20230727000776-uo941ti","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000776-uo941ti","updated":"20230727000776"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"sync.RWMutex\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000777-xyjmw0v","Type":"NodeParagraph","Properties":{"id":"20230727000777-xyjmw0v","updated":"20230727000777"},"Children":[{"Type":"NodeText","Data":"叫读写锁，它有两种锁："}]},{"ID":"20230727000778-t3cf00b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000778-t3cf00b","updated":"20230727000778"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"RLock()\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000779-glo2dfj","Type":"NodeParagraph","Properties":{"id":"20230727000779-glo2dfj","updated":"20230727000779"},"Children":[{"Type":"NodeText","Data":"和"}]},{"ID":"20230727000780-957pxlh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000780-957pxlh","updated":"20230727000780"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Lock()\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000781-n98n1z1","Type":"NodeParagraph","Properties":{"id":"20230727000781-n98n1z1","updated":"20230727000781"},"Children":[{"Type":"NodeText","Data":"："}]},{"ID":"20230727000782-o280okt","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000782-o280okt","updated":"20230727000782"},"Children":[{"ID":"20230727000783-vucj58u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000783-vucj58u","updated":"20230727000783"},"Children":[{"ID":"20230727000784-lyw7mrl","Type":"NodeParagraph","Properties":{"id":"20230727000784-lyw7mrl","updated":"20230727000784"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RLock()"},{"Type":"NodeText","Data":" 叫读锁。它不是绝对锁，可以有多个读者同时获取此锁（调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"mu.RLock"},{"Type":"NodeText","Data":"）。"}]}]},{"ID":"20230727000785-9juxtjl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000785-9juxtjl","updated":"20230727000785"},"Children":[{"ID":"20230727000786-mvmced2","Type":"NodeParagraph","Properties":{"id":"20230727000786-mvmced2","updated":"20230727000786"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock()"},{"Type":"NodeText","Data":" 叫写锁，它是个绝对锁，就是说，如果一旦某人拿到了这个锁，别人就不能再获取此锁了。"}]}]}]}]}]},{"ID":"20230727000787-l6mu24m","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000787-l6mu24m","updated":"20230727000787"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"1. "},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"Mutex-互斥锁"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000788-k9frncx","Type":"NodeParagraph","Properties":{"id":"20230727000788-k9frncx","updated":"20230727000788"},"Children":[{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"Mutex 的实现主要借助了 CAS 指令 + 自旋 + 信号量"},{"Type":"NodeMark2CloseMarker","Data":"=="}]},{"Type":"NodeText","Data":"数据结构："}]},{"ID":"20230727000789-6gt4vmt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000789-6gt4vmt","updated":"20230727000789"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"type Mutex struct {\n    state int32\n    sema  uint32\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000790-tru41qo","Type":"NodeParagraph","Properties":{"id":"20230727000790-tru41qo","updated":"20230727000790"},"Children":[{"Type":"NodeText","Data":"上述两个加起来只占 8 字节空间的结构体表示了 Go语言中的互斥锁"}]},{"ID":"20230727000791-f0vvqk7","Type":"NodeParagraph","Properties":{"id":"20230727000791-f0vvqk7","updated":"20230727000791"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"状态"},{"Type":"NodeText","Data":"："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"在默认情况下，互斥锁的所有状态位都是 0，int32 中的不同位分别表示了不同的状态："}]},{"ID":"20230727000792-i9u7zdl","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000792-i9u7zdl","updated":"20230727000792"},"Children":[{"ID":"20230727000793-ax89sj2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000793-ax89sj2","updated":"20230727000793"},"Children":[{"ID":"20230727000794-68dx9ur","Type":"NodeParagraph","Properties":{"id":"20230727000794-68dx9ur","updated":"20230727000794"},"Children":[{"Type":"NodeText","Data":"1位表示是否被锁定"}]}]},{"ID":"20230727000795-04h7ogo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000795-04h7ogo","updated":"20230727000795"},"Children":[{"ID":"20230727000796-45n2q9p","Type":"NodeParagraph","Properties":{"id":"20230727000796-45n2q9p","updated":"20230727000796"},"Children":[{"Type":"NodeText","Data":"1位表示是否有协程已经被唤醒"}]}]},{"ID":"20230727000797-c8b6zhx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000797-c8b6zhx","updated":"20230727000797"},"Children":[{"ID":"20230727000798-rpe4q5g","Type":"NodeParagraph","Properties":{"id":"20230727000798-rpe4q5g","updated":"20230727000798"},"Children":[{"Type":"NodeText","Data":"1位表示是否处于饥饿状态"}]}]},{"ID":"20230727000799-4fkjmse","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000799-4fkjmse","updated":"20230727000799"},"Children":[{"ID":"20230727000800-onegqy8","Type":"NodeParagraph","Properties":{"id":"20230727000800-onegqy8","updated":"20230727000800"},"Children":[{"Type":"NodeText","Data":"剩下29位表示阻塞的协程数"}]}]}]},{"ID":"20230727000801-k2qovys","Type":"NodeParagraph","Properties":{"id":"20230727000801-k2qovys","updated":"20230727000801"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"正常模式和饥饿模式"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"正常模式"},{"Type":"NodeText","Data":"：正常模式下waiter都是先入先出，在队列中等待的waiter被唤醒后不会直接获取锁，因为要和新来的goroutine 进行竞争，新来的goroutine相对于被唤醒的waiter是具有优势的，新的goroutine 正在cpu上运行，被唤醒的waiter还要进行调度才能进入状态，所以在并发的情况下waiter大概率抢不过新来的goroutine，这个时候waiter会被放到队列的头部，如果等待的时间超过了1ms，这个时候Mutex就会进入饥饿模式。"}]},{"ID":"20230727000802-6a7o3pn","Type":"NodeParagraph","Properties":{"id":"20230727000802-6a7o3pn","updated":"20230727000802"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"饥饿模式"},{"Type":"NodeText","Data":"：当Mutex进入饥饿模式之后，锁的所有权会从解锁的goroutine移交给队列头部的goroutine，这几个时候新来的goroutine会直接放入队列的尾部，这样很好的解决了老的goroutine一直抢不到锁的场景。"}]},{"ID":"20230727000803-8ycpyx8","Type":"NodeParagraph","Properties":{"id":"20230727000803-8ycpyx8","updated":"20230727000803"},"Children":[{"Type":"NodeText","Data":"对于两种模式，正常模式下的性能是最好的，goroutine可以连续多次获取锁，饥饿模式解决了取锁公平的问题，但是性能会下降，其实是性能和公平的一个平衡模式。所以在lock的源码里面，当队列只剩本省goroutine一个并且等待时间没有超过1ms，这个时候Mutex会重新恢复到正常模式。"}]},{"ID":"20230727000804-afefasx","Type":"NodeParagraph","Properties":{"id":"20230727000804-afefasx","updated":"20230727000804"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Lock函数"}]},{"ID":"20230727000805-wyddt8b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000805-wyddt8b","updated":"20230727000805"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 加锁\n// 如果锁已经被使用，调用goroutine阻塞，直到锁可用\nfunc (m *Mutex) Lock() {\n    // 快速路径：没有竞争直接获取到锁，修改状态位为加锁\n    if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) {\n        // 开启-race之后会进行判断，正常情况可忽略\n        if race.Enabled {\n            race.Acquire(unsafe.Pointer(m))\n        }\n        return\n    }\n    // 慢路径（以便快速路径可以内联）\n    m.lockSlow()\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000806-q9acnk2","Type":"NodeParagraph","Properties":{"id":"20230727000806-q9acnk2","updated":"20230727000806"},"Children":[{"Type":"NodeText","Data":"来看看Lock函数，分为两个部分， 快速路径，先通过CAS尝试直接获取锁，如果能获取到直接返回，否则进入慢路径的方法，这里的代码注释提到了内联"}]},{"ID":"20230727000807-l1tsfmv","Type":"NodeBlockquote","Properties":{"id":"20230727000807-l1tsfmv","updated":"20230727000807"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230727000808-oj6wm8g","Type":"NodeParagraph","Properties":{"id":"20230727000808-oj6wm8g","updated":"20230727000808"},"Children":[{"Type":"NodeText","Data":"tips：方法内联"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"简单的说方法内联就是将被调用方函数代码“复制”到调用方函数中，减少函数调用开销，在2018年之前的go版本中，所有的逻辑都在Lock函数中，并没有拆出来，2018年之后Go开发者将slow path拆出来，当lock方法被频繁调用的时候，有两种情况，如果直接获得锁走的是fast path，这个时候内联就只有fast path 的代码，这样会减少方法调用的堆栈空间和时间的消耗 ，如果处于自旋，锁竞争的情况下，走的是slow path，这个时候才会把lock slow 的方法内联进来，这样方便了编译器做内联。"}]}]},{"ID":"20230727000809-li1qgjk","Type":"NodeParagraph","Properties":{"id":"20230727000809-li1qgjk","updated":"20230727000809"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"lockSlow 函数"}]},{"ID":"20230727000810-re61cpw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000810-re61cpw","updated":"20230727000810"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func (m *Mutex) lockSlow() {\n    var waitStartTime int64 //记录请求锁的初始时间\n    starving := false //饥饿标记\n    awoke := false //唤醒标记\n    iter := 0 //自旋次数\n    old := m.state  //当前锁的状态\n    for {\n        //锁处于正常模式还没有释放的时候，尝试自旋\n        if old\u0026(mutexLocked|mutexStarving) == mutexLocked \u0026\u0026 runtime_canSpin(iter) {        \n            //在临界区耗时很短的情况下提高性能\n            if !awoke \u0026\u0026 old\u0026mutexWoken == 0 \u0026\u0026 old\u003e\u003emutexWaiterShift != 0 \n            \u0026\u0026 atomic.CompareAndSwapInt32(\u0026m.state, old, old|mutexWoken) {\n                awoke = true\n            }\n            runtime_doSpin()\n            iter++\n            //更新锁的状态\n            old = m.state\n            continue\n        }\n        new := old\n        // 非饥饿状态进行加锁\n        if old\u0026mutexStarving == 0 {\n            new |= mutexLocked\n        }\n        // 等待着数量+1\n        if old\u0026(mutexLocked|mutexStarving) != 0 {\n            new += 1 \u003c\u003c mutexWaiterShift\n        }\n        \n        // 加锁的情况下切换为饥饿模式\n        if starving \u0026\u0026 old\u0026mutexLocked != 0 {\n            new |= mutexStarving\n        }\n        //goroutine 唤醒的时候进行重置标志\n        if awoke {\n            if new\u0026mutexWoken == 0 {\n                throw(\"sync: inconsistent mutex state\")\n            }\n            new \u0026^= mutexWoken\n        }\n                \n        // 设置新的状态\n        if atomic.CompareAndSwapInt32(\u0026m.state, old, new) {\n            if old\u0026(mutexLocked|mutexStarving) == 0 {\n                break \n            }\n            // 判断是不是第一次加入队列\n            // 如果之前就在队列里面等待了，加入到队头\n            queueLifo := waitStartTime != 0\n            if waitStartTime == 0 {\n                waitStartTime = runtime_nanotime()\n            }\n            // 阻塞等待\n            runtime_SemacquireMutex(\u0026m.sema, queueLifo, 1)\n            // 检查锁是否处于饥饿状态\n            starving = starving || runtime_nanotime()-waitStartTime \u003e starvationThresholdNs\n            old = m.state\n            // 如果锁处于饥饿状态，直接抢到锁\n            if old\u0026mutexStarving != 0 {\n            \n                if old\u0026(mutexLocked|mutexWoken) != 0 || old\u003e\u003emutexWaiterShift == 0 {\n                    throw(\"sync: inconsistent mutex state\")\n                }\n                // 设置标志，进行加锁并且waiter-1\n                delta := int32(mutexLocked - 1\u003c\u003cmutexWaiterShift)\n                // 如果是最后一个的话清除饥饿标志\n                if !starving || old\u003e\u003emutexWaiterShift == 1 {\n                    // 退出饥饿模式               \n                    delta -= mutexStarving\n                }\n                atomic.AddInt32(\u0026m.state, delta)\n                break\n            }\n            awoke = true\n            iter = 0\n        } else {\n            old = m.state\n        }\n    }\n    // -race开启检测冲突，可以忽略\n    if race.Enabled {\n        race.Acquire(unsafe.Pointer(m))\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000811-zm8cyex","Type":"NodeParagraph","Properties":{"id":"20230727000811-zm8cyex","updated":"20230727000811"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Unlock函数"}]},{"ID":"20230727000812-qwzxg6t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000812-qwzxg6t","updated":"20230727000812"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//如果对没有lock 的Mutex进行unlock会报错\n//unlock和goroutine是没有绑定的，对于一个Mutex，可以一个goroutine加锁，另一个goroutine进行解锁\nfunc (m *Mutex) Unlock() {\n    if race.Enabled {\n        _ = m.state\n        race.Release(unsafe.Pointer(m))\n    }\n\n    // 快速之路，直接解锁，去除加锁位的标记\n    new := atomic.AddInt32(\u0026m.state, -mutexLocked)\n    if new != 0 {\n        // 解锁失败进入慢路径\n        //同样的对慢路径做了单独封装，便于内联\n        m.unlockSlow(new)\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000813-tv34lyp","Type":"NodeParagraph","Properties":{"id":"20230727000813-tv34lyp","updated":"20230727000813"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"unlockSlow函数"}]},{"ID":"20230727000814-i00wpmg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000814-i00wpmg","updated":"20230727000814"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func (m *Mutex) unlockSlow(new int32) {\n    //解锁一个未加锁的Mutex会报错（可以想想为什么，Mutex使用状态位进行标记锁的状态的）\n    if (new+mutexLocked)\u0026mutexLocked == 0 {\n        throw(\"sync: unlock of unlocked mutex\")\n    }\n    if new\u0026mutexStarving == 0 {\n        old := new\n        for {\n            //正常模式下，没有waiter或者在处理事情的情况下直接返回\n            if old\u003e\u003emutexWaiterShift == 0 || old\u0026(mutexLocked|mutexWoken|mutexStarving) != 0 {\n                return\n            }\n            //如果有等待者，设置mutexWoken标志，waiter-1，更新state\n            new = (old - 1\u003c\u003cmutexWaiterShift) | mutexWoken\n            if atomic.CompareAndSwapInt32(\u0026m.state, old, new) {\n                runtime_Semrelease(\u0026m.sema, false, 1)\n                return\n            }\n            old = m.state\n        }\n    } else {\n        // 饥饿模式下会直接将mutex交给下一个等待的waiter，让出时间片，以便waiter执行\n        runtime_Semrelease(\u0026m.sema, true, 1)\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000815-7e4alqu","Type":"NodeParagraph","Properties":{"id":"20230727000815-7e4alqu","updated":"20230727000815"},"Children":[{"Type":"NodeText","Data":"同样的，在unlock也有fastpath和slowpath，fastpath尝试解锁，解锁成功就返回，否则进入slowpath，slowpath分为正常模式的处理和饥饿模式的处理，饥饿模式直接将锁的控制权交给队列中等待的waiter，正常模式分两种情况 如果当前没有waiter，只有自己本身，直接解锁返回，如果有waiter，解锁后唤醒下个等待者。"}]},{"ID":"20230727000816-56ottnm","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000816-56ottnm","updated":"20230727000816"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2. RWMutex-读写锁"}]},{"ID":"20230727000817-0xsnzkd","Type":"NodeParagraph","Properties":{"id":"20230727000817-0xsnzkd","updated":"20230727000817"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RWMutex"},{"Type":"NodeText","Data":" 是一个读/写互斥锁，在某一时刻只能由任意数量的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"reader"},{"Type":"NodeText","Data":" 持有 或者 一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"writer"},{"Type":"NodeText","Data":" 持有。也就是说，要么放行任意数量的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"reader"},{"Type":"NodeText","Data":"，多个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"reader"},{"Type":"NodeText","Data":" 可以并行读；要么放行一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"writer"},{"Type":"NodeText","Data":"，多个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"writer"},{"Type":"NodeText","Data":" 需要串行写。"}]},{"ID":"20230727000818-mfsac1l","Type":"NodeParagraph","Properties":{"id":"20230727000818-mfsac1l","updated":"20230727000818"},"Children":[{"Type":"NodeText","Data":"RWMutex 对外暴露的方法有五个："}]},{"ID":"20230727000819-ifqwll3","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000819-ifqwll3","updated":"20230727000819"},"Children":[{"ID":"20230727000820-vtzqg63","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000820-vtzqg63","updated":"20230727000820"},"Children":[{"ID":"20230727000821-40m1u61","Type":"NodeParagraph","Properties":{"id":"20230727000821-40m1u61","updated":"20230727000821"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RLock()"},{"Type":"NodeText","Data":"：读操作获取锁，如果锁已经被 writer 占用，会一直阻塞直到 writer 释放锁；否则直接获得锁；"}]}]},{"ID":"20230727000822-1yufvd3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000822-1yufvd3","updated":"20230727000822"},"Children":[{"ID":"20230727000823-c988cyh","Type":"NodeParagraph","Properties":{"id":"20230727000823-c988cyh","updated":"20230727000823"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RUnlock()"},{"Type":"NodeText","Data":"：读操作完毕之后释放锁；"}]}]},{"ID":"20230727000824-5wp6xto","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000824-5wp6xto","updated":"20230727000824"},"Children":[{"ID":"20230727000825-5b26dx9","Type":"NodeParagraph","Properties":{"id":"20230727000825-5b26dx9","updated":"20230727000825"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock()"},{"Type":"NodeText","Data":"：写操作获取锁，如果锁已经被 reader 或者 writer 占用，会一直阻塞直到获取到锁；否则直接获得锁；"}]}]},{"ID":"20230727000826-67oxh0s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000826-67oxh0s","updated":"20230727000826"},"Children":[{"ID":"20230727000827-zdk4w22","Type":"NodeParagraph","Properties":{"id":"20230727000827-zdk4w22","updated":"20230727000827"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unlock()"},{"Type":"NodeText","Data":"：写操作完毕之后释放锁；"}]}]},{"ID":"20230727000828-56xthtx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000828-56xthtx","updated":"20230727000828"},"Children":[{"ID":"20230727000829-dhmlq00","Type":"NodeParagraph","Properties":{"id":"20230727000829-dhmlq00","updated":"20230727000829"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RLocker()"},{"Type":"NodeText","Data":"：返回读操作的 Locker 对象，该对象的 Lock() 方法对应 RWMutex 的 - "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RLock()"},{"Type":"NodeText","Data":"，Unlock() 方法对应 RWMutex 的 RUnlock() 方法。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"一旦涉及到多个 reader 和 writer ，就需要考虑优先级问题，是 reader 优先还是 writer 优先。"}]}]}]},{"ID":"20230727000830-62koxvz","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230727000830-62koxvz","updated":"20230727000830"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.1 RWMutex流程概览"}]},{"ID":"20230727000831-x5ypn1p","Type":"NodeParagraph","Properties":{"id":"20230727000831-x5ypn1p","updated":"20230727000831"},"Children":[{"Type":"NodeText","Data":"可以想象 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RWMutex"},{"Type":"NodeText","Data":" 有两个队伍，一个是包含 所有reader 和你获得准入权writer 的 队列A，一个是还没有获得准入权 writer 的 队列B。"}]},{"ID":"20230727000832-bqjm5hp","Type":"NodeParagraph","Properties":{"id":"20230727000832-bqjm5hp","updated":"20230727000832"},"Children":[{"Type":"NodeText","Data":"队列 A 最多只允许有 一个writer，如果有其他 writer，需要在 队列B 等待；"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"当一个 writer 到了 队列A 后，只允许它 之前的reader 执行读操作，新来的 reader 需要在 队列A 后面排队；"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"当前面的 reader 执行完读操作之后，writer 执行写操作；"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"writer 执行完写操作后，让 后面的reader 执行读操作，再唤醒队列B 的一个 writer 到 队列A 后面排队。"}]},{"ID":"20230727000833-8htpnmr","Type":"NodeParagraph","Properties":{"id":"20230727000833-8htpnmr","updated":"20230727000833"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"初始时刻"},{"Type":"NodeText","Data":" 队列A 中 writer W1 前面有三个 reader，后面有两个 reader，队列B中有两个 writer"}]},{"ID":"20230727000834-gtrpi8b","Type":"NodeParagraph","Properties":{"id":"20230727000834-gtrpi8b","updated":"20230727000834"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https:////upload-images.jianshu.io/upload_images/16581067-108204c8ddeb687c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000835-o0avhzj","Type":"NodeParagraph","Properties":{"id":"20230727000835-o0avhzj","updated":"20230727000835"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并发读"},{"Type":"NodeText","Data":" 多个 reader 可以同时获取到读锁，进入临界区进行读操作；writer W1 在 队列A 中等待，同时又来了两个 reader，直接在 队列A 后面排队"}]},{"ID":"20230727000836-8pglkuw","Type":"NodeParagraph","Properties":{"id":"20230727000836-8pglkuw","updated":"20230727000836"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https:////upload-images.jianshu.io/upload_images/16581067-9e007ccf145e7f6e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000837-5qch971","Type":"NodeParagraph","Properties":{"id":"20230727000837-5qch971","updated":"20230727000837"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"写操作"},{"Type":"NodeText","Data":" W1 前面所有的 reader 完成后，W1 获得锁，进入临界区操作"}]},{"ID":"20230727000838-ii722ie","Type":"NodeParagraph","Properties":{"id":"20230727000838-ii722ie","updated":"20230727000838"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https:////upload-images.jianshu.io/upload_images/16581067-04e9ad64e0186f5b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000839-vehig1x","Type":"NodeParagraph","Properties":{"id":"20230727000839-vehig1x","updated":"20230727000839"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"获得准入权"},{"Type":"NodeText","Data":" W1 完成写操作退出，先让后面排队的 reader 进行读操作，然后从 队列B 中唤醒 W2 到 队列A 排队。W2 从 队列B 到 队列A 的过程中，R8 先到了 队列A，因此 R8 可以执行读操作。R9、R10、R11 在 W2 之后到的，所以在后面排队；新来的 W4 直接在队列B 排队。"}]},{"ID":"20230727000840-de0x83l","Type":"NodeParagraph","Properties":{"id":"20230727000840-de0x83l","updated":"20230727000840"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https:////upload-images.jianshu.io/upload_images/16581067-f880ddbbe100b7b5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000841-u42gmld","Type":"NodeParagraph","Properties":{"id":"20230727000841-u42gmld","updated":"20230727000841"},"Children":[{"Type":"NodeText","Data":"从上面的示例可以看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RWMutex"},{"Type":"NodeText","Data":" 可以看作是没有优先级，按照先来先到的顺序去执行，只不过是 多个reader 可以 并行去执行罢了。"}]},{"ID":"20230727000842-m7cj0mk","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230727000842-m7cj0mk","updated":"20230727000842"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.2 写锁饥饿问题"}]},{"ID":"20230727000843-fm9rmrp","Type":"NodeParagraph","Properties":{"id":"20230727000843-fm9rmrp","updated":"20230727000843"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"因为读锁是共享的，所以如果当前已经有读锁，那后续goroutine继续加读锁正常情况下是可以加锁成功，但是如果一直有读锁进行加锁，那尝试加写锁的goroutine则可能会长期获取不到锁，这就是因为读锁而导致的写锁饥饿问题"}]},{"ID":"20230727000844-qkonhwq","Type":"NodeParagraph","Properties":{"id":"20230727000844-qkonhwq","updated":"20230727000844"},"Children":[{"Type":"NodeText","Data":"go通过引入以下特性避免出现写锁饥饿："}]},{"ID":"20230727000845-yehqe7u","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000845-yehqe7u","updated":"20230727000845"},"Children":[{"ID":"20230727000846-fe0nrb8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000846-fe0nrb8","updated":"20230727000846"},"Children":[{"ID":"20230727000847-v3f0gz6","Type":"NodeParagraph","Properties":{"id":"20230727000847-v3f0gz6","updated":"20230727000847"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当写锁阻塞时，新的读锁是无法申请的"}]}]}]},{"ID":"20230727000848-jrbn1p6","Type":"NodeParagraph","Properties":{"id":"20230727000848-jrbn1p6","updated":"20230727000848"},"Children":[{"Type":"NodeText","Data":"即在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sync.RWMutex"},{"Type":"NodeText","Data":"的使用中，一个线程请求了他的写锁（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"mx.Lock()"},{"Type":"NodeText","Data":"）后，即便它还没有取到该锁（可能由于资源已被其他人锁定），后面所有的读锁的申请，都将被阻塞，只有取写锁的请求得到了锁且用完释放后，读锁才能去取。"}]},{"ID":"20230727000849-ccft92n","Type":"NodeParagraph","Properties":{"id":"20230727000849-ccft92n","updated":"20230727000849"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这种特性可以有效防止写锁饥饿。如果一个线程因为某种原因，导致长时间得不到CPU时间片，这种状态被称之为饥饿"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230727000850-emrz4eq","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230727000850-emrz4eq","updated":"20230727000850"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.3. golang的读写锁源码剖析"}]},{"ID":"20230727000851-hzlau3x","Type":"NodeParagraph","Properties":{"id":"20230727000851-hzlau3x","updated":"20230727000851"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"成员变量"}]},{"ID":"20230727000852-l72nrga","Type":"NodeParagraph","Properties":{"id":"20230727000852-l72nrga","updated":"20230727000852"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https:////upload-images.jianshu.io/upload_images/16581067-4460786c1b2e04fb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1142/format/webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000853-194rxu5","Type":"NodeParagraph","Properties":{"id":"20230727000853-194rxu5","updated":"20230727000853"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"结构体"}]},{"ID":"20230727000854-ffux16l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000854-ffux16l","updated":"20230727000854"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"type RWMutex struct {\n    w           Mutex  // held if there are pending writers\n    writerSem   uint32 // 用于writer等待读完成排队的信号量\n    readerSem   uint32 // 用于reader等待写完成排队的信号量\n    readerCount int32  // 读锁的计数器\n    readerWait  int32  // 等待读锁释放的数量\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000855-r9qdupv","Type":"NodeParagraph","Properties":{"id":"20230727000855-r9qdupv","updated":"20230727000855"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"写锁计数"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"读写锁中允许加读锁的最大数量是4294967296，在go里面对写锁的计数采用了负值进行，通过递减最大允许加读锁的数量从而进行写锁对读锁的抢占"}]},{"ID":"20230727000856-fxxcrwp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000856-fxxcrwp","updated":"20230727000856"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"const rwmutexMaxReaders = 1 \u003c\u003c 30\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000857-goggpyp","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20230727000857-goggpyp","updated":"20230727000857"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.3.1 读锁实现"}]},{"ID":"20230727000858-rwtyvz0","Type":"NodeParagraph","Properties":{"id":"20230727000858-rwtyvz0","updated":"20230727000858"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"读锁加锁逻辑"}]},{"ID":"20230727000859-2i0zldw","Type":"NodeParagraph","Properties":{"id":"20230727000859-2i0zldw","updated":"20230727000859"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https:////upload-images.jianshu.io/upload_images/16581067-317cdd9ddfcc1827.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000860-8yjm4c6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000860-8yjm4c6","updated":"20230727000860"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func (rw *RWMutex) RLock() {\n    if race.Enabled {\n        _ = rw.w.state\n        race.Disable()\n    }\n    // 累加reader计数器，如果小于0则表明有writer正在等待\n    if atomic.AddInt32(\u0026rw.readerCount, 1) \u003c 0 {\n        // 当前有writer正在等待读锁，读锁就加入排队\n        runtime_SemacquireMutex(\u0026rw.readerSem, false)\n    }\n    if race.Enabled {\n        race.Enable()\n        race.Acquire(unsafe.Pointer(\u0026rw.readerSem))\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000861-s2p61zt","Type":"NodeParagraph","Properties":{"id":"20230727000861-s2p61zt","updated":"20230727000861"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"读锁释放逻辑"}]},{"ID":"20230727000862-q9doizw","Type":"NodeParagraph","Properties":{"id":"20230727000862-q9doizw","updated":"20230727000862"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https:////upload-images.jianshu.io/upload_images/16581067-9fccb921ded6feee.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000863-kqx5mxs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000863-kqx5mxs","updated":"20230727000863"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func (rw *RWMutex) RUnlock() {\n    if race.Enabled {\n        _ = rw.w.state\n        race.ReleaseMerge(unsafe.Pointer(\u0026rw.writerSem))\n        race.Disable()\n    }\n    // 如果小于0，则表明当前有writer正在等待\n    if r := atomic.AddInt32(\u0026rw.readerCount, -1); r \u003c 0 {\n        if r+1 == 0 || r+1 == -rwmutexMaxReaders {\n            race.Enable()\n            throw(\"sync: RUnlock of unlocked RWMutex\")\n        }\n        // 将等待reader的计数减1，证明当前是已经有一个读的，如果值==0，则进行唤醒等待的\n        if atomic.AddInt32(\u0026rw.readerWait, -1) == 0 {\n            // The last reader unblocks the writer.\n            runtime_Semrelease(\u0026rw.writerSem, false)\n        }\n    }\n    if race.Enabled {\n        race.Enable()\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000864-u34xyg2","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20230727000864-u34xyg2","updated":"20230727000864"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.3.2 写锁实现"}]},{"ID":"20230727000865-pdeozn3","Type":"NodeParagraph","Properties":{"id":"20230727000865-pdeozn3","updated":"20230727000865"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"加写锁实现"}]},{"ID":"20230727000866-dloa62e","Type":"NodeParagraph","Properties":{"id":"20230727000866-dloa62e","updated":"20230727000866"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https:////upload-images.jianshu.io/upload_images/16581067-f7c1435078a42b1b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000867-2lkkomd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000867-2lkkomd","updated":"20230727000867"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func (rw *RWMutex) Lock() {\n    if race.Enabled {\n        _ = rw.w.state\n        race.Disable()\n    }\n    // 首先获取mutex锁，同时多个goroutine只有一个可以进入到下面的逻辑\n    rw.w.Lock()\n    // 对readerCounter进行进行抢占，通过递减rwmutexMaxReaders允许最大读的数量\n    // 来实现写锁对读锁的抢占\n    r := atomic.AddInt32(\u0026rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders\n    // 记录需要等待多少个reader完成,如果发现不为0，则表明当前有reader正在读取，当前goroutine\n    // 需要进行排队等待\n    if r != 0 \u0026\u0026 atomic.AddInt32(\u0026rw.readerWait, r) != 0 {\n        runtime_SemacquireMutex(\u0026rw.writerSem, false)\n    }\n    if race.Enabled {\n        race.Enable()\n        race.Acquire(unsafe.Pointer(\u0026rw.readerSem))\n        race.Acquire(unsafe.Pointer(\u0026rw.writerSem))\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000868-bueqxfs","Type":"NodeParagraph","Properties":{"id":"20230727000868-bueqxfs","updated":"20230727000868"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"释放写锁"}]},{"ID":"20230727000869-k9yzxgz","Type":"NodeParagraph","Properties":{"id":"20230727000869-k9yzxgz","updated":"20230727000869"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https:////upload-images.jianshu.io/upload_images/16581067-c608b95d31eb2b2b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000870-fea48te","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000870-fea48te","updated":"20230727000870"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func (rw *RWMutex) Unlock() {\n    if race.Enabled {\n        _ = rw.w.state\n        race.Release(unsafe.Pointer(\u0026rw.readerSem))\n        race.Disable()\n    }\n\n    // 将reader计数器复位，上面减去了一个rwmutexMaxReaders现在再重新加回去即可复位\n    r := atomic.AddInt32(\u0026rw.readerCount, rwmutexMaxReaders)\n    if r \u003e= rwmutexMaxReaders {\n        race.Enable()\n        throw(\"sync: Unlock of unlocked RWMutex\")\n    }\n    // 唤醒所有的读锁\n    for i := 0; i \u003c int(r); i++ {\n        runtime_Semrelease(\u0026rw.readerSem, false)\n    }\n    // 释放mutex\n    rw.w.Unlock()\n    if race.Enabled {\n        race.Enable()\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000871-doc3xxz","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20230727000871-doc3xxz","updated":"20230727000871"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.3.3 关键核心机制"}]},{"ID":"20230727000872-94cfzzt","Type":"NodeParagraph","Properties":{"id":"20230727000872-94cfzzt","updated":"20230727000872"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"写锁对读锁的抢占"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"加写锁的抢占"}]},{"ID":"20230727000873-twbtbjn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000873-twbtbjn","updated":"20230727000873"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    // 在加写锁的时候通过将readerCount递减最大允许加读锁的数量，来实现对加读锁的抢占\n    r := atomic.AddInt32(\u0026rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000874-g03699i","Type":"NodeParagraph","Properties":{"id":"20230727000874-g03699i","updated":"20230727000874"},"Children":[{"Type":"NodeText","Data":"加读锁的抢占检测"}]},{"ID":"20230727000875-tmto77j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000875-tmto77j","updated":"20230727000875"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 如果没有写锁的情况下读锁的readerCount进行Add后一定是一个\u003e0的数字，这里通过检测值为负数\n//就实现了读锁对写锁抢占的检测\nif atomic.AddInt32(\u0026rw.readerCount, 1) \u003c 0 {\n        // A writer is pending, wait for it.\n        runtime_SemacquireMutex(\u0026rw.readerSem, false)\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000876-p1yt8qz","Type":"NodeParagraph","Properties":{"id":"20230727000876-p1yt8qz","updated":"20230727000876"},"Children":[{"Type":"NodeText","Data":"写锁抢占读锁后后续的读锁就会加锁失败，但是如果想加写锁成功还要继续对已经加读锁成功的进行等待"}]},{"ID":"20230727000877-3dfix34","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000877-3dfix34","updated":"20230727000877"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"if r != 0 \u0026\u0026 atomic.AddInt32(\u0026rw.readerWait, r) != 0 {\n        // 写锁发现需要等待的读锁释放的数量不为0，就自己自己去休眠了\n        runtime_SemacquireMutex(\u0026rw.writerSem, false)\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000878-hgytu9w","Type":"NodeParagraph","Properties":{"id":"20230727000878-hgytu9w","updated":"20230727000878"},"Children":[{"Type":"NodeText","Data":"写锁既然休眠了，则必定要有一种唤醒机制其实就是每次释放锁的时候，当检查到有加写锁的情况下，就递减readerWait，并由最后一个释放reader lock的goroutine来实现唤醒写锁"}]},{"ID":"20230727000879-eb60zj8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000879-eb60zj8","updated":"20230727000879"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"if atomic.AddInt32(\u0026rw.readerWait, -1) == 0 {\n            // The last reader unblocks the writer.\n            runtime_Semrelease(\u0026rw.writerSem, false)\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000880-8k0quys","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230727000880-8k0quys","updated":"20230727000880"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3. 常见问题"}]},{"ID":"20230727000881-5bsjidu","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20230727000881-5bsjidu","updated":"20230727000881"},"Children":[{"ID":"20230727000882-nkodhlk","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20230727000882-nkodhlk","updated":"20230727000882"},"Children":[{"ID":"20230727000883-3tlmxyo","Type":"NodeParagraph","Properties":{"id":"20230727000883-3tlmxyo","updated":"20230727000883"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不可复制"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"和 Mutex 一样，RWMutex 也是不可复制。不能复制的原因和互斥锁一样。一旦读写锁被使用，它的字段就会记录它当前的一些状态。这个时候你去复制这把锁，就会把它的状态也给复制过来。但是，原来的锁在释放的时候，并不会修改你复制出来的这个读写锁，这就会导致复制出来的读写锁的状态不对，可能永远无法释放锁。"}]}]},{"ID":"20230727000884-gqmx1pp","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20230727000884-gqmx1pp","updated":"20230727000884"},"Children":[{"ID":"20230727000885-z8xielu","Type":"NodeParagraph","Properties":{"id":"20230727000885-z8xielu","updated":"20230727000885"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不可重入"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"不可重入的原因是，获得锁之后，还没释放锁，又申请锁，这样有可能造成死锁。比如 reader A 获取到了读锁，writer B 等待 reader A 释放锁，reader 还没释放锁又申请了一把锁，但是这把锁申请不成功，他需要等待 writer B。这就形成了一个循环等待的死锁。"}]}]},{"ID":"20230727000886-mcsiku0","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20230727000886-mcsiku0","updated":"20230727000886"},"Children":[{"ID":"20230727000887-3drcg0z","Type":"NodeParagraph","Properties":{"id":"20230727000887-3drcg0z","updated":"20230727000887"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"加锁和释放锁一定要成对出现"},{"Type":"NodeText","Data":"，不能忘记释放锁，也不能解锁一个未加锁的锁。"}]}]}]}]}