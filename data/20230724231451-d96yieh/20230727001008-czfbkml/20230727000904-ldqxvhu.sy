{"ID":"20230727000904-ldqxvhu","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f33d","id":"20230727000904-ldqxvhu","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230727000904-ldqxvhu\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230727000905-2xf9u53\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230727000967-o5k6sh1\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230727000905-2xf9u53\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","tags":"Go 内存分配,Go 内存泄漏","title":"17. Go 内存泄漏","updated":"20230727000904"},"Children":[{"ID":"20230727000905-2xf9u53","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230727000905-2xf9u53","updated":"20230727000905"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"17. Go 内存泄漏"}]},{"ID":"20230727000906-lo3ptvx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000906-lo3ptvx","updated":"20230727000906"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"简介"}]},{"ID":"20230727000907-15dbcta","Type":"NodeParagraph","Properties":{"id":"20230727000907-15dbcta","updated":"20230727000907"},"Children":[{"Type":"NodeText","Data":"go虽然自带GC,会自动将分配在堆上且不被引用的内存回收，但如果编程中操作不当，仍然会出现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类似内存泄露"},{"Type":"NodeText","Data":"或"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"真内存泄露"},{"Type":"NodeText","Data":"的情况。"}]},{"ID":"20230727000908-iov569q","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000908-iov569q","updated":"20230727000908"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"类似内存泄漏"}]},{"ID":"20230727000909-0q0j7mo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000909-0q0j7mo","updated":"20230727000909"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"子字符串截取"}]},{"ID":"20230727000910-x0mjyun","Type":"NodeParagraph","Properties":{"id":"20230727000910-x0mjyun","updated":"20230727000910"},"Children":[{"Type":"NodeText","Data":"此时s0与s1共享相同的底层数组，继续使用s0, 不会导致s1的其余部分内存被释放， 那么现在只有50字节内存可用，1048576-50个字节的垃圾内存不可用！"}]},{"ID":"20230727000911-9cb3ts6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000911-9cb3ts6","updated":"20230727000911"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"var s0 string // a package-level variable\n \n// A demo purpose function.\nfunc f(s1 string) {\n\ts0 = s1[:50]\n\t// Now, s0 shares the same underlying memory block\n\t// with s1. Although s1 is not alive now, but s0\n\t// is still alive, so the memory block they share\n\t// couldn't be collected, though there are only 50\n\t// bytes used in the block and all other bytes in\n\t// the block become unavailable.\n}\nfunc demo() {\n\ts := createStringWithLengthOnHeap(1 \u003c\u003c 20) // 1M bytes\n\tf(s)\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000912-ax56a8e","Type":"NodeParagraph","Properties":{"id":"20230727000912-ax56a8e","updated":"20230727000912"},"Children":[{"Type":"NodeText","Data":"解决方案"}]},{"ID":"20230727000913-m3v7oo5","Type":"NodeParagraph","Properties":{"id":"20230727000913-m3v7oo5","updated":"20230727000913"},"Children":[{"Type":"NodeText","Data":"为了避免这种情况，可以使用如下方法:"}]},{"ID":"20230727000914-5pbkjqi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000914-5pbkjqi","updated":"20230727000914"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func f(s1 string) {\n\ts0 = string([]byte(s1[:50]))\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000915-ajv9njg","Type":"NodeParagraph","Properties":{"id":"20230727000915-ajv9njg","updated":"20230727000915"},"Children":[{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"这种方法会产生s1前50字节的两个副本，即两次拷贝，最后一次拷贝变成s0,第一次拷贝将不在引用会被回收。"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000916-b2n9ry5","Type":"NodeParagraph","Properties":{"id":"20230727000916-b2n9ry5","updated":"20230727000916"},"Children":[{"Type":"NodeText","Data":"为了避免这多余的一次拷贝，可以使用go编译器专门为这种操作做的优化："}]},{"ID":"20230727000917-ezgk89c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000917-ezgk89c","updated":"20230727000917"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func f(s1 string) {\n\ts0 := (\"\" + s1[:50])[1:]\n\tfmt.Println(s0)\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000918-7vqtchb","Type":"NodeParagraph","Properties":{"id":"20230727000918-7vqtchb","updated":"20230727000918"},"Children":[{"Type":"NodeText","Data":"但这种方式有可能在后续go编译器中不再支持！"}]},{"ID":"20230727000919-15fkl86","Type":"NodeParagraph","Properties":{"id":"20230727000919-15fkl86","updated":"20230727000919"},"Children":[{"Type":"NodeText","Data":"​    还有一种方式就是使用"},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"strings.builder 来构建字符串"},{"Type":"NodeMark2CloseMarker","Data":"=="}]},{"Type":"NodeText","Data":"，其实就是将我们所需的字节拷贝到[]byte切片中，然后做了一次unsafe.Pointer的指针类型的强制拷贝！，当然绝对不是使用string([]byte())操作。"}]},{"ID":"20230727000920-i36dez1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000920-i36dez1","updated":"20230727000920"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import \"strings\"\n\nfunc f(s1 string) {\n\tvar b strings.Builder\n\tb.Grow(50)\n\tb.WriteString(s1[:50])\n\ts0 = b.String()\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000921-bxy7vvw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000921-bxy7vvw","updated":"20230727000921"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"子切片的截取(slice 泄漏)"}]},{"ID":"20230727000922-kzhwwf8","Type":"NodeParagraph","Properties":{"id":"20230727000922-kzhwwf8","updated":"20230727000922"},"Children":[{"Type":"NodeText","Data":"slice 底层原理"}]},{"ID":"20230727000923-v2eyolu","Type":"NodeParagraph","Properties":{"id":"20230727000923-v2eyolu","updated":"20230727000923"},"Children":[{"Type":"NodeText","Data":"slice 的数据结构只记录了如下的三个部分："}]},{"ID":"20230727000924-2j60ey2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000924-2j60ey2","updated":"20230727000924"},"Children":[{"ID":"20230727000925-kek07p1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000925-kek07p1","updated":"20230727000925"},"Children":[{"ID":"20230727000926-9s8gtkt","Type":"NodeParagraph","Properties":{"id":"20230727000926-9s8gtkt","updated":"20230727000926"},"Children":[{"Type":"NodeText","Data":"数组指针。指向了真正的数组地址。"}]}]},{"ID":"20230727000927-77hhpyp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000927-77hhpyp","updated":"20230727000927"},"Children":[{"ID":"20230727000928-77zaono","Type":"NodeParagraph","Properties":{"id":"20230727000928-77zaono","updated":"20230727000928"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":" 的长度"}]}]},{"ID":"20230727000929-kipl48e","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230727000929-kipl48e","updated":"20230727000929"},"Children":[{"ID":"20230727000930-bvi5uqu","Type":"NodeParagraph","Properties":{"id":"20230727000930-bvi5uqu","updated":"20230727000930"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":" 的容量"}]}]}]},{"ID":"20230727000931-t6lgkld","Type":"NodeParagraph","Properties":{"id":"20230727000931-t6lgkld","updated":"20230727000931"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"E:\\Typora picture\\v2-89e218bb3d1f839acfb4c5b17a457b73_r.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230727000932-xdd7egx","Type":"NodeParagraph","Properties":{"id":"20230727000932-xdd7egx","updated":"20230727000932"},"Children":[{"Type":"NodeText","Data":"与子字符串截取很相似。截取后，小切片与大切片共享相同的底层数组，只有当小切片不再被使用时，这个底层数组才能被释放。"}]},{"ID":"20230727000933-9g8xhoj","Type":"NodeParagraph","Properties":{"id":"20230727000933-9g8xhoj","updated":"20230727000933"},"Children":[{"Type":"NodeText","Data":"​    "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注：底层数组只能整体释放，整体回收，参考malloc如何回收内存的"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230727000934-yug0vxj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000934-yug0vxj","updated":"20230727000934"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func g(s1 []int) {\n    // Assume the length of s1 if much larger than 30\n    s0 = s1[len(s1)-30:]\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000935-r5oh9h1","Type":"NodeParagraph","Properties":{"id":"20230727000935-r5oh9h1","updated":"20230727000935"},"Children":[{"Type":"NodeText","Data":"解决方案"}]},{"ID":"20230727000936-j2c2qcu","Type":"NodeParagraph","Properties":{"id":"20230727000936-j2c2qcu","updated":"20230727000936"},"Children":[{"Type":"NodeText","Data":"核心思路："},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"如果我们需要使用切片时，尽量保证切片只作为局部变量使用，不会被传到方法外，这样在局部变量使用完后，该切片就会被回收。"},{"Type":"NodeMark2CloseMarker","Data":"=="}]},{"Type":"NodeText","Data":" "},{"Type":"NodeStrong","Children":[{"Type":"NodeStrongA6kOpenMarker","Data":"**"},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"如果我们不能保证将切片作为局部变量使用且不传递，则应该对需要的切片数据进行拷贝，防止内存泄露。"},{"Type":"NodeMark2CloseMarker","Data":"=="}]},{"Type":"NodeStrongA6kCloseMarker","Data":"**"}]}]},{"ID":"20230727000937-30kejzn","Type":"NodeParagraph","Properties":{"id":"20230727000937-30kejzn","updated":"20230727000937"},"Children":[{"Type":"NodeText","Data":"使用专门用于切片拷贝的copy函数解决这个问题"}]},{"ID":"20230727000938-hasaiy4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000938-hasaiy4","updated":"20230727000938"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func g(s1 []int) {\n  s0 = make([]int, 30)\n  copy(s0, s1[len(s1-30):])\n  // Now, the memory block hosting the elements\n\t// of s1 can be collected if no other values\n\t// are referencing the memory block.\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000939-b2ss60m","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000939-b2ss60m","updated":"20230727000939"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"指针切片截取"}]},{"ID":"20230727000940-ydkswjl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000940-ydkswjl","updated":"20230727000940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func h() []*int {\n\t\ts := []*int{new(int),new(int),new(int),new(int)}\n\t\t// do something with s \n\t\treturn s[1:3:3]\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000941-3rb29f1","Type":"NodeParagraph","Properties":{"id":"20230727000941-3rb29f1","updated":"20230727000941"},"Children":[{"Type":"NodeText","Data":"这种情况下：当函数返回后，只要s还存活，s中的所有元素都不能被释放，即使s中的第一个元素和最后一个元素没有被使用了，也不能被释放。我们可以将不要的元素置为nil就能解决这个问题。"}]},{"ID":"20230727000942-55nd2d3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000942-55nd2d3","updated":"20230727000942"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func h() *[]int {\n  s := []*int{new(int),new(int),new(int),new(int)}\n  \n  s[0],s[len(s)-1] = nil,nil\n  return s[1:3:3]\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000943-s70zhk1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000943-s70zhk1","updated":"20230727000943"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"defer 导致的内存泄露"}]},{"ID":"20230727000944-fyjy0j5","Type":"NodeParagraph","Properties":{"id":"20230727000944-fyjy0j5","updated":"20230727000944"},"Children":[{"Type":"NodeText","Data":"我们都知道，defer是将执行到压到函数的最后，并按先defer后执行的顺序执行。"}]},{"ID":"20230727000945-d2wb7wc","Type":"NodeParagraph","Properties":{"id":"20230727000945-d2wb7wc","updated":"20230727000945"},"Children":[{"Type":"NodeText","Data":"如果存在以下情况，在for中存在很多defer去进行资源的释放,那么"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这么多资源只能在函数结束时才能得到释放。"}]},{"ID":"20230727000946-rocfo4r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000946-rocfo4r","updated":"20230727000946"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func writeManyFiles(files []File) error {\n  for _,file := range files {\n    f, err := os.Open(file.path)\n    if err != nil {\n      return err\n    }\n    defer f.Close()\n    \n    _,err = f.WriteString(file.content)\n    if err != nil {\n      return err\n    }\n    \n    err = f.Sync()\n    if err != nil {\n      return err\n    }\n  }\n  return nil\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000947-fv4458j","Type":"NodeParagraph","Properties":{"id":"20230727000947-fv4458j","updated":"20230727000947"},"Children":[{"Type":"NodeText","Data":"那么我们可是使用昵名函数将这个问题解决。"},{"Type":"NodeMark","Children":[{"Type":"NodeMark2OpenMarker","Data":"=="},{"Type":"NodeText","Data":"每一次循环后启动一个函数，函数结束后资源就释放了，不存在以上情况！"},{"Type":"NodeMark2CloseMarker","Data":"=="}]}]},{"ID":"20230727000948-ca57mie","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000948-ca57mie","updated":"20230727000948"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func writeManyFiles(files []File) error {\n  for _,file := range files {\n    if err := func() error {\n      f,err := os.Open(file.path)\n      if err := nil {\n        \treturn err\n      }\n      // The close method will be called at the end of the current loop step\n      defer f.Close()\n      \n      _, err = f.WriteString(file.content)\n      if err != nil {\n        return err\n      }\n      \n      return f.Sync()\n    }() ;err != nil {\n      return err\n    }\n  }\n  return nil\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000949-mcy9y7j","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230727000949-mcy9y7j","updated":"20230727000949"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"真内存泄漏"}]},{"ID":"20230727000950-my8draq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000950-my8draq","updated":"20230727000950"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"协程泄漏"}]},{"ID":"20230727000951-npphd60","Type":"NodeParagraph","Properties":{"id":"20230727000951-npphd60","updated":"20230727000951"},"Children":[{"Type":"NodeText","Data":"如下情况：如果exit被注释，那么执行task的那个协程就永远不能退出。"}]},{"ID":"20230727000952-8kbg8tn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000952-8kbg8tn","updated":"20230727000952"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func task() {\n  for {\n    select {\n      // case \u003c- exit:\n      // return \n      case \u003c- other\n      \t//do task\n    }\n  }      \n}\n\nfunc  main() {\n  go task()\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000953-v70ju65","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000953-v70ju65","updated":"20230727000953"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"time.Ticker"}]},{"ID":"20230727000954-kkixj3i","Type":"NodeBlockquote","Properties":{"id":"20230727000954-kkixj3i","updated":"20230727000954"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230727000955-r0xtooe","Type":"NodeParagraph","Properties":{"id":"20230727000955-r0xtooe","updated":"20230727000955"},"Children":[{"Type":"NodeText","Data":"注意： Ticker 和 Timer 是不同的，TImer 只会定时一次，而Ticker如果不Stop，就会一直发送定时。"}]}]},{"ID":"20230727000956-xwn28zr","Type":"NodeParagraph","Properties":{"id":"20230727000956-xwn28zr","updated":"20230727000956"},"Children":[{"Type":"NodeText","Data":"time.After在定时器到达时，会自动内回收。然后time.Ticker 钟摆不使用时，一定要Stop,不然会造成真内存泄露。至于为什么，看Ticker源码！如下代码，当task退出后，t 就不能回收。"}]},{"ID":"20230727000957-c5idq8p","Type":"NodeParagraph","Properties":{"id":"20230727000957-c5idq8p","updated":"20230727000957"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Ticker"},{"Type":"NodeText","Data":"使用示例"}]},{"ID":"20230727000958-g7wkrga","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z3A=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000958-g7wkrga","updated":"20230727000958"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z3A=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func TestTickNormal(t *testing.T) {\n\tticker ;= time.NewTicker(time.Second)\n\tdefer ticker.Stop()\n\tgo func () {\n\t\tfor {\n\t\t\tfmt.Println(\u003c-ticker.C)\n\t\t}\n\t}()\n\ttime.Sleep(time.Second * 3)\n\tfmt.Println(\"finis\")\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000959-s34ukxs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000959-s34ukxs","updated":"20230727000959"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func task() {\n\tt := time.NewTicker(time.Second)\n\tfor {\n\t\tselect {\n\t\tcase \u003c- t.C:\n\t\t\t// do something\n\t\tcase \u003c- exit:\n\t\t\treturn \n\t\t}\n\t}\n}\nfunc main() {\n  go task()\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000960-fbdrfsp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727000960-fbdrfsp","updated":"20230727000960"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"runtime.SetFinalizer"}]},{"ID":"20230727000961-47x9no7","Type":"NodeParagraph","Properties":{"id":"20230727000961-47x9no7","updated":"20230727000961"},"Children":[{"Type":"NodeText","Data":"对循环引用的对象使用runtime.SetFinalizer进行终止，如下："}]},{"ID":"20230727000962-qnqdv4z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Z28=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230727000962-qnqdv4z","updated":"20230727000962"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"func memoryLeaking() {\n\ttype T struct {\n\t\tv [1\u003c\u003c20]int\n\t\tt *T\n\t}\n\t\n\tvar finalizer = func(t *T) {\n\t\tfmt.Println(\"finalizer caller\")\n\t}\n\tvar x, y T\n\t// The SetFinalizer call makes x escape to heap.\n\truntime.SetFinalizer(\u0026x, finalizer)\n \n\t// The following line forms a cyclic reference\n\t// group with two members, x and y.\n\t// This causes x and y are not collectable.\n\tx.t, y.t = \u0026y, \u0026x // y also escapes to heap.\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230727000963-p6vnw1a","Type":"NodeParagraph","Properties":{"id":"20230727000963-p6vnw1a","updated":"20230727000963"},"Children":[{"Type":"NodeText","Data":"那么x、y不能被GC回收，且附着在对象上的finalizer函数将不会被调用。"}]},{"ID":"20230727000964-tzfpznf","Type":"NodeParagraph","Properties":{"id":"20230727000964-tzfpznf","updated":"20230727000964"},"Children":[{"Type":"NodeText","Data":"标准库文档说："}]},{"ID":"20230727000965-gd08t3p","Type":"NodeParagraph","Properties":{"id":"20230727000965-gd08t3p","updated":"20230727000965"},"Children":[{"Type":"NodeText","Data":"runtime - The Go Programming Language"}]},{"ID":"20230727000966-fodwp3h","Type":"NodeParagraph","Properties":{"id":"20230727000966-fodwp3h","updated":"20230727000966"},"Children":[{"Type":"NodeText","Data":"Finalizers are run in dependency order: if A points at B, both have finalizers, and they are otherwise unreachable, only the finalizer for A runs; once A is freed, the finalizer for B can run. If a cyclic structure includes a block with a finalizer, that cycle is not guaranteed to be garbage collected and the finalizer is not guaranteed to run, because there is no ordering that respects the dependencies."}]},{"ID":"20230727000967-o5k6sh1","Type":"NodeParagraph","Properties":{"id":"20230727000967-o5k6sh1","updated":"20230727000967"},"Children":[{"Type":"NodeText","Data":"总之，没事别使用runtime.SetFinalizer函数来释放对象。使用runtime.SetFinalizer前，还是参考标准库文档说明比较好"}]}]}