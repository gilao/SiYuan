{"ID":"20240327151502-u6oxdc4","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f99b","id":"20240327151502-u6oxdc4","tags":"Go-Map","title":"Golang Map 元素取值问题：cannot assign to struct field XXXX in map","updated":"20240327151742"},"Children":[{"ID":"20240327151502-woenfxt","Type":"NodeParagraph","Properties":{"id":"20240327151502-woenfxt","updated":"20240327151602"},"Children":[{"Type":"NodeText","Data":"问题描述 ：golang 中对 map 类型中的 struct 赋值报错"}]},{"ID":"20240327151602-mwzxgrw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240327151602-mwzxgrw","updated":"20240327151614"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\ttype Entity struct {\n\t\tValue string\n\t}\n\n\tentityMap := make(map[string]Entity, 0)\n\tentityMap[\"cat\"] = Entity{Value: \"This is a cat\"}\n\tentityMap[\"cat\"].Value= \"This is a another cat\"\n\tfmt.Println(\"value \",entityMap[\"cat\"].Value)\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240327151637-j205jfe","Type":"NodeParagraph","Properties":{"id":"20240327151637-j205jfe","updated":"20240327151637"},"Children":[{"Type":"NodeText","Data":"第12行编译报错 ： cannot assign to struct field entityMap[“cat”].Value in map"}]},{"ID":"20240327151637-vzgsq4s","Type":"NodeParagraph","Properties":{"id":"20240327151637-vzgsq4s","updated":"20240327151637"},"Children":[{"Type":"NodeText","Data":"原因是 map 元素是无法取址的，也就说可以得到 a[“tao”], 但是无法对其进行修改。"}]},{"ID":"20240327151637-s0qquyo","Type":"NodeParagraph","Properties":{"id":"20240327151637-s0qquyo","updated":"20240327151637"},"Children":[{"Type":"NodeText","Data":"解决办法：使用指针的map"}]},{"ID":"20240327151639-eu06brk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240327151639-eu06brk","updated":"20240327151658"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport \"fmt\"\n\nfunc main() {\n   fmt.Println(\"Hello, World!\")\n\ttype Entity struct {\n\t\tValue string\n\t}\n\n\tentityMap := make(map[string]*Entity, 2)\n\tentityMap[\"cat\"] = \u0026Entity{Value: \"This is a cat\"}\n\n\n\tentityMap[\"cat\"].Value = \"This is a another cat\"\n\tfmt.Println(\"value \",entityMap[\"cat\"].Value)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240327151659-h9rkw9f","Type":"NodeParagraph","Properties":{"id":"20240327151659-h9rkw9f","updated":"20240327151659"},"Children":[{"Type":"NodeText","Data":"golang里面的map是通过hashtable来实现的，具体方式就是通过拉链法（数组+链表）来实现的，这里对比c++的map,c++里面的map， 是通过红黑树来实现的。\n所以二者在遍历的时候做删除操作，golang的是可以直接操作的，因为内部实现是哈希映射，删除并不影响其他项，而c++中的map删除，由于是红黑树，删除任意一项，都会打乱迭代指针，不能再O(1)时间内删除。"}]},{"ID":"20240327151659-7h30119","Type":"NodeParagraph","Properties":{"id":"20240327151659-7h30119","updated":"20240327151659"},"Children":[{"Type":"NodeText","Data":"同时，golang里面的key是无序的，即使你顺序添加，遍历的时候也是无序。"}]},{"ID":"20240327151659-s46l8oq","Type":"NodeParagraph","Properties":{"id":"20240327151659-s46l8oq","updated":"20240327151659"},"Children":[{"Type":"NodeText","Data":"golang里面的map,当通过key获取到value时，这个value是不可寻址的，因为map 会进行动态扩容，当进行扩展后，map的value就会进行内存迁移，其地址发生变化，所以无法对这个value进行寻址。也就是造成上述问题的原因所在。map的扩容与slice不同，那么map本身是引用类型，作为形参或返回参数的时候，传递的是值的拷贝，而值是地址，扩容时也不会改变这个地址。而slice的扩容，会导致地址的变化"}]},{"ID":"20240327151704-uebsyan","Type":"NodeParagraph","Properties":{"id":"20240327151704-uebsyan","updated":"20240327151711"},"Children":[{"Type":"NodeText","Data":"MAP的原理"}]},{"ID":"20240327151711-httv2v5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240327151711-httv2v5","updated":"20240327151718"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type hmap struct {\n    count        int  //元素个数\n    flags        uint8   \n    B            uint8 //扩容常量\n    noverflow    uint16 //溢出 bucket 个数\n    hash0        uint32 //hash 种子\n    buckets      unsafe.Pointer //bucket 数组指针\n    oldbuckets   unsafe.Pointer //扩容时旧的buckets 数组指针\n    nevacuate    uintptr  //扩容搬迁进度\n    extra        *mapextra //记录溢出相关\n}\n\ntype bmap struct {\n    tophash        [bucketCnt]uint8  \n    // Followed by bucketCnt keys \n    //and then bucketan Cnt values  \n    // Followed by overflow pointer.\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240327151732-q4srduv","Type":"NodeParagraph","Properties":{"id":"20240327151732-q4srduv","updated":"20240327151742"},"Children":[{"Type":"NodeText","Data":"每个map的底层结构是hmap，是有若干个结构为bmap的bucket组成的数组，每个bucket可以存放若干个元素(通常是8个)，那么每个key会根据hash算法归到同一个bucket中，当一个bucket中的元素超过8个的时候，hmap会使用extra中的overflow来扩展存储key。"}]}]}