{"ID":"20240526234951-mlw54ri","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f6cb-fe0f","id":"20240526234951-mlw54ri","title":"API Import","type":"doc","updated":"20240526235012"},"Children":[{"ID":"20240526235007-uo69yr9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240526235007-uo69yr9","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"概述"}]},{"ID":"20240526235007-8ogeeuz","Type":"NodeParagraph","Properties":{"id":"20240526235007-8ogeeuz","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"在 go-zero 中，我们通过 api 语言来声明 HTTP 服务，然后通过 goctl 生成 HTTP 服务代码，在之前我们系统性的介绍了 "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://go-zero.dev/docs/tutorials","TextMarkTextContent":"API 规范"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240526235007-2ika4ta","Type":"NodeParagraph","Properties":{"id":"20240526235007-2ika4ta","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"在 HTTP 服务开发中，我们都是通过 api 描述语言来描述 HTTP 服务，随着业务量的增加，api 文件可能会越来越大，又或者我们有一些公共结构体，如果我们都写在同一个 api 文件中，那么 api文件将变成非常巨大，不易阅读和维护，我们可以通过 api import 来引入其他 api 文件解决这类问题。"}]},{"ID":"20240526235007-n10lxjn","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240526235007-n10lxjn","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"api 文件引入"}]},{"ID":"20240526235007-h1tto6y","Type":"NodeParagraph","Properties":{"id":"20240526235007-h1tto6y","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"假设我们 HTTP 服务的响应格式统一为如下 json 格式："}]},{"ID":"20240526235007-0dkzjey","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240526235007-0dkzjey","updated":"20240526235007"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"anNvbg=="},{"Type":"NodeCodeBlockCode","Data":"{\n\"code\": 0,\n\"msg\": \"success\",\n\"data\": {}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240526235007-q916g7q","Type":"NodeParagraph","Properties":{"id":"20240526235007-q916g7q","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"通过如上 json 可以看出，我们的响应格式中有 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"code"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"msg"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"data"},{"Type":"NodeText","Data":"​ 三个字段，其中 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"code"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"msg"},{"Type":"NodeText","Data":"​ 是固定的，data 是可变的，我们可以将其中2个字段 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"code"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"msg"},{"Type":"NodeText","Data":"​ 抽象出来，定义为一个公共的结构体，然后在其他 api 文件中引入这个结构体。"}]},{"ID":"20240526235007-y3yrutj","Type":"NodeParagraph","Properties":{"id":"20240526235007-y3yrutj","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"示例，假设我们有一个用户服务来查询用户信息和修改用户信息，我们可以将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"code"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"msg"},{"Type":"NodeText","Data":"​ 抽象在 base.api 中，然后 user.api 中复用和定义具体的响应结构体即可。"}]},{"ID":"20240526235007-t6arulz","Type":"NodeList","ListData":{},"Properties":{"id":"20240526235007-t6arulz","updated":"20240526235007"},"Children":[{"ID":"20240526235007-7fmksop","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240526235007-7fmksop","updated":"20240526235007"},"Children":[{"ID":"20240526235007-ehgnt3k","Type":"NodeParagraph","Properties":{"id":"20240526235007-ehgnt3k","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"base.api"}]}]},{"ID":"20240526235007-d1ce9co","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240526235007-d1ce9co","updated":"20240526235007"},"Children":[{"ID":"20240526235007-3su11e2","Type":"NodeParagraph","Properties":{"id":"20240526235007-3su11e2","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"user.api"}]}]}]},{"ID":"20240526235007-dxlkv5l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240526235007-dxlkv5l","updated":"20240526235007"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"syntax =  \"v1\"\n\ntype Base {\n    Code int    `json:\"code\"`\n    Msg  string `json:\"msg\"`\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240526235007-ra5t729","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20240526235007-ra5t729","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"温馨提示"}]},{"ID":"20240526235007-bm4mw6s","Type":"NodeParagraph","Properties":{"id":"20240526235007-bm4mw6s","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"在 api 描述语言中，没有 package 的概念，所以在引入其他 api 文件时，需要使用相对路径，如上面示例中的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"import \u0026quot;base.api\u0026quot;"},{"Type":"NodeText","Data":"​，如果是在同一个目录下，亦可以使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"import \u0026quot;./base.api\u0026quot;"},{"Type":"NodeText","Data":"​。 import 支持相对路径和绝对路径。"}]},{"ID":"20240526235007-ik3oz41","Type":"NodeParagraph","Properties":{"id":"20240526235007-ik3oz41","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"在 api 描述语言中，我们规定将所有 service 语法块声明的 HTTP 服务信息都放在 main api文件中，抽象结构体放在其他 api 文件中，然后在 main api 文件中引入其他 api 文件，这样可以让 main api 文件更加简洁，易于维护，而被引入的 api 文件中不允许出现 service 语法块，否则会报错。"}]},{"ID":"20240526235007-imvjb7x","Type":"NodeParagraph","Properties":{"id":"20240526235007-imvjb7x","updated":"20240526235007"},"Children":[{"Type":"NodeText","Data":"特别注意：api 引入不支持循环引入！！！"}]}]}