{"ID":"20240526233311-3w9emaw","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1fa9d","id":"20240526233311-3w9emaw","title":"路由前缀","type":"doc","updated":"20240526233406"},"Children":[{"ID":"20240526233352-rysztzg","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240526233352-rysztzg","updated":"20240526233352"},"Children":[{"Type":"NodeText","Data":"概述"}]},{"ID":"20240526233352-lcsuytu","Type":"NodeParagraph","Properties":{"id":"20240526233352-lcsuytu","updated":"20240526233353"},"Children":[{"Type":"NodeText","Data":"在 go-zero 中，我们通过 api 语言来声明 HTTP 服务，然后通过 goctl 生成 HTTP 服务代码，在之前我们系统性的介绍了 "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://go-zero.dev/docs/tutorials","TextMarkTextContent":"API 规范"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240526233352-e39uudj","Type":"NodeParagraph","Properties":{"id":"20240526233352-e39uudj","updated":"20240526233353"},"Children":[{"Type":"NodeText","Data":"在 HTTP 服务开发中，路由前缀需求是非常常见的，比如我们通过路由来区分版本，或者通过路由来区分不同的服务，这些都是非常常见的需求。"}]},{"ID":"20240526233352-zzvruqn","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240526233352-zzvruqn","updated":"20240526233352"},"Children":[{"Type":"NodeText","Data":"路由前缀"}]},{"ID":"20240526233352-nureteh","Type":"NodeParagraph","Properties":{"id":"20240526233352-nureteh","updated":"20240526233353"},"Children":[{"Type":"NodeText","Data":"假设我们有一个用户服务，我们需要通过路由来区分不同的版本，我们可以通过 api 语言来声明路由前缀："}]},{"ID":"20240526233352-npbbys6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240526233352-npbbys6","updated":"20240526233353"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"dW5kZWZpbmVk"},{"Type":"NodeCodeBlockCode","Data":"https://example.com/v1/users\nhttps://example.com/v2/users\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240526233352-0x6eicj","Type":"NodeParagraph","Properties":{"id":"20240526233352-0x6eicj","updated":"20240526233353"},"Children":[{"Type":"NodeText","Data":"在上文路由中，我们通过版本 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"v1"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"v2"},{"Type":"NodeText","Data":"​ 来区分了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"/users"},{"Type":"NodeText","Data":"​ 路由，我们可以通过 api 语言来声明路由前缀："}]},{"ID":"20240526233352-6eayfng","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240526233352-6eayfng","updated":"20240526233353"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"syntax = \"v1\"\n\ntype UserV1 {\n    Name string `json:\"name\"`\n}\n\ntype UserV2 {\n    Name string `json:\"name\"`\n}\n\n@server (\n    prefix: /v1\n)\nservice user-api {\n    @handler usersv1\n    get /users returns ([]UserV1)\n}\n\n@server (\n    prefix: /v2\n)\nservice user-api {\n    @handler usersv2\n    get /users returns ([]UserV2)\n}\n\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240526233352-18ptvtv","Type":"NodeParagraph","Properties":{"id":"20240526233352-18ptvtv","updated":"20240526233353"},"Children":[{"Type":"NodeText","Data":"在上文中，我们通过在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"@server"},{"Type":"NodeText","Data":"​ 中来通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"prefix"},{"Type":"NodeText","Data":"​ 关键字声明了路由前缀，然后通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"@handler"},{"Type":"NodeText","Data":"​ 来声明了路由处理函数，这样我们就可以通过路由前缀来区分不同的版本了。"}]},{"ID":"20240526233352-oftiyeh","Type":"NodeParagraph","Properties":{"id":"20240526233352-oftiyeh","updated":"20240526233353"},"Children":[{"Type":"NodeText","Data":"下面简单看一下生成的路由代码："}]},{"ID":"20240526233352-i207soj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240526233352-i207soj","updated":"20240526233353"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func RegisterHandlers(server *rest.Server, serverCtx *svc.ServiceContext) {\n    server.AddRoutes(\n        []rest.Route{\n            {\n                Method:  http.MethodGet,\n                Path:    \"/users\",\n                Handler: usersv1Handler(serverCtx),\n            },\n        },\n        rest.WithPrefix(\"/v1\"),\n    )\n\n    server.AddRoutes(\n        []rest.Route{\n            {\n                Method:  http.MethodGet,\n                Path:    \"/users\",\n                Handler: usersv2Handler(serverCtx),\n            },\n        },\n        rest.WithPrefix(\"/v2\"),\n    )\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240526233352-2cg1l0g","Type":"NodeParagraph","Properties":{"id":"20240526233352-2cg1l0g","updated":"20240526233353"},"Children":[{"Type":"NodeText","Data":"在上文中，我们可以看到，我们声明的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"prefix"},{"Type":"NodeText","Data":"​ 其实在生成代码后通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"rest.WithPrefix"},{"Type":"NodeText","Data":"​ 来声明了路由前缀，这样我们就可以通过路由前缀来区分不同的版本了。"}]}]}