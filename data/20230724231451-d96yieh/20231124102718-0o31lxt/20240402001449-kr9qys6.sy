{"ID":"20240402001449-kr9qys6","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f418","id":"20240402001449-kr9qys6","tags":"公众号-刘丹冰Aceld,未完成","title":"深入理解Golang协程调度GPM","updated":"20240402011726"},"Children":[{"ID":"20240402001514-trz3qc6","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240402001514-trz3qc6","updated":"20240402001627"},"Children":[{"Type":"NodeText","Data":"一、Golang “调度器” 的由来"}]},{"ID":"20240402001627-549j6c2","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240402001627-549j6c2","updated":"20240402001645"},"Children":[{"Type":"NodeText","Data":"（1）单进程时代不需要调度器"}]},{"ID":"20240402001654-6y085mr","Type":"NodeParagraph","Properties":{"id":"20240402001654-6y085mr","updated":"20240402001654"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是“单进程时代”"}]},{"ID":"20240402001654-nqcaww9","Type":"NodeParagraph","Properties":{"id":"20240402001654-nqcaww9","updated":"20240402001654"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"一切的程序只能串行发生。"}]},{"ID":"20240402001654-vqg10gq","Type":"NodeParagraph","Properties":{"id":"20240402001654-vqg10gq","updated":"20240402004416"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://cdn.nlark.com/yuque/0/2022/png/26269664/1650776039816-a8a5efb6-06be-4984-bfb0-7565c14b0a61.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_45%2Ctext_5YiY5Li55YawQWNlbGQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240402001449-n81lb1z","Type":"NodeParagraph","Properties":{"id":"20240402001449-n81lb1z","updated":"20240402001721"},"Children":[{"Type":"NodeText","Data":"早期的单进程操作系统，面临两个问题："}]},{"ID":"20240402001721-tps0n0e","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240402001721-tps0n0e","updated":"20240402001722"},"Children":[{"ID":"20240402001722-sde90zx","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240402001722-sde90zx","updated":"20240402001722"},"Children":[{"ID":"20240402001722-k8gwxsm","Type":"NodeParagraph","Properties":{"id":"20240402001722-k8gwxsm","updated":"20240402001741"},"Children":[{"Type":"NodeText","Data":"单一的执行流程，计算机只能一个任务一个任务处理"}]}]},{"ID":"20240402001741-bsblyw7","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240402001741-bsblyw7"},"Children":[{"ID":"20240402001741-sis09v5","Type":"NodeParagraph","Properties":{"id":"20240402001741-sis09v5","updated":"20240402001753"},"Children":[{"Type":"NodeText","Data":"进程阻塞带来的CPU时间浪费"}]}]}]},{"ID":"20240402001754-zfefs9q","Type":"NodeParagraph","Properties":{"id":"20240402001754-zfefs9q","updated":"20240402001832"},"Children":[{"Type":"NodeText","Data":"那么能不能有多个进程来宏观一起来执行多个任务呢?"}]},{"ID":"20240402001832-6gqnjbm","Type":"NodeParagraph","Properties":{"id":"20240402001832-6gqnjbm","updated":"20240402002450"},"Children":[{"Type":"NodeText","Data":"后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。"}]},{"ID":"20240402002450-0pouojz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240402002450-0pouojz","updated":"20240402002521"},"Children":[{"Type":"NodeText","Data":"（2）多进程/线程时代有了调度器的需求"}]},{"ID":"20240402002529-4cxq3yh","Type":"NodeParagraph","Properties":{"id":"20240402002529-4cxq3yh","updated":"20240402004415"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240402002529-k7ojiws.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240402002335-2m8kiwp","Type":"NodeParagraph","Properties":{"id":"20240402002335-2m8kiwp","updated":"20240402002621"},"Children":[{"Type":"NodeText","Data":"在多进程/多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。"}]},{"ID":"20240402002606-ebav361","Type":"NodeParagraph","Properties":{"id":"20240402002606-ebav361","updated":"20240402002618"},"Children":[{"Type":"NodeText","Data":"但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。"}]},{"ID":"20240402002631-kider7a","Type":"NodeParagraph","Properties":{"id":"20240402002631-kider7a","updated":"20240402002631"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"怎么才能提高CPU的利用率呢？"}]},{"ID":"20240402002631-7qc05tq","Type":"NodeParagraph","Properties":{"id":"20240402002631-7qc05tq","updated":"20240402002634"},"Children":[{"Type":"NodeText","Data":"但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。"}]},{"ID":"20240402002639-vm2el8q","Type":"NodeParagraph","Properties":{"id":"20240402002639-vm2el8q","updated":"20240402004413"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240402002639-gb0wc12.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240402002650-s4pdtf9","Type":"NodeParagraph","Properties":{"id":"20240402002650-s4pdtf9","updated":"20240402002652"},"Children":[{"Type":"NodeText","Data":"很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。"}]},{"ID":"20240402002650-iip8qp7","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240402002650-iip8qp7","updated":"20240402002717"},"Children":[{"Type":"NodeText","Data":"（3） 协程来提高CPU利用率"}]},{"ID":"20240402002717-lltpzrm","Type":"NodeParagraph","Properties":{"id":"20240402002717-lltpzrm","updated":"20240402002729"},"Children":[{"Type":"NodeText","Data":"多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。"}]},{"ID":"20240402002653-6agyzgr","Type":"NodeParagraph","Properties":{"id":"20240402002653-6agyzgr","updated":"20240402002749"},"Children":[{"Type":"NodeText","Data":"大量的进程/线程出现了新的问题"}]},{"ID":"20240402002751-9d5arzj","Type":"NodeList","ListData":{},"Properties":{"id":"20240402002751-9d5arzj","updated":"20240402002751"},"Children":[{"ID":"20240402002751-cgy37d8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240402002751-cgy37d8","updated":"20240402002751"},"Children":[{"ID":"20240402002751-6cxojrg","Type":"NodeParagraph","Properties":{"id":"20240402002751-6cxojrg","updated":"20240402002755"},"Children":[{"Type":"NodeText","Data":"高内存占用"}]}]},{"ID":"20240402002755-whdkw52","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240402002755-whdkw52"},"Children":[{"ID":"20240402002755-gpo838l","Type":"NodeParagraph","Properties":{"id":"20240402002755-gpo838l","updated":"20240402002806"},"Children":[{"Type":"NodeText","Data":"调度的高消耗CPU"}]}]}]},{"ID":"20240402002806-f31tbgo","Type":"NodeParagraph","Properties":{"id":"20240402002806-f31tbgo","updated":"20240402002917"},"Children":[{"Type":"NodeText","Data":"好了，然后工程师们就发现，其实一个线程分为 “内核态” 线程和“用户态” 线程。"}]},{"ID":"20240402002917-yh0zle9","Type":"NodeParagraph","Properties":{"id":"20240402002917-yh0zle9","updated":"20240402003042"},"Children":[{"Type":"NodeText","Data":"一个 “用户态线程”必须要绑定一个 “内核态线程”，但是 CPU并不知道有“用户态线程”的存在，他只知道它运行的是一个“内核态线程” （Linux 的PCB进程控制块）。"}]},{"ID":"20240402003050-8h5yixj","Type":"NodeParagraph","Properties":{"id":"20240402003050-8h5yixj","updated":"20240402004412"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240402003050-tx0y6mz.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240402003052-e8tcw1m","Type":"NodeParagraph","Properties":{"id":"20240402003052-e8tcw1m","updated":"20240402003139"},"Children":[{"Type":"NodeText","Data":"这样，我们再去细化去分类一下，内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)\"."}]},{"ID":"20240402003112-ik1r2ru","Type":"NodeParagraph","Properties":{"id":"20240402003112-ik1r2ru","updated":"20240402004411"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240402003112-rdf7ns0.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240402003114-z4zri6d","Type":"NodeParagraph","Properties":{"id":"20240402003114-z4zri6d","updated":"20240402003132"},"Children":[{"Type":"NodeText","Data":"看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。"}]},{"ID":"20240402003123-jkqcfi4","Type":"NodeParagraph","Properties":{"id":"20240402003123-jkqcfi4","updated":"20240402003154"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"之后，我们就看到了有3种协程和线程的映射关系："}]},{"ID":"20240402003144-oc2j6at","Type":"NodeBlockquote","Properties":{"id":"20240402003144-oc2j6at","updated":"20240402003208"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240402003159-6vg6ptk","Type":"NodeParagraph","Properties":{"id":"20240402003159-6vg6ptk","updated":"20240402003207"},"Children":[{"Type":"NodeText","Data":"N:1关系"}]}]},{"ID":"20240402003208-wn393gm","Type":"NodeParagraph","Properties":{"id":"20240402003208-wn393gm","updated":"20240402003341"},"Children":[{"Type":"NodeText","Data":"N个协程绑定一个吸纳成，优点就是 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。"},{"Type":"NodeText","Data":" 但是也有很大的缺点，1个进程的所有协程都绑定在1个线程上。"}]},{"ID":"20240402003341-yml0odo","Type":"NodeParagraph","Properties":{"id":"20240402003341-yml0odo","updated":"20240402003349"},"Children":[{"Type":"NodeText","Data":"缺点："}]},{"ID":"20240402003350-yz4t2kn","Type":"NodeList","ListData":{},"Properties":{"id":"20240402003350-yz4t2kn","updated":"20240402003449"},"Children":[{"ID":"20240402003351-poepou5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240402003351-poepou5","updated":"20240402003351"},"Children":[{"ID":"20240402003351-kmn6yfn","Type":"NodeParagraph","Properties":{"id":"20240402003351-kmn6yfn","updated":"20240402003406"},"Children":[{"Type":"NodeText","Data":"某个程序用不了硬件的多核加速能力"}]}]},{"ID":"20240402003406-1z1uduf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240402003406-1z1uduf","updated":"20240402003449"},"Children":[{"ID":"20240402003406-sewa1q3","Type":"NodeParagraph","Properties":{"id":"20240402003406-sewa1q3","updated":"20240402003449"},"Children":[{"Type":"NodeText","Data":"一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。"}]}]}]},{"ID":"20240402003517-9gaytmd","Type":"NodeParagraph","Properties":{"id":"20240402003517-9gaytmd","updated":"20240402004409"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240402003517-8vgtfkl.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240402003520-xqdt9zp","Type":"NodeBlockquote","Properties":{"id":"20240402003520-xqdt9zp","updated":"20240402003536"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240402003528-xuehctk","Type":"NodeParagraph","Properties":{"id":"20240402003528-xuehctk","updated":"20240402003535"},"Children":[{"Type":"NodeText","Data":"1:1 关系"}]}]},{"ID":"20240402003536-k9mfpdp","Type":"NodeParagraph","Properties":{"id":"20240402003536-k9mfpdp","updated":"20240402003619"},"Children":[{"Type":"NodeText","Data":"1个协程绑定1 个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N：1缺点。"}]},{"ID":"20240402003620-ciuz4sd","Type":"NodeParagraph","Properties":{"id":"20240402003620-ciuz4sd","updated":"20240402003624"},"Children":[{"Type":"NodeText","Data":"缺点："}]},{"ID":"20240402003624-oozxh8d","Type":"NodeList","ListData":{},"Properties":{"id":"20240402003624-oozxh8d","updated":"20240402003659"},"Children":[{"ID":"20240402003626-h8310z6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240402003626-h8310z6","updated":"20240402003659"},"Children":[{"ID":"20240402003626-h5jtyj8","Type":"NodeParagraph","Properties":{"id":"20240402003626-h5jtyj8","updated":"20240402003659"},"Children":[{"Type":"NodeText","Data":"协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。"}]}]}]},{"ID":"20240402003705-rgxe6b3","Type":"NodeParagraph","Properties":{"id":"20240402003705-rgxe6b3","updated":"20240402004408"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240402003705-2wovcj6.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240402003710-ounsefh","Type":"NodeBlockquote","Properties":{"id":"20240402003710-ounsefh","updated":"20240402003720"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240402003711-33hr0bx","Type":"NodeParagraph","Properties":{"id":"20240402003711-33hr0bx","updated":"20240402003720"},"Children":[{"Type":"NodeText","Data":"M:N 关系"}]}]},{"ID":"20240402003720-0max52e","Type":"NodeParagraph","Properties":{"id":"20240402003720-0max52e","updated":"20240402003829"},"Children":[{"Type":"NodeText","Data":"M个协程绑定N个线程，是 N:1 和 1:1 类型的结合，克服了以上两种模型的缺点，但实现起来最为复杂。"}]},{"ID":"20240402003838-er9we8t","Type":"NodeParagraph","Properties":{"id":"20240402003838-er9we8t","updated":"20240402004406"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240402003837-qud63nz.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240402003839-ue09kxo","Type":"NodeParagraph","Properties":{"id":"20240402003839-ue09kxo","updated":"20240402004023"},"Children":[{"Type":"NodeText","Data":"协程跟线程是有区别的，线程由CPU调度是抢占式的，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"协程由用户态调度是协作式的"},{"Type":"NodeText","Data":"，一个协程让出CPU后，才执行下一个协程。"}]},{"ID":"20240402004021-83vlq7d","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240402004021-83vlq7d","updated":"20240402004139"},"Children":[{"Type":"NodeText","Data":"（4）Go语言的协程 goroutine"}]},{"ID":"20240402004154-u5wnj8d","Type":"NodeParagraph","Properties":{"id":"20240402004154-u5wnj8d","updated":"20240402004259"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Go为了提供更容易使用的并发方法，使用了goroutine和channel。"},{"Type":"NodeText","Data":"goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"runtime"},{"Type":"NodeText","Data":"​调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。"}]},{"ID":"20240402004154-w9oo2c1","Type":"NodeParagraph","Properties":{"id":"20240402004154-w9oo2c1","updated":"20240402004251"},"Children":[{"Type":"NodeText","Data":"Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"runtime"},{"Type":"NodeText","Data":"​会自动为goroutine分配。"}]},{"ID":"20240402004154-t7lbe5s","Type":"NodeParagraph","Properties":{"id":"20240402004154-t7lbe5s","updated":"20240402004154"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Goroutine特点："}]},{"ID":"20240402004154-z43twld","Type":"NodeList","ListData":{},"Properties":{"id":"20240402004154-z43twld","updated":"20240402004154"},"Children":[{"ID":"20240402004154-bp3u3jj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240402004154-bp3u3jj","updated":"20240402004154"},"Children":[{"ID":"20240402004154-hxdmyqc","Type":"NodeParagraph","Properties":{"id":"20240402004154-hxdmyqc","updated":"20240402004154"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"占用内存更小（几kb）"}]}]},{"ID":"20240402004154-dkxmlsl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240402004154-dkxmlsl","updated":"20240402004154"},"Children":[{"ID":"20240402004154-7jrpw66","Type":"NodeParagraph","Properties":{"id":"20240402004154-7jrpw66","updated":"20240402004154"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"调度更灵活(runtime调度)"}]}]}]},{"ID":"20240402004300-v094r2b","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240402004300-v094r2b","updated":"20240402004318"},"Children":[{"Type":"NodeText","Data":"(5) 被废弃的goroutine 调度器"}]},{"ID":"20240402004334-7qvduu7","Type":"NodeParagraph","Properties":{"id":"20240402004334-7qvduu7","updated":"20240402004340"},"Children":[{"Type":"NodeText","Data":"好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。"}]},{"ID":"20240402004334-qxbxeki","Type":"NodeParagraph","Properties":{"id":"20240402004334-qxbxeki","updated":"20240402004338"},"Children":[{"Type":"NodeText","Data":"Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？"}]},{"ID":"20240402004334-26i2fqm","Type":"NodeParagraph","Properties":{"id":"20240402004334-26i2fqm","updated":"20240402004336"},"Children":[{"Type":"NodeText","Data":"大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。"}]},{"ID":"20240402004353-ubtxhmq","Type":"NodeParagraph","Properties":{"id":"20240402004353-ubtxhmq","updated":"20240402004402"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240402004353-wdc9kt4.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240402004422-5bzrl2w","Type":"NodeParagraph","Properties":{"id":"20240402004422-5bzrl2w","updated":"20240402004448"},"Children":[{"Type":"NodeText","Data":"下面我们来看看被废弃的golang调度器是如何实现的？"}]},{"ID":"20240402004453-i8287iq","Type":"NodeParagraph","Properties":{"id":"20240402004453-i8287iq","updated":"20240402004455"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240402004453-hbp3049.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240402004502-5jo8iya","Type":"NodeParagraph","Properties":{"id":"20240402004502-5jo8iya","updated":"20240402004510"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。"}]},{"ID":"20240402004512-bludl3h","Type":"NodeParagraph","Properties":{"id":"20240402004512-bludl3h","updated":"20240402004529"},"Children":[{"Type":"NodeText","Data":"老调度器有几个缺点："}]},{"ID":"20240402004529-ephs1ew","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240402004529-ephs1ew","updated":"20240402004902"},"Children":[{"ID":"20240402004531-08q53yc","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240402004531-08q53yc","updated":"20240402004531"},"Children":[{"ID":"20240402004531-p7jnxjs","Type":"NodeParagraph","Properties":{"id":"20240402004531-p7jnxjs","updated":"20240402004554"},"Children":[{"Type":"NodeText","Data":"创建、销毁、调度G都需要每个M获取锁，这就形成了锁的竞争"}]}]},{"ID":"20240402004555-pyqtbh3","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240402004555-pyqtbh3"},"Children":[{"ID":"20240402004555-g5w4guc","Type":"NodeParagraph","Properties":{"id":"20240402004555-g5w4guc","updated":"20240402004814"},"Children":[{"Type":"NodeText","Data":"M 转移G会造成延迟和额外的系统负载，比如当G中包含创建新协程的时候，M创建了G‘，为了继续执行G，需要把G’ 交给 M‘ 执行，也造成了"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"很差的局部性，"},{"Type":"NodeText","Data":"因为 G’和G 是相关的，最好放在M上执行，而不是其他M‘"}]}]},{"ID":"20240402004819-kffmhny","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240402004819-kffmhny","updated":"20240402004902"},"Children":[{"ID":"20240402004819-p7f75cw","Type":"NodeParagraph","Properties":{"id":"20240402004819-p7f75cw","updated":"20240402004902"},"Children":[{"Type":"NodeText","Data":"系统调用（CPU在M之间的切换）导致频繁的线程阻塞和取消阻塞增加了系统的开销"}]}]}]},{"ID":"20240402004915-e9qchpk","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240402004915-e9qchpk","updated":"20240402004933"},"Children":[{"Type":"NodeText","Data":"二、Goroutine 调度器的GMP 模型的设计思想"}]},{"ID":"20240402004950-drl8m2u","Type":"NodeParagraph","Properties":{"id":"20240402004950-drl8m2u","updated":"20240402005012"},"Children":[{"Type":"NodeText","Data":"面都之前的调度器的问题，Go设计了新的调度器。"}]},{"ID":"20240402005012-qmygneu","Type":"NodeParagraph","Properties":{"id":"20240402005012-qmygneu","updated":"20240402005054"},"Children":[{"Type":"NodeText","Data":"在新的调度器中，除了M thread 和 G goroutine ，又引进了P Processor"}]},{"ID":"20240402005102-swqjkc0","Type":"NodeParagraph","Properties":{"id":"20240402005102-swqjkc0","updated":"20240402005110"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240402005102-pdninne.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240402005115-1yfprng","Type":"NodeParagraph","Properties":{"id":"20240402005115-1yfprng","updated":"20240402005116"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列"}]},{"ID":"20240402004934-cqcc6jg","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240402004934-cqcc6jg","updated":"20240402004945"},"Children":[{"Type":"NodeText","Data":"（1）GMP 模型"}]},{"ID":"20240402004945-6hs5a4g","Type":"NodeParagraph","Properties":{"id":"20240402004945-6hs5a4g","updated":"20240402005218"},"Children":[{"Type":"NodeText","Data":"在Go 中，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"线程是运行goroutine 的实体，调度器的功能是把可运行的goroutine 分配到工作线程上。"}]},{"ID":"20240402005225-66qusi5","Type":"NodeParagraph","Properties":{"id":"20240402005225-66qusi5","updated":"20240402005229"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240402005225-5m365qx.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240402010529-41lv5sc","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240402010529-41lv5sc","updated":"20240402010645"},"Children":[{"ID":"20240402010529-v5qd7nd","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240402010529-v5qd7nd","updated":"20240402010645"},"Children":[{"ID":"20240402010529-52dyv01","Type":"NodeParagraph","Properties":{"id":"20240402010529-52dyv01","updated":"20240402010645"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"全局队列（Global Queue）："},{"Type":"NodeText","Data":"存放等待运行的G。"}]}]},{"ID":"20240402010529-9m1ota7","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240402010529-9m1ota7","updated":"20240402010638"},"Children":[{"ID":"20240402010529-85cegfv","Type":"NodeParagraph","Properties":{"id":"20240402010529-85cegfv","updated":"20240402010638"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"P的本地队列："},{"Type":"NodeText","Data":"同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。"}]}]},{"ID":"20240402010529-ptne1dq","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240402010529-ptne1dq","updated":"20240402010631"},"Children":[{"ID":"20240402010529-l89s0dn","Type":"NodeParagraph","Properties":{"id":"20240402010529-l89s0dn","updated":"20240402010631"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"P列表："},{"Type":"NodeText","Data":"所有的P都在程序启动时创建，并保存在数组中，最多有"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GOMAXPROCS"},{"Type":"NodeText","Data":"​(可配置)个。"}]}]},{"ID":"20240402010529-zzn2f8g","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20240402010529-zzn2f8g","updated":"20240402010621"},"Children":[{"ID":"20240402010529-hretek1","Type":"NodeParagraph","Properties":{"id":"20240402010529-hretek1","updated":"20240402010621"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"M："},{"Type":"NodeText","Data":"线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"拿"},{"Type":"NodeText","Data":"一批G放到P的本地队列，或从其他P的本地队列"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"偷"},{"Type":"NodeText","Data":"一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。"}]}]}]},{"ID":"20240402010622-o9zr8f5","Type":"NodeParagraph","Properties":{"id":"20240402010622-o9zr8f5","updated":"20240402011647"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行。"}]},{"ID":"20240402011700-9ype9uc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240402011700-9ype9uc","updated":"20240402011700"},"Children":[{"Type":"NodeText","Data":"有关P和M的个数问题"}]},{"ID":"20240402011700-cee0eca","Type":"NodeParagraph","Properties":{"id":"20240402011700-cee0eca","updated":"20240402011701"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1、P的数量："}]},{"ID":"20240402011700-ur2vqqu","Type":"NodeList","ListData":{},"Properties":{"id":"20240402011700-ur2vqqu","updated":"20240402011726"},"Children":[{"ID":"20240402011700-326l8y2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240402011700-326l8y2","updated":"20240402011726"},"Children":[{"ID":"20240402011700-rtmmb4a","Type":"NodeParagraph","Properties":{"id":"20240402011700-rtmmb4a","updated":"20240402011726"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"由启动时环境变量"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"$GOMAXPROCS"},{"Type":"NodeText","Data":"​或者是由"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"runtime"},{"Type":"NodeText","Data":"​的方法"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GOMAXPROCS()"},{"Type":"NodeText","Data":"​决定。这意味着在程序执行的任意时刻都只有"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"$GOMAXPROCS"},{"Type":"NodeText","Data":"​个goroutine在同时运行。"}]}]}]},{"ID":"20240402011700-x0k5ols","Type":"NodeParagraph","Properties":{"id":"20240402011700-x0k5ols","updated":"20240402011701"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"2、M的数量:"}]},{"ID":"20240402011700-smu9a9f","Type":"NodeList","ListData":{},"Properties":{"id":"20240402011700-smu9a9f","updated":"20240402011701"},"Children":[{"ID":"20240402011700-41u0kk9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240402011700-41u0kk9","updated":"20240402011700"},"Children":[{"ID":"20240402011700-x0pp279","Type":"NodeParagraph","Properties":{"id":"20240402011700-x0pp279","updated":"20240402011700"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。"}]}]},{"ID":"20240402011700-mofrjx2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240402011700-mofrjx2","updated":"20240402011700"},"Children":[{"ID":"20240402011700-2a7fx3o","Type":"NodeParagraph","Properties":{"id":"20240402011700-2a7fx3o","updated":"20240402011700"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"runtime/debug中的SetMaxThreads函数，设置M的最大数量"}]}]},{"ID":"20240402011700-gdgz1da","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240402011700-gdgz1da","updated":"20240402011700"},"Children":[{"ID":"20240402011700-n77ekjf","Type":"NodeParagraph","Properties":{"id":"20240402011700-n77ekjf","updated":"20240402011700"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"一个M阻塞了，会创建新的M。"}]}]}]},{"ID":"20240402011700-nwzvkt9","Type":"NodeParagraph","Properties":{"id":"20240402011700-nwzvkt9","updated":"20240402011701"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。"}]},{"ID":"20240402011700-iiq2eq8","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240402011700-iiq2eq8","updated":"20240402011700"},"Children":[{"Type":"NodeText","Data":"P和M何时会被创建"}]},{"ID":"20240402011700-f4s6kpn","Type":"NodeParagraph","Properties":{"id":"20240402011700-f4s6kpn","updated":"20240402011701"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。"}]},{"ID":"20240402011700-8h68w7z","Type":"NodeParagraph","Properties":{"id":"20240402011700-8h68w7z","updated":"20240402011701"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。"}]}]}