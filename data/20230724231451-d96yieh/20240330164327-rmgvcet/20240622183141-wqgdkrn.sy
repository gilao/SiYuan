{"ID":"20240622183141-wqgdkrn","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f418","id":"20240622183141-wqgdkrn","title":"钩子函数 Hook Function","type":"doc","updated":"20240622202014"},"Children":[{"ID":"20240622183239-282fk6j","Type":"NodeParagraph","Properties":{"id":"20240622183239-282fk6j","updated":"20240622183454"},"Children":[{"Type":"NodeText","Data":"在Go语言中，钩子函数（Hook Function） 是一种特殊类型的函数，它在特定的事件或程序生命周期的某些阶段自动被调用，允许开发者插入自定义的逻辑而无需修改原有的代码结构。"}]},{"ID":"20240622183454-0rvvkj4","Type":"NodeParagraph","Properties":{"id":"20240622183454-0rvvkj4","updated":"20240622194552"},"Children":[{"Type":"NodeText","Data":"钩子函数常用于扩展框架，库或者应用程序的行为，尤其是在事件驱动编程、插件系统、AOP(面向切面编程)等方面"}]},{"ID":"20240622194553-0yglydm","Type":"NodeParagraph","Properties":{"id":"20240622194553-0yglydm","updated":"20240622194627"},"Children":[{"Type":"NodeText","Data":"Go语言通过以下几种方式实现钩子的功能"}]},{"ID":"20240622194627-tm0fwk2","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240622194627-tm0fwk2","updated":"20240622201724"},"Children":[{"ID":"20240622194630-6o4ovcu","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240622194630-6o4ovcu","updated":"20240622194630"},"Children":[{"ID":"20240622194630-qecaoc6","Type":"NodeParagraph","Properties":{"id":"20240622194630-qecaoc6","updated":"20240622195113"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"接口与多态"},{"Type":"NodeText","Data":"：通过定义接口，要求类型实现特定的方法。这可以视为简单的钩子机制，可以为特定时间或过程提供自定义实现。例如在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"database/sql"},{"Type":"NodeText","Data":"​包中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"sql.DB"},{"Type":"NodeText","Data":"​的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"SetConnMaxLifetime"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"SetMaxOpenConns"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"SetMaxIdleConns"},{"Type":"NodeText","Data":"​等方法可以看作是对数据库连接池行为的配置钩子。"}]},{"ID":"20240622201220-jywuv0o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240622201220-jywuv0o","updated":"20240622201518"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Hook interface {\n  Execute()\n}\n\ntype MyHook struct {}\nfunc (h MyHook) Execute() {\n  // 钩子逻辑\n}\n\nfunc main() {\n  var hook Hook MyHook{}\n  hook.Execute()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20240622195351-iup699i","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240622195351-iup699i"},"Children":[{"ID":"20240622195351-su7z5r7","Type":"NodeParagraph","Properties":{"id":"20240622195351-su7z5r7","updated":"20240622195508"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"闭包 Closures"},{"Type":"NodeText","Data":" 闭包允许你定义一个匿名函数，并在函数内部访问外部函数的变量。"}]},{"ID":"20240622201043-3ch72ti","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240622201043-3ch72ti","updated":"20240622201132"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n  x := 10\n  hook := func () {\n    fmt.Println(x)\n  }\n  hook()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20240622194917-4655mz2","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240622194917-4655mz2"},"Children":[{"ID":"20240622194917-p09492s","Type":"NodeParagraph","Properties":{"id":"20240622194917-p09492s","updated":"20240622195117"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"中间件模式"},{"Type":"NodeText","Data":"：在web框架中，如Gin或Echo，中间件是一种常用的钩子实现方式。开发者可以定义函数，这些函数在HTTP请求处理流程中的特定点被调用，比如请求前、请求后或错误发生时，从而插入自定义的处理逻辑"}]}]},{"ID":"20240622195105-6z4arxm","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20240622195105-6z4arxm"},"Children":[{"ID":"20240622195105-vwscnf0","Type":"NodeParagraph","Properties":{"id":"20240622195105-vwscnf0","updated":"20240622195229"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"结构体嵌入与方法覆盖："},{"Type":"NodeText","Data":"通过嵌入结构体并覆盖其方法，可以在保留原始行为的同时插入额外的操作。这在某些场景下可以作为钩子使用。"}]}]},{"ID":"20240622194721-oz2h2x7","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20240622194721-oz2h2x7"},"Children":[{"ID":"20240622194721-34eo4ix","Type":"NodeParagraph","Properties":{"id":"20240622194721-34eo4ix","updated":"20240622201003"},"Children":[{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"函数回调"},{"Type":"NodeText","Data":"：在Go中，回调函数是一种常见的实现钩子函数的方式。函数可以作为参数传递，这样可以在特定时刻调用这些函数。例如，在HTTP服务器中，你可以为不同的路由注册不同的处理函数。"}]},{"ID":"20240622195517-thhbzar","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240622195517-thhbzar","updated":"20240622200930"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"http.HandleFunc(\"/hook\", func(w http.ResponseWriter, r *http.Request) {\n    // 钩子逻辑\n})\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20240622195254-gumz2dv","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Ni4=","Num":6},"Properties":{"id":"20240622195254-gumz2dv"},"Children":[{"ID":"20240622195254-v046tdl","Type":"NodeParagraph","Properties":{"id":"20240622195254-v046tdl","updated":"20240622195316"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"第三方库的钩子机制："},{"Type":"NodeText","Data":" "},{"Type":"NodeText","Data":"一些第三方库，如ORM框架GORM，提供了钩子接口，允许用户在模型的保存、更新、删除等操作前后执行自定义的代码。"}]}]},{"ID":"20240622201549-q2j33dh","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Ny4=","Num":7},"Properties":{"id":"20240622201549-q2j33dh","updated":"20240622201724"},"Children":[{"ID":"20240622201549-rc3gc6y","Type":"NodeParagraph","Properties":{"id":"20240622201549-rc3gc6y","updated":"20240622201710"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"通道 Channels"},{"Type":"NodeText","Data":"  Go的通道可以用来多个goroutine 之间传递消息。可以通过发送消息到通道来触发钩子函数"}]},{"ID":"20240622201710-il5lww4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240622201710-il5lww4","updated":"20240622201724"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    hookChan := make(chan bool)\n\n    go func() {\n        for {\n            \u003c-hookChan\n            // 钩子逻辑\n        }\n    }()\n\n    hookChan \u003c- true\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}]},{"ID":"20240622183205-0d0s634","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240622183205-0d0s634","updated":"20240622202014"},"Children":[{"ID":"20240622201726-uuxf3d1","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"OC4=","Num":8},"Properties":{"id":"20240622201726-uuxf3d1","updated":"20240622202014"},"Children":[{"ID":"20240622201726-ie1ytll","Type":"NodeParagraph","Properties":{"id":"20240622201726-ie1ytll","updated":"20240622201927"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"依赖注入"},{"Type":"NodeText","Data":" 通过依赖注入，可以将钩子函数作为参数传递给他们的组件。"}]},{"ID":"20240622201937-ta2in8s","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240622201937-ta2in8s","updated":"20240622202013"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Component struct {\n    Hook func()\n}\n\nfunc main() {\n    c := Component{\n        Hook: func() {\n            // 钩子逻辑\n        },\n    }\n    c.Hook()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240622202014-ag7hdeb","Type":"NodeParagraph","Properties":{"id":"20240622202014-ag7hdeb"}}]}]}]}