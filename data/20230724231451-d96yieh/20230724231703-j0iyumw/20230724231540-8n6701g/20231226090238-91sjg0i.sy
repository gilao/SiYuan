{"ID":"20231226090238-91sjg0i","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231226090238-91sjg0i","title":"Expvar 包","updated":"20231226095919"},"Children":[{"ID":"20231226090304-dn6r3rj","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231226090304-dn6r3rj","updated":"20231226090311"},"Children":[{"Type":"NodeText","Data":"介绍与使用"}]},{"ID":"20231226090317-2hj37le","Type":"NodeParagraph","Properties":{"id":"20231226090317-2hj37le","updated":"20231226090317"},"Children":[{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"expvar 是 exposed variable的简写"}]},{"ID":"20231226090317-z95wd1q","Type":"NodeParagraph","Properties":{"id":"20231226090317-z95wd1q","updated":"20231226090317"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fcuishuang%2Fgo1.16%2Ftree%2Fmaster%2Fsrc%2Fexpvar","TextMarkATitle":"https://gitee.com/cuishuang/go1.16/tree/master/src/expvar","TextMarkTextContent":"expvar包"},{"Type":"NodeText","Data":"是 Golang 官方为暴露Go应用内部指标数据所提供的标准对外接口，可以辅助获取和调试全局变量。"}]},{"ID":"20231226090317-iq5abu7","Type":"NodeParagraph","Properties":{"id":"20231226090317-iq5abu7","updated":"20231226090317"},"Children":[{"Type":"NodeText","Data":"其通过init函数将内置的expvarHandler(一个标准http HandlerFunc)注册到http包ListenAndServe创建的默认Server上"}]},{"ID":"20231226090517-l6ntpqd","Type":"NodeParagraph","Properties":{"id":"20231226090517-l6ntpqd","updated":"20231226090521"},"Children":[{"Type":"NodeText","Data":"如下案例："}]},{"ID":"20231226090522-3e09hqv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226090522-3e09hqv","updated":"20231226095601"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"encoding/json\"\n\t\"expvar\"\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"runtime\"\n\t\"time\"\n)\n\nfunc main() {\n\trouter := gin.Default() //初始化一个gin实例\n\n\trouter.GET(\"/debug/vars\", GetCurrentRunningStats) //接口路由，如果url不是/debug/vars，则用metricBeat去获取会出问题\n\trouter.Run(\":8080\")\n}\n\nvar CuMemoryPtr *map[string]string\nvar BTCMemoryPtr *map[string]interface{}\n\n// 开始时间\nvar start = time.Now()\n\n// calculateUptime 计算运行时间\nfunc calculateUptime() interface{} {\n\treturn time.Since(start).String()\n}\n\n// currentGoVersion 当前 Golang 版本\nfunc currentGoVersion() interface{} {\n\treturn runtime.Version()\n}\n\n// getNumCPUs 获取 CPU 核心数量\nfunc getNumCPUs() interface{} {\n\treturn runtime.NumCPU()\n}\n\n// getGoOS 当前系统类型\nfunc getGoOS() interface{} {\n\treturn runtime.GOOS\n}\n\n// getNumGoroutins 当前 goroutine 数量\nfunc getNumGoroutins() interface{} {\n\treturn runtime.NumGoroutine()\n}\n\n// getNumCgoCall CGo 调用次数\nfunc getNumCgoCall() interface{} {\n\treturn runtime.NumCgoCall()\n}\n\n// 业务特定的内存数据\nfunc getCuMemoryMap() interface{} {\n\tif CuMemoryPtr == nil {\n\t\treturn 0\n\t} else {\n\t\treturn len(*CuMemoryPtr)\n\t}\n}\n\n// 业务特定的内存数据\nfunc getBTCMemoryMap() interface{} {\n\tif BTCMemoryPtr == nil {\n\t\treturn 0\n\t} else {\n\t\treturn len(*BTCMemoryPtr)\n\t}\n}\n\nvar lastPause uint32\n\n// getLastGCPauseTime 获取上次 GC 的暂停时间\nfunc getLastGCPauseTime() interface{} {\n\tvar gcPause uint64\n\tms := new(runtime.MemStats)\n\n\tstatString := expvar.Get(\"memstats\").String()\n\tif statString != \"\" {\n\t\tjson.Unmarshal([]byte(statString), ms)\n\n\t\tif lastPause == 0 || lastPause != ms.NumGC {\n\t\t\tgcPause = ms.PauseNs[(ms.NumGC+255)%256]\n\t\t\tlastPause = ms.NumGC\n\t\t}\n\t}\n\n\treturn gcPause\n}\n\n// GetCurrentRunningStats 返回当前运行信息\nfunc GetCurrentRunningStats(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\n\tfirst := true\n\treport := func(key string, value interface{}) {\n\t\tif !first {\n\t\t\tfmt.Fprintf(c.Writer, \",\\n\")\n\t\t}\n\t\tfirst = false\n\t\tif str, ok := value.(string); ok {\n\t\t\tfmt.Fprintf(c.Writer, \"%q: %q\", key, str)\n\t\t} else {\n\t\t\tfmt.Fprintf(c.Writer, \"%q: %v\", key, value)\n\t\t}\n\t}\n\n\tfmt.Fprintf(c.Writer, \"{\\n\")\n\texpvar.Do(func(kv expvar.KeyValue) {\n\t\treport(kv.Key, kv.Value)\n\t})\n\tfmt.Fprintf(c.Writer, \"\\n}\\n\")\n\n\tc.String(http.StatusOK, \"\")\n}\n\nfunc init() { //这些都是自定义变量，发布到expvar中，每次请求接口，expvar会自动去获取这些变量，并返回\n\texpvar.Publish(\"运行时间\", expvar.Func(calculateUptime))\n\texpvar.Publish(\"version\", expvar.Func(currentGoVersion))\n\texpvar.Publish(\"cores\", expvar.Func(getNumCPUs))\n\texpvar.Publish(\"os\", expvar.Func(getGoOS))\n\texpvar.Publish(\"cgo\", expvar.Func(getNumCgoCall))\n\texpvar.Publish(\"goroutine\", expvar.Func(getNumGoroutins))\n\texpvar.Publish(\"gcpause\", expvar.Func(getLastGCPauseTime))\n\texpvar.Publish(\"CuMemory\", expvar.Func(getCuMemoryMap))\n\texpvar.Publish(\"BTCMemory\", expvar.Func(getBTCMemoryMap))\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226095618-4hjeund","Type":"NodeParagraph","Properties":{"id":"20231226095618-4hjeund","updated":"20231226095633"},"Children":[{"Type":"NodeText","Data":"运行程序，并请求 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"http://localhost:8080/debug/vars"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231226095637-rqtqn1k","Type":"NodeParagraph","Properties":{"id":"20231226095637-rqtqn1k","updated":"20231226095642"},"Children":[{"Type":"NodeText","Data":"结果如下："}]},{"ID":"20231226095700-79rr12d","Type":"NodeParagraph","Properties":{"id":"20231226095700-79rr12d","updated":"20231226095700"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231226095700-eyrt4db.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231226095642-s0an230","Type":"NodeParagraph","Properties":{"id":"20231226095642-s0an230","updated":"20231226095800"},"Children":[{"Type":"NodeText","Data":"其中，expvar包会默认携带"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"memstats"},{"Type":"NodeText","Data":"，该字段内含 各种内存堆栈以及GC的一些信息，具体可见源码注释"}]},{"ID":"20231226095800-qgkp1hq","Type":"NodeParagraph","Properties":{"id":"20231226095800-qgkp1hq","updated":"20231226095812"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"src/runtime/mstats.go"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231226095813-sp8669r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226095813-sp8669r","updated":"20231226095825"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// A MemStats records statistics about the memory allocator.\ntype MemStats struct {\n\t// General statistics.\n\n\t// Alloc is bytes of allocated heap objects.\n\t//\n\t// This is the same as HeapAlloc (see below).\n\tAlloc uint64\n\n\t// TotalAlloc is cumulative bytes allocated for heap objects.\n\t//\n\t// TotalAlloc increases as heap objects are allocated, but\n\t// unlike Alloc and HeapAlloc, it does not decrease when\n\t// objects are freed.\n\tTotalAlloc uint64\n\n\t// Sys is the total bytes of memory obtained from the OS.\n\t//\n\t// Sys is the sum of the XSys fields below. Sys measures the\n\t// virtual address space reserved by the Go runtime for the\n\t// heap, stacks, and other internal data structures. It's\n\t// likely that not all of the virtual address space is backed\n\t// by physical memory at any given moment, though in general\n\t// it all was at some point.\n\tSys uint64\n\n\t// Lookups is the number of pointer lookups performed by the\n\t// runtime.\n\t//\n\t// This is primarily useful for debugging runtime internals.\n\tLookups uint64\n\n\t// Mallocs is the cumulative count of heap objects allocated.\n\t// The number of live objects is Mallocs - Frees.\n\tMallocs uint64\n\n\t// Frees is the cumulative count of heap objects freed.\n\tFrees uint64\n\n\t// Heap memory statistics.\n\t//\n\t// Interpreting the heap statistics requires some knowledge of\n\t// how Go organizes memory. Go divides the virtual address\n\t// space of the heap into \"spans\", which are contiguous\n\t// regions of memory 8K or larger. A span may be in one of\n\t// three states:\n\t//\n\t// An \"idle\" span contains no objects or other data. The\n\t// physical memory backing an idle span can be released back\n\t// to the OS (but the virtual address space never is), or it\n\t// can be converted into an \"in use\" or \"stack\" span.\n\t//\n\t// An \"in use\" span contains at least one heap object and may\n\t// have free space available to allocate more heap objects.\n\t//\n\t// A \"stack\" span is used for goroutine stacks. Stack spans\n\t// are not considered part of the heap. A span can change\n\t// between heap and stack memory; it is never used for both\n\t// simultaneously.\n\n\t// HeapAlloc is bytes of allocated heap objects.\n\t//\n\t// \"Allocated\" heap objects include all reachable objects, as\n\t// well as unreachable objects that the garbage collector has\n\t// not yet freed. Specifically, HeapAlloc increases as heap\n\t// objects are allocated and decreases as the heap is swept\n\t// and unreachable objects are freed. Sweeping occurs\n\t// incrementally between GC cycles, so these two processes\n\t// occur simultaneously, and as a result HeapAlloc tends to\n\t// change smoothly (in contrast with the sawtooth that is\n\t// typical of stop-the-world garbage collectors).\n\tHeapAlloc uint64\n\n\t// HeapSys is bytes of heap memory obtained from the OS.\n\t//\n\t// HeapSys measures the amount of virtual address space\n\t// reserved for the heap. This includes virtual address space\n\t// that has been reserved but not yet used, which consumes no\n\t// physical memory, but tends to be small, as well as virtual\n\t// address space for which the physical memory has been\n\t// returned to the OS after it became unused (see HeapReleased\n\t// for a measure of the latter).\n\t//\n\t// HeapSys estimates the largest size the heap has had.\n\tHeapSys uint64\n\n\t// HeapIdle is bytes in idle (unused) spans.\n\t//\n\t// Idle spans have no objects in them. These spans could be\n\t// (and may already have been) returned to the OS, or they can\n\t// be reused for heap allocations, or they can be reused as\n\t// stack memory.\n\t//\n\t// HeapIdle minus HeapReleased estimates the amount of memory\n\t// that could be returned to the OS, but is being retained by\n\t// the runtime so it can grow the heap without requesting more\n\t// memory from the OS. If this difference is significantly\n\t// larger than the heap size, it indicates there was a recent\n\t// transient spike in live heap size.\n\tHeapIdle uint64\n\n\t// HeapInuse is bytes in in-use spans.\n\t//\n\t// In-use spans have at least one object in them. These spans\n\t// can only be used for other objects of roughly the same\n\t// size.\n\t//\n\t// HeapInuse minus HeapAlloc estimates the amount of memory\n\t// that has been dedicated to particular size classes, but is\n\t// not currently being used. This is an upper bound on\n\t// fragmentation, but in general this memory can be reused\n\t// efficiently.\n\tHeapInuse uint64\n\n\t// HeapReleased is bytes of physical memory returned to the OS.\n\t//\n\t// This counts heap memory from idle spans that was returned\n\t// to the OS and has not yet been reacquired for the heap.\n\tHeapReleased uint64\n\n\t// HeapObjects is the number of allocated heap objects.\n\t//\n\t// Like HeapAlloc, this increases as objects are allocated and\n\t// decreases as the heap is swept and unreachable objects are\n\t// freed.\n\tHeapObjects uint64\n\n\t// Stack memory statistics.\n\t//\n\t// Stacks are not considered part of the heap, but the runtime\n\t// can reuse a span of heap memory for stack memory, and\n\t// vice-versa.\n\n\t// StackInuse is bytes in stack spans.\n\t//\n\t// In-use stack spans have at least one stack in them. These\n\t// spans can only be used for other stacks of the same size.\n\t//\n\t// There is no StackIdle because unused stack spans are\n\t// returned to the heap (and hence counted toward HeapIdle).\n\tStackInuse uint64\n\n\t// StackSys is bytes of stack memory obtained from the OS.\n\t//\n\t// StackSys is StackInuse, plus any memory obtained directly\n\t// from the OS for OS thread stacks (which should be minimal).\n\tStackSys uint64\n\n\t// Off-heap memory statistics.\n\t//\n\t// The following statistics measure runtime-internal\n\t// structures that are not allocated from heap memory (usually\n\t// because they are part of implementing the heap). Unlike\n\t// heap or stack memory, any memory allocated to these\n\t// structures is dedicated to these structures.\n\t//\n\t// These are primarily useful for debugging runtime memory\n\t// overheads.\n\n\t// MSpanInuse is bytes of allocated mspan structures.\n\tMSpanInuse uint64\n\n\t// MSpanSys is bytes of memory obtained from the OS for mspan\n\t// structures.\n\tMSpanSys uint64\n\n\t// MCacheInuse is bytes of allocated mcache structures.\n\tMCacheInuse uint64\n\n\t// MCacheSys is bytes of memory obtained from the OS for\n\t// mcache structures.\n\tMCacheSys uint64\n\n\t// BuckHashSys is bytes of memory in profiling bucket hash tables.\n\tBuckHashSys uint64\n\n\t// GCSys is bytes of memory in garbage collection metadata.\n\tGCSys uint64\n\n\t// OtherSys is bytes of memory in miscellaneous off-heap\n\t// runtime allocations.\n\tOtherSys uint64\n\n\t// Garbage collector statistics.\n\n\t// NextGC is the target heap size of the next GC cycle.\n\t//\n\t// The garbage collector's goal is to keep HeapAlloc ≤ NextGC.\n\t// At the end of each GC cycle, the target for the next cycle\n\t// is computed based on the amount of reachable data and the\n\t// value of GOGC.\n\tNextGC uint64\n\n\t// LastGC is the time the last garbage collection finished, as\n\t// nanoseconds since 1970 (the UNIX epoch).\n\tLastGC uint64\n\n\t// PauseTotalNs is the cumulative nanoseconds in GC\n\t// stop-the-world pauses since the program started.\n\t//\n\t// During a stop-the-world pause, all goroutines are paused\n\t// and only the garbage collector can run.\n\tPauseTotalNs uint64\n\n\t// PauseNs is a circular buffer of recent GC stop-the-world\n\t// pause times in nanoseconds.\n\t//\n\t// The most recent pause is at PauseNs[(NumGC+255)%256]. In\n\t// general, PauseNs[N%256] records the time paused in the most\n\t// recent N%256th GC cycle. There may be multiple pauses per\n\t// GC cycle; this is the sum of all pauses during a cycle.\n\tPauseNs [256]uint64\n\n\t// PauseEnd is a circular buffer of recent GC pause end times,\n\t// as nanoseconds since 1970 (the UNIX epoch).\n\t//\n\t// This buffer is filled the same way as PauseNs. There may be\n\t// multiple pauses per GC cycle; this records the end of the\n\t// last pause in a cycle.\n\tPauseEnd [256]uint64\n\n\t// NumGC is the number of completed GC cycles.\n\tNumGC uint32\n\n\t// NumForcedGC is the number of GC cycles that were forced by\n\t// the application calling the GC function.\n\tNumForcedGC uint32\n\n\t// GCCPUFraction is the fraction of this program's available\n\t// CPU time used by the GC since the program started.\n\t//\n\t// GCCPUFraction is expressed as a number between 0 and 1,\n\t// where 0 means GC has consumed none of this program's CPU. A\n\t// program's available CPU time is defined as the integral of\n\t// GOMAXPROCS since the program started. That is, if\n\t// GOMAXPROCS is 2 and a program has been running for 10\n\t// seconds, its \"available CPU\" is 20 seconds. GCCPUFraction\n\t// does not include CPU time used for write barrier activity.\n\t//\n\t// This is the same as the fraction of CPU reported by\n\t// GODEBUG=gctrace=1.\n\tGCCPUFraction float64\n\n\t// EnableGC indicates that GC is enabled. It is always true,\n\t// even if GOGC=off.\n\tEnableGC bool\n\n\t// DebugGC is currently unused.\n\tDebugGC bool\n\n\t// BySize reports per-size class allocation statistics.\n\t//\n\t// BySize[N] gives statistics for allocations of size S where\n\t// BySize[N-1].Size \u003c S ≤ BySize[N].Size.\n\t//\n\t// This does not report allocations larger than BySize[60].Size.\n\tBySize [61]struct {\n\t\t// Size is the maximum byte size of an object in this\n\t\t// size class.\n\t\tSize uint32\n\n\t\t// Mallocs is the cumulative count of heap objects\n\t\t// allocated in this size class. The cumulative bytes\n\t\t// of allocation is Size*Mallocs. The number of live\n\t\t// objects in this size class is Mallocs - Frees.\n\t\tMallocs uint64\n\n\t\t// Frees is the cumulative count of heap objects freed\n\t\t// in this size class.\n\t\tFrees uint64\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226095825-h2uom85","Type":"NodeParagraph","Properties":{"id":"20231226095825-h2uom85","updated":"20231226095833"},"Children":[{"Type":"NodeText","Data":"对于各个字段的意义 可参考："}]},{"ID":"20231226095834-sfq8aq2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226095834-sfq8aq2","updated":"20231226095838"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"1、Alloc uint64 //Go语言框架 堆空间分配的字节数\n2、TotalAlloc uint64 //从服务开始运行至今分配器为分配的堆空间总和，只增加，释放时不减少\n3、Sys uint64 //服务现在使用的系统内存\n4、Lookups uint64 //被runtime监视的指针数\n5、Mallocs uint64 //服务malloc的次数\n6、Frees uint64 //服务回收的heap objects的字节数\n7、HeapAlloc uint64 //服务分配的堆内存字节数\n8、HeapSys uint64 //系统分配的作为运行栈的内存\n9、HeapIdle uint64 //申请但未分配的堆内存或者回收了的堆内存（空闲）字节数\n10、HeapInuse uint64 //正在使用的堆内存字节数\n10、HeapReleased uint64 //返回给OS的堆内存，类似C/C++中的free\n11、HeapObjects uint64 //堆内存块申请的量\n12、StackInuse uint64 //正在使用的栈字节数\n13、StackSys uint64 //系统分配的作为运行栈的内存\n14、MSpanInuse uint64 //用于测试用的结构体使用的字节数\n15、MSpanSys uint64 //系统为测试用的结构体分配的字节数\n16、MCacheInuse uint64 //mcache结构体申请的字节数(不会被视为垃圾回收)\n17、MCacheSys uint64 //操作系统申请的堆空间用于mcache的字节数\n18、BuckHashSys uint64 //用于剖析桶散列表的堆空间\n19、GCSys uint64 //垃圾回收标记元信息使用的内存\n20、OtherSys uint64 //golang系统架构占用的额外空间\n21、NextGC uint64 //垃圾回收器检视的内存大小\n22、LastGC uint64 // 垃圾回收器最后一次执行时间。\n23、PauseTotalNs uint64 // 垃圾回收或者其他信息收集导致服务暂停的次数。\n24、PauseNs [256]uint64 //一个循环队列，记录最近垃圾回收系统中断的时间\n25、PauseEnd [256]uint64 //一个循环队列，记录最近垃圾回收系统中断的时间开始点。\n26、NumForcedGC uint32 //服务调用runtime.GC()强制使用垃圾回收的次数。\n27、GCCPUFraction float64 //垃圾回收占用服务CPU工作的时间总和。如果有100个goroutine，垃圾回收的时间为1S,那么就占用了100S。\n28、BySize //内存分配器使用情况\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226095855-1rwmmkb","Type":"NodeParagraph","Properties":{"id":"20231226095855-1rwmmkb","updated":"20231226095855"},"Children":[{"Type":"NodeText","Data":"社区同行开发的"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdivan%2Fexpvarmon","TextMarkATitle":"https://github.com/divan/expvarmon","TextMarkTextContent":"expvarmon"},{"Type":"NodeText","Data":"工具，可以在命令行终端以图形化的方式"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实时展示特定的指标数据的变化"},{"Type":"NodeText","Data":"，（expvarmon 即expvar monitor）"}]},{"ID":"20231226095855-nywc7ar","Type":"NodeParagraph","Properties":{"id":"20231226095855-nywc7ar","updated":"20231226095855"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"go get github.com/divan/expvarmon"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231226095855-68u65u4","Type":"NodeParagraph","Properties":{"id":"20231226095855-68u65u4","updated":"20231226095855"},"Children":[{"Type":"NodeText","Data":"启动刚才的程序，然后执行如下命令，可实时查看应用指标变化 （期间可以进行不同qps的请求）"}]},{"ID":"20231226095855-l3omja1","Type":"NodeParagraph","Properties":{"id":"20231226095855-l3omja1","updated":"20231226095855"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"expvarmon -ports=\u0026quot;http://localhost:6666/debug/vars\u0026quot; -i 1s"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231226095919-dxyui76","Type":"NodeParagraph","Properties":{"id":"20231226095919-dxyui76","updated":"20231226095919"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231226095919-2zy9lsp.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231226095906-16p84iz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231226095906-16p84iz","updated":"20231226095906"},"Children":[{"Type":"NodeText","Data":"官方库或知名项目中的使用"}]},{"ID":"20231226095906-8vv78im","Type":"NodeParagraph","Properties":{"id":"20231226095906-8vv78im","updated":"20231226095906"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fcuishuang%2Fgo1.16%2Fblob%2Fmaster%2Fsrc%2Fnet%2Fhttp%2Ftriv.go","TextMarkATitle":"https://gitee.com/cuishuang/go1.16/blob/master/src/net/http/triv.go","TextMarkTextContent":"src/net/http/triv.go"},{"Type":"NodeText","Data":" 中使用了这个包"}]},{"ID":"20231226095906-n2x8pm3","Type":"NodeParagraph","Properties":{"id":"20231226095906-n2x8pm3","updated":"20231226095906"},"Children":[{"Type":"NodeText","Data":"另外 golang.org/x/tools@v0.1.6/cmd/godoc/main.go"}]},{"ID":"20231226095906-imxo7y7","Type":"NodeParagraph","Properties":{"id":"20231226095906-imxo7y7","updated":"20231226095906"},"Children":[{"Type":"NodeText","Data":"golang.org/x/tools@v0.1.6/go/internal/gccgoimporter/gccgoinstallation_test.go"}]},{"ID":"20231226095906-vf273nc","Type":"NodeParagraph","Properties":{"id":"20231226095906-vf273nc","updated":"20231226095906"},"Children":[{"Type":"NodeText","Data":"go/test/bench/garbage/parser.go"}]},{"ID":"20231226095906-sx91anp","Type":"NodeParagraph","Properties":{"id":"20231226095906-sx91anp","updated":"20231226095906"},"Children":[{"Type":"NodeText","Data":"也有使用"}]},{"ID":"20231226095906-1r2r2l8","Type":"NodeParagraph","Properties":{"id":"20231226095906-1r2r2l8","updated":"20231226095906"},"Children":[{"Type":"NodeText","Data":"以及前面提到的"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdivan%2Fexpvarmon","TextMarkATitle":"https://github.com/divan/expvarmon","TextMarkTextContent":"expvarmon"}]},{"ID":"20231226095906-az6a9m4","Type":"NodeParagraph","Properties":{"id":"20231226095906-az6a9m4","updated":"20231226095906"},"Children":[{"Type":"NodeText","Data":"作者：fliter\n链接：https://juejin.cn/post/7280006531923640375\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}]}]}