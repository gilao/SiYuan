{"ID":"20240407110827-3k43zhm","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f415-200d-1f9ba","id":"20240407110827-3k43zhm","tags":"公众号-Golang语言开发栈,Go-依赖注入","title":"Go 语言中怎么使用依赖注入","updated":"20240407111333"},"Children":[{"ID":"20240407110841-ebqluq8","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240407110841-ebqluq8","updated":"20240407110847"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240407110854-avictr4","Type":"NodeParagraph","Properties":{"id":"20240407110854-avictr4","updated":"20240407110847"},"Children":[{"Type":"NodeText","Data":"在 Go 语言项目开发中，我们处理组件层级之间的依赖关系时，通常我们会先在依赖层级的代码中实例化被依赖层级，然后调用它的方法，即依赖方需要主动获取被依赖方。"}]},{"ID":"20240407110854-j7ku9h6","Type":"NodeParagraph","Properties":{"id":"20240407110854-j7ku9h6","updated":"20240407110847"},"Children":[{"Type":"NodeText","Data":"但是，当被依赖层级的代码发生变化时，依赖层级的代码也需要修改，耦合性比较高，代码不方便扩展。"}]},{"ID":"20240407110854-escktll","Type":"NodeParagraph","Properties":{"id":"20240407110854-escktll","updated":"20240407110847"},"Children":[{"Type":"NodeText","Data":"所谓依赖注入，即依赖方不再需要主动获取被依赖方，而是被依赖方主动传递给依赖方。"}]},{"ID":"20240407110854-xmq3ek3","Type":"NodeParagraph","Properties":{"id":"20240407110854-xmq3ek3","updated":"20240407110854"},"Children":[{"Type":"NodeText","Data":"本文我们介绍 Go 语言怎么使用依赖注入。"}]},{"ID":"20240407110859-gb0lyoi","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240407110859-gb0lyoi","updated":"20240407110909"},"Children":[{"Type":"NodeText","Data":"Go 语言使用依赖注入"}]},{"ID":"20240407110915-zouxpmr","Type":"NodeParagraph","Properties":{"id":"20240407110915-zouxpmr","updated":"20240407110915"},"Children":[{"Type":"NodeText","Data":"在 Go 语言中，怎么使用依赖注入呢？我准备以 clean arch 架构的代码讲解。"}]},{"ID":"20240407110915-ytb6iga","Type":"NodeParagraph","Properties":{"id":"20240407110915-ytb6iga","updated":"20240407110915"},"Children":[{"Type":"NodeText","Data":"推荐读者朋友们先阅读我之前写的一遍文章 「"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==\u0026amp;mid=2247486096\u0026amp;idx=1\u0026amp;sn=94de9e36b2ccb779b7f9fb61de8ab368\u0026amp;chksm=9f81a0fea8f629e8e93d118eb745db8b78fbed3ef1ea2021cc72a79076b102ba704fc902f719\u0026amp;scene=21#wechat_redirect","TextMarkTextContent":"Go 语言整洁架构实践"},{"Type":"NodeText","Data":"」。"}]},{"ID":"20240407110915-egbznlv","Type":"NodeParagraph","Properties":{"id":"20240407110915-egbznlv","updated":"20240407110915"},"Children":[{"Type":"NodeText","Data":"参照 Bob 大叔的一篇关于整洁架构的文章 The Clean Architecture，我们分 4 个层级："}]},{"ID":"20240407110915-mof8nth","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240407110915-mof8nth","updated":"20240407110915"},"Children":[{"ID":"20240407110915-wf76zwi","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240407110915-wf76zwi","updated":"20240407110915"},"Children":[{"ID":"20240407110915-9lzxcjl","Type":"NodeParagraph","Properties":{"id":"20240407110915-9lzxcjl","updated":"20240407110915"},"Children":[{"Type":"NodeText","Data":"Models"}]}]},{"ID":"20240407110915-irw6bit","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240407110915-irw6bit","updated":"20240407110915"},"Children":[{"ID":"20240407110915-egcid1h","Type":"NodeParagraph","Properties":{"id":"20240407110915-egcid1h","updated":"20240407110915"},"Children":[{"Type":"NodeText","Data":"Repository"}]}]},{"ID":"20240407110915-phfnkj4","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240407110915-phfnkj4","updated":"20240407110915"},"Children":[{"ID":"20240407110915-r35o8if","Type":"NodeParagraph","Properties":{"id":"20240407110915-r35o8if","updated":"20240407110915"},"Children":[{"Type":"NodeText","Data":"Usecase"}]}]},{"ID":"20240407110915-vfuo5wp","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20240407110915-vfuo5wp","updated":"20240407110915"},"Children":[{"ID":"20240407110915-620bb67","Type":"NodeParagraph","Properties":{"id":"20240407110915-620bb67","updated":"20240407110915"},"Children":[{"Type":"NodeText","Data":"Delivery"}]}]}]},{"ID":"20240407110915-q1wl778","Type":"NodeParagraph","Properties":{"id":"20240407110915-q1wl778","updated":"20240407110915"},"Children":[{"Type":"NodeText","Data":"限于篇幅，本文主要介绍在 Go 语言中使用构造函数的方式实现依赖注入，读者朋友们可以在留言区分享其它实现方式。"}]},{"ID":"20240407110915-mmuz80f","Type":"NodeParagraph","Properties":{"id":"20240407110915-mmuz80f","updated":"20240407110915"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240407110917-b2y7d9o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240407110917-b2y7d9o","updated":"20240407111143"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// Models 层\ntype Todolist struct {\n\tId      int64  `json:\"id\"`\n\tTitle   string `json:\"title\"`\n\tStatus  int    `json:\"status\"`\n\tCreated int    `json:\"created\"`\n\tUpdated int    `json:\"updated\"`\n}\n\ntype TodoListRepository interface {\n\tCreate(ctx context.Context, t *Todolist) (err error)\n}\n\ntype TodoListUsecase interface {\n\tCreate(context.Context, *Todolist) (err error)\n}\n\n// Repository 层\ntype mysqlTodoListRepository struct {\n\tConn *sql.DB\n}\n\nfunc NewMysqlTodoListRepository(Conn *sql.DB) models.TodoListRepository {\n\treturn \u0026mysqlTodoListRepository{Conn}\n}\n\nfunc (m *mysqlTodoListRepository) Create(ctx context.Context, t *models.Todolist) (err error) {\n\t// ...\n\treturn\n}\n\n// Usecase 层\ntype todoListUsecase struct {\n\ttodoListRepo models.TodoListRepository\n}\n\nfunc NewTodoListUsecase(t models.TodoListRepository) models.TodoListRepository {\n\treturn \u0026todoListUsecase{\n\t\ttodoListRepo: t,\n\t}\n}\n\nfunc (tl *todoListUsecase) Create(ctx context.Context, t *models.Todolist) (err error) {\n\tif t.Title == \"\" {\n\t\treturn fmt.Errorf(\"illegal parameter\")\n\t}\n\treturn tl.todoListRepo.Create(ctx, t)\n}\n\n// Delivery 层\ntype TodoListHandler struct {\n\tTodoListUsecase models.TodoListUsecase\n}\n\nfunc NewTodoListHandler(r *gin.Engine, todoListUsecase models.TodoListUsecase) {\n\thandler := \u0026TodoListHandler{\n\t\tTodoListUsecase: todoListUsecase,\n\t}\n\tr.POST(\"/create\", handler.Create)\n\tr.Run()\n}\n\n// main 函数\nfunc main() {\n\tconn, err := sql.Open(`mysql`, \"root:root@tcp(127.0.0.1:3306)/todolist\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tr := gin.Default()\n\ttodoListRepository := mysql.NewMysqlTodoListRepository(conn)\n\ttodoListUsecase := usecase.NewTodoListUsecase(todoListRepository)\n\thttp.NewTodoListHandler(r, todoListUsecase)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240407111208-d2gi8fs","Type":"NodeParagraph","Properties":{"id":"20240407111208-d2gi8fs","updated":"20240407111208"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们可以发现 Repository 层依赖数据库驱动 conn，Usecase 层依赖 Repository 层，Delivery 层依赖 Usecase 层。"}]},{"ID":"20240407111208-wzoorwt","Type":"NodeParagraph","Properties":{"id":"20240407111208-wzoorwt","updated":"20240407111208"},"Children":[{"Type":"NodeText","Data":"以 Repository 层和 Usecase 层为例，我们可以发现 Usecase 层通过构造函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"func NewTodoListUsecase(t models.TodoListRepository) models.TodoListRepository"},{"Type":"NodeText","Data":"​ 将其依赖项 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"models.TodoListRepository"},{"Type":"NodeText","Data":"​ 以参数的形式传递过来，并将其放入 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"todoListUsecase"},{"Type":"NodeText","Data":"​ 结构体中。"}]},{"ID":"20240407111208-3uwm8gh","Type":"NodeParagraph","Properties":{"id":"20240407111208-3uwm8gh","updated":"20240407111208"},"Children":[{"Type":"NodeText","Data":"所以，我们使用 Usecase 层的构造函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NewTodoListUsecase"},{"Type":"NodeText","Data":"​ 创建 Usecase 对象时，需要先使用 Repository 层的构造函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NewMysqlTodoListRepository"},{"Type":"NodeText","Data":"​ 创建 Repository 对象，并将其以参数的形式传递给 Usecase 层的构造函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NewTodoListUsecase"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240407111208-zb5uxt9","Type":"NodeParagraph","Properties":{"id":"20240407111208-zb5uxt9","updated":"20240407111208"},"Children":[{"Type":"NodeText","Data":"通过依赖注入的方式，可以有效降低组件层级之间的耦合性，方便代码的扩展。比如示例代码中 Repository 层的方法修改代码，不会影响 Usecase 层的代码。"}]},{"ID":"20240407111237-1pudne7","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240407111237-1pudne7","updated":"20240407111242"},"Children":[{"Type":"NodeText","Data":"依赖注入工具"}]},{"ID":"20240407111251-o7momm1","Type":"NodeParagraph","Properties":{"id":"20240407111251-o7momm1","updated":"20240407111251"},"Children":[{"Type":"NodeText","Data":"除了手写依赖注入代码，我们也可以使用依赖注入工具，开源社区有很多依赖注入工具，其中比较流行的主要有以下 3 个。"}]},{"ID":"20240407111251-jwemwns","Type":"NodeParagraph","Properties":{"id":"20240407111251-jwemwns","updated":"20240407111251"},"Children":[{"Type":"NodeText","Data":"Google 开源的依赖注入工具 Wire"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[1]"},{"Type":"NodeText","Data":"，它是一个代码生成工具，也就是说它是在编译时自动生成代码。"}]},{"ID":"20240407111251-exl091a","Type":"NodeParagraph","Properties":{"id":"20240407111251-exl091a","updated":"20240407111251"},"Children":[{"Type":"NodeText","Data":"另外 2 个依赖注入工具是在运行时基于 Go 反射实现，分别是 uber开源的依赖注入工具 Dig"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[2]"},{"Type":"NodeText","Data":" 和 facebook 开源的依赖注入工具"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[3]"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240407111251-9nb6b1u","Type":"NodeParagraph","Properties":{"id":"20240407111251-9nb6b1u","updated":"20240407111251"},"Children":[{"Type":"NodeText","Data":"读者朋友们可以根据实际开发中的需求，选择合适的工具。"}]},{"ID":"20240407111322-p2m4rjw","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240407111322-p2m4rjw","updated":"20240407111326"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20240407111333-11uaq5t","Type":"NodeParagraph","Properties":{"id":"20240407111333-11uaq5t","updated":"20240407111333"},"Children":[{"Type":"NodeText","Data":"读者朋友们可能已经发现，依赖注入实际上就是面向对象五大原则之一，依赖倒置原则的实现方式。"}]},{"ID":"20240407111333-xfefgx6","Type":"NodeParagraph","Properties":{"id":"20240407111333-xfefgx6","updated":"20240407111333"},"Children":[{"Type":"NodeText","Data":"我们可以在 Go 项目开发中，使用依赖注入的方式，降低组件层级之间的代码耦合性，使代码更方便扩展。"}]}]}