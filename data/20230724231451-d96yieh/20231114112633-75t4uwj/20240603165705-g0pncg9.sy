{"ID":"20240603165705-g0pncg9","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f6f6","id":"20240603165705-g0pncg9","tags":"Go-线程池","title":"线程池详解并使用Go语言实现Pool","type":"doc","updated":"20240603170415"},"Children":[{"ID":"20240603165730-na3fzpj","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240603165730-na3fzpj","updated":"20240603165738"},"Children":[{"Type":"NodeText","Data":"写在前面"}]},{"ID":"20240603165738-1igchb7","Type":"NodeParagraph","Properties":{"id":"20240603165738-1igchb7","updated":"20240603165813"},"Children":[{"Type":"NodeText","Data":"在线程池中存在几个概念： "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"核心线程数"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"最大线程数"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"任务队列"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240603165819-5xa9533","Type":"NodeList","ListData":{},"Properties":{"id":"20240603165819-5xa9533","updated":"20240603165819"},"Children":[{"ID":"20240603165819-b5t9zcn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240603165819-b5t9zcn","updated":"20240603165819"},"Children":[{"ID":"20240603165819-oxbww63","Type":"NodeParagraph","Properties":{"id":"20240603165819-oxbww63","updated":"20240603165819"},"Children":[{"Type":"NodeText","Data":"核心线程数指的是线程池的基本大小；也就是指worker的数量"}]}]},{"ID":"20240603165819-vggmiet","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240603165819-vggmiet","updated":"20240603165819"},"Children":[{"ID":"20240603165819-ve1jle1","Type":"NodeParagraph","Properties":{"id":"20240603165819-ve1jle1","updated":"20240603165819"},"Children":[{"Type":"NodeText","Data":"最大线程数指的是，同一时刻线程池中线程的数量最大不能超过该值；实际上就是指task任务的数量。"}]}]},{"ID":"20240603165819-19h5vgp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240603165819-19h5vgp","updated":"20240603165819"},"Children":[{"ID":"20240603165819-rkrp47f","Type":"NodeParagraph","Properties":{"id":"20240603165819-rkrp47f","updated":"20240603165819"},"Children":[{"Type":"NodeText","Data":"任务队列是当任务较多时，线程池中线程的数量已经达到了核心线程数，这时候就是用任务队列来存储我们提交的任务。相当于缓冲作用。"}]}]}]},{"ID":"20240603165848-agps11m","Type":"NodeParagraph","Properties":{"id":"20240603165848-agps11m","updated":"20240603165906"},"Children":[{"Type":"NodeText","Data":"与其他池化技术不同的是，线程池是基于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"生产者-消费者"},{"Type":"NodeText","Data":"​模式来实现的，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"任务的提交方是生产者，线程池是消费者"},{"Type":"NodeText","Data":" 。当我们需要执行某个任务时，只需要把任务扔到线程池中即可。"}]},{"ID":"20240603165908-5156wcx","Type":"NodeBlockquote","Properties":{"id":"20240603165908-5156wcx","updated":"20240603165933"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240603165923-4lnywd3","Type":"NodeParagraph","Properties":{"id":"20240603165923-4lnywd3","updated":"20240603165933"},"Children":[{"Type":"NodeText","Data":"池化技术：这里的池化和卷积的池化不一样，这里的池化技术简单点来说，就是提前保存大量的资源，以备不时之需"}]}]},{"ID":"20240603165934-j7hka7k","Type":"NodeParagraph","Properties":{"id":"20240603165934-j7hka7k","updated":"20240603165937"},"Children":[{"Type":"NodeText","Data":"线程池中执行任务的流程如下图如下。"}]},{"ID":"20240603165942-4j8ha5j","Type":"NodeParagraph","Properties":{"id":"20240603165942-4j8ha5j","updated":"20240603165942"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240603165942-fwxphhk.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240603165953-ilrlklh","Type":"NodeParagraph","Properties":{"id":"20240603165953-ilrlklh","updated":"20240603165953"},"Children":[{"Type":"NodeText","Data":"那么使用线程池可以带来一系列好处："}]},{"ID":"20240603165953-237oxve","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240603165953-237oxve","updated":"20240603165953"},"Children":[{"ID":"20240603165953-zasjmlg","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240603165953-zasjmlg","updated":"20240603165953"},"Children":[{"ID":"20240603165953-g2z29tp","Type":"NodeParagraph","Properties":{"id":"20240603165953-g2z29tp","updated":"20240603165953"},"Children":[{"Type":"NodeText","Data":"降低资源消耗："},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。"}]}]},{"ID":"20240603165953-pco65c1","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240603165953-pco65c1","updated":"20240603165953"},"Children":[{"ID":"20240603165953-9nfodym","Type":"NodeParagraph","Properties":{"id":"20240603165953-9nfodym","updated":"20240603165953"},"Children":[{"Type":"NodeText","Data":"提高响应速度：任务到达时，无需等待线程创建即可"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"立即执行"},{"Type":"NodeText","Data":"​。"}]}]},{"ID":"20240603165953-ri8dwya","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240603165953-ri8dwya","updated":"20240603165953"},"Children":[{"ID":"20240603165953-81vgxen","Type":"NodeParagraph","Properties":{"id":"20240603165953-81vgxen","updated":"20240603165953"},"Children":[{"Type":"NodeText","Data":"提高线程的可管理性：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"使用线程池可以进行统一的分配、调优和监控。"}]}]},{"ID":"20240603165953-igd0zy1","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20240603165953-igd0zy1","updated":"20240603165953"},"Children":[{"ID":"20240603165953-ny225od","Type":"NodeParagraph","Properties":{"id":"20240603165953-ny225od","updated":"20240603165953"},"Children":[{"Type":"NodeText","Data":"提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能。"}]}]}]},{"ID":"20240603170003-f7aqeu6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240603170003-f7aqeu6","updated":"20240603170003"},"Children":[{"Type":"NodeText","Data":"任务调度"}]},{"ID":"20240603170003-gl4e3a2","Type":"NodeParagraph","Properties":{"id":"20240603170003-gl4e3a2","updated":"20240603170004"},"Children":[{"Type":"NodeText","Data":"首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。"}]},{"ID":"20240603170012-tto0egi","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240603170012-tto0egi","updated":"20240603170012"},"Children":[{"ID":"20240603170012-f09d0fy","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240603170012-f09d0fy","updated":"20240603170012"},"Children":[{"ID":"20240603170012-h3s0bor","Type":"NodeParagraph","Properties":{"id":"20240603170012-h3s0bor","updated":"20240603170012"},"Children":[{"Type":"NodeText","Data":"如果 taskCount \u003c corePoolSize，则创建并启动一个线程来执行新提交的任务。"}]},{"ID":"20240603170020-kvsscgj","Type":"NodeParagraph","Properties":{"id":"20240603170020-kvsscgj","updated":"20240603170020"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240603170020-m6sd7n9.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20240603170021-xxv14rj","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240603170021-xxv14rj"},"Children":[{"ID":"20240603170028-mn4brbr","Type":"NodeParagraph","Properties":{"id":"20240603170028-mn4brbr","updated":"20240603170028"},"Children":[{"Type":"NodeText","Data":"如果 taskCount \u003e= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。"}]},{"ID":"20240603170039-rgalw2r","Type":"NodeParagraph","Properties":{"id":"20240603170039-rgalw2r","updated":"20240603170039"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240603170039-5s93inl.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20240603170047-gxofg2z","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240603170047-gxofg2z","updated":"20240603170052"},"Children":[{"ID":"20240603170047-7albnty","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240603170047-7albnty","updated":"20240603170052"},"Children":[{"ID":"20240603170047-7v8yjt4","Type":"NodeParagraph","Properties":{"id":"20240603170047-7v8yjt4","updated":"20240603170047"},"Children":[{"Type":"NodeText","Data":"如果workerCount \u003e= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"拒绝策略"},{"Type":"NodeText","Data":" 来处理该任务, 默认的处理方式是直接抛异常。"}]},{"ID":"20240603170052-wwhpliy","Type":"NodeParagraph","Properties":{"id":"20240603170052-wwhpliy","updated":"20240603170052"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240603170052-6otcqtd.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20240603170038-azr3yzg","Type":"NodeBlockquote","Properties":{"id":"20240603170038-azr3yzg","updated":"20240603170132"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240603170132-hg2992p","Type":"NodeParagraph","Properties":{"id":"20240603170132-hg2992p","updated":"20240603170132"},"Children":[{"Type":"NodeText","Data":"常见的拒绝策略有以下几种"}]},{"ID":"20240603170132-mk2r76t","Type":"NodeList","ListData":{},"Properties":{"id":"20240603170132-mk2r76t","updated":"20240603170132"},"Children":[{"ID":"20240603170132-htseaan","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240603170132-htseaan","updated":"20240603170132"},"Children":[{"ID":"20240603170132-bzjlb3r","Type":"NodeParagraph","Properties":{"id":"20240603170132-bzjlb3r","updated":"20240603170132"},"Children":[{"Type":"NodeText","Data":"AbortPolicy 中止策略：丢弃任务并"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"抛出异常"},{"Type":"NodeText","Data":"​。"}]}]},{"ID":"20240603170132-7sfxxvk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240603170132-7sfxxvk","updated":"20240603170132"},"Children":[{"ID":"20240603170132-g2h6uac","Type":"NodeParagraph","Properties":{"id":"20240603170132-g2h6uac","updated":"20240603170132"},"Children":[{"Type":"NodeText","Data":"DiscardPolicy 丢弃策略：丢弃任务，但是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"不抛出异常"},{"Type":"NodeText","Data":"​。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。"}]}]},{"ID":"20240603170132-vejv3xj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240603170132-vejv3xj","updated":"20240603170132"},"Children":[{"ID":"20240603170132-y74mjrv","Type":"NodeParagraph","Properties":{"id":"20240603170132-y74mjrv","updated":"20240603170132"},"Children":[{"Type":"NodeText","Data":"DiscardOldestPolicy 弃老策略：丢弃队列最前面的任务，然后重新提交被拒绝的任务。"}]}]}]}]},{"ID":"20240603170133-xd9qct9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240603170133-xd9qct9","updated":"20240603170143"},"Children":[{"Type":"NodeText","Data":"简单实现"}]},{"ID":"20240603170143-4lv3wi3","Type":"NodeParagraph","Properties":{"id":"20240603170143-4lv3wi3","updated":"20240603170149"},"Children":[{"Type":"NodeText","Data":"定义任务Task 并 定义NewTask来新建Task对象"}]},{"ID":"20240603170150-tir8su9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240603170150-tir8su9","updated":"20240603170157"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Task struct {\n f func() error\n}\n\nfunc NewTask(f func() error) *Task {\n return \u0026Task{f: f}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240603170158-vaey0yy","Type":"NodeParagraph","Properties":{"id":"20240603170158-vaey0yy","updated":"20240603170202"},"Children":[{"Type":"NodeText","Data":"定义 WorkPool 线程池"}]},{"ID":"20240603170203-aehnpo4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240603170203-aehnpo4","updated":"20240603170208"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type WorkPool struct {\n TaskQueue chan *Task // Task队列\n workNum   int        // 协程池中最大的worker数量\n shop      chan struct{} // 停止工作标识\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240603170209-ffudcwv","Type":"NodeParagraph","Properties":{"id":"20240603170209-ffudcwv","updated":"20240603170213"},"Children":[{"Type":"NodeText","Data":"创建 WorkPool 的函数"}]},{"ID":"20240603170214-smn3ump","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240603170214-smn3ump","updated":"20240603170218"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func NewWorkPool(cap int) *WorkPool {\n if cap \u003c= 0 {\n  cap = 10\n }\n return \u0026WorkPool{\n  TaskQueue: make(chan *Task),\n  workNum:   cap,\n  shop:      make(chan struct{}),\n }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240603170220-2rsb3yx","Type":"NodeParagraph","Properties":{"id":"20240603170220-2rsb3yx","updated":"20240603170223"},"Children":[{"Type":"NodeText","Data":"具体的协程池中的工作节点"}]},{"ID":"20240603170223-5rvvbp2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240603170223-5rvvbp2","updated":"20240603170232"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (p *WorkPool) worker(workId int) {\n for task := range p.TaskQueue {\n  err := task.Execute()\n  if err != nil {\n   fmt.Println(err)\n   continue\n  }\n  fmt.Printf(\" work id %d finished \\n\", workId) // 打印出具体是哪个节点进行工作\n }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240603170233-fgvsged","Type":"NodeParagraph","Properties":{"id":"20240603170233-fgvsged","updated":"20240603170237"},"Children":[{"Type":"NodeText","Data":"协程池启动函数"}]},{"ID":"20240603170237-959332h","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240603170237-959332h","updated":"20240603170243"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (p *WorkPool) run() {\n // 根据work num 去创建worker工作\n for i := 0; i \u003c p.workNum; i++ {\n  go p.worker(i)\n }\n \u003c-p.shop\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240603170249-a142vvz","Type":"NodeParagraph","Properties":{"id":"20240603170249-a142vvz","updated":"20240603170249"},"Children":[{"Type":"NodeText","Data":"协程池关闭函数"}]},{"ID":"20240603170249-kq5fxgo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240603170249-kq5fxgo","updated":"20240603170257"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (p *WorkPool) close() {\n p.shop \u003c- struct{}{}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240603170258-2uvji4v","Type":"NodeParagraph","Properties":{"id":"20240603170258-2uvji4v","updated":"20240603170302"},"Children":[{"Type":"NodeText","Data":"测试一下，使用定时器，每2秒进行一次投放，并且投放超过5个之后开始停止。"}]},{"ID":"20240603170303-bm0axch","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240603170303-bm0axch","updated":"20240603170309"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func TestWorkPool(t *testing.T) {\n task := NewTask(func() error {\n  fmt.Print(time.Now())\n  return nil\n })\n taskCount := 0\n ticker := time.NewTicker(2 * time.Second)\n p := NewWorkPool(3)\n go func(c *time.Ticker) {\n  for {\n   p.TaskQueue \u003c- task\n   \u003c-c.C\n   taskCount++\n   if taskCount == 5 {\n    p.close()\n    break\n   }\n  }\n  return\n }(ticker)\n p.run()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240603170310-uy1qca4","Type":"NodeParagraph","Properties":{"id":"20240603170310-uy1qca4","updated":"20240603170312"},"Children":[{"Type":"NodeText","Data":"结果"}]},{"ID":"20240603170317-7rybwh9","Type":"NodeParagraph","Properties":{"id":"20240603170317-7rybwh9","updated":"20240603170317"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240603170317-1esru7q.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240603170318-7mpkq4j","Type":"NodeParagraph","Properties":{"id":"20240603170318-7mpkq4j","updated":"20240603170323"},"Children":[{"Type":"NodeText","Data":"可以看到结果是每两秒进行一次打印，并且worker对象都不一样。"}]},{"ID":"20240603170323-c0439wi","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240603170323-c0439wi","updated":"20240603170326"},"Children":[{"Type":"NodeText","Data":"完整代码"}]},{"ID":"20240603170329-lm5qlk4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240603170329-lm5qlk4","updated":"20240603170415"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package gorountine_pool\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestWorkPool(t *testing.T) {\n\ttask := NewTask(func() error {\n\t\tfmt.Print(time.Now())\n\t\treturn nil\n\t})\n\ttaskCount := 0\n\tticker := time.NewTicker(2 * time.Second)\n\tp := NewWorkPool(3)\n\tgo func(c *time.Ticker) {\n\t\tfor {\n\t\t\tp.TaskQueue \u003c- task\n\t\t\t\u003c-c.C\n\t\t\ttaskCount++\n\t\t\tif taskCount == 5 {\n\t\t\t\tp.close()\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t}(ticker)\n\tp.run()\n}\n\ntype Task struct {\n\tf func() error\n}\n\nfunc NewTask(f func() error) *Task {\n\treturn \u0026Task{f: f}\n}\n\n// Execute 执行业务方法\nfunc (t *Task) Execute() error {\n\treturn t.f()\n}\n\ntype WorkPool struct {\n\tTaskQueue chan *Task // task队列\n\tworkNum   int        // 携程池中最大的worker数量\n\tshop      chan struct{} // 停止标识\n}\n\n// 创建Pool的函数\nfunc NewWorkPool(cap int) *WorkPool {\n\tif cap \u003c= 0 {\n\t\tcap = 10\n\t}\n\treturn \u0026WorkPool{\n\t\tTaskQueue: make(chan *Task),\n\t\tworkNum:   cap,\n\t\tshop:      make(chan struct{}),\n\t}\n}\n\nfunc (p *WorkPool) worker(workId int) {\n\t// 具体的工作\n\tfor task := range p.TaskQueue {\n\t\terr := task.Execute()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Printf(\" work id %d finished \\n\", workId)\n\t}\n}\n\n// 携程池开始工作\nfunc (p *WorkPool) run() {\n\t// 根据work num 去创建worker工作\n\tfor i := 0; i \u003c p.workNum; i++ {\n\t\tgo p.worker(i)\n\t}\n\t\u003c-p.shop\n}\n\nfunc (p *WorkPool) close() {\n\tp.shop \u003c- struct{}{}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}