{"ID":"20240415000749-m872nhx","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240415000749-m872nhx","title":"第一章 深入理解Go语言协程调度器GPM 模型","updated":"20240415003137"},"Children":[{"ID":"20240415001206-fuf69oo","Type":"NodeParagraph","Properties":{"id":"20240415001206-fuf69oo","updated":"20240415001224"},"Children":[{"Type":"NodeText","Data":"Go语言协程调度原理是Go语言开发者追求理解的⾸要知识点。Go语⾔的特性具备优秀的调度设计与⾼性能的协程调度模型。作为Go语⾔开发者掌握与深⼊理解这部分知识是⾮常必要的。"}]},{"ID":"20240415001206-j60kcjv","Type":"NodeParagraph","Properties":{"id":"20240415001206-j60kcjv","updated":"20240415001206"},"Children":[{"Type":"NodeText","Data":"本章介绍Go语⾔中调度器的由来，以及如何演进到GPM模型的设计，其中包含⼀个Go语⾔协程在启动过程中如何运⾏和加载GPM模型的细节动作，也包括GPM模型的可视化编程和调试分析，最后形象地介绍GPM模型的各个触发条件及运作的场景。"}]},{"ID":"20240415000749-oli3dml","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240415000749-oli3dml","updated":"20240415001333"},"Children":[{"Type":"NodeText","Data":"1.1 Go 语言“调度器”的由来"}]},{"ID":"20240415001341-h68g0cg","Type":"NodeParagraph","Properties":{"id":"20240415001341-h68g0cg","updated":"20240415001341"},"Children":[{"Type":"NodeText","Data":"众所周知，⼀切软件都运⾏在操作系统上，使这些软件能够运⾏且⼯作起来，真正⽤来计算的是CPU。早期的操作系统的每个程序就是⼀个进程，直到⼀个程序运⾏完，才能执⾏下⼀个进程，就是单进程时代，所有的程序只能以串⾏的⽅式执⾏，如图1.1所示。"}]},{"ID":"20240415001359-lrgy4xo","Type":"NodeParagraph","Properties":{"id":"20240415001359-lrgy4xo","updated":"20240415001401"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240415001359-pbtm69x.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240415001403-kb1383s","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240415001403-kb1383s","updated":"20240415001424"},"Children":[{"Type":"NodeText","Data":"1.1.1 单进程时代不需要调度器"}]},{"ID":"20240415001424-b1p4562","Type":"NodeParagraph","Properties":{"id":"20240415001424-b1p4562","updated":"20240415001840"},"Children":[{"Type":"NodeText","Data":"早期的单进程操作系统，面临两个问题。"}]},{"ID":"20240415001840-5jugceu","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240415001840-5jugceu","updated":"20240415001847"},"Children":[{"ID":"20240415001847-qnmu6o8","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240415001847-qnmu6o8","updated":"20240415001847"},"Children":[{"ID":"20240415001847-p6f77r8","Type":"NodeParagraph","Properties":{"id":"20240415001847-p6f77r8","updated":"20240415002034"},"Children":[{"Type":"NodeText","Data":"单一的执行流行。计算机只能一个任务一个任务处理，所有的程序几乎是阻塞的，更不用说具备图形化界面或者鼠标这种异步交互的处理能力"}]}]},{"ID":"20240415002035-eovwhwc","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240415002035-eovwhwc"},"Children":[{"ID":"20240415002035-ac1vi1v","Type":"NodeParagraph","Properties":{"id":"20240415002035-ac1vi1v","updated":"20240415002609"},"Children":[{"Type":"NodeText","Data":"进程阻塞所带来的CPU时间浪费。在一个进程完整的生命周期中，所要访问的物理部分包括CPU、Cache、主内存、磁盘、网络等，不同的硬件媒介处理计算的能力相差甚大。如果将这些处理速度不同的处理媒介通过一个进程串在一起，则会出现高速度媒介等待和浪费的现象。如当一个程序加载一个磁盘数据的时候，在读写的过程中，CPU 处于等待状态，那么对于单进程的操作系统来讲，很明显会造成CPU运算能力的浪费，因为CPU此刻本应该被合理地分配到其他进程上去做高层的计算。"}]}]}]},{"ID":"20240415002640-3sl5ada","Type":"NodeParagraph","Properties":{"id":"20240415002640-3sl5ada","updated":"20240415002726"},"Children":[{"Type":"NodeText","Data":"那么能不能有多个进程来宏观地⼀起执⾏多个任务呢？后来操作系统就具有了最早的并发能⼒，即多进程并发。当⼀个进程阻塞的时候，切换到另外等待执⾏的进程，这样就能尽量把CPU利⽤起来，CPU也就不那么浪费了。"}]},{"ID":"20240415001937-ux3k4nz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240415001937-ux3k4nz","updated":"20240415002754"},"Children":[{"Type":"NodeText","Data":"1.1.2 多进程/ 多线程时代的调度器需求"}]},{"ID":"20240415002754-rot1dw2","Type":"NodeParagraph","Properties":{"id":"20240415002754-rot1dw2","updated":"20240415002952"},"Children":[{"Type":"NodeText","Data":"多进程/多线程的操作系统解决了阻塞的问题，一个进程阻塞CPU可以立刻切换到其他进程中去执行，而且调度CPU的算法可以保证在运行的进程都可以分配到CPU的运行时间片。从宏观来看，似乎多个进程是在同时被运行，如图1.2所示："}]},{"ID":"20240415003018-a8h4of0","Type":"NodeParagraph","Properties":{"id":"20240415003018-a8h4of0","updated":"20240415003020"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240415003018-pu4pt81.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240415003021-i7nuceb","Type":"NodeParagraph","Properties":{"id":"20240415003021-i7nuceb","updated":"20240415003137"},"Children":[{"Type":"NodeText","Data":"图1.2 为一个CPU通过调度器切换CPU时间轴的情景。如果未来满足宏观上每个进程/线程是一起执行的，则CPU必须切换，每个进程会被分配到一个时间片中。"}]}]}