{"ID":"20240609230112-s5n1n6t","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f43b","id":"20240609230112-s5n1n6t","title":"第九章 函数与栈","type":"doc","updated":"20240609231019"},"Children":[{"ID":"20240609230135-50crig8","Type":"NodeParagraph","Properties":{"id":"20240609230135-50crig8","updated":"20240609230151"},"Children":[{"Type":"NodeText","Data":"函数是程序中为了执行特定任务而存在的一系列执行代码。函数接受输入并返回输出，执行程序的过程可以看作一系列函数的调用过程。"}]},{"ID":"20240609230112-34cpybv","Type":"NodeParagraph","Properties":{"id":"20240609230112-34cpybv","updated":"20240609230253"},"Children":[{"Type":"NodeText","Data":"Go 语言中最重要的函数是main函数，其是程序执行用户代码的入口，在每个程序中都需要存在。"}]},{"ID":"20240609230253-k1dkzt6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240609230253-k1dkzt6","updated":"20240609230311"},"Children":[{"Type":"NodeText","Data":"9.1 函数基本使用方式"}]},{"ID":"20240609230312-6l8aewd","Type":"NodeParagraph","Properties":{"id":"20240609230312-6l8aewd","updated":"20240609230326"},"Children":[{"Type":"NodeText","Data":"使用函数具有减少冗余、隐藏信息、提高代码清晰度等优点。在Go语言中，函数是一等公民（first-class），这意味着可以将它看作变量，并且它可以作为参数传递、返回及赋值。"}]},{"ID":"20240609230331-twa1u0u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240609230331-twa1u0u","updated":"20240609230532"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 函数作为返回值\nfunc makeGreeter() func() string {\n  return func () string {\n    return \"hello jonson\"\n  }\n}\n\n// 函数作为参数\nfunc visit(numbers []int, callback func(int) ) {\n  for _, n := range numbers {\n    callback(n)\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240609230433-csx03s9","Type":"NodeParagraph","Properties":{"id":"20240609230433-csx03s9","updated":"20240609230602"},"Children":[{"Type":"NodeText","Data":"Go语言中的函数还具有多返回值的特点，多返回值最常用于返回error错误信息，从而被调用者捕获。一种常见的处理方式如下所示，main函数调用了除法函数dlv并在返回时判断函数调用是否出错。"}]},{"ID":"20240609230603-jrg3fkd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240609230603-jrg3fkd","updated":"20240609230623"},"Children":[{"Type":"NodeText","Data":"9.2 函数闭包与陷阱"}]},{"ID":"20240609230623-pm1xyv6","Type":"NodeParagraph","Properties":{"id":"20240609230623-pm1xyv6","updated":"20240609230752"},"Children":[{"Type":"NodeText","Data":"Go语言同样支持匿名函数和闭包。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"闭包（Closure）是在函数作为一类公民的编程语言中实现词法绑定的一种技术，闭包包含了函数的入口地址和其关联的环境。闭包和普通函数最大的区别在于，闭包函数中可以引用闭包外的变量。"}]},{"ID":"20240609230748-1b65r0g","Type":"NodeParagraph","Properties":{"id":"20240609230748-1b65r0g","updated":"20240609230810"},"Children":[{"Type":"NodeText","Data":"当闭包与range同时使用时，可能出现下例中的错误，这也是Go语言中一类非常经典的错误，被收录在了Go语言“共同的错误”[2]中，最终协程会打印出values切片的最后一个值。因为当前val值引用的是同一个地址的数据，所以在range循环的过程中，会不断在val地址中更新数据。而在闭包中，由于引用了外部变量val，所以在访问时会获取val地址中的值，可能会获取最后放入其中的值，而不是遍历所有值，从而导致严重的错误。"}]},{"ID":"20240609230853-1szmgxh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240609230853-1szmgxh","updated":"20240609230924"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"for _, val := range values {\n  go func() {\n    fmt.Println(val)\n  }()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240609230934-j1487b6","Type":"NodeParagraph","Properties":{"id":"20240609230934-j1487b6","updated":"20240609230934"},"Children":[{"Type":"NodeText","Data":"修复该问题的办法是通过函数传递参数，从而避免闭包引用导致的陷阱。"}]},{"ID":"20240609230935-fg2az9e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240609230935-fg2az9e","updated":"20240609231019"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"for _,val := range values {\n  go func(val string) {\n    fmt.Println(val)\n  }()\n }\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}