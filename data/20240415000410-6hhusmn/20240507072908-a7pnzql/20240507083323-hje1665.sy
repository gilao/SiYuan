{"ID":"20240507083323-hje1665","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f3aa","id":"20240507083323-hje1665","title":"第一章 深入Go语言编译器","updated":"20240507222759"},"Children":[{"ID":"20240507083443-lgeeox2","Type":"NodeParagraph","Properties":{"id":"20240507083443-lgeeox2"},"Children":[{"Type":"NodeText","Data":"以.go为后缀的UTF-8格式的Go文本文件最终能被编译成特定机器上的可执行文件，离不开Go语言编译器的复杂工作。Go语言编译器不仅能准确地翻译高级语言，也能进行代码优化。在本章中，笔者将解析从编写Go文本文件到生成可执行文件的关键流程。"}]},{"ID":"20240507084139-ewj7rtz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507084139-ewj7rtz","updated":"20240507084157"},"Children":[{"Type":"NodeText","Data":"1.1 为什么要了解Go语言编译器"}]},{"ID":"20240507084157-puo35du","Type":"NodeParagraph","Properties":{"id":"20240507084157-puo35du","updated":"20240507084930"},"Children":[{"Type":"NodeText","Data":"编译器是一个大型且复杂的系统，一个好的编译器会很好地结合形式语言理论、算法、人工智能、系统设计、计算机体系结构及编程语言理论。Go语言的编译器遵循了主流编译器采用的经典策略及相似的处理流程和优化规则（例如经典的递归下降的语法解析、抽象语法树的构建）。另外，Go语言编译器有一些特殊的设计，例如内存的逃逸等。在本章中，笔者将分别介绍Go语言编译器的各个阶段。"}]},{"ID":"20240507084931-kppsery","Type":"NodeParagraph","Properties":{"id":"20240507084931-kppsery","updated":"20240507084938"},"Children":[{"Type":"NodeText","Data":"编译原理值得用一本书的笔墨去讲解，通过了解Go语言编辑器，不仅可以了解大部分高级语言编译器的一般性流程与规则，也能指导我们写出更加优秀的程序。本书后面的章节经常会禁用编译器的优化以及内联函数等特性调试和查看代码的执行流程。后面还会看到，很多Go语言的语法特性都离不开编译时与运行时的共同作用。另外，如果读者希望开发go import、go fmt、go lint等扫描源代码的工具，那么同样离不开编译器的知识和Go语言提供的API。"}]},{"ID":"20240507084948-zxalsji","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507084948-zxalsji","updated":"20240507085008"},"Children":[{"Type":"NodeText","Data":"1.2 Go 语言编译器的阶段"}]},{"ID":"20240507085133-8e9ncde","Type":"NodeParagraph","Properties":{"id":"20240507085133-8e9ncde","updated":"20240507085133"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507085133-0gr71io.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240507085008-rmab68p","Type":"NodeParagraph","Properties":{"id":"20240507085008-rmab68p","updated":"20240507085200"},"Children":[{"Type":"NodeText","Data":"如图所示，在经典的编译原理中，一般将编译器分为编译器前端、优化器和编译器后端。这种编译器被称为"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"三阶段编译器（three-phase compiler）"},{"Type":"NodeText","Data":"。其中，编译器前端主要专注于理解源程序、扫描解析源程序并进行精准的语义表达。编译器的中间阶段（Intermediate Representation，IR）可能有多个，编译器会使用多个IR阶段、多种数据结构表示代码，并在中间阶段对代码进行多次优化。例如，识别冗余代码、识别内存逃逸等。编译器的中间阶段离不开编译器前端记录的细节。编译器后端专注于生成特定目标机器上的程序，这种程序可能是可执行文件，也可能是需要进一步处理的中间形态obj文件、汇编语言等。"}]},{"ID":"20240507085200-40o6rxn","Type":"NodeParagraph","Properties":{"id":"20240507085200-40o6rxn","updated":"20240507085234"},"Children":[{"Type":"NodeText","Data":"需要注意的是，编译器优化并不是一个非常明确的概念。优化的主要目的一般是降低程序资源的消耗，比较常见的是降低内存与CPU的使用率。但在很多时候，这些目标可能是相互冲突的，对一个目标的优化可能降低另一个目标的效率。同时，理论已经表明有一些代码优化存在着NP难题，这意味着随着代码的增加，优化的难度将越来越大，需要花费的时间呈指数增长。因为这些原因，编译器无法进行最佳的优化，所以通常采用一种折中的方案。\nGo语言编译器一般缩写为小写的gc（go compiler），需要和大写的GC（垃圾回收）进行区分。Go语言编译器的执行流程可细化为多个阶段，包括词法解析、语法解析、抽象语法树构建、类型检查、变量捕获、函数内联、逃逸分析、闭包重写、遍历函数、SSA生成、机器码生成，如图1-2所示。后面的章节将对这些阶段逐一进行分析。"}]},{"ID":"20240507085307-um4rrfz","Type":"NodeParagraph","Properties":{"id":"20240507085307-um4rrfz","updated":"20240507085307"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507085307-71f9cec.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240507085309-egemv6c","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507085309-egemv6c","updated":"20240507220003"},"Children":[{"Type":"NodeText","Data":"词法解析"}]},{"ID":"20240507220018-tp05akm","Type":"NodeParagraph","Properties":{"id":"20240507220018-tp05akm","updated":"20240507220027"},"Children":[{"Type":"NodeText","Data":"和Go语言编译器有关的代码主要位于src/cmd/compile/internal目录下，在后面分析中给出的文件路径均默认位于该目录中。在词法解析阶段，Go语言编译器会扫描输入的Go源文件，并将其符号（token）化。例如“+”和“-”操作符会被转换为_IncOp，赋值符号“：=”会被转换为_Define。这些token实质上是用iota声明的整数，定义在syntax/tokens.go中。"}]},{"ID":"20240507091105-44vji9p","Type":"NodeParagraph","Properties":{"id":"20240507091105-44vji9p","updated":"20240507220043"},"Children":[{"Type":"NodeText","Data":"符号化保留了Go语言中定义的符号，可以识别出错误的拼写。同时，字符串被转换为整数后，在后续的阶段中能够被更加高效地处理。图1-3为一个示例，展现了将表达式a：=b+c（12）符号化之后的情形。代码中声明的标识符、关键字、运算符和分隔符等字符串都可以转化为对应的符号。"}]},{"ID":"20240507220116-6n3gqac","Type":"NodeParagraph","Properties":{"id":"20240507220116-6n3gqac","updated":"20240507220116"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"width: 626px;","style":"width: 616px;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"1715090472727"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/1715090472727-20240507220116-xg39g79.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"width: 616px;\" parent-style=\"width: 626px;\"}"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240507220119-kgwae9w","Type":"NodeParagraph","Properties":{"id":"20240507220119-kgwae9w","updated":"20240507220123"},"Children":[{"Type":"NodeText","Data":"Go语言标准库go/scanner、go/token也提供了许多接口用于扫描源代码。在下例中，我们将使用这些接口模拟对Go文本文件的扫描。"}]},{"ID":"20240507220621-t227zk3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240507220621-t227zk3","updated":"20240507221419"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n\t\"go/scanner\"\n\t\"go/token\"\n)\n\nfunc main() {\n\tsrc := []byte(\"cos(x) + 2i*sin(x) // Euler\")\n\n\t// 初始化 scanner\n\tvar s scanner.Scanner\n\tfset := token.NewFileSet()\n\tfile := fset.AddFile(\"\", fset.Base(), len(src))\n\ts.Init(file, src, nil, scanner.ScanComments)\n\n\t// 扫描\n\tfor {\n\t\tpos, tok, lit := s.Scan()\n\t\tif tok == token.EOF {\n\t\t\tbreak\n\t\t}\n\t\tprintln(fset.Position(pos), tok, lit)\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240507221432-x6q17xj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507221432-x6q17xj","updated":"20240507221437"},"Children":[{"Type":"NodeText","Data":"语法解析"}]},{"ID":"20240507221437-z93gwk2","Type":"NodeParagraph","Properties":{"id":"20240507221437-z93gwk2","updated":"20240507221707"},"Children":[{"Type":"NodeText","Data":"词法解析阶段结束后，需要根据Go语言中指定的语法对符号化后的Go文件进行解析。Go语言采用了标准的自上而下的递归下降（Top-Down Recursive-Descent）算法，以简单高效的方式完成无须回溯的语法扫描，核心算法位于syntax/nodes.go及syntax/parser.go中。图1-4为Go语言编译器对文件进行语法解析的示意图。在一个Go源文件中主要有包导入声明（import）、静态常量（const）、类型声明（type）、变量声明（var）及函数声明。"}]},{"ID":"20240507221740-1xhwhkq","Type":"NodeParagraph","Properties":{"id":"20240507221740-1xhwhkq","updated":"20240507221754"},"Children":[{"Type":"NodeText","Data":"Go语言编译器对文件进行语法解析的示意图"}]},{"ID":"20240507221731-nzzxwie","Type":"NodeParagraph","Properties":{"id":"20240507221731-nzzxwie","updated":"20240507221731"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507221731-xh01f2o.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240507221733-h3smedp","Type":"NodeParagraph","Properties":{"id":"20240507221733-h3smedp","updated":"20240507222022"},"Children":[{"Type":"NodeText","Data":"源文件中的每一种声明都有对应的语法，递归下降通过识别初始的标识符，例如_const，采用对应的语法进行解析。这种方式能够较快地解析并识别可能出现的语法错误。每一种声明语法在Go语言规范中都有定义。"}]},{"ID":"20240507222027-dof2e0p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240507222027-dof2e0p","updated":"20240507222454"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 包导入声明\nImportSpec = [ \".\" | PackageName ] ImportPath . \nImportPath = string_lit . \n// 静态常量\nConstSpec = IndetifierList [ [ Type ] \"=\" ExpressionList ] .\n// 类型声明\nTypeSpec = identifier [ \"=\" ] Type\n// 变量声明\nVarSpec = IdentifierList ( Type [ \"=\" ExpressionList ] | \"=\" ExpressionList ) .\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240507222501-5qtd1r9","Type":"NodeParagraph","Properties":{"id":"20240507222501-5qtd1r9","updated":"20240507222503"},"Children":[{"Type":"NodeText","Data":"函数声明是文件中最复杂的一类语法，因为在函数体的内部可能有多种声明、赋值（例如：=）、表达式及函数调用等。例如defer语法为defer Expression，其后必须跟一个函数或方法。每一种声明语法或者表达式都有对应的结构体，例如a：=b+f（89）对应的结构体为赋值声明AssignStmt。Op代表当前的操作符，即“：=”，Lhs与Rhs分别代表左右两个表达式。"}]},{"ID":"20240507222511-dz9yclu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240507222511-dz9yclu","updated":"20240507222548"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"AssignStmt struct {\n  Op Operator\n  Lhs, Rhs Expr\n  simpleStmt\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240507222600-deax2or","Type":"NodeParagraph","Properties":{"id":"20240507222600-deax2or","updated":"20240507222610"},"Children":[{"Type":"NodeText","Data":"语法解析丢弃了一些不重要的标识符，例如括号“（”，并将语义存储到了对应的结构体中。语法声明的结构体拥有对应的层次结构，这是构建抽象语法树的基础。图1-5为a：=b+c（12）语句被语法解析后转换为对应的syntax.AssignStmt结构体之后的情形。最顶层的Op操作符为token.Def（：=）。Lhs表达式类型为标识符syntax.Name，值为标识符“a”。Rhs表达式为syntax.Operator加法运算。加法运算左边为标识符“b”，右边为函数调用表达式，类型为CallExpr。其中，函数名c的类型为syntax.Name，参数为常量类型syntax.BasicLit，代表数字12。"}]},{"ID":"20240507222629-k70nles","Type":"NodeParagraph","Properties":{"id":"20240507222629-k70nles","updated":"20240507222629"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507222629-d2sarjh.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240507222631-m6lfaux","Type":"NodeParagraph","Properties":{"id":"20240507222631-m6lfaux","updated":"20240507222652"},"Children":[{"Type":"NodeText","Data":"特定表达式的语法解析示例"}]},{"ID":"20240507222652-pnaiuzo","Type":"NodeParagraph","Properties":{"id":"20240507222652-pnaiuzo","updated":"20240507222652"}},{"ID":"20240507222653-e8uq20n","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507222653-e8uq20n","updated":"20240507222717"},"Children":[{"Type":"NodeText","Data":"1.5 抽象语法树构建"}]},{"ID":"20240507222717-cwn8bwy","Type":"NodeParagraph","Properties":{"id":"20240507222717-cwn8bwy","updated":"20240507222734"},"Children":[{"Type":"NodeText","Data":"编译器前端必须构建程序的中间表示形式，以便在编译器中间阶段及后端使用。抽象语法树（Abstract Syntax Tree，AST）是一种常见的树状结构的中间态。\n在Go语言源文件中的任何一种import、type、const、func声明都是一个根节点，在根节点下包含当前声明的子节点。如下decls函数将源文件中的所有声明语句转换为节点（Node）数组。核心逻辑位于gc/noder.go中。"}]},{"ID":"20240507222759-puhyjr7","Type":"NodeParagraph","Properties":{"id":"20240507222759-puhyjr7"}}]}