{"ID":"20240605210608-usdhhhq","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f3dd-fe0f","id":"20240605210608-usdhhhq","title":"第七章 切片","type":"doc","updated":"20240606154514"},"Children":[{"ID":"20240605210608-f4xa65t","Type":"NodeParagraph","Properties":{"id":"20240605210608-f4xa65t","updated":"20240605210633"},"Children":[{"Type":"NodeText","Data":"Go语言中的切片（slice）在某种程度上和其他语言（例如C语言）中的数组在使用中有许多相似的地方。"}]},{"ID":"20240605210644-3ywzdut","Type":"NodeParagraph","Properties":{"id":"20240605210644-3ywzdut","updated":"20240605210645"},"Children":[{"Type":"NodeText","Data":"Go语言中的切片有许多独特之处："}]},{"ID":"20240605210645-97on009","Type":"NodeList","ListData":{},"Properties":{"id":"20240605210645-97on009","updated":"20240605210646"},"Children":[{"ID":"20240605210646-if6zgab","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240605210646-if6zgab","updated":"20240605210646"},"Children":[{"ID":"20240605210646-r7bkgnu","Type":"NodeParagraph","Properties":{"id":"20240605210646-r7bkgnu","updated":"20240605210712"},"Children":[{"Type":"NodeText","Data":"切片时长度可变的序列，序列中每个元素都有相同的类型"}]}]},{"ID":"20240605210713-178tc6k","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240605210713-178tc6k"},"Children":[{"ID":"20240605210713-zlwtr9c","Type":"NodeParagraph","Properties":{"id":"20240605210713-zlwtr9c","updated":"20240605210754"},"Children":[{"Type":"NodeText","Data":"一个切片一般写作"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[]T"},{"Type":"NodeText","Data":"​，其中 T 代表 slice 中元素类型。"}]}]},{"ID":"20240605210755-6ttpa81","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240605210755-6ttpa81"},"Children":[{"ID":"20240605210755-wt14uh9","Type":"NodeParagraph","Properties":{"id":"20240605210755-wt14uh9","updated":"20240605210804"},"Children":[{"Type":"NodeText","Data":"切片不用指定固定长度"}]}]}]},{"ID":"20240605210805-6vciiif","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240605210805-6vciiif","updated":"20240605210820"},"Children":[{"Type":"NodeText","Data":"切片的使用方法"}]},{"ID":"20240605210820-7ab7oh8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240605210820-7ab7oh8","updated":"20240605210826"},"Children":[{"Type":"NodeText","Data":"切片的结构"}]},{"ID":"20240605210826-ts5jkiu","Type":"NodeParagraph","Properties":{"id":"20240605210826-ts5jkiu","updated":"20240605211036"},"Children":[{"Type":"NodeText","Data":"切片是一种轻量级的数据结构，提供了访问数组任意元素的功能，切片运行时结构如图7-1所示。"}]},{"ID":"20240605211052-yucobwa","Type":"NodeParagraph","Properties":{"id":"20240605211052-yucobwa","updated":"20240605211052"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240605211052-uemluyp.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240605211135-89rcaj2","Type":"NodeParagraph","Properties":{"id":"20240605211135-89rcaj2","updated":"20240605211147"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"一个切片在运行时由指针（date）、长度（len）和容量（cap）3部分构成。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20240605211147-8b2yttz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240605211147-8b2yttz","updated":"20240605211221"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type SliceHeader struct {\n  Data uinptr\n  Len int\n  Cap int\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240605211226-txwpmjg","Type":"NodeParagraph","Properties":{"id":"20240605211226-txwpmjg","updated":"20240605213720"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"指针指向切片元素对应的底层数组元素的地址。"}]},{"ID":"20240605213725-kmkke80","Type":"NodeParagraph","Properties":{"id":"20240605213725-kmkke80","updated":"20240605213725"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"长度对应切片中元素的数目，长度不能超过容量。"}]},{"ID":"20240605213727-1o2x1ki","Type":"NodeParagraph","Properties":{"id":"20240605213727-1o2x1ki","updated":"20240605213727"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"容量一般是从切片的开始位置到底层数据的结尾位置的长度。"}]},{"ID":"20240605213728-okd5gas","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240605213728-okd5gas","updated":"20240605213744"},"Children":[{"Type":"NodeText","Data":"7.1.2 切片初始化"}]},{"ID":"20240605213744-gejcdyd","Type":"NodeParagraph","Properties":{"id":"20240605213744-gejcdyd","updated":"20240605214624"},"Children":[{"Type":"NodeText","Data":"切片有多种声明方式，如下所示，在只声明不赋初始值的情况下，切片 slice1 的值为预置的nil，切片的初始化需要使用内置的make函数"}]},{"ID":"20240605214625-g4n0jg2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240605214625-g4n0jg2","updated":"20240605214748"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"var slice1 []int\nvar slice2 []int = make([]int, 5)\nvar slice3 []int = make([]int, 5,7)\nnumbers := []int{1,2,3,4,5,6,7,8}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240605213707-rjchmit","Type":"NodeParagraph","Properties":{"id":"20240605213707-rjchmit","updated":"20240605214804"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"切片有长度和容量的区别，可以在初始化时指定。"}]},{"ID":"20240605214804-89rfy0l","Type":"NodeParagraph","Properties":{"id":"20240605214804-89rfy0l","updated":"20240605214832"},"Children":[{"Type":"NodeText","Data":"由于切片具有可扩展性，所以当它的容量比长度大时，意味着为切片元素的增长预留了内存空间。"}]},{"ID":"20240605214848-x02lunt","Type":"NodeParagraph","Properties":{"id":"20240605214848-x02lunt","updated":"20240605214854"},"Children":[{"Type":"NodeText","Data":"上例中slice2指定了长度为5的int切片，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果不指定容量，则默认其容量与长度相同。"}]},{"ID":"20240605214854-wtvl2xj","Type":"NodeParagraph","Properties":{"id":"20240605214854-wtvl2xj","updated":"20240605214934"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"number被称为切片字面量，在初始化阶段对切片进行了赋值。编译器会自动推断出切片初始化的长度，并使其容量与长度相同。"},{"Type":"NodeText","Data":"\n"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"内置的len和cap函数可以分别获取切片的长度和容量。"}]},{"ID":"20240605214935-5v54i74","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240605214935-5v54i74","updated":"20240605214951"},"Children":[{"Type":"NodeText","Data":"7.1.3 切片的截取"}]},{"ID":"20240605214951-pyvmr4v","Type":"NodeParagraph","Properties":{"id":"20240605214951-pyvmr4v","updated":"20240605215009"},"Children":[{"Type":"NodeText","Data":"和数组一样，切片中的数据仍然是内存中的一片连续区域。要获取切片某一区域的连续数据，可以通过下标的方式对切片进行截断。"}]},{"ID":"20240605215250-nyncvdw","Type":"NodeParagraph","Properties":{"id":"20240605215250-nyncvdw","updated":"20240605215558"},"Children":[{"Type":"NodeText","Data":"被截取后的切片，其长度和容量都发生了变化。如下，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"number1包含了切片中第2、3号元素。切片的长度变为了2，容量变为了6"},{"Type":"NodeText","Data":"，即从第2号元素开始到元素数组的末尾。"}]},{"ID":"20240605215251-erkb70r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240605215251-erkb70r","updated":"20240605215508"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"numbers := []int{1,2,3,4,5,6,7,8}\n// 从下标2一直到下标4，但是不包括下标4\nnumbers1 := numbers[2:4]\n// 从下标0 一直到下标3，但是不包括下标3\nnumbers2 := numbers[:3]\n// 从下标3 一直到结尾\nnumbers3 := numbers[3:]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240605215441-j64r313","Type":"NodeParagraph","Properties":{"id":"20240605215441-j64r313","updated":"20240605215528"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"切片在被截取时的另一个特点是，被截取后的数组仍然指向原始切片的底层数据。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20240605215528-bsno5iv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240605215528-bsno5iv","updated":"20240606152101"},"Children":[{"Type":"NodeText","Data":"7.1.4 切片值复制与数据引用"}]},{"ID":"20240606152102-mvq2ga5","Type":"NodeParagraph","Properties":{"id":"20240606152102-mvq2ga5","updated":"20240606152234"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"数组的复制是值复制"}]},{"ID":"20240606152236-ddvh4r1","Type":"NodeParagraph","Properties":{"id":"20240606152236-ddvh4r1","updated":"20240606152259"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"然而，对于切片b的副本d的修改会影响到原来的切片b。这说明切片的副本与原始切片共用一个内存空间。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20240606152318-25uzjlg","Type":"NodeParagraph","Properties":{"id":"20240606152318-25uzjlg","updated":"20240606152331"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240606152318-jvdb6om.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240606152319-0bik235","Type":"NodeParagraph","Properties":{"id":"20240606152319-0bik235","updated":"20240606152329"},"Children":[{"Type":"NodeText","Data":"在Go语言中，切片的复制其实也是值复制，但这里的值复制指对于运行时SliceHeader结构的复制。"}]},{"ID":"20240606152332-redq23c","Type":"NodeParagraph","Properties":{"id":"20240606152332-redq23c","updated":"20240606152505"},"Children":[{"Type":"NodeText","Data":"如图7-3所示，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"底层指针仍然指向相同的底层数据的数组地址，因此可以理解为数据进行了引用传递。切片的这一特性使得即便切片中有大量数据，在复制时的成本也比较小，这与数组有显著的不同。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20240606152402-7yddups","Type":"NodeParagraph","Properties":{"id":"20240606152402-7yddups","updated":"20240606152402"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240606152402-nw6sypn.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240606152552-lkqmn8j","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240606152552-lkqmn8j","updated":"20240606152606"},"Children":[{"Type":"NodeText","Data":"7.1.5 切片的收缩与扩容"}]},{"ID":"20240606152606-tzeu079","Type":"NodeParagraph","Properties":{"id":"20240606152606-tzeu079","updated":"20240606152614"},"Children":[{"Type":"NodeText","Data":"Go语言内置的append函数可以添加新的元素到切片的末尾，它可以接受可变长度的元素，并且可以自动扩容。如果原有数组的长度和容量已经相同，那么在扩容后，长度和容量都会相应增加。"}]},{"ID":"20240606152621-kp0qbau","Type":"NodeParagraph","Properties":{"id":"20240606152621-kp0qbau","updated":"20240606152621"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240606152621-4x2ykuz.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240606152631-qbdojyv","Type":"NodeParagraph","Properties":{"id":"20240606152631-qbdojyv","updated":"20240606152632"},"Children":[{"Type":"NodeText","Data":"如下所示，numbers切片一开始的长度和容量都为4，当添加一个元素后，其长度变为了5，容量变为了8，相当于扩容了一倍。"}]},{"ID":"20240606152652-o4p3rtw","Type":"NodeParagraph","Properties":{"id":"20240606152652-o4p3rtw","updated":"20240606152718"},"Children":[{"Type":"NodeText","Data":"删除切片的第一个和最后一个元素都非常容易。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"如果要删除切片中间的某一段或某一个元素，可以借助切片的截取特性，通过截取删除元素前后的切片数组，再使用append函数拼接的方式实现。这种处理方式比较优雅，并且效率很高，因为它不会申请额外的内存空间"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20240606152708-3u3l33i","Type":"NodeParagraph","Properties":{"id":"20240606152708-3u3l33i","updated":"20240606152708"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240606152708-1d1tyqh.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240606152720-zrlrzaf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240606152720-zrlrzaf","updated":"20240606152735"},"Children":[{"Type":"NodeText","Data":"7.2 切片底层原理"}]},{"ID":"20240606152735-epezi2h","Type":"NodeParagraph","Properties":{"id":"20240606152735-epezi2h","updated":"20240606152743"},"Children":[{"Type":"NodeText","Data":"在编译时构建抽象语法树阶段会将切片构建为如下类型。"}]},{"ID":"20240606152744-6hhq9h1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240606152744-6hhq9h1","updated":"20240606152818"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Slice struct {\n  Elem *Type // element type\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240606152829-628knks","Type":"NodeParagraph","Properties":{"id":"20240606152829-628knks","updated":"20240606152830"},"Children":[{"Type":"NodeText","Data":"编译时使用NewSlice函数新建一个切片类型，并需要传递切片元素的类型。从中可以看出，切片元素的类型elem是在编译期间确定的。"}]},{"ID":"20240606152831-621tf23","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240606152831-621tf23","updated":"20240606152932"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func NewSlice(elem *Type) *Type {\n  t := New(TSLICE)\n  t.Extra = Slice(Elem: elem)\n  elem.Cache.slice = t\n  return t\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240606152937-xzbocbv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240606152937-xzbocbv","updated":"20240606152938"},"Children":[{"Type":"NodeText","Data":"7.2.1 字面量初始化"}]},{"ID":"20240606152940-pctjlps","Type":"NodeParagraph","Properties":{"id":"20240606152940-pctjlps","updated":"20240606153009"},"Children":[{"Type":"NodeText","Data":"当使用形如[]int{1，2，3}的字面量创建新的切片时，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"会创建一个array数组（[3]int{1，2，3}）存储于静态区中，并在堆区创建一个新的切片，在程序启动时将静态区的数据复制到堆区，这样可以加快切片的初始化过程。"}]},{"ID":"20240606153009-idqpx5q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240606153009-idqpx5q","updated":"20240606153024"},"Children":[{"Type":"NodeText","Data":"7.2.2 make 初始化"}]},{"ID":"20240606153024-gigv5ka","Type":"NodeParagraph","Properties":{"id":"20240606153024-gigv5ka","updated":"20240606153032"},"Children":[{"Type":"NodeText","Data":"对形如make（[]int，3，4）的初始化切片。在类型检查阶段typecheck1函数中，节点Node的Op操作为OMAKESLICE，并且左节点存储长度为3，右节点存储容量为4。"}]},{"ID":"20240606153053-qtfcmsf","Type":"NodeParagraph","Properties":{"id":"20240606153053-qtfcmsf","updated":"20240606153110"},"Children":[{"Type":"NodeText","Data":"编译时对于字面量的重要优化是判断变量应该被分配到栈中还是应该逃逸到堆区。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果make函数初始化了一个太大的切片，则该切片会逃逸到堆中。如果分配了一个比较小的切片，则会直接在栈中分配。此临界值定义在cmd/compile/internal/gc.maxImplicitStackVarSize变量中，默认为64KB，可以通过指定编译时smallframes标识进行更新，因此，make（[]int64，1023）与make（[]int64，1024）实现的细节是截然不同的。"}]},{"ID":"20240606153111-9tzp7sb","Type":"NodeParagraph","Properties":{"id":"20240606153111-9tzp7sb","updated":"20240606153121"},"Children":[{"Type":"NodeText","Data":"字面量内存逃逸的核心逻辑位于cmd/compile/internal/gc/walk.go，n.Esc代表是否判断出变量需要逃逸。其伪代码如下。"}]},{"ID":"20240606153130-kega65r","Type":"NodeParagraph","Properties":{"id":"20240606153130-kega65r","updated":"20240606153132"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240606153130-d34fhyo.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240606153132-mhz3wgb","Type":"NodeParagraph","Properties":{"id":"20240606153132-mhz3wgb","updated":"20240606153141"},"Children":[{"Type":"NodeText","Data":"如果没有逃逸，那么切片运行时最终会被分配在栈中。而如果发生了逃逸，那么运行时调用makesliceXX函数会将切片分配在堆中。当切片的长度和容量小于int类型的最大值时，会调用makeslice函数，反之调用makeslice64函数创建切片。"}]},{"ID":"20240606153142-pyf2yqj","Type":"NodeParagraph","Properties":{"id":"20240606153142-pyf2yqj","updated":"20240606153142"}},{"ID":"20240606153159-wa1kgvp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240606153159-wa1kgvp","updated":"20240606153212"},"Children":[{"Type":"NodeText","Data":"7.2.3 切片扩容原理"}]},{"ID":"20240606153212-pzqxyhp","Type":"NodeParagraph","Properties":{"id":"20240606153212-pzqxyhp","updated":"20240606153221"},"Children":[{"Type":"NodeText","Data":"切片使用append函数添加元素，但不是使用了append函数就需要进行扩容，如下代码向长度为3，容量为4的切片a中添加元素后不需要扩容。"}]},{"ID":"20240606153222-j21792x","Type":"NodeParagraph","Properties":{"id":"20240606153222-j21792x","updated":"20240606153229"},"Children":[{"Type":"NodeText","Data":"切片增加元素后长度超过了现有容量，例如b一开始的长度和容量都为3，但使用append函数后，其容量变为了6。"}]},{"ID":"20240606153248-w5yxxsy","Type":"NodeParagraph","Properties":{"id":"20240606153248-w5yxxsy","updated":"20240606153300"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"Go语言中切片扩容的策略为：\n◎ 如果新申请容量（cap）大于2倍的旧容量（old.cap），则最终容量（newcap）是新申请的容量（cap）。\n◎ 如果旧切片的长度小于1024，则最终容量是旧容量的2倍，即newcap=doublecap。\n◎ 如果旧切片长度大于或等于1024，则最终容量从旧容量开始循环增加原来的1/4，即newcap=old.cap，for {newcap+=newcap/4}，直到最终容量大于或等于新申请的容量为止，即newcap ≥ cap。\n◎ 如果最终容量计算值溢出，即超过了int的最大范围，则最终容量就是新申请容量。\nGrowslice函数会根据切片的类型，分配不同大小的内存。为了对齐内存，申请的内存可能大于实际的类型大小×容量大小。\n如果切片需要扩容，那么最后需要到堆区申请内存。要注意的是，扩容后新的切片不一定拥有新的地址。因此在使用append函数时，通常会采用a=append（a，T）的形式。根据et.ptrdata是否判断切片类型为指针，执行不同的逻辑。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20240606153356-z6xzv52","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240606153356-z6xzv52","updated":"20240606153411"},"Children":[{"Type":"NodeText","Data":"7.2.4 切片截取原理"}]},{"ID":"20240606153411-qjok5xa","Type":"NodeParagraph","Properties":{"id":"20240606153411-qjok5xa","updated":"20240606154142"},"Children":[{"Type":"NodeText","Data":"如下所示，根据下标截取的原理，new切片截取了old切片的第2、3号元素。截取后虽然生成了一个新的切片，但是两个切片指向的底层数据源是同一个，可以使用fmt.Printf的%p格式化打印出变量的地址进行验证。"}]},{"ID":"20240606154149-9654qj8","Type":"NodeParagraph","Properties":{"id":"20240606154149-9654qj8","updated":"20240606154152"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240606154149-8ozrq15.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240606154150-rrzv1if","Type":"NodeParagraph","Properties":{"id":"20240606154150-rrzv1if","updated":"20240606154209"},"Children":[{"Type":"NodeText","Data":"二者的地址正好相差8字节，这不是偶然的，而是因为二者指向了相同的数据源，所以刚好相差int64的大小。"}]},{"ID":"20240606154302-tg64bou","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240606154302-tg64bou","updated":"20240606154314"},"Children":[{"Type":"NodeText","Data":"7.2.5 切片的完整复制"}]},{"ID":"20240606154315-6wy17oc","Type":"NodeParagraph","Properties":{"id":"20240606154315-6wy17oc","updated":"20240606154336"},"Children":[{"Type":"NodeText","Data":"复制的切片不会改变指向底层的数据源，但有些时候我们希望建一个新的数组，并且与旧数组不共享相同的数据源，这时可以使用copy函数。"}]},{"ID":"20240606154337-pix9x3t","Type":"NodeParagraph","Properties":{"id":"20240606154337-pix9x3t","updated":"20240606154357"},"Children":[{"Type":"NodeText","Data":"如果在复制时，数组的长度与切片的长度不同，例如copy（arr[：]，slice），则复制的元素为len（arr）与len（slice）的较小值。"}]},{"ID":"20240606154403-gllbfe2","Type":"NodeParagraph","Properties":{"id":"20240606154403-gllbfe2","updated":"20240606154411"},"Children":[{"Type":"NodeText","Data":"copy函数在运行时主要调用了memmove函数，用于实现内存的复制。如果采用协程调用的方式go copy（numbers1，numbers）或者加入了race检测，则会转而调用运行时slicestringcopy或slicecopy函数，进行额外的检查。"}]},{"ID":"20240606154412-gk8tmvn","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240606154412-gk8tmvn","updated":"20240606154419"},"Children":[{"Type":"NodeText","Data":"7.3 总结"}]},{"ID":"20240606154419-81tjpmg","Type":"NodeParagraph","Properties":{"id":"20240606154419-81tjpmg","updated":"20240606154514"},"Children":[{"Type":"NodeText","Data":"切片是Go语言中最常用的数据结构。和其他语言不同的是，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"切片除了维护底层的元素地址，还维护长度和容量。"},{"Type":"NodeText","Data":"\n切片与数组的赋值拷贝有明显区别，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"切片在赋值拷贝与下标截断时引用了相同的底层数据。如果要完全拷贝切片，则使用copy函数。其逻辑是新建一个内存，并复制过去。在极端情况下需要考虑其对性能的影响。"},{"Type":"NodeText","Data":"\n"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"切片字面量的初始化，会以数组的形式存储于静态区中。在使用make函数初始化时，如果make函数初始化了一个大于64KB的切片，那么这个切片会逃逸到堆中，在运行时调用makeslice函数创建切片，小于64KB的切片直接在栈中初始化。"},{"Type":"NodeText","Data":"\nGo语言中内置append函数用于添加元素，当容量超过了现有容量时，切片需要进行扩容，其策略是：\n◎ 如果新申请容量大于2倍的旧容量，则最终容量是新申请的容量。\n◎ 如果旧切片的长度小于1024，则最终容量是旧容量的2倍。\n◎ 如果旧切片长度大于或等于1024，则最终容量从旧容量开始循环增加原来的1/4，直到最终容量大于或等于新申请的容量为止。\n◎ 如果最终容量过大导致溢出，则最终容量就是新申请容量。\n"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"切片扩容后返回的地址并不一定和原来的地址相同"},{"Type":"NodeText","Data":"，因此必须小心其可能遇到的陷阱，一般会使用形如a=append（a，T）的方式保证其安全。"}]}]}