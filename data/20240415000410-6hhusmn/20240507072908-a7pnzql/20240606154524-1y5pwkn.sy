{"ID":"20240606154524-1y5pwkn","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f346","id":"20240606154524-1y5pwkn","title":"第八章 哈希表与Go语言实现机制","type":"doc","updated":"20240607112656"},"Children":[{"ID":"20240606154524-488a9tq","Type":"NodeParagraph","Properties":{"id":"20240606154524-488a9tq","updated":"20240606154704"},"Children":[{"Type":"NodeText","Data":"Go语言中的map又被称为哈希表，是使用频率极高的一种数据结构。哈希表的原理是将多个键/值（key/value）对分散存储在buckets（桶）中。给定一个键（key），哈希（Hash）算法会计算出键值对存储的位置。"}]},{"ID":"20240606160527-guzjc0h","Type":"NodeParagraph","Properties":{"id":"20240606160527-guzjc0h","updated":"20240606160528"},"Children":[{"Type":"NodeText","Data":"在实践中，我们通常将map看作o（1）时间复杂度的操作，通过一个键快速寻找其唯一对应的值（value）。在许多情况下，哈希表的查找速度明显快于一些搜索树形式的数据结构，被广泛用于关联数组、缓存、数据库缓存等场景中。"}]},{"ID":"20240606160529-qw5mz1d","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240606160529-qw5mz1d","updated":"20240606160544"},"Children":[{"Type":"NodeText","Data":"8.1 哈希碰撞与解决方法"}]},{"ID":"20240606160544-92jk6a1","Type":"NodeParagraph","Properties":{"id":"20240606160544-92jk6a1","updated":"20240606160554"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"哈希函数在实际中遇到的最常见问题是哈希碰撞（Hash Collision），即不同的键通过哈希函数可能产生相同的哈希值。"}]},{"ID":"20240606160556-bwp9l30","Type":"NodeParagraph","Properties":{"id":"20240606160556-bwp9l30","updated":"20240606160612"},"Children":[{"Type":"NodeText","Data":"如果将2450个键随机分配到一百万个桶中，则根据概率计算，至少有两个键被分配到同一个桶中的可能性有惊人的95%。"}]},{"ID":"20240606160620-p58iav8","Type":"NodeParagraph","Properties":{"id":"20240606160620-p58iav8","updated":"20240606160628"},"Children":[{"Type":"NodeText","Data":"哈希碰撞导致同一个桶中可能存在多个元素，有多种方式可以避免哈希碰撞，一般有两种主要的策略："},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"拉链法及开放寻址法。"}]},{"ID":"20240606160629-m65puk6","Type":"NodeParagraph","Properties":{"id":"20240606160629-m65puk6","updated":"20240606160719"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"拉链法将同一个桶中的元素通过链表的形式进行链接，这是一种最简单、最常用的策略。随着桶中元素的增加，可以不断链接新的元素，同时不用预先为元素分配内存。拉链法的不足之处在于，需要存储额外的指针用于链接元素，这增加了整个哈希表的大小。同时由于链表存储的地址不连续，所以无法高效利用CPU高速缓存。"}]},{"ID":"20240606160652-fnj16x5","Type":"NodeParagraph","Properties":{"id":"20240606160652-fnj16x5","updated":"20240606160656"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240606160652-1x58ebc.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240606160658-aobfkik","Type":"NodeParagraph","Properties":{"id":"20240606160658-aobfkik","updated":"20240606160820"},"Children":[{"Type":"NodeText","Data":"与拉链法对应的另一种解决哈希碰撞的策略为开放寻址法（Open Addressing），如图8-2所示，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"所有元素都存储在桶的数组中。当必须插入新条目时，将按某种探测策略操作，直到找到未使用的数组插槽为止。当搜索元素时，将按相同顺序扫描存储桶，直到查找到目标记录或找到未使用的插槽为止。"}]},{"ID":"20240606160806-mxp75jd","Type":"NodeParagraph","Properties":{"id":"20240606160806-mxp75jd","updated":"20240606160808"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240606160806-ilbupru.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240606160809-9ggq6oz","Type":"NodeParagraph","Properties":{"id":"20240606160809-9ggq6oz","updated":"20240606162428"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"Go语言中的哈希表采用的是开放寻址法中的线性探测（Linear Probing）策略，线性探测策略是顺序（每次探测间隔为1）的。由于良好的CPU高速缓存利用率和高性能，该算法是现代计算机体系中使用最广泛的结构。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeText","Data":"在第12章还会看到，接口使用的全局itab哈希表采用了开放寻址法中的二方探测策略。"}]},{"ID":"20240606160923-vfzjw3p","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240606160923-vfzjw3p","updated":"20240606162437"},"Children":[{"Type":"NodeText","Data":"8.2 map 基本操作"}]},{"ID":"20240606162438-catay0k","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240606162438-catay0k","updated":"20240606162449"},"Children":[{"Type":"NodeText","Data":"8.2.1 map 的声明与初始化"}]},{"ID":"20240606162502-7tguip6","Type":"NodeParagraph","Properties":{"id":"20240606162502-7tguip6","updated":"20240606162510"},"Children":[{"Type":"NodeText","Data":"map 的声明："}]},{"ID":"20240606162647-3n6rg44","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240606162647-3n6rg44","updated":"20240606162657"},"Children":[{"Type":"NodeText","Data":"声明一："}]},{"ID":"20240606162449-raeepps","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240606162449-raeepps","updated":"20240606162657"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"var hash map[T]T\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240606162526-fect0qw","Type":"NodeParagraph","Properties":{"id":"20240606162526-fect0qw","updated":"20240606162705"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"其并未对map 进行初始化操作，值为nil。因此一旦进行 hash[key]=value 这样的赋值操作就会报错。Go语言允许对值为nil的map进行访问，虽然结果毫无意义。"}]},{"ID":"20240606162632-5tajf16","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240606162632-5tajf16","updated":"20240606162711"},"Children":[{"Type":"NodeText","Data":"声明二："}]},{"ID":"20240606162712-wldgav2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240606162712-wldgav2","updated":"20240606162744"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"var hash = make(map[T][T],NUMBER)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240606162614-977gezs","Type":"NodeParagraph","Properties":{"id":"20240606162614-977gezs","updated":"20240606162850"},"Children":[{"Type":"NodeText","Data":"通过使用make 函数初始化。make 函数中的第二个参数代表初始化创建map的长度，当NUMBER为空时，其默认长度为0。"}]},{"ID":"20240606162851-lgrv5vu","Type":"NodeParagraph","Properties":{"id":"20240606162851-lgrv5vu","updated":"20240607095438"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"可以正常地对map进行访问与赋值。map还有字面量形式初始化的方式如下所示，country与rating在创建map时即在其中添加了元素"}]},{"ID":"20240607095441-hakmlfs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240607095441-hakmlfs","updated":"20240607095631"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"var country = map[string]string{\n  \"China\": \"Beijing\",\n  \"Japan\": \"Tokyo\",\n  \"India\": \"New Delhi\"\n}\nrating := map[string]float64{\"c\": 5, \"Go\": 4.5, \"Python\": 4.5,\"C++\": 3}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240607095633-t30x1pn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240607095633-t30x1pn","updated":"20240607095650"},"Children":[{"Type":"NodeText","Data":"8.2.2 map 访问"}]},{"ID":"20240607095650-5e7kdbg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240607095650-5e7kdbg","updated":"20240607095718"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"v := hash[key]\nv, ok := map[key]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240607095724-hsty9ay","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240607095724-hsty9ay","updated":"20240607095738"},"Children":[{"Type":"NodeText","Data":"8.2.3 map 赋值"}]},{"ID":"20240607095744-788xeyk","Type":"NodeParagraph","Properties":{"id":"20240607095744-788xeyk","updated":"20240607100346"},"Children":[{"Type":"NodeText","Data":"map的赋值语法相对简单，例如hash[key]=value代表将value与map1哈希表中的key绑定在一起。"}]},{"ID":"20240607100355-ilunyjt","Type":"NodeParagraph","Properties":{"id":"20240607100355-ilunyjt","updated":"20240607100355"},"Children":[{"Type":"NodeText","Data":"delete是Go语言中的关键字，用于进行map的删除操作，形如delete（hash，key），可以对相同的key进行多次删除操作而不会报错。"}]},{"ID":"20240607100358-drxkf5q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240607100358-drxkf5q","updated":"20240607100410"},"Children":[{"Type":"NodeText","Data":"8.2.4 key 的比较性"}]},{"ID":"20240607100410-1mcfk13","Type":"NodeList","ListData":{},"Properties":{"id":"20240607100410-1mcfk13","updated":"20240607103428"},"Children":[{"ID":"20240607100418-xyr5gdw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240607100418-xyr5gdw","updated":"20240607100418"},"Children":[{"ID":"20240607100418-d5awkwe","Type":"NodeParagraph","Properties":{"id":"20240607100418-d5awkwe","updated":"20240607100429"},"Children":[{"Type":"NodeText","Data":"布尔类型是可比较的；"}]}]},{"ID":"20240607100430-bo76k7c","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240607100430-bo76k7c"},"Children":[{"ID":"20240607100430-jz8932b","Type":"NodeParagraph","Properties":{"id":"20240607100430-jz8932b","updated":"20240607100504"},"Children":[{"Type":"NodeText","Data":"整数值是可比较的；"}]}]},{"ID":"20240607100504-1mfhq91","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240607100504-1mfhq91"},"Children":[{"ID":"20240607100504-r9v1u65","Type":"NodeParagraph","Properties":{"id":"20240607100504-r9v1u65","updated":"20240607100513"},"Children":[{"Type":"NodeText","Data":"浮点值是可比较的；"}]}]},{"ID":"20240607100513-3hirzsf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240607100513-3hirzsf"},"Children":[{"ID":"20240607100513-qkc14f4","Type":"NodeParagraph","Properties":{"id":"20240607100513-qkc14f4","updated":"20240607100525"},"Children":[{"Type":"NodeText","Data":"复数值是可比较的；"}]}]},{"ID":"20240607100526-uh1ugre","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240607100526-uh1ugre"},"Children":[{"ID":"20240607100526-mjk6y1u","Type":"NodeParagraph","Properties":{"id":"20240607100526-mjk6y1u","updated":"20240607100537"},"Children":[{"Type":"NodeText","Data":"字符串是可比较的；"}]}]},{"ID":"20240607100538-bn2p90t","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240607100538-bn2p90t"},"Children":[{"ID":"20240607100538-w5kwwgf","Type":"NodeParagraph","Properties":{"id":"20240607100538-w5kwwgf","updated":"20240607100624"},"Children":[{"Type":"NodeText","Data":"指针值是可比较的；如果两个指针指向相同的变量或者两个指针的值均为 null，则他们相等；"}]}]},{"ID":"20240607100625-ppktne8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240607100625-ppktne8"},"Children":[{"ID":"20240607100625-9zxudqj","Type":"NodeParagraph","Properties":{"id":"20240607100625-9zxudqj","updated":"20240607103341"},"Children":[{"Type":"NodeText","Data":"通道值是可以比较的；如果两个通道值是由相同的make函数调用创建的，或者两个值都为nil，则它们相等"}]}]},{"ID":"20240607103342-aaozctv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240607103342-aaozctv"},"Children":[{"ID":"20240607103342-7msm2cm","Type":"NodeParagraph","Properties":{"id":"20240607103342-7msm2cm","updated":"20240607103357"},"Children":[{"Type":"NodeText","Data":"接口值是可以比较的；如果两个接口值具有相同的动态类型和相等的动态值，或者两个接口值都为nil，则它们相等。"}]}]},{"ID":"20240607103357-w2zmv26","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240607103357-w2zmv26"},"Children":[{"ID":"20240607103357-ft15a7z","Type":"NodeParagraph","Properties":{"id":"20240607103357-ft15a7z","updated":"20240607103403"},"Children":[{"Type":"NodeText","Data":"如果结构的所有字段都是可比较的，则它们的值是可比较的。"}]}]},{"ID":"20240607103409-jgnfhtl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240607103409-jgnfhtl"},"Children":[{"ID":"20240607103409-13stj3m","Type":"NodeParagraph","Properties":{"id":"20240607103409-13stj3m","updated":"20240607103409"},"Children":[{"Type":"NodeText","Data":"如果数组元素类型的值可比较，则数组值可比较。如果两个数组对应的元素相等，则它们相等。"}]}]},{"ID":"20240607103410-vg80y6f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240607103410-vg80y6f","updated":"20240607103428"},"Children":[{"ID":"20240607103410-li9398c","Type":"NodeParagraph","Properties":{"id":"20240607103410-li9398c","updated":"20240607103428"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"text strong","TextMarkTextContent":"切片、函数、map是不可比较的。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]}]}]},{"ID":"20240607102451-vjep2fr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240607102451-vjep2fr","updated":"20240607103447"},"Children":[{"Type":"NodeText","Data":"8.2.5 map 并发冲突"}]},{"ID":"20240607103447-fkh910i","Type":"NodeParagraph","Properties":{"id":"20240607103447-fkh910i","updated":"20240607103501"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"map并不支持并发的读写"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20240607103502-cxfw5l1","Type":"NodeParagraph","Properties":{"id":"20240607103502-cxfw5l1","updated":"20240607103544"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"Go语言只支持并发"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-font-color1); font-size: 29px;"},"TextMarkType":"text strong","TextMarkTextContent":"读取"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-font-color1); font-size: 29px;\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"map，"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20240607103531-iubc1py","Type":"NodeParagraph","Properties":{"id":"20240607103531-iubc1py","updated":"20240607103610"},"Children":[{"Type":"NodeText","Data":"map不需要从多个Goroutine安全访问，在实际情况下，map可能是某些已经同步的较大数据结构或计算的一部分。因此，要求所有map操作都互斥将减慢大多数程序的速度，而只会增加少数程序的安全性。”即"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color7);"},"TextMarkType":"strong text","TextMarkTextContent":"Go语言只支持并发读写的原因是保证大多数场景下的查找效率。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color7);\"}"}]},{"ID":"20240607103611-zy2rmku","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240607103611-zy2rmku","updated":"20240607103652"},"Children":[{"Type":"NodeText","Data":"8.3 哈希表底层结构"}]},{"ID":"20240607103652-vshu331","Type":"NodeParagraph","Properties":{"id":"20240607103652-vshu331","updated":"20240607103728"},"Children":[{"Type":"NodeText","Data":"Go语言map的底层实现如下所示："}]},{"ID":"20240607103729-rcxhuda","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240607103729-rcxhuda","updated":"20240607104007"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type hmap struct {\n\tcount int\n\tflags uint8\n\tB uint8\n\tnoverflow uint16\n\thash0 uint32\n\tbuckets unsafe.Pointer\n\toldbuckets unsafe.Pointer\n\tnevacuate uintptr\n\textra *mapextra\n}"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240607104010-lxer4pm","Type":"NodeParagraph","Properties":{"id":"20240607104010-lxer4pm","updated":"20240607104022"},"Children":[{"Type":"NodeText","Data":"其中，\n◎ count代表map中元素的数量。\n◎ flags代表当前map的状态（是否处于正在写入的状态等）。\n◎ 2的B次幂表示当前map中桶的数量，2^B=Buckets size。\n◎ noverflow为map中溢出桶的数量。当溢出的桶太多时，map会进行same-size map growth，其实质是避免溢出桶过大导致内存泄露。\n◎ hash0代表生成hash的随机数种子。\n◎ buckets是指向当前map对应的桶的指针。\n◎ oldbuckets是在map扩容时存储旧桶的，当所有旧桶中的数据都已经转移到了新桶中时，则清空。\n◎ nevacuate在扩容时使用，用于标记当前旧桶中小于nevacuate的数据都已经转移到了新桶中。\n◎ extra存储map中的溢出桶。"}]},{"ID":"20240607104113-s7bcncx","Type":"NodeParagraph","Properties":{"id":"20240607104113-s7bcncx","updated":"20240607104114"},"Children":[{"Type":"NodeText","Data":"代表桶的bmap结构在运行时只列出了首个字段，即一个固定长度为8的数组。此字段顺序存储key的哈希值的前8位。"}]},{"ID":"20240607104115-0glw5dn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240607104115-0glw5dn","updated":"20240607104148"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type bmap struct {\n  tophash [bucketCnt]uint8\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240607104128-i1gojte","Type":"NodeParagraph","Properties":{"id":"20240607104128-i1gojte","updated":"20240607104211"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"map在编译时即确定了map中key、value及桶的大小，因此在运行时仅仅通过指针操作就可以找到特定位置的元素。桶在存储的tophash字段后，会存储key数组及value数组。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20240607104212-pzezpei","Type":"NodeParagraph","Properties":{"id":"20240607104212-pzezpei","updated":"20240607104212"}},{"ID":"20240607104215-kdgs3rj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240607104215-kdgs3rj","updated":"20240607104227"},"Children":[{"Type":"NodeText","Data":"8.4 哈希表原理图解"}]},{"ID":"20240607104621-dfz6gt8","Type":"NodeParagraph","Properties":{"id":"20240607104621-dfz6gt8","updated":"20240607104625"},"Children":[{"Type":"NodeText","Data":"Go语言选择将key与value分开存储而不是以key/value/key/value的形式存储，是为了在字节对齐时压缩空间。"}]},{"ID":"20240607104629-ob2cy3g","Type":"NodeParagraph","Properties":{"id":"20240607104629-ob2cy3g","updated":"20240607104629"},"Children":[{"Type":"NodeText","Data":"在进行hash[key]的map访问操作时，会首先找到桶的位置，如下为伪代码："}]},{"ID":"20240607104630-px3ceb7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240607104630-px3ceb7","updated":"20240607104651"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"hash = hashfunc(key)\nindex = hash % array_size\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240607104658-g2rh1yp","Type":"NodeParagraph","Properties":{"id":"20240607104658-g2rh1yp","updated":"20240607104659"},"Children":[{"Type":"NodeText","Data":"找到桶的位置后遍历tophash数组，如图8-3所示，如果在数组中找到了相同的hash，那么可以接着通过指针的寻址操作找到对应的key与value。"}]},{"ID":"20240607104706-usqieb7","Type":"NodeParagraph","Properties":{"id":"20240607104706-usqieb7","updated":"20240607104710"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240607104706-oiz0o8k.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240607104712-cpeas2m","Type":"NodeParagraph","Properties":{"id":"20240607104712-cpeas2m","updated":"20240607104819"},"Children":[{"Type":"NodeText","Data":"在Go语言中还有一个"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"溢出桶"},{"Type":"NodeText","Data":"的概念"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，在执行hash[key]=value赋值操作时，当指定桶中的数据超过8个时，并不会直接开辟一个新桶，而是将数据放置到溢出桶中，每个桶的最后都存储了overflow，即溢出桶的指针。在正常情况下，数据是很少会跑到溢出桶里面去的。"}]},{"ID":"20240607104754-et3h3wi","Type":"NodeParagraph","Properties":{"id":"20240607104754-et3h3wi","updated":"20240607104807"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"同理，我们可以知道，在map执行查找操作时，如果key的hash在指定桶的tophash数组中不存在，那么需要遍历溢出桶中的数据。"}]},{"ID":"20240607104807-gqfi9h2","Type":"NodeParagraph","Properties":{"id":"20240607104807-gqfi9h2","updated":"20240607104834"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果一开始，初始化map的数量比较大，则map会提前创建好一些溢出桶存储在extra*mapextra字段。"}]},{"ID":"20240607104852-wf2zzp2","Type":"NodeParagraph","Properties":{"id":"20240607104852-wf2zzp2","updated":"20240607104855"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240607104852-vx5gr98.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240607104855-kli9dov","Type":"NodeParagraph","Properties":{"id":"20240607104855-kli9dov","updated":"20240607105240"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这样当出现溢出现象时，可以用提前创建好的桶而不用申请额外的内存空间。只有预分配的溢出桶使用完了，才会新建溢出桶。\n当发生以下两种情况之一时，map会进行重建：\n◎ map超过了负载因子大小。\n◎ 溢出桶的数量过多。"},{"Type":"NodeText","Data":"\n在哈希表中有经典的负载因子的概念：\n"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"负载因子=哈希表中的元素数量/桶的数量"}]},{"ID":"20240607104920-gzpqile","Type":"NodeParagraph","Properties":{"id":"20240607104920-gzpqile","updated":"20240607105324"},"Children":[{"Type":"NodeText","Data":"负载因子的增大，意味着更多的元素会被分配到同一个桶中，此时效率会减慢。试想，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果桶的数量只有1个，则此时负载因子到达最大，搜索效率就成了遍历数组。Go语言中的负载因子为6.5，当超过其大小后，map会进行扩容，增大到旧表2倍的大小，如图8-4所示。旧桶的数据会存到oldbuckets字段中，并想办法分散转移到新桶中。"},{"Type":"NodeText","Data":"\n"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"当旧桶中的数据全部转移到新桶中后，旧桶就会被清空。map的重建还存在第二种情况，即溢出桶的数量太多，这时map只会新建和原来相同大小的桶，目的是防止溢出桶的数量缓慢增长导致的内存泄露。"},{"Type":"NodeText","Data":"\n如图8-5所示，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"当进行map的delete操作时，和赋值操作类似，delete操作会根据key找到指定的桶，如果存在指定的key，那么就释放掉key与value引用的内存。同时tophash中的指定位置会存储emptyOne，代表当前位置是空的。"}]},{"ID":"20240607104937-fjjc28v","Type":"NodeParagraph","Properties":{"id":"20240607104937-fjjc28v","updated":"20240607104955"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240607104937-bh58dsg.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240607105016-jwm77xn","Type":"NodeParagraph","Properties":{"id":"20240607105016-jwm77xn","updated":"20240607105335"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240607105016-jdovb6i.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240607105023-rkynf5b","Type":"NodeParagraph","Properties":{"id":"20240607105023-rkynf5b","updated":"20240607105331"},"Children":[{"Type":"NodeText","Data":"同时，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"删除操作会探测当前要删除的元素之后是否都是空的。如果是，则tophash会存储为emptyRest。这样做的好处是在做查找操作时，遇到emptyRest可以直接退出，因为后面的元素都是空的。"}]},{"ID":"20240607105336-5kupefj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240607105336-5kupefj","updated":"20240607105349"},"Children":[{"Type":"NodeText","Data":"8.5 深入哈希表原理"}]},{"ID":"20240607105349-hrzx1gb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240607105349-hrzx1gb","updated":"20240607105403"},"Children":[{"Type":"NodeText","Data":"8.5.1 make 初始化原理"}]},{"ID":"20240607105419-mbbxgav","Type":"NodeParagraph","Properties":{"id":"20240607105419-mbbxgav","updated":"20240607112155"},"Children":[{"Type":"NodeText","Data":"如果使用make关键字初始化map，则在typecheck1类型检查阶段，将节点Node的Op操作变为OMAKEMAP；如果make指定了哈希表的长度，则会将长度常量值类型转换为TINT；如果未指定长度，则长度为0（nodintconst（0））。"}]},{"ID":"20240607112212-k8t7r83","Type":"NodeParagraph","Properties":{"id":"20240607112212-k8t7r83","updated":"20240607112214"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240607112212-biqfbu8.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240607112215-4q8qjvv","Type":"NodeParagraph","Properties":{"id":"20240607112215-4q8qjvv","updated":"20240607112222"},"Children":[{"Type":"NodeText","Data":"如果make的第二个参数不是整数，则会在类型检查时报错。"}]},{"ID":"20240607112232-9kw14xd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240607112232-9kw14xd","updated":"20240607112247"},"Children":[{"Type":"NodeText","Data":"8.5.2 字面量初始化原理"}]},{"ID":"20240607112247-3lg5l2w","Type":"NodeParagraph","Properties":{"id":"20240607112247-3lg5l2w","updated":"20240607112311"},"Children":[{"Type":"NodeText","Data":"如果map采取了字面量初始化的方式，那么它最终仍然需要转换为make操作。map的长度被自动推断为字面量的长度，其核心逻辑位于gc/sinit.go文件的anylit函数中，该函数专门用于处理各种类型的字面量。"}]},{"ID":"20240607112314-dv0jbrw","Type":"NodeParagraph","Properties":{"id":"20240607112314-dv0jbrw","updated":"20240607112324"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果字面量的个数大于25，则会构建两个数组专门存储key与value，在运行时循环添加数据。如果字面量的个数小于25，则编译时会通过在运行时初始化时直接添加的方式进行赋值"}]},{"ID":"20240607112318-7twjt04","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240607112318-7twjt04","updated":"20240607112337"},"Children":[{"Type":"NodeText","Data":"8.5.3 map 访问原理"}]},{"ID":"20240607112338-4hf936c","Type":"NodeParagraph","Properties":{"id":"20240607112338-4hf936c","updated":"20240607112632"},"Children":[{"Type":"NodeText","Data":"对map的访问有两种形式：一种是返回单个值v：=hash[key]，一种是返回多个值。"}]},{"ID":"20240607112633-oreekrn","Type":"NodeParagraph","Properties":{"id":"20240607112633-oreekrn","updated":"20240607112656"},"Children":[{"Type":"NodeText","Data":"Go语言采用了一种简单的方式hash\u0026m计算出key应该位于哪一个桶中。获取桶的位置后，tophash（hash）计算出hash的前8位。接着此hash挨个与存储在桶中的tophash进行对比。如果有hash值相同，则会找到此hash值对应的key值并判断是否相同。如果key值也相同，则说明查找到了结果，返回value。"}]}]}