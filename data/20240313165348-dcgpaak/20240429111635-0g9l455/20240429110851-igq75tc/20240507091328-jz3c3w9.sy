{"ID":"20240507091328-jz3c3w9","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f981","id":"20240507091328-jz3c3w9","title":"controller 调度策略解析","updated":"20240507101403"},"Children":[{"ID":"20240507095117-v9bwhns","Type":"NodeParagraph","Properties":{"id":"20240507095117-v9bwhns","updated":"20240507100034"},"Children":[{"Type":"NodeText","Data":"Controller 的调度策略默认为shortest_queue（最短队列）,可选策略有：抽奖、最短队列。"}]},{"ID":"20240507100035-ud1gmd0","Type":"NodeParagraph","Properties":{"id":"20240507100035-ud1gmd0","updated":"20240507100054"},"Children":[{"Type":"NodeText","Data":"get_worker_address:"}]},{"ID":"20240507100055-pyssn3d","Type":"NodeParagraph","Properties":{"id":"20240507100055-pyssn3d","updated":"20240507101451"},"Children":[{"Type":"NodeText","Data":"检查调度策略是否为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"DispatchMethod.LOTTERY"},{"Type":"NodeText","Data":"​，如果是该策略，则收集符合条件的工作者信息：遍历工作者信息字典，找到包含指定模型名称的工作者，将它们的名称（worker_names) 和速度（worker_speeds) 分别存储到列表中。"}]},{"ID":"20240507100444-wclqel7","Type":"NodeParagraph","Properties":{"id":"20240507100444-wclqel7","updated":"20240507101252"},"Children":[{"Type":"NodeText","Data":"处理工作者速度：将速度列表转换为 numpy 数组，检查速度总和是否小于 1e-4(视为无可用工作者)，如果小于则返回空，如果大于则将速度数组除以速度之和（归一化），根据归一化的速度比例使用随机数生成器选择一个工作者。然后返回。"}]},{"ID":"20240507100620-oscuy5r","Type":"NodeParagraph","Properties":{"id":"20240507100620-oscuy5r","updated":"20240507101108"},"Children":[{"Type":"NodeText","Data":"该策略中还包含了检查工作者状态的方法，只是未启用。该方法会检查随机数选择的工作者状态，如果该工作者状态不正常，则会移除该工作者，并更新速度数组，然后再一次归一化速度数组并使用随机数生成器重新选择新的检查工作者，这个过程会持续进行，直到找到状态正常的工作者为止。如果所有的工作者都被移除且速度总和小于 1e-4 （视为无可用工作者），函数返回空字符串表示无法找到合适的工作者地址。"}]},{"ID":"20240507101308-nowvx37","Type":"NodeParagraph","Properties":{"id":"20240507101308-nowvx37","updated":"20240507102347"},"Children":[{"Type":"NodeText","Data":"当调度策略为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"DispatchMethod.SHORTEST_QUEUE"},{"Type":"NodeText","Data":"​，则循环遍历worker_info,将指定的model_name 的w_name 添加到 worker_names 列表中，并计算其队列长度除以速度的比值，将此比值添加到worker_qlen 列表中。再检查worker_names 列表是否为空，如果为空则返回空字符串。否则，使用 numpy 的 argmin 函数找到worker_qlen 列表中的最小值的索引，通过该索引从worker_names 获取对应的w_name,即为负载最少的工作。更新工作队列长度并记录日志，在找到的最少负载工作w_name对应的 queue_length 上加1，模拟分配任务后队列增长的情况。使用logger.info记录操作详情，包括所有考虑的工作名称、他们的队列长度比值以及最终返回的工作名称。然后返回负载最小的w_name。"}]},{"ID":"20240507102347-t6o9oef","Type":"NodeParagraph","Properties":{"id":"20240507102347-t6o9oef","updated":"20240507102434"},"Children":[{"Type":"NodeText","Data":"如果无对应的调度策略，则抛出异常信息。指出无效的调度方法。"}]},{"ID":"20240507091328-7hxq4tj","Type":"NodeParagraph","Properties":{"id":"20240507091328-7hxq4tj","updated":"20240507101403"}}]}