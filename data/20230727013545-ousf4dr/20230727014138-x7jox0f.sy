{"ID":"20230727014138-x7jox0f","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f3a2","id":"20230727014138-x7jox0f","tags":"Kafka,高并发架构","title":"高并发下Kafka的解决方案和常见问题","updated":"20230727014215"},"Children":[{"ID":"20230727014142-zae9q0x","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727014142-zae9q0x","updated":"20230727014142"},"Children":[{"Type":"NodeText","Data":"1、kafka在高并发的情况下，如何避免消息丢失和消息重复"}]},{"ID":"20230727014142-80a18kv","Type":"NodeParagraph","Properties":{"id":"20230727014142-80a18kv","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"消息丢失解决方案:"}]},{"ID":"20230727014142-dyza7qg","Type":"NodeParagraph","Properties":{"id":"20230727014142-dyza7qg","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"首先对"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://so.csdn.net/so/search?q=kafka\u0026amp;spm=1001.2101.3001.7020","TextMarkTextContent":"kafka"},{"Type":"NodeText","Data":"进行限速， 其次启用重试机制，重试间隔时间设置长一些，最后Kafka设置acks=all，即需要相应的所有处于ISR的分区都确认收到该消息后，才算发送成功"}]},{"ID":"20230727014142-vpp3clm","Type":"NodeParagraph","Properties":{"id":"20230727014142-vpp3clm","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"消息重复解决方案:"}]},{"ID":"20230727014142-0ber59a","Type":"NodeParagraph","Properties":{"id":"20230727014142-0ber59a","updated":"20230727014148"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"消息可以使用唯一id标识"}]},{"ID":"20230727014142-digaf9g","Type":"NodeParagraph","Properties":{"id":"20230727014142-digaf9g","updated":"20230727014147"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"生产者（ack=all 代表至少成功发送一次)"}]},{"ID":"20230727014142-hjos392","Type":"NodeParagraph","Properties":{"id":"20230727014142-hjos392","updated":"20230727014150"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"消费者 （offset手动提交，业务逻辑成功处理后，提交offset）"}]},{"ID":"20230727014142-ddwfbrm","Type":"NodeParagraph","Properties":{"id":"20230727014142-ddwfbrm","updated":"20230727014151"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"落表（主键或者唯一索引的方式，避免重复数据）"}]},{"ID":"20230727014142-qwru8hw","Type":"NodeParagraph","Properties":{"id":"20230727014142-qwru8hw","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"业务逻辑处理（选择唯一主键存储到Redis或者mongdb中，先查询是否存在，若存在则不处理；若不存在，先插入Redis或Mongdb,再进行业务逻辑处理）"}]},{"ID":"20230727014142-x0xge8t","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727014142-x0xge8t","updated":"20230727014142"},"Children":[{"Type":"NodeText","Data":"2、kafka怎么保证数据消费一次且仅消费一次"}]},{"ID":"20230727014142-nd23dch","Type":"NodeParagraph","Properties":{"id":"20230727014142-nd23dch","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"幂等producer：保证发送单个分区的消息只会发送一次，不会出现重复消息"}]},{"ID":"20230727014142-xrtnhov","Type":"NodeParagraph","Properties":{"id":"20230727014142-xrtnhov","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"事务(transaction)：保证原子性地写入到多个分区，即写入到多个分区的消息要么全部成功，要么全部回滚流处理EOS：流处理本质上可看成是“读取-处理-写入”的管道。此EOS保证整个过程的操作是原子性。注意，这只适用于Kafka Streams"}]},{"ID":"20230727014142-xjc5n9v","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727014142-xjc5n9v","updated":"20230727014142"},"Children":[{"Type":"NodeText","Data":"3、kafka保证数据一致性和可靠性"}]},{"ID":"20230727014142-7exncsc","Type":"NodeParagraph","Properties":{"id":"20230727014142-7exncsc","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"数据一致性保证"}]},{"ID":"20230727014142-edqwo77","Type":"NodeParagraph","Properties":{"id":"20230727014142-edqwo77","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"一致性定义：若某条消息对client可见，那么即使Leader挂了，在新Leader上数据依然可以被读到"}]},{"ID":"20230727014142-gh7ml0m","Type":"NodeParagraph","Properties":{"id":"20230727014142-gh7ml0m","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"HW-HighWaterMark: client可以从Leader读到的最大msg offset，即对外可见的最大offset， HW=max(replica.offset)"}]},{"ID":"20230727014142-qa52by4","Type":"NodeParagraph","Properties":{"id":"20230727014142-qa52by4","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"对于Leader新收到的msg，client不能立刻消费，Leader会等待该消息被所有ISR中的replica同步后，更新HW，此时该消息才能被client消费，这样就保证了如果Leader fail，该消息仍然可以从新选举的Leader中获取。"}]},{"ID":"20230727014142-8nogx2n","Type":"NodeParagraph","Properties":{"id":"20230727014142-8nogx2n","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"对于来自内部Broker的读取请求，没有HW的限制。同时，Follower也会维护一份自己的HW，Folloer.HW = min(Leader.HW, Follower.offset)"}]},{"ID":"20230727014142-fn0xejm","Type":"NodeParagraph","Properties":{"id":"20230727014142-fn0xejm","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"数据可靠性保证"}]},{"ID":"20230727014142-cfop2si","Type":"NodeParagraph","Properties":{"id":"20230727014142-cfop2si","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"当Producer向Leader发送数据时，可以通过acks参数设置数据可靠性的级别"}]},{"ID":"20230727014142-ztyrisz","Type":"NodeParagraph","Properties":{"id":"20230727014142-ztyrisz","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"0: 不论写入是否成功，server不需要给Producer发送Response，如果发生异常，server会终止连接，触发Producer更新meta数据；"}]},{"ID":"20230727014142-31c3fq0","Type":"NodeParagraph","Properties":{"id":"20230727014142-31c3fq0","updated":"20230727014206"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1: Leader写入成功后即发送Response，此种情况如果Leader fail，会丢失数据"}]},{"ID":"20230727014142-h5433q6","Type":"NodeParagraph","Properties":{"id":"20230727014142-h5433q6","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"-1: 等待所有ISR接收到消息后再给Producer发送Response，这是最强保证"}]},{"ID":"20230727014142-i0ktign","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230727014142-i0ktign","updated":"20230727014142"},"Children":[{"Type":"NodeText","Data":"4、kafka到spark streaming怎么保证数据完整性，怎么保证数据不重复消费？"}]},{"ID":"20230727014142-hbi7z2n","Type":"NodeParagraph","Properties":{"id":"20230727014142-hbi7z2n","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"保证数据不丢失（at-least）"}]},{"ID":"20230727014142-mbtcsvo","Type":"NodeParagraph","Properties":{"id":"20230727014142-mbtcsvo","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"spark RDD内部机制可以保证数据at-least语义。"}]},{"ID":"20230727014142-qdq5rj1","Type":"NodeParagraph","Properties":{"id":"20230727014142-qdq5rj1","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Receiver方式"}]},{"ID":"20230727014142-mte1jqd","Type":"NodeParagraph","Properties":{"id":"20230727014142-mte1jqd","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"开启WAL（预写日志），将从kafka中接受到的数据写入到日志文件中，所有数据从失败中可恢复。"}]},{"ID":"20230727014142-vvbf0dn","Type":"NodeParagraph","Properties":{"id":"20230727014142-vvbf0dn","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Direct方式"}]},{"ID":"20230727014142-3kbja9s","Type":"NodeParagraph","Properties":{"id":"20230727014142-3kbja9s","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"依靠checkpoint机制来保证。"}]},{"ID":"20230727014142-jtxdc75","Type":"NodeParagraph","Properties":{"id":"20230727014142-jtxdc75","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"保证数据不重复（exactly-once）"}]},{"ID":"20230727014142-sogvtld","Type":"NodeParagraph","Properties":{"id":"20230727014142-sogvtld","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"要保证数据不重复，即Exactly once语义。"}]},{"ID":"20230727014142-eqt0u6g","Type":"NodeParagraph","Properties":{"id":"20230727014142-eqt0u6g","updated":"20230727014159"},"Children":[{"Type":"NodeText","Data":"-"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"幂等操作：重复执行不会产生问题，不需要做额外的工作即可保证数据不重复"}]},{"ID":"20230727014142-heomp9n","Type":"NodeParagraph","Properties":{"id":"20230727014142-heomp9n","updated":"20230727014201"},"Children":[{"Type":"NodeText","Data":"-"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"业务代码添加事务操作"}]},{"ID":"20230727014142-p5rrntb","Type":"NodeParagraph","Properties":{"id":"20230727014142-p5rrntb","updated":"20230727014142"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"就是说针对每个partition的数据，产生一个uniqueId，只有这个partition的所有数据被完全消费，则算成功，否则算失效，要回滚。下次重复执行这个uniqueId时，如果已经被执行成功，则skip掉。"}]}]}