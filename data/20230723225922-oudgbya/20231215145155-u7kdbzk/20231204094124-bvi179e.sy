{"ID":"20231204094124-bvi179e","Spec":"1","Type":"NodeDocument","Properties":{"icon":"2708","id":"20231204094124-bvi179e","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20231204094124-bvi179e\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231204100940-s8y034t\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231204101315-jgr9jyl\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20231204101315-jgr9jyl\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","tags":"公众号-polarisxu,Go-for,未完成,Go 1.22","title":"定了：Go 1.22将修复for循环变量错误","updated":"20231204101315"},"Children":[{"ID":"20231204100940-s8y034t","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231204100940-s8y034t","updated":"20231204100946"},"Children":[{"Type":"NodeText","Data":"存在的问题"}]},{"ID":"20231204094124-uizo7lk","Type":"NodeParagraph","Properties":{"id":"20231204094124-uizo7lk","updated":"20231204095416"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Go 开发者经常会犯的错误是在循环迭代结束后，保留对循环变量的引用，此时它会采用预期之外的新值。"}]},{"ID":"20231204095417-z8ubkaf","Type":"NodeParagraph","Properties":{"id":"20231204095417-z8ubkaf","updated":"20231204095507"},"Children":[{"Type":"NodeText","Data":"例如下面的程序："}]},{"ID":"20231204095507-8vtckvb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231204095507-8vtckvb","updated":"20231204095805"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n\tdone := make(chan bool)\n\n\tvalues := []string{\"a\",\"b\",\"c\"}\n\tfor _, v := range values {\n\t\tgo func() {\n\t\t\tfmt.Println(v)\n\t\t\tdone \u003c- true\n\t\t}()\n\t}\n\n\t// wait for all goroutines to complete before exiting\n\tfor _ = range values {\n\t\t\u003c-done\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231204095814-cnuyupr","Type":"NodeParagraph","Properties":{"id":"20231204095814-cnuyupr","updated":"20231204095824"},"Children":[{"Type":"NodeText","Data":"其创建的三个 goroutine 都用于打印相同的变量 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"v"},{"Type":"NodeText","Data":"​，因此它们只会打印出 “c”, “c”, “c”，而不是按顺序打印 “a”, “b”, 和 “c”。"}]},{"ID":"20231204095814-zkw9vfr","Type":"NodeParagraph","Properties":{"id":"20231204095814-zkw9vfr","updated":"20231204095836"},"Children":[{"Type":"NodeText","Data":"从 Go1.21 开始，开发者可以启用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GOEXPERIMENT=loopvar"},{"Type":"NodeText","Data":"​ 来构建 Go 程序，以解决上文提到的 for 循环变量问题。"}]},{"ID":"20231204095819-4xu3l8w","Type":"NodeParagraph","Properties":{"id":"20231204095819-4xu3l8w","updated":"20231204095911"},"Children":[{"Type":"NodeText","Data":"构建命令："}]},{"ID":"20231204095933-2ge17cp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231204095933-2ge17cp","updated":"20231204095943"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"GOEXPERIMENT\\=loopvar go install my/program\nGOEXPERIMENT\\=loopvar go build my/program\nGOEXPERIMENT\\=loopvar go test my/program\nGOEXPERIMENT\\=loopvar go test my/program -bench\\=.\n...\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231204095945-6om27pi","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231204095945-6om27pi","updated":"20231204100930"},"Children":[{"Type":"NodeText","Data":"解决方案"}]},{"ID":"20231204100957-hh7u6xz","Type":"NodeParagraph","Properties":{"id":"20231204100957-hh7u6xz","updated":"20231204101052"},"Children":[{"Type":"NodeText","Data":"解决方案是在每次迭代时使用 be 变量的不同实例使 for 循环中声明的循环变量。这样，如果该值是在闭包或 goroutine 中捕获的，或者以其他方式超过迭代，则以后对它的引用将看到它在该迭代期间的值，而不是被后续迭代覆盖的值。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":":="},{"Type":"NodeText","Data":"​"}]},{"ID":"20231204101053-e2sej00","Type":"NodeParagraph","Properties":{"id":"20231204101053-e2sej00","updated":"20231204101154"},"Children":[{"Type":"NodeText","Data":"对于范围循环，效果就好像每个循环体都以 和 开头。 在上面的 Let's Encrypt 示例中，没有必要，并且由于没有而导致的错误本来可以避免。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"k := k"},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"v := v"},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"kCopy := k"},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"v := v"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231204101117-qf9ehcs","Type":"NodeParagraph","Properties":{"id":"20231204101117-qf9ehcs","updated":"20231204101229"},"Children":[{"Type":"NodeText","Data":"对于 3 子句 for 循环，效果就好像每个循环体都以反向赋值开头，然后反向赋值 发生在循环体的末尾，将每次迭代复制回将用于 为下一次迭代做好准备。这听起来很复杂，但在实践中，所有常见的循环习语仍在继续 一如既往地工作。循环行为更改的唯一时间是捕获和共享时 用别的东西。例如，此代码一如既往地运行："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"i := iiii"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231204101242-yehmao7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231204101242-yehmao7","updated":"20231204101313"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\tfor i := 0;; i++ {\n\t\tif i \u003e= len(s) || s[i] == '\"' {\n\t\t\treturn s[:i]\n\t\t}\n\t\tif s[i] == '\\\\' { // skip escaped char, potentially a quote\n\t\t\ti++\n\t\t}\n\t}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231204101315-jgr9jyl","Type":"NodeParagraph","Properties":{"id":"20231204101315-jgr9jyl"}}]}