{"ID":"20230724231512-wk0t2pb","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f381","id":"20230724231512-wk0t2pb","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230724231512-wk0t2pb\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230724231513-z2ud995\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231123100744-ydpj05a\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20231121100445-mm5qe9x\u0026quot;,\u0026quot;focusStart\u0026quot;:4,\u0026quot;focusEnd\u0026quot;:4\u0026#125;","tags":"设计模式-装饰器模式,公众号-小徐先生的编程世界","title":"Golang 设计模式之装饰器模式","updated":"20231215155933"},"Children":[{"ID":"20230724231513-z2ud995","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230724231513-z2ud995","updated":"20231121003929"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/XG2G1O67o-p_u_MPj5N0oQ","TextMarkTextContent":"Go 装饰器模式"}]},{"ID":"20231121100445-mm5qe9x","Type":"NodeParagraph","Properties":{"id":"20231121100445-mm5qe9x","updated":"20231121100445"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231121100445-7b90bdr.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231121194101-7225vf5","Type":"NodeParagraph","Properties":{"id":"20231121194101-7225vf5"}},{"ID":"20231121194103-z4x3g7t","Type":"NodeParagraph","Properties":{"id":"20231121194103-z4x3g7t","updated":"20231121194106"},"Children":[{"Type":"NodeText","Data":"本期和大家交流的是设计模式中的装饰器模式.\n下面聊聊关于装饰器模式的基本定义：装饰器模式能够在不改变原对象结构的基础上，动态地为对象增加附属能力. 在实现思路上，装饰器模式和“继承”一定的类似之处，但是两者侧重点有所不同，可以把装饰器模式作为“继承”的一种补充手段.\n这么干讲概念显得过于抽象，下面我们通过一个实际案例，来和大家具体地剖析一下有关于装饰器模式的实现思路：\n• 现在摆在我们面前的时一碗热腾腾的白米饭，我们需要在此基础上添加出各种配菜组合，搭配出一款美味的盖浇饭.\n• 当前可供我们选择主菜是几种肉食，包括培根、牛肉还有鸡排\n• 除了主菜外，还有几道副菜作为调剂，包括鸡蛋、青椒还有黑椒汁"}]},{"ID":"20231121194122-3zcu6an","Type":"NodeTable","TableAligns":[0,0,0],"Properties":{"colgroup":"||","id":"20231121194122-3zcu6an","updated":"20231121194122"},"Children":[{"Type":"NodeTableHead","Data":"thead","Children":[{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"主食"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"主菜"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"副菜"}]}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"米饭"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"培根"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"鸡蛋"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"米饭"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"牛肉"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"青椒"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"米饭"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"鸡排"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"黑椒汁"}]}]}]},{"ID":"20231121194124-1tzul1b","Type":"NodeParagraph","Properties":{"id":"20231121194124-1tzul1b","updated":"20231121194139"},"Children":[{"Type":"NodeText","Data":"基于以上条件，我们开始烹饪创作：\n• 比如选用主菜培根搭配上副菜鸡蛋，就形成了一碗鸡蛋培根盖浇饭；\n• 比如选用主菜牛肉搭配上副菜青椒，就形成了一碗青椒牛肉盖浇饭；\n• 比如选用主菜鸡排搭配上副菜黑椒汁，就形成了一碗黑椒鸡排盖浇饭.\n聊到这里，下面我们尝试通过编程的方式还原上面的场景问题.\n一种常见的实现方式是可以采用继承的方式进行实现：\n• 我们构造出一个最基础的父类：米饭\n• 在白米饭的基础上，根据添加的主菜肉食，实现出现对应的几个一级子类：培根饭、牛肉饭、鸡排饭\n• 在一级子类的基础上，再搭配上各种副菜，实现对应的几个二级子类，包括：鸡蛋培根饭、青椒培根饭、青椒牛肉饭、黑椒鸡排饭等等"}]},{"ID":"20231121194225-z2bwh7v","Type":"NodeParagraph","Properties":{"id":"20231121194225-z2bwh7v","updated":"20231121194225"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231121194225-y9ngg1j.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231121194226-wlh1wdz","Type":"NodeParagraph","Properties":{"id":"20231121194226-wlh1wdz","updated":"20231121195104"},"Children":[{"Type":"NodeText","Data":"在上述“继承”的实现思路中，我们需要对子类的等级以及种类进行枚举，包括通过加入主菜后形成的一系列一级子类以及加入主菜和副菜后形成的一系列二级子类，这样一套相对固定的等级架构也暴露出来一些问题：\n• 在实际场景中，主菜和副菜的结合可以是更加灵活多样的，比如作为副菜的鸡蛋不仅可以和主菜的培根组合，还可以和牛肉或者鸡排搭配；比如实际场景中，后续可能有更多的主菜和副菜类型出现，如果需要对所有的组合进行穷尽，则需要经历一轮笛卡尔内积，最终子类的数量将会严重膨胀无法收敛\n• 使用主菜和副菜对配菜的类型进行界定显得过于刻板，主菜和副菜本质上都是菜品而已，可以根据用户的喜好灵活添加，比如用户可以只要副菜或者只要主菜，可以只添加双份甚至三份的鸡蛋而不添加培根或者牛肉，也可以选择要一份主菜搭配多份配菜，比如一份牛肉两份鸡蛋等等. 这样的话，原本约定好的基于继承实现的等级架构就不再适用了\n结合以上两点，我们发现在这类“加料”的场景中，使用继承的设计模式未必合适. 我们不妨切换思路，不再聚焦于尝试对所有组合种类进行一一枚举，而是把注意力放在“加料”的这个过程行为当中：\n"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"• 首先,我们不再区分主菜和副菜，不论是鸡蛋还是培根还是青椒，我们都把它们当中一种普通的“菜品”\n• 针对于每一种“菜品”，我们定义出一个装饰器类\n• 每次使用一个装饰器类时，对应的逻辑是会往原本的主食中添加一份对应的“菜品”"},{"Type":"NodeText","Data":"\n在这种实现的思路下，就诞生出了基于“装饰器模式”的实现架构，如下图所示:"}]},{"ID":"20231121195122-kuvwkg5","Type":"NodeParagraph","Properties":{"id":"20231121195122-kuvwkg5","updated":"20231121195122"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231121195122-23eokpb.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231121195124-vbtlitj","Type":"NodeParagraph","Properties":{"id":"20231121195124-vbtlitj","updated":"20231121195204"},"Children":[{"Type":"NodeText","Data":"在装饰器模式中，一份鸡蛋培根盖浇饭 "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":" 一份白米饭（核心类）+ 一份鸡蛋（装饰器1）+ 一份培根（装饰器2），其中鸡蛋和培根对应装饰器的使用顺序是不作限制的. 于是不管后续有多少种新的“菜品”加入，我们都只需要声明其对应的装饰器类即可，只要“菜品”的种类确定，后续用户想要组装出何种形式的盖浇饭，都是 easy case.\n比如，双份鸡蛋盖浇饭 "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":" 一份白米饭（核心类）+ 一份鸡蛋（装饰器1）+一份鸡蛋（装饰器1）；鸡蛋火腿青椒盖浇饭 "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":" 一份白米饭（核心类）+ 一份鸡蛋（装饰器1）+一份青椒（装饰器2）+一份火腿（装饰器3）；双份牛肉青椒盖浇饭 "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":" 一份白米饭（核心类）+ 一份青椒（装饰器4）+一份牛肉（装饰器5）+一份牛肉（装饰器5）\n到这里为止，问题已经得到圆满解决. 下面，我们再回过头对装饰器模式和继承模式做一个对比总结：\n"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"• 继承强调的是等级制度和子类种类，这部分架构需要一开始就明确好\n• 装饰器模式强调的是“装饰”的过程，而不强调输入与输出，能够动态地为对象增加某种特定的附属能力，相比于继承模式显得更加灵活，且符合开闭原则"}]},{"ID":"20231121195205-rm7sbq2","Type":"NodeParagraph","Properties":{"id":"20231121195205-rm7sbq2"}},{"ID":"20231121195213-k8yn3t2","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231121195213-k8yn3t2","updated":"20231121195229"},"Children":[{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20231121195229-lomm6ou","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231121195229-lomm6ou","updated":"20231121195404"},"Children":[{"Type":"NodeText","Data":"类型声明实现"}]},{"ID":"20231121195253-79n1fjd","Type":"NodeParagraph","Properties":{"id":"20231121195253-79n1fjd","updated":"20231121195416"},"Children":[{"Type":"NodeText","Data":"下面我们就进入代码实战环节，通过编程的方式实现一个搭配食材的案例，以此来展示装饰器模式的实现细节."}]},{"ID":"20231121195429-58grbdr","Type":"NodeParagraph","Properties":{"id":"20231121195429-58grbdr","updated":"20231121195429"},"Children":[{"Type":"NodeText","Data":"这个案例非常简单，我们需要主食的基础上添加配菜，最终搭配出美味可口的食物套餐. 其中主食包括米饭 rice 和面条 noodle 两条，而配菜则包括老干妈 LaoGanMa（老干妈拌饭顶呱呱）、火腿肠 HamSausage 和煎蛋 FriedEgg 三类."}]},{"ID":"20231121195429-es886zo","Type":"NodeParagraph","Properties":{"id":"20231121195429-es886zo","updated":"20231121195429"},"Children":[{"Type":"NodeText","Data":"事实上如果需要的话，主食和配菜也可以随时进行扩展，在装饰器模式中，这种扩展行为的成本并不高."}]},{"ID":"20231121195429-o5ve4qi","Type":"NodeParagraph","Properties":{"id":"20231121195429-o5ve4qi","updated":"20231121195429"},"Children":[{"Type":"NodeText","Data":"下面先展示一下总体的 UML 类图："}]},{"ID":"20231121195453-aydtgs1","Type":"NodeParagraph","Properties":{"id":"20231121195453-aydtgs1","updated":"20231121195453"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231121195453-t2ox0j8.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231121195454-fhagsop","Type":"NodeParagraph","Properties":{"id":"20231121195454-fhagsop","updated":"20231121195502"},"Children":[{"Type":"NodeText","Data":"首先是对应于装饰器模式中核心类的是原始的主食 Food，我们声明了一个 interface，其中包含两个核心方法，Eat 和 Cost，含义分别为食用主食以及计算出主食对应的花费."}]},{"ID":"20231121195503-nktjywo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231121195503-nktjywo","updated":"20231121195610"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Food interface {\n  // 食用主食\n  Eat() string\n  // 计算主食的花费\n  Cost() float32\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231121195623-jcc9cp9","Type":"NodeParagraph","Properties":{"id":"20231121195623-jcc9cp9","updated":"20231121195624"},"Children":[{"Type":"NodeText","Data":"Food 对应的实现类包括米饭 rice 和面条 noodle："}]},{"ID":"20231121195835-z2rho91","Type":"NodeParagraph","Properties":{"id":"20231121195835-z2rho91"}},{"ID":"20231121195840-u6c1i9p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231121195840-u6c1i9p","updated":"20231121200655"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Rice struct {\n}\n\nfunc NewRice() Food {\n\treturn \u0026Rice{}\n}\n\nfunc (r *Rice) Eat() string {\n\treturn \"一碗米饭\"\n}\n\n// 花费的金额\nfunc (r *Rice) Cost() float32 {\n\treturn 1\n}\n\ntype Noodle struct {\n\n}\n\nfunc NewNoodle() Food {\n\treturn \u0026Noodle{}\n}\n\nfunc (n *Noodle) Eat() string {\n\treturn \"一碗面条\"\n}\n\nfunc (n *Noodle) Cost() float32 {\n\treturn 1.5\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231121200658-qshih4d","Type":"NodeParagraph","Properties":{"id":"20231121200658-qshih4d","updated":"20231121200705"},"Children":[{"Type":"NodeText","Data":"接下来是装饰器部分，我们声明了一个 Decorate interface，它们本身是在强依附于核心类（主食）的基础上产生的，只能起到锦上添花的作用，因此在构造器函数中，需要传入对应的主食 Food."}]},{"ID":"20231121200706-2fkkcjn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231121200706-2fkkcjn","updated":"20231121200814"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func NewDecorator(f Food) Decorator {\n\treturn f\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231121200839-jd26kjn","Type":"NodeParagraph","Properties":{"id":"20231121200839-jd26kjn","updated":"20231121200839"},"Children":[{"Type":"NodeText","Data":"接下来分别声明三个装饰器的具体实现类，对应为老干妈 LaoGanMaDecorator、火腿肠 HamSausageDecorator、和煎蛋 FriedEggDecorator."}]},{"ID":"20231121200839-glej2s9","Type":"NodeParagraph","Properties":{"id":"20231121200839-glej2s9","updated":"20231121200839"},"Children":[{"Type":"NodeText","Data":"每个装饰器类的作用是对食物进行一轮装饰增强，因此需要在构造器函数中传入待装饰的食物，然后通过重写食物的 Eat 和 Cost 方法，实现对应的增强装饰效果."}]},{"ID":"20231121200854-6w16jw6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231121200854-6w16jw6","updated":"20231122073916"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type LaoGanMaDecorator struct {\n\tDecorator\n}\n\nfunc NewLaoGanMaDecorator(d Decorator) Decorator {\n\treturn \u0026LaoGanMaDecorator{\n\t\tDecorator: d,\n\t}\n}\n\nfunc (l *LaoGanMaDecorator) Eat() string {\n\t// 加入老干妈配料\n\treturn \"加入一份老干妈\" + l.Decorator.Eat()\n}\n\nfunc (l *LaoGanMaDecorator) Cost() float32 {\n\t// 价格加0.5元\n\treturn 0.5 + l.Decorator.Cost()\n}\n\ntype HamSausageDecorator struct {\n\tDecorator\n}\n\nfunc NewHamSausageDecorator(d Decorator) Decorator {\n\treturn \u0026HamSausageDecorator{\n\t\tDecorator: d,\n\t}\n}\n\nfunc (h *HamSausageDecorator) Eat() string {\n\t// 加入火腿肠配料\n\treturn \"加一份火腿\" + h.Decorator.Eat()\n}\n\nfunc (h *HamSausageDecorator) Cost() float32 {\n\t// 价格加1.5\n\treturn 1.5 + h.Decorator.Cost()\n}\n\ntype FriedEggDecorator struct {\n\tDecorator\n}\n\nfunc NewFriedEggDecorator(d Decorator) Decorator {\n\treturn \u0026FriedEggDecorator{\n\t\tDecorator: d,\n\t}\n}\n\nfunc (f *FriedEggDecorator) Eat() string {\n\treturn \"加一份煎蛋\" + f.Decorator.Eat()\n}\n\nfunc (f *FriedEggDecorator) Cost() float32 {\n\treturn 1 + f.Decorator.Cost()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231122073916-311mqg1","Type":"NodeParagraph","Properties":{"id":"20231122073916-311mqg1","updated":"20231122073923"},"Children":[{"Type":"NodeText","Data":"做好所有的准备工作之后，下面我们通过单测代码，展示装饰器模式的使用示例："}]},{"ID":"20231122073924-zawst1g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231122073924-zawst1g","updated":"20231122074000"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func Test_decorator(t *testing.T) {\n    // 一碗干净的米饭\n    rice := NewRice()\n    rice.Eat()\n\n\n    // 一碗干净的面条\n    noodle := NewNoodle()\n    noodle.Eat()\n\n\n    // 米饭加个煎蛋\n    rice = NewFriedEggDecorator(rice)\n    rice.Eat()\n\n\n    // 面条加份火腿\n    noodle = NewHamSausageDecorator(noodle)\n    noodle.Eat()\n\n\n    // 米饭再分别加个煎蛋和一份老干妈\n    rice = NewFriedEggDecorator(rice)\n    rice = NewLaoGanMaDecorator(rice)\n    rice.Eat()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231122074027-brz0hoy","Type":"NodeParagraph","Properties":{"id":"20231122074027-brz0hoy"}},{"ID":"20231122074028-wmwj75o","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231122074028-wmwj75o","updated":"20231122074042"},"Children":[{"Type":"NodeText","Data":"增强函数实现"}]},{"ID":"20231122074042-p4gtw3f","Type":"NodeParagraph","Properties":{"id":"20231122074042-p4gtw3f","updated":"20231122074124"},"Children":[{"Type":"NodeText","Data":"下面提供另一种闭包实现装饰增强函数的实现示例，其实现也是遵循着装饰器模式的思路，但在形式上会更加简洁直观一些："}]},{"ID":"20231122074125-tvnk5ly","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231122074125-tvnk5ly","updated":"20231122074317"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type handleFunc func(ctx context.Context, param map[string]interface{}) error\n\nfunc Decorate(fn handleFunc) handleFunc {\n    return func(ctx context.Context, param map[string]interface{}) error {\n        // 前处理\n        fmt.Println(\"preprocess...\")\n        err := fn(ctx, param)\n        fmt.Println(\"postprocess...\")\n        return err\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231122074322-seijwe6","Type":"NodeParagraph","Properties":{"id":"20231122074322-seijwe6","updated":"20231122074329"},"Children":[{"Type":"NodeText","Data":"其中核心的处理方法 handleFunc 对应的是装饰器模式中的核心类，Decorate 增强方法对应的则是装饰器类，每次在执行 Decorate 的过程中，都会在 handleFunc 前后增加的一些额外的附属逻辑."}]},{"ID":"20231122074330-t3od4y7","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231122074330-t3od4y7","updated":"20231122074341"},"Children":[{"Type":"NodeText","Data":"工程案例"}]},{"ID":"20231122074857-c23ejyl","Type":"NodeParagraph","Properties":{"id":"20231122074857-c23ejyl","updated":"20231122074857"},"Children":[{"Type":"NodeText","Data":"为了进一步加深理解，下面摘出一个实际项目中应用到装饰器模式的使用案例和大家共同分析探讨."}]},{"ID":"20231122074857-wpnnu80","Type":"NodeParagraph","Properties":{"id":"20231122074857-wpnnu80","updated":"20231122074857"},"Children":[{"Type":"NodeText","Data":"这里给到的案例是 grpc-go 中对拦截器链 chainUnaryInterceptors 的实现."}]},{"ID":"20231122074857-l9t9m2i","Type":"NodeParagraph","Properties":{"id":"20231122074857-l9t9m2i","updated":"20231122074857"},"Children":[{"Type":"NodeText","Data":"grpc-go 的开源地址：https://github.com/grpc/grpc-go"}]},{"ID":"20231122074857-mp7mvnt","Type":"NodeParagraph","Properties":{"id":"20231122074857-mp7mvnt","updated":"20231122074857"},"Children":[{"Type":"NodeText","Data":"下面走读的源码版本为 Release 1.53.0"}]},{"ID":"20231122074908-39zg6kg","Type":"NodeParagraph","Properties":{"id":"20231122074908-39zg6kg","updated":"20231122075116"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在 grpc-go 服务端模块中，每次接收到来自客户端的 grpc 请求，会根据请求的 path 映射到对应的 service 和 handler 进行执行逻辑的处理，但在真正调用 handler 之前，会先先经历一轮对拦截器链 chainUnaryInterceptors 的遍历调用，在这里我们可以把 handler 理解为装饰器模式中的核心类，拦截器链中的每一个拦截器 unaryInterceptors 可以理解为一个装饰器."}]},{"ID":"20231122074908-z0efld7","Type":"NodeParagraph","Properties":{"id":"20231122074908-z0efld7","updated":"20231122074908"},"Children":[{"Type":"NodeText","Data":"下面我们来观察一下其中具体的源码细节."}]},{"ID":"20231122074908-s7cvhbd","Type":"NodeParagraph","Properties":{"id":"20231122074908-s7cvhbd","updated":"20231122074908"},"Children":[{"Type":"NodeText","Data":"首先，对于拦截器类 UnaryServerInterceptor，本身是一个函数的类型："}]},{"ID":"20231122074910-eiv21xf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231122074910-eiv21xf","updated":"20231122074920"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231122074921-gi7p5ro","Type":"NodeParagraph","Properties":{"id":"20231122074921-gi7p5ro","updated":"20231122075018"},"Children":[{"Type":"NodeText","Data":"UnaryServerInterceptor 对应的几个入参包括：\n• ctx：golang 请求链路中的上下文，不赘述\n• req：grpc 请求的入参\n• info：grpc 业务服务 service\n• handler：核心逻辑执行方法"}]},{"ID":"20231122075019-96rr9vn","Type":"NodeParagraph","Properties":{"id":"20231122075019-96rr9vn","updated":"20231122075028"},"Children":[{"Type":"NodeText","Data":"其中核心逻辑执行方法 handler 对应的类型为 UnaryHandler，入参为 context 和 req，出参为 resp 和 error"}]},{"ID":"20231122075028-hadbbp2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231122075028-hadbbp2","updated":"20231122075034"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type UnaryHandler func(ctx context.Context, req interface{}) (interface{}, error)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231122075134-ihuic60","Type":"NodeParagraph","Properties":{"id":"20231122075134-ihuic60","updated":"20231122122927"},"Children":[{"Type":"NodeText","Data":"  下面是生成拦截器链的方法 chainUnaryInterceptors. 该方法的入参是用户定义好的一系列拦截器 interceptors，内部会按照顺序对拦截器进行组装，最终通过层层装饰增强的方式，将整个执行链路压缩成一个拦截器 UnaryServerInterceptor 的形式进行方法."}]},{"ID":"20231122122928-8monbsc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231122122928-8monbsc","updated":"20231122122935"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func chainUnaryInterceptors(interceptors []UnaryServerInterceptor) UnaryServerInterceptor {\n    return func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (interface{}, error) {\n        return interceptors[0](ctx, req, info, getChainUnaryHandler(interceptors, 0, info, handler))\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231122122937-1j2ytfb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231122122937-1j2ytfb","updated":"20231122123024"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func getChainUnaryHandler(interceptors []UnaryServerInterceptor, curr int, info *UnaryServerInfo, finalHandler UnaryHandler) UnaryHandler {\n    if curr == len(interceptors)-1 {\n        return finalHandler\n    }\n    return func(ctx context.Context, req interface{}) (interface{}, error) {\n        return interceptors[curr+1](ctx, req, info, getChainUnaryHandler(interceptors, curr+1, info, finalHandler))\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231123100123-syzgqts","Type":"NodeParagraph","Properties":{"id":"20231123100123-syzgqts","updated":"20231123100123"},"Children":[{"Type":"NodeText","Data":"在 chainUnaryInterceptors 方法中，闭包返回了一个对应于拦截器 UnaryServerInterceptor 类型的函数. 这个闭包函数内部的执行逻辑是，会调用拦截器列表 interceptors 当中的首个拦截器，并通过 getChainUnaryHandler 方法，依次使用下一枚拦截器对核心方法 handler 进行装饰包裹，封装形成一个新的“handler”供当前的拦截器使用."}]},{"ID":"20231123100139-pzojk78","Type":"NodeParagraph","Properties":{"id":"20231123100139-pzojk78","updated":"20231123100139"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231123100139-2vmdipe.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231123100140-25k3lk0","Type":"NodeParagraph","Properties":{"id":"20231123100140-25k3lk0","updated":"20231123100146"},"Children":[{"Type":"NodeText","Data":"在这个过程中，就体现了我们今天讨论的装饰器模式的设计思路. 核心业务处理方法 handler 对应的就是装饰器模式中的核心类，每一轮通过拦截器 UnaryServerInterceptor 对 handler 进行增强的过程，对应的就是一次“装饰”的步骤."}]},{"ID":"20231123100317-8y0qm7x","Type":"NodeParagraph","Properties":{"id":"20231123100317-8y0qm7x","updated":"20231123100323"},"Children":[{"Type":"NodeText","Data":"下面给出一个具体实现的装饰器的代码示例，可以看到其中在核心方法 handler 前后分别执行了对应的附属逻辑，起到了装饰的效果."}]},{"ID":"20231123100323-rq07m6z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231123100323-rq07m6z","updated":"20231123100329"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"var myInterceptor = func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {\n    // 添加前处理...\n    fmt.Printf(\"interceptor preprocess, req: %+v\\n\", req)\n    resp, err = handler(ctx, req)\n    // 添加后处理...\n    fmt.Printf(\"interceptor postprocess, req: %+v\\n\", resp)\n    return\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231123100744-cgler3o","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231123100744-cgler3o","updated":"20231123100744"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20231123100744-ydpj05a","Type":"NodeParagraph","Properties":{"id":"20231123100744-ydpj05a","updated":"20231123100744"},"Children":[{"Type":"NodeText","Data":"本期和大家交流了设计模式中的装饰器模式. 装饰器模式能够动态地为对象增加某种特定的附属能力，相比于继承模式显得更加灵活，且符合开闭原则，可以作为继承模式的一种有效补充手段."}]}]}