{"ID":"20231025114451-wbs1eeu","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f4a3","id":"20231025114451-wbs1eeu","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20231025114451-wbs1eeu\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231025114451-y8nos90\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231030005442-omspsk7\u0026quot;,\u0026quot;scrollTop\u0026quot;:9762\u0026#125;","tags":"go,时间轮算法,redis,未完成,需要仔细看","title":"基于 golang 从零到一实现时间轮算法","updated":"20231108014216"},"Children":[{"ID":"20231025114451-y8nos90","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231025114451-y8nos90","updated":"20231025114554"},"Children":[{"Type":"NodeText","Data":"前言"}]},{"ID":"20231025114554-bew465x","Type":"NodeParagraph","Properties":{"id":"20231025114554-bew465x","updated":"20231025114559"},"Children":[{"Type":"NodeText","Data":"如何基于 golang 从零到一实现 redis."}]},{"ID":"20231025114652-2vzeaz3","Type":"NodeParagraph","Properties":{"id":"20231025114652-2vzeaz3","updated":"20231025142453"},"Children":[{"Type":"NodeText","Data":"这里选择的学习素材是 hdt3213 大佬于 github 上开源的 godis 项目. 在大佬的实现中，充分利用了 golang 的特性，将 redis 存储层由单线程模型转为并发模型，其中在实现数据的 expire 机制时，采用的是单机时间轮模型进行过期数据的删除操作。"}]},{"ID":"20231025142501-xk5rtlp","Type":"NodeParagraph","Properties":{"id":"20231025142501-xk5rtlp","updated":"20231025142514"},"Children":[{"Type":"NodeText","Data":"godis 项目开源地址："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"http://github.com/HDT3213/godis"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025142501-zhpxlt0","Type":"NodeParagraph","Properties":{"id":"20231025142501-zhpxlt0","updated":"20231025142501"},"Children":[{"Type":"NodeText","Data":"godis 时间轮代码："}]},{"ID":"20231025142505-j1mctdb","Type":"NodeParagraph","Properties":{"id":"20231025142505-j1mctdb","updated":"20231025142518"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"http://github.com/HDT3213/godis/blob/master/lib/timewheel/timewheel.go"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025142518-ahpw8f0","Type":"NodeParagraph","Properties":{"id":"20231025142518-ahpw8f0","updated":"20231025142604"},"Children":[{"Type":"NodeText","Data":"实际上，在我之前分享个人项目——分布式定时器 xtimer 中也有到了时间轮算法，这部分内容具有一定共性. 借此机会，本期单独对时间轮算法的原理和实践内容进行梳理，并基于 golang 从零到一开源实现出一个单机版和 redis 分布式版的时间轮，供大家一起交流探讨。"}]},{"ID":"20231025142605-bbx9a5m","Type":"NodeParagraph","Properties":{"id":"20231025142605-bbx9a5m","updated":"20231025142616"},"Children":[{"Type":"NodeText","Data":"个人开源的时间轮项目地址为："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"http://github.com/xiaoxuxiansheng/timewheel"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025142617-kmpyhct","Type":"NodeParagraph","Properties":{"id":"20231025142617-kmpyhct"}},{"ID":"20231025142817-h4c67eb","Type":"NodeParagraph","Properties":{"id":"20231025142817-h4c67eb"}},{"ID":"20231025142817-vsys36s","Type":"NodeParagraph","Properties":{"id":"20231025142817-vsys36s","updated":"20231025142829"},"Children":[{"Type":"NodeText","Data":"目录大纲如下"}]},{"ID":"20231025142843-e3766mv","Type":"NodeParagraph","Properties":{"id":"20231025142843-e3766mv","updated":"20231025142843"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025142843-lhxnrzk.png"},{"Type":"NodeCloseParen"}]}]},{"ID":"20231025142910-ceg9mlk","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231025142910-ceg9mlk","updated":"20231025142918"},"Children":[{"Type":"NodeText","Data":"时间轮原理"}]},{"ID":"20231025142941-sijmdpi","Type":"NodeParagraph","Properties":{"id":"20231025142941-sijmdpi","updated":"20231025142941"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025142941-6wd1yzk.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025142844-gknuimj","Type":"NodeParagraph","Properties":{"id":"20231025142844-gknuimj","updated":"20231025143211"},"Children":[{"Type":"NodeText","Data":"时间轮是定时任务调度系统中常用到的一种经典的算法模型. 有关时间轮算法的详细概念介绍，可以参见论文:《Hashed and Hierarchical Time Wheels: Data Structures for the Efficient Implementation of a Time Facility》http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf"}]},{"ID":"20231025143244-yclrahw","Type":"NodeParagraph","Properties":{"id":"20231025143244-yclrahw","updated":"20231025143252"},"Children":[{"Type":"NodeText","Data":"接下来我也会从个人角度出发，谈谈我对于时间轮算法的一些浅显理解."}]},{"ID":"20231025143257-px6cloy","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231025143257-px6cloy","updated":"20231025143303"},"Children":[{"Type":"NodeText","Data":"时间轮概念"}]},{"ID":"20231025143309-qtu7rcu","Type":"NodeParagraph","Properties":{"id":"20231025143309-qtu7rcu","updated":"20231025143314"},"Children":[{"Type":"NodeText","Data":"聊时间轮之前，先聊聊时间的概念。"}]},{"ID":"20231025143309-cszx3mj","Type":"NodeParagraph","Properties":{"id":"20231025143309-cszx3mj","updated":"20231025143311"},"Children":[{"Type":"NodeText","Data":"首先时间是一维、单向的，我们可以用一条一维的时间轴将其具象化. 我们对时间轴进行刻度拆分，每个刻度对应一个时间范围，那么刻度拆分得越细，则表示的时间范围越精确。"}]},{"ID":"20231025143342-mt8ifx9","Type":"NodeParagraph","Properties":{"id":"20231025143342-mt8ifx9","updated":"20231025143342"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025143342-fjjjxoz.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025143458-5tkehwc","Type":"NodeParagraph","Properties":{"id":"20231025143458-5tkehwc","updated":"20231025143458"},"Children":[{"Type":"NodeText","Data":"然而，我们知道时间是没有尽头的，因此这条一维时间轴的长度是无穷大的. 倘若我们想要建立一个数据结构去表达这条由一系列刻度聚合形成的时间轴，这个数据结构所占用的空间也是无穷无尽的."}]},{"ID":"20231025143458-ojjozz3","Type":"NodeParagraph","Properties":{"id":"20231025143458-ojjozz3","updated":"20231025143458"},"Children":[{"Type":"NodeText","Data":"那么，我们应该如何优化这个问题呢？此时，大家不妨低头看一眼自己的手表. 手表或时钟这类日常生活中用来关联表达时间的工具，采用的是首尾衔接的环状结构来替代无穷长度的一维时间轴，每当钟表划过一圈，刻度从新回到零值，但是已有的时间进度会传承往下."}]},{"ID":"20231025143458-twd5lkl","Type":"NodeParagraph","Properties":{"id":"20231025143458-twd5lkl","updated":"20231025143458"},"Children":[{"Type":"NodeText","Data":"本期所聊的时间轮算法采用的思路正是与之类似，下面我们梳理一下核心流程："}]},{"ID":"20231025143542-i962djv","Type":"NodeList","ListData":{},"Properties":{"id":"20231025143542-i962djv","updated":"20231025143542"},"Children":[{"ID":"20231025143542-88tyu3r","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143542-88tyu3r","updated":"20231025143542"},"Children":[{"ID":"20231025143542-521aaxl","Type":"NodeParagraph","Properties":{"id":"20231025143542-521aaxl","updated":"20231025143542"},"Children":[{"Type":"NodeText","Data":"建立一个环状数据结构"}]}]},{"ID":"20231025143551-nh8ik58","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143551-nh8ik58"},"Children":[{"ID":"20231025143551-qs9ljrd","Type":"NodeParagraph","Properties":{"id":"20231025143551-qs9ljrd"},"Children":[{"Type":"NodeText","Data":"每个刻度对应一个时间范围"}]}]},{"ID":"20231025143555-z351zk1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143555-z351zk1"},"Children":[{"ID":"20231025143555-x91q0o7","Type":"NodeParagraph","Properties":{"id":"20231025143555-x91q0o7"},"Children":[{"Type":"NodeText","Data":"创建定时任务时，根据距今的相对时长，推算出需要向后推移的刻度值"}]}]},{"ID":"20231025143542-wg2vmtp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143542-wg2vmtp","updated":"20231025143542"},"Children":[{"ID":"20231025143542-c705xln","Type":"NodeParagraph","Properties":{"id":"20231025143542-c705xln","updated":"20231025143557"},"Children":[{"Type":"NodeText","Data":"倘若来到环形数组的结尾，则重新从起点开始计算，但是记录时把执行轮次数加1"}]}]},{"ID":"20231025143542-a4m01t4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231025143542-a4m01t4","updated":"20231025143542"},"Children":[{"ID":"20231025143542-plo1hwj","Type":"NodeParagraph","Properties":{"id":"20231025143542-plo1hwj","updated":"20231025143559"},"Children":[{"Type":"NodeText","Data":"一个刻度可能存在多笔定时任务，所以每个刻度需要挂载一个定时任务链表"}]}]}]},{"ID":"20231025143602-4w6ug3f","Type":"NodeParagraph","Properties":{"id":"20231025143602-4w6ug3f","updated":"20231025145140"},"Children":[{"Type":"NodeText","Data":"接下来，我们建立时间轮的扫描机制，就如同钟表中的指针一般，按照固定的时间节奏，沿着环形数组周而复始地持续向下扫描. 每当来到一个刻度时，则取出链表中轮次为 0 的定时任务进行执行. 这就是时间轮算法的核心思路。"}]},{"ID":"20231025145156-wc0jvp8","Type":"NodeParagraph","Properties":{"id":"20231025145156-wc0jvp8","updated":"20231025145156"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025145156-fs2tcf6.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025143604-60o336e","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231025143604-60o336e","updated":"20231025145637"},"Children":[{"Type":"NodeText","Data":"多级时间轮"}]},{"ID":"20231025145644-lqjljdt","Type":"NodeParagraph","Properties":{"id":"20231025145644-lqjljdt","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"接下来聊一聊时间轮中的等级制度与多级时间轮的概念."}]},{"ID":"20231025145644-ao5z52q","Type":"NodeParagraph","Properties":{"id":"20231025145644-ao5z52q","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"首先捋一捋，时间轮每个周期轮次中，使用的数据结构容量与所表达的时间范围之间的关系."}]},{"ID":"20231025145644-rkjn53z","Type":"NodeParagraph","Properties":{"id":"20231025145644-rkjn53z","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"我们把时间轮中的每个刻度记为一个 slot，每个 slot 表示的时间范围记为 t."}]},{"ID":"20231025145644-gdl4obk","Type":"NodeParagraph","Properties":{"id":"20231025145644-gdl4obk","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"假设时间轮中总共包含 2m 个 slot，求问如何组织我们的时间轮数据结构，能够使得时间轮每个轮次对应表达的时间范围尽可能的长. （一个轮次对应的时间范围越长，在时间流逝过程中轮次的迭代速度就越慢，于是每个 slot 对应的定时任务链表长度就越短，执行定时任务时的检索效率就越高.）"}]},{"ID":"20231025145644-wa3v7my","Type":"NodeParagraph","Properties":{"id":"20231025145644-wa3v7my","updated":"20231025145644"},"Children":[{"Type":"NodeText","Data":"这里最简单的方式就是进行采用一维纵向排列的方式，那么能够表达的时间范围就是 2m * t，某个刻度对应的时间值就记为 {slot_i}."}]},{"ID":"20231025145716-lcwh4ng","Type":"NodeParagraph","Properties":{"id":"20231025145716-lcwh4ng","updated":"20231025145716"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231025145716-m89rg67.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231025145723-yas22wa","Type":"NodeParagraph","Properties":{"id":"20231025145723-yas22wa","updated":"20231025145723"},"Children":[{"Type":"NodeText","Data":"另一种思路是，我们在时间轮中建立一种等级秩序."}]},{"ID":"20231025145723-6xnbwzr","Type":"NodeParagraph","Properties":{"id":"20231025145723-6xnbwzr","updated":"20231025145751"},"Children":[{"Type":"NodeText","Data":"比如我们将 2m 个 slot 拆成两个等级——level1 和 level2. 最终我们通过 {level1_slot}_{level2_slot} 的方式进行时间的表达."}]},{"ID":"20231025145723-tnkl6uv","Type":"NodeParagraph","Properties":{"id":"20231025145723-tnkl6uv","updated":"20231025145723"},"Children":[{"Type":"NodeText","Data":"我们给 level2 分配 m 个 slot，其中每个 slot 对应的时间范围同样为 t. 而 level1 同样也分配 m 个 slot，但是此时其中每个 slot 对应的时间范围应该为 m * t，因为在 level1 中的 slot 确定时，level2 中还有 m 种 slot 的组合方式."}]},{"ID":"20231025145723-swgq5xz","Type":"NodeParagraph","Properties":{"id":"20231025145723-swgq5xz","updated":"20231025145723"},"Children":[{"Type":"NodeText","Data":"如此一来，这种组织方式下，时间轮单个轮次所能表达的时间范围就是 m * m * t."}]},{"ID":"20231025145723-kqi6u3f","Type":"NodeParagraph","Properties":{"id":"20231025145723-kqi6u3f","updated":"20231025145723"},"Children":[{"Type":"NodeText","Data":"这里探讨的核心不是具体某级时间轮的时间范围结果，而是抛出了一种多级时间轮的思路，从一到二是质变，从二到三、从三到四就仅仅是量变的问题，可以继续复刻相同的思路."}]},{"ID":"20231028233553-lmlndic","Type":"NodeParagraph","Properties":{"id":"20231028233553-lmlndic","updated":"20231028233553"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231028233553-17gatoh.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231028233600-n7l1zve","Type":"NodeParagraph","Properties":{"id":"20231028233600-n7l1zve","updated":"20231028233600"},"Children":[{"Type":"NodeText","Data":"回过头来看，我们会发现日常使用的时间表达式正是采用了这样一种多级时间轮的等级制度，比如当前的时刻为：2023-09-23 15:50:00. 这本质上是一种通过 {year}-{month}-{date}-{hour}-{minute}-{second} 组成的 6 级时间轮等级结构."}]},{"ID":"20231028233600-br4sxln","Type":"NodeParagraph","Properties":{"id":"20231028233600-br4sxln","updated":"20231028233600"},"Children":[{"Type":"NodeText","Data":"后续在本文第 3 章探讨如何基于 redis zset 实现时间轮的话题中，我们会进一步利用这种多级时间轮的思路，将每个任务首先基于前 5 级 {year}-{month}-{date}-{hour}-{minute} 的等级表达式进行分钟级时间片的纵向拆分，最终在 1 分钟范围内进行定时任务的有序组织，保证在每次插入、删除和检索任务时，处理的数据量级能够维持在分钟级的数量，最大化地提高时间轮结果的处理性能."}]},{"ID":"20231028233615-j4imx7w","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231028233615-j4imx7w","updated":"20231028233628"},"Children":[{"Type":"NodeText","Data":"单机版实现"}]},{"ID":"20231029001635-sdoy0j7","Type":"NodeParagraph","Properties":{"id":"20231029001635-sdoy0j7","updated":"20231029001635"},"Children":[{"Type":"NodeText","Data":"聊完原理部分，下面我们一起进入实战环节."}]},{"ID":"20231029001635-v2j37ac","Type":"NodeParagraph","Properties":{"id":"20231029001635-v2j37ac","updated":"20231029001635"},"Children":[{"Type":"NodeText","Data":"在本章中，我们会使用 golang 标准库的定时器工具 time ticker 结合环状数组的设计思路，实现一个单机版的单级时间轮."}]},{"ID":"20231029001636-xht7pjm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231029001636-xht7pjm","updated":"20231029001640"},"Children":[{"Type":"NodeText","Data":"核心类"}]},{"ID":"20231029001640-ka1yhu2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231029001640-ka1yhu2","updated":"20231029001647"},"Children":[{"Type":"NodeText","Data":"时间轮"}]},{"ID":"20231029002231-jv1m7xp","Type":"NodeParagraph","Properties":{"id":"20231029002231-jv1m7xp","updated":"20231029002231"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231029002231-y18eqhu.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231029002239-cfiafkr","Type":"NodeParagraph","Properties":{"id":"20231029002239-cfiafkr","updated":"20231029002239"},"Children":[{"Type":"NodeText","Data":"在几个核心字段中："}]},{"ID":"20231029004635-qqgy5vc","Type":"NodeList","ListData":{},"Properties":{"id":"20231029004635-qqgy5vc","updated":"20231029004635"},"Children":[{"ID":"20231029004635-zlvjq0d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231029004635-zlvjq0d","updated":"20231029004635"},"Children":[{"ID":"20231029002239-coe1qpd","Type":"NodeParagraph","Properties":{"id":"20231029002239-coe1qpd","updated":"20231029004635"},"Children":[{"Type":"NodeText","Data":"slots——类似于时钟的表盘"}]}]},{"ID":"20231029004635-bmfscqn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231029004635-bmfscqn","updated":"20231029004635"},"Children":[{"ID":"20231029002239-08b1gdt","Type":"NodeParagraph","Properties":{"id":"20231029002239-08b1gdt","updated":"20231029004635"},"Children":[{"Type":"NodeText","Data":"curSlot——类似于时钟的指针"}]}]},{"ID":"20231029004635-pw603ha","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231029004635-pw603ha","updated":"20231029004635"},"Children":[{"ID":"20231029002239-qsaa4yl","Type":"NodeParagraph","Properties":{"id":"20231029002239-qsaa4yl","updated":"20231029004635"},"Children":[{"Type":"NodeText","Data":"ticker 是使用 golang 标准库的定时器工具，类似于驱动指针运转的齿轮"}]}]}]},{"ID":"20231029002239-7ebau6e","Type":"NodeParagraph","Properties":{"id":"20231029002239-7ebau6e","updated":"20231029002239"},"Children":[{"Type":"NodeText","Data":"在创建时间轮实例时，会通过一个异步的常驻 goroutine 执行定时任务的检索、添加、删除等操作，并通过几个 channel 进行 goroutine 的执行逻辑和生命周期的控制："}]},{"ID":"20231029004618-yui4pjc","Type":"NodeList","ListData":{},"Properties":{"id":"20231029004618-yui4pjc","updated":"20231029004618"},"Children":[{"ID":"20231029004618-6tqle73","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231029004618-6tqle73","updated":"20231029004618"},"Children":[{"ID":"20231029002239-y6u0acm","Type":"NodeParagraph","Properties":{"id":"20231029002239-y6u0acm","updated":"20231029004618"},"Children":[{"Type":"NodeText","Data":"stopc：用于停止 goroutine"}]}]},{"ID":"20231029004618-c4apu5d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231029004618-c4apu5d","updated":"20231029004618"},"Children":[{"ID":"20231029002239-8es4prr","Type":"NodeParagraph","Properties":{"id":"20231029002239-8es4prr","updated":"20231029004618"},"Children":[{"Type":"NodeText","Data":"addTaskCh：用于接收创建定时器指令"}]}]},{"ID":"20231029004618-rx2gi4b","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231029004618-rx2gi4b","updated":"20231029004618"},"Children":[{"ID":"20231029002239-psok0e0","Type":"NodeParagraph","Properties":{"id":"20231029002239-psok0e0","updated":"20231029004618"},"Children":[{"Type":"NodeText","Data":"removeTaskCh：用于接收删除定时任务的指令"}]}]}]},{"ID":"20231030003458-c7e8uqj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231030003458-c7e8uqj","updated":"20231030003459"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 单机版时间轮\ntype TimeWheel struct {\n\t// 单例工具，保证时间轮停止操作只能执行一次\n\tsync.Once\n\t// 时间轮运行时间间隔\n\tinterval time.Duration\n\t// 时间轮定时器\n\tticker *time.Ticker\n\t// 停止时间轮的 channel\n\tstopc chan struct{}\n\t// 新增定时任务的入口 channel\n\taddTaskCh chan *teskElement\n\t// 删除定时任务的入口 channel\n\tremoveTaskCh chan string\n\t// 通过 list 组成的环状数组，通过遍历环状数组的方式实现时间轮\n\t// 定时任务数量较大，每个 slot 槽内可能存在多个定时任务，因此通过 list 进行组装\n\tslots []*list.List\n\t// 当前遍历到的环状数组的索引\n\tcurSlot int\n\t// 定时任务 key 到任务节点的映射，便于在 list中删除任务节点\n\tkeyToETask map[string]*list.Element\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231030003510-qcntjhd","Type":"NodeParagraph","Properties":{"id":"20231030003510-qcntjhd","updated":"20231030003510"},"Children":[{"Type":"NodeText","Data":"此处有几个技术细节需要提及："}]},{"ID":"20231030003510-r666vea","Type":"NodeParagraph","Properties":{"id":"20231030003510-r666vea","updated":"20231030003510"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"首先："},{"Type":"NodeText","Data":" 所谓环状数组指的是逻辑意义上的. 在实际的实现过程中，会通过一个定长数组结合循环遍历的方式，来实现这个逻辑意义上的“环状”性质."}]},{"ID":"20231030003510-izdadqx","Type":"NodeParagraph","Properties":{"id":"20231030003510-izdadqx","updated":"20231030003510"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"其次："},{"Type":"NodeText","Data":" 数组每一轮能表达的时间范围是固定的. 每当在添加添加一个定时任务时，需要根据其延迟的相对时长推算出其所处的 slot 位置，其中可能跨遍历轮次的情况，这时候需要额外通过定时任务中的 cycle 字段来记录这一信息，避免定时任务被提前执行."}]},{"ID":"20231030003510-7zgea7t","Type":"NodeParagraph","Properties":{"id":"20231030003510-7zgea7t","updated":"20231030003510"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"最后："},{"Type":"NodeText","Data":" 时间轮中一个 slot 可能需要挂载多笔定时任务，因此针对每个 slot，需要采用 golang 标准库 container/list 中实现的双向链表进行定时任务数据的存储."}]},{"ID":"20231030004010-ynku86f","Type":"NodeParagraph","Properties":{"id":"20231030004010-ynku86f","updated":"20231030004010"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231030004010-j3ypam8.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231030004453-8vx1qy9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231030004453-8vx1qy9","updated":"20231030004459"},"Children":[{"Type":"NodeText","Data":"定时任务"}]},{"ID":"20231030004506-83weqq3","Type":"NodeParagraph","Properties":{"id":"20231030004506-83weqq3","updated":"20231030004506"},"Children":[{"Type":"NodeText","Data":"下面是对一笔定时任务的类定义："}]},{"ID":"20231030004522-919emhn","Type":"NodeList","ListData":{},"Properties":{"id":"20231030004522-919emhn","updated":"20231030004522"},"Children":[{"ID":"20231030004522-i2vq90h","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231030004522-i2vq90h","updated":"20231030004522"},"Children":[{"ID":"20231030004506-xlthz23","Type":"NodeParagraph","Properties":{"id":"20231030004506-xlthz23","updated":"20231030004522"},"Children":[{"Type":"NodeText","Data":"key：每个定时任务的全局唯一标识键"}]}]},{"ID":"20231030004522-u1teqtx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231030004522-u1teqtx","updated":"20231030004522"},"Children":[{"ID":"20231030004506-ig684y7","Type":"NodeParagraph","Properties":{"id":"20231030004506-ig684y7","updated":"20231030004522"},"Children":[{"Type":"NodeText","Data":" task：包含了定时任务执行逻辑的闭包函数"}]}]},{"ID":"20231030004522-xzddlr7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231030004522-xzddlr7","updated":"20231030004522"},"Children":[{"ID":"20231030004506-zjf3u1o","Type":"NodeParagraph","Properties":{"id":"20231030004506-zjf3u1o","updated":"20231030004522"},"Children":[{"Type":"NodeText","Data":"pos：定时任务在环形数组所处的位置，即数组的索引 index"}]}]},{"ID":"20231030004522-1ueej72","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231030004522-1ueej72","updated":"20231030004522"},"Children":[{"ID":"20231030004506-fa0go6n","Type":"NodeParagraph","Properties":{"id":"20231030004506-fa0go6n","updated":"20231030004522"},"Children":[{"Type":"NodeText","Data":"cycle：定时任务的延迟轮次. 时间轮的 curSlot 指针每完成一整轮的数组遍历，所有定时任务的 cycle 指数都需要减 1. 当定时任务 cycle 指数为 0 时，代表该任务在当前遍历轮次执行."}]}]}]},{"ID":"20231030004506-io3x2pu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231030004506-io3x2pu","updated":"20231030005247"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 封装了一笔定时任务的明细信息\ntype taskElement struct {\n\t// 内聚了定时任务执行逻辑的闭包函数\n\ttask func()\n\t// 定时任务挂载在环状数组中的索引位置\n\tpos int\n\t// 定时任务的延时轮次，指的是 curSlot 指针还要扫描过环状数组多少轮，才能满足执行该任务的条件\n\tcycle int\n\t// 定时任务的唯一标识键\n\tkey string\n}"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231030005249-g17tkro","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231030005249-g17tkro","updated":"20231030005258"},"Children":[{"Type":"NodeText","Data":"构造器"}]},{"ID":"20231030005442-mvisr5f","Type":"NodeParagraph","Properties":{"id":"20231030005442-mvisr5f","updated":"20231030005442"},"Children":[{"Type":"NodeText","Data":"在创建时间轮的构造器函数中，需要传入两个入参："}]},{"ID":"20231030005442-a6gvy63","Type":"NodeList","ListData":{},"Properties":{"id":"20231030005442-a6gvy63","updated":"20231030005453"},"Children":[{"ID":"20231030005453-l06mr56","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231030005453-l06mr56","updated":"20231030005453"},"Children":[{"ID":"20231030005453-gso928j","Type":"NodeParagraph","Properties":{"id":"20231030005453-gso928j","updated":"20231030005453"},"Children":[{"Type":"NodeText","Data":"slotNum：由使用方指定 slot 的个数，默认为 10"}]}]}]},{"ID":"20231030005442-szvjh3k","Type":"NodeList","ListData":{},"Properties":{"id":"20231030005442-szvjh3k","updated":"20231030005442"},"Children":[{"ID":"20231030005447-usclrka","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231030005447-usclrka"},"Children":[{"ID":"20231030005447-rpq8dok","Type":"NodeParagraph","Properties":{"id":"20231030005447-rpq8dok"},"Children":[{"Type":"NodeText","Data":"nterval：由使用方指定每个 slot 对应的时间范围，默认为 1 秒"}]}]}]},{"ID":"20231030005442-zp2z17b","Type":"NodeParagraph","Properties":{"id":"20231030005442-zp2z17b","updated":"20231030005442"},"Children":[{"Type":"NodeText","Data":"初始化时间轮实例的过程中，会完成定时器 ticker 以及各个 channel 的初始化，并针对数组 中的各个 slot 进行初始化，每个 slot 位置都需要填充一个 list."}]},{"ID":"20231030005442-omspsk7","Type":"NodeParagraph","Properties":{"id":"20231030005442-omspsk7","updated":"20231030005442"},"Children":[{"Type":"NodeText","Data":"每个时间轮实例都会异步调用 run 方法，启动一个常驻 goroutine 用于接收和处理定时任务."}]},{"ID":"20231106144703-ss3c1kg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231106144703-ss3c1kg","updated":"20231106145246"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 创建单机版时间轮 slotNum——时间轮环状数组长度  interval——扫描时间间隔\nfunc NewTimeWheel(slotNum int, interval time.Duration) *TimeWheel {\n\t// 环状数组长度默认为 10\n\tif slotNum \u003c= 0 {\n\t\tslotNum = 10\n\t}\n\t// 扫描时间间隔默认为 1 秒\n\tif interval \u003c= 0 {\n\t\tinterval = time.Second\n\t}\n\n\t// 初始化时间轮实例\n\tt := TimeWheel{\n\t\tinterval:     interval,\n\t\tticker:       time.NewTicker(interval),\n\t\tstopc:        make(chan struct{}),\n\t\tkeyToETask:   make(map[string]*list.Element),\n\t\tslots:        make([]*list.List, 0, slotNum),\n\t\taddTaskCh:    make(chan *taskElement),\n\t\tremoveTaskCh: make(chan string),\n\t}\n\tfor i := 0; i \u003c slotNum; i++ {\n\t\tt.slots = append(t.slots, list.New())\n\t}\n\n\t// 异步启动时间轮常驻 goroutine\n\tgo t.run()\n\treturn \u0026t\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231106145248-684qsrx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231106145248-684qsrx","updated":"20231106160417"},"Children":[{"Type":"NodeText","Data":"启动与停止"}]},{"ID":"20231106160418-g72zbf0","Type":"NodeParagraph","Properties":{"id":"20231106160418-g72zbf0","updated":"20231106160533"},"Children":[{"Type":"NodeText","Data":"时间轮运行的核心逻辑位于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"timeWhell.run"},{"Type":"NodeText","Data":"​ 方法中，该方法会通过 for 循环结合 select 多路复用的方式运行，属于 golang 中非常常见的异步编程风格。"}]},{"ID":"20231106160533-7d1ypws","Type":"NodeParagraph","Properties":{"id":"20231106160533-7d1ypws","updated":"20231106160633"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 运行过程中需要从以下四类 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​中接受不同的信号，并进行逻辑的分发处理："}]},{"ID":"20231106160641-2bl2zpx","Type":"NodeList","ListData":{},"Properties":{"id":"20231106160641-2bl2zpx","updated":"20231106160829"},"Children":[{"ID":"20231106160653-e5s960g","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231106160653-e5s960g","updated":"20231106160653"},"Children":[{"ID":"20231106160653-movk322","Type":"NodeParagraph","Properties":{"id":"20231106160653-movk322","updated":"20231106160755"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"stopc"},{"Type":"NodeText","Data":"​​：停止时间轮，使得当前"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​​退出"}]}]},{"ID":"20231106160755-o0s6zqz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231106160755-o0s6zqz","updated":"20231106160829"},"Children":[{"ID":"20231106160755-c1umhbj","Type":"NodeParagraph","Properties":{"id":"20231106160755-c1umhbj","updated":"20231107100005"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ticker"},{"Type":"NodeText","Data":"​​：接受到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ticker"},{"Type":"NodeText","Data":"​​的信号说明时间由往前推进了一个 interval，则需要批量检索并执行当前 slot 中的定时任务. 并推进指针 curSlot 往前偏移"}]}]},{"ID":"20231107100006-7vs98r1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107100006-7vs98r1"},"Children":[{"ID":"20231107100006-pdxyc1y","Type":"NodeParagraph","Properties":{"id":"20231107100006-pdxyc1y","updated":"20231107100040"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"addTaskCh"},{"Type":"NodeText","Data":"​：接收创建定时任务的指令"}]}]},{"ID":"20231107100040-2q8387g","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107100040-2q8387g"},"Children":[{"ID":"20231107100040-dcnisbi","Type":"NodeParagraph","Properties":{"id":"20231107100040-dcnisbi","updated":"20231107100121"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"removeTaskCh"},{"Type":"NodeText","Data":"​：接收删除定时任务的指令"}]}]}]},{"ID":"20231107100132-mz7al16","Type":"NodeParagraph","Properties":{"id":"20231107100132-mz7al16","updated":"20231107100133"},"Children":[{"Type":"NodeText","Data":"此处值得一提的是，后续不论是创建、删除还是检索定时任务，都是通过这个常驻 goroutine 完成的，因此在访问一些临界资源的时候，不需要加锁，因为不存在并发访问的情况"}]},{"ID":"20231107100200-8fg5urs","Type":"NodeParagraph","Properties":{"id":"20231107100200-8fg5urs","updated":"20231107100200"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231107100200-io4ywho.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231106160102-ckfo2mi","Type":"NodeParagraph","Properties":{"id":"20231106160102-ckfo2mi"}},{"ID":"20231106160045-9mlpf0a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231106160045-9mlpf0a","updated":"20231107110537"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 运行时间轮\nfunc (t *TimeWheel) run() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\t// ...\n\t\t}\n\t}()\n\n\t// 通过 for + select 的代码结构运行一个常驻 goroutine 是常规操作\n\tfor {\n\t\tselect {\n\t\t// 停止时间轮\n\t\tcase \u003c-t.stopc:\n\t\t\treturn\n\t\t// 接收到定时信号\n\t\tcase \u003c-t.ticker.C:\n\t\t\t// 批量执行定时任务\n\t\t\tt.tick()\n\t\t// 接收创建定时任务的信号\n\t\tcase task := \u003c-t.addTaskCh:\n\t\t\tt.addTask(task)\n\t\t// 接收到删除任务的定时信号\n\t\tcase removeKey := \u003c-t.removeTaskCh:\n\t\t\tt.removeTask(removeKey)\n\t\t}\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231107110515-dq50xq0","Type":"NodeParagraph","Properties":{"id":"20231107110515-dq50xq0","updated":"20231107110515"},"Children":[{"Type":"NodeText","Data":"时间轮提供了一个 Stop 方法，用于手动停止时间轮，回收对应的 goroutine 和 ticker 资源."}]},{"ID":"20231107110515-pj8qqkd","Type":"NodeParagraph","Properties":{"id":"20231107110515-pj8qqkd","updated":"20231107110515"},"Children":[{"Type":"NodeText","Data":"停止时间轮的操作是通过关闭 stopc channel 完成的，由于 channel 不允许被反复关闭，因此这里通过 sync.Once 保证该逻辑只被调用一次."}]},{"ID":"20231107110542-orhyukg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231107110542-orhyukg","updated":"20231107155126"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 停止时间轮\nfunc (t *TimeWheel) Stop() {\n\t//  通过单例工具，保证 channel 只能被关闭一次，避免 panic\n\tt.Do(func() {\n\t\t// 定制定时器 ticker\n\t\tt.ticker.Stop()\n\t\t// 关闭定时器运行的 stopc\n\t\tclose(t.stopc)\n\t})\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231107155131-bevkldy","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231107155131-bevkldy","updated":"20231107155142"},"Children":[{"Type":"NodeText","Data":"创建任务"}]},{"ID":"20231107155142-1iq62c1","Type":"NodeParagraph","Properties":{"id":"20231107155142-1iq62c1","updated":"20231107161315"},"Children":[{"Type":"NodeText","Data":"创建一笔定时任务的核心步骤如下："}]},{"ID":"20231107161315-owwuicv","Type":"NodeList","ListData":{},"Properties":{"id":"20231107161315-owwuicv","updated":"20231107161319"},"Children":[{"ID":"20231107161319-o3ne7bu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107161319-o3ne7bu","updated":"20231107161319"},"Children":[{"ID":"20231107161319-3xc0vpk","Type":"NodeParagraph","Properties":{"id":"20231107161319-3xc0vpk","updated":"20231107161408"},"Children":[{"Type":"NodeText","Data":"使用方往 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"addTaskCh"},{"Type":"NodeText","Data":"​ 中投递定时任务，由常驻 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 接收定时任务"}]}]},{"ID":"20231107161409-vjjbbud","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107161409-vjjbbud"},"Children":[{"ID":"20231107161409-g2eakpc","Type":"NodeParagraph","Properties":{"id":"20231107161409-g2eakpc","updated":"20231107161456"},"Children":[{"Type":"NodeText","Data":"根据执行时间，推算出定时任务所处的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slot"},{"Type":"NodeText","Data":"​ 位置以及需要延迟的轮次 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"cycle"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20231107161445-8y9svmq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107161445-8y9svmq"},"Children":[{"ID":"20231107161445-h3yayi2","Type":"NodeParagraph","Properties":{"id":"20231107161445-h3yayi2","updated":"20231107161543"},"Children":[{"Type":"NodeText","Data":"将定时任务包装成就一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list node"},{"Type":"NodeText","Data":"​，追加到对应 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slot"},{"Type":"NodeText","Data":"​ 位置的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list"},{"Type":"NodeText","Data":"​ 尾部"}]}]},{"ID":"20231107161544-dgkfw27","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107161544-dgkfw27"},"Children":[{"ID":"20231107161544-a263tsk","Type":"NodeParagraph","Properties":{"id":"20231107161544-a263tsk","updated":"20231107161700"},"Children":[{"Type":"NodeText","Data":"以定时任务唯一键为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"key"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list node"},{"Type":"NodeText","Data":"​ 为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"value"},{"Type":"NodeText","Data":"​，在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"keyToETask map"},{"Type":"NodeText","Data":"​ 中建立映射关系，方便后续删除任务时使用"}]}]}]},{"ID":"20231107161711-1qnlvq2","Type":"NodeParagraph","Properties":{"id":"20231107161711-1qnlvq2","updated":"20231107161711"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231107161711-15xefty.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231107161712-yfolo12","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231107161712-yfolo12","updated":"20231107163201"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 添加定时任务到时间轮中\nfunc (t *TimeWheel) AddTask(key string, task func(), executeAt time.Time) {\n\t// 根据执行时间推算得到定时任务从属的 slot 位置，以及需要延迟的轮次\n\tpos, cycle := t.getPosAndCircle(executeAt)\n\t// 将定时任务通过 channel 进行投递\n\tt.addTaskCh \u003c- \u0026taskElement{\n\t\tpos:   pos,\n\t\tcycle: cycle,\n\t\ttask:  task,\n\t\tkey:   key,\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231107163150-eynein6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231107163150-eynein6","updated":"20231107163151"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 根据执行时间推算得到定时任务从属的 slot 位置，以及需要延迟的轮次\nfunc (t *TimeWheel) getPosAndCircle(executeAt time.Time) (int, int) {\n\tdelay := int(time.Until(executeAt))\n\t// 定时任务的延时轮次\n\tcycle := delay / (len(t.slots) * int(t.interval))\n\t// 定时任务从属的环状数组 index\n\tpos := (t.curSlot + delay/int(t.interval)) % len(t.slots)\n\treturn pos, cycle\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231107163153-djbr0fa","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231107163153-djbr0fa","updated":"20231107163158"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 常驻 goroutine 接收到创建定时任务后的处理逻辑\nfunc (t *TimeWheel) addTask(task *taskElement) {\n\t// 获取到定时任务从属的环状数组 index 以及对应的list\n\tlist := t.slots[task.pos]\n\t// 倘若定时任务 key 之前已存在，则需要先删除定时任务\n\tif _, ok := t.keyToETask[task.key]; ok {\n\t\tt.removeTask(task.key)\n\t}\n\t// 将定时任务追加到 list 尾部\n\teTask := list.PushBack(task)\n\t// 建立定时任务 key 到将定时任务所处的节点\n\tt.keyToETask[task.key] = eTask\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231107163208-zixvyct","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231107163208-zixvyct","updated":"20231107163212"},"Children":[{"Type":"NodeText","Data":"删除任务"}]},{"ID":"20231107163212-sl4i3oe","Type":"NodeParagraph","Properties":{"id":"20231107163212-sl4i3oe","updated":"20231107163225"},"Children":[{"Type":"NodeText","Data":"删除一笔定时任务的核心步骤如下："}]},{"ID":"20231107163225-cy55mxn","Type":"NodeList","ListData":{},"Properties":{"id":"20231107163225-cy55mxn","updated":"20231107163519"},"Children":[{"ID":"20231107163227-ujtmyak","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107163227-ujtmyak","updated":"20231107163227"},"Children":[{"ID":"20231107163227-6t5cbum","Type":"NodeParagraph","Properties":{"id":"20231107163227-6t5cbum","updated":"20231107163312"},"Children":[{"Type":"NodeText","Data":"使用方往 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"removeTaskCh"},{"Type":"NodeText","Data":"​ 中投递删除任务的 key，由常驻 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​接收处理"}]}]},{"ID":"20231107163340-3s09rzg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107163340-3s09rzg"},"Children":[{"ID":"20231107163340-gwql0yf","Type":"NodeParagraph","Properties":{"id":"20231107163340-gwql0yf","updated":"20231107163412"},"Children":[{"Type":"NodeText","Data":"从 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"keyToETask map"},{"Type":"NodeText","Data":"​ 中，找到该任务对应的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list node"}]}]},{"ID":"20231107163412-ogv22ue","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107163412-ogv22ue"},"Children":[{"ID":"20231107163412-pzh5fhz","Type":"NodeParagraph","Properties":{"id":"20231107163412-pzh5fhz","updated":"20231107163451"},"Children":[{"Type":"NodeText","Data":"从 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"keyToETask map"},{"Type":"NodeText","Data":"​ 中移除该组 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"kv"},{"Type":"NodeText","Data":"​ 对"}]}]},{"ID":"20231107163451-cif6p37","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107163451-cif6p37","updated":"20231107163519"},"Children":[{"ID":"20231107163451-28phzns","Type":"NodeParagraph","Properties":{"id":"20231107163451-28phzns","updated":"20231107163519"},"Children":[{"Type":"NodeText","Data":"从对应 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slot"},{"Type":"NodeText","Data":"​ 的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list"},{"Type":"NodeText","Data":"​ 中移除该 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list node"},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20231107163533-sbs4j0f","Type":"NodeParagraph","Properties":{"id":"20231107163533-sbs4j0f","updated":"20231107163533"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231107163533-kj0rlp8.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231107163534-912bi43","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231107163534-912bi43","updated":"20231107231902"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 删除定时任务，投递信号\nfunc (t *TimeWheel) RemoveTask(key string) {\n\tt.removeTaskCh \u003c- key\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231107231903-prpiir7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231107231903-prpiir7","updated":"20231107231904"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 时间轮常驻 goroutine 接收到删除任务信号后，执行的删除任务逻辑\nfunc (t *TimeWheel) removeTask(key string) {\n\teTask, ok := t.keyToETask[key]\n\tif !ok {\n\t\treturn\n\t}\n\t// 将定时任务节点从映射map中删除\n\tdelete(t.keyToETask,key)\n\t// 获取到定时任务节点后，将其从 list 中移除\n\ttask, _ := eTask.Value.(*taskElement)\n\t_ = t.slots[task.pos].Remove(eTask)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231107231906-g9hbu98","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231107231906-g9hbu98","updated":"20231107231913"},"Children":[{"Type":"NodeText","Data":"执行定时任务"}]},{"ID":"20231107231920-9pj15zj","Type":"NodeParagraph","Properties":{"id":"20231107231920-9pj15zj","updated":"20231107231920"},"Children":[{"Type":"NodeText","Data":"最后来捋一下最核心的链路——检索并批量执行定时任务的流程."}]},{"ID":"20231107231920-c0n2tbu","Type":"NodeParagraph","Properties":{"id":"20231107231920-c0n2tbu","updated":"20231107231920"},"Children":[{"Type":"NodeText","Data":"首先，每当接收到 ticker 信号时，会根据当前的 curSlot 指针，获取到对应 slot 位置挂载的定时任务 list，调用 execute 方法执行其中的定时任务. 最后通过 circularIncr 方法推进 curSlot 指针向前移动."}]},{"ID":"20231107231948-rffc9r6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231107231948-rffc9r6","updated":"20231107232323"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 常驻 goroutine 每次接收到定时信号后用于执行定时任务的逻辑\nfunc (t *TimeWheel) tick() {\n\t// 根据 curSlot 获取到当前所处的环状数组索引位置，取出对应的list \n\tlist := t.slots[t.curSlot]\n\t// 在方法返回前，推进 curSlot 指针的位置，进行环状遍历\n\tdefer t.circularIncr()\n\t// 批量处理满足执行条件的定时任务\n\tt.execute(list)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231107232324-a36mwxl","Type":"NodeParagraph","Properties":{"id":"20231107232324-a36mwxl","updated":"20231107232330"},"Children":[{"Type":"NodeText","Data":"在 execute 方法中，会对 list 中的定时任务进行遍历："}]},{"ID":"20231107232330-kzf2z4i","Type":"NodeList","ListData":{},"Properties":{"id":"20231107232330-kzf2z4i","updated":"20231107232331"},"Children":[{"ID":"20231107232331-9f4hp3k","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107232331-9f4hp3k","updated":"20231107232331"},"Children":[{"ID":"20231107232331-gb5fiap","Type":"NodeParagraph","Properties":{"id":"20231107232331-gb5fiap","updated":"20231107232340"},"Children":[{"Type":"NodeText","Data":"对于 cycle \u003e 0 的定时任务，说明当前还未达到执行条件，需要将其 cycle 值减 1，留待后续轮次再处理"}]}]},{"ID":"20231107232341-ft7556f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107232341-ft7556f"},"Children":[{"ID":"20231107232341-yuix1om","Type":"NodeParagraph","Properties":{"id":"20231107232341-yuix1om","updated":"20231107232345"},"Children":[{"Type":"NodeText","Data":"对于 cycle = 0 的定时任务，开启一个 goroutine ，执行其中的闭包函数 task，并将其从 list 和 map 中移除"}]}]}]},{"ID":"20231107232347-p6hbetg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231107232347-p6hbetg","updated":"20231107233005"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 执行定时任务，每次处理一个 list\nfunc (t *TimeWheel) execute(l *list.List) {\n\t// 遍历 list\n\tfor e := l.Front(); e != nil {\n\t\t// 获取到每个节点对应的定时任务信息\n\t\ttaskElement, _ := e.Value.(*taskElement)\n\t\t// 倘若任务还存在延迟轮次，则只对 cyc了计数器进行扣减，本轮不作任务的执行\n\t\tif taskElement.cycle \u003e 0 {\n\t\t\ttaskElement.cycle--\n\t\t\te = e.Next()\n\t\t\tcontinue\n\t\t}\n\t\n\t\t// 当前节点对应定时任务已达成执行条件，开启一个 goroutine 负责执行任务\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tif err := recover(); err != nil {\n\t\t\t\t\t// ...\n\t\t\t\t}\n\t\t\t}()\n\t\t\ttaskElement.task()\n\t\t}()\n\t\n\t\t// 任务已执行，需要把对应的任务节点从 list 中删除\n\t\tnext := e.Next()\n\t\tl.Remove(e)\n\t\t// 把任务 key 从映射 map 中删除\n\t\tdelete(t.keyToETask, taskElement.key)\n\t\te = next\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231107233009-nfq1ufw","Type":"NodeParagraph","Properties":{"id":"20231107233009-nfq1ufw","updated":"20231107233042"},"Children":[{"Type":"NodeText","Data":"在 circularlncr 方法中，呼应了环状数组的逻辑处理方式："}]},{"ID":"20231107233050-h4f1fum","Type":"NodeParagraph","Properties":{"id":"20231107233050-h4f1fum","updated":"20231107233050"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231107233050-rw34z40.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231107233051-zrs8p8y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231107233051-zrs8p8y","updated":"20231107233337"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 每次 tick 后需要推进 curSlot 指针的位置，slots 在逻辑意义上是环状数组，\n//所以在到达尾部时需要重新回到头部\nfunc (t *TimeWheel) circularIncr() {\n\tt.curSlot = (t.curSlot+ 1) % len(t.slots)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231107234147-sg3yqau","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231107234147-sg3yqau","updated":"20231107234157"},"Children":[{"Type":"NodeText","Data":"分布式版实现"}]},{"ID":"20231107234209-z7i89fs","Type":"NodeParagraph","Properties":{"id":"20231107234209-z7i89fs","updated":"20231107234209"},"Children":[{"Type":"NodeText","Data":"本章我们讨论一下，如何基于 redis 实现分布式版本的时间轮，以贴合实际生产环境对分布式定时任务调度系统的诉求."}]},{"ID":"20231107234209-7b1mig8","Type":"NodeParagraph","Properties":{"id":"20231107234209-7b1mig8","updated":"20231107234209"},"Children":[{"Type":"NodeText","Data":"redis 版时间轮的实现思路是使用 redis 中的有序集合 sorted set（简称 zset） 进行定时任务的存储管理，其中以每个定时任务执行时间对应的时间戳作为 zset 中的 score，完成定时任务的有序排列组合."}]},{"ID":"20231107234209-n17kww9","Type":"NodeParagraph","Properties":{"id":"20231107234209-n17kww9","updated":"20231107234209"},"Children":[{"Type":"NodeText","Data":"zset 数据结构的 redis 官方文档链接：https://redis.io/docs/data-types/sorted-sets/"}]},{"ID":"20231107234240-oxlt2np","Type":"NodeParagraph","Properties":{"id":"20231107234240-oxlt2np","updated":"20231107234240"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231107234240-cnxvazu.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231107235541-a5f6qye","Type":"NodeParagraph","Properties":{"id":"20231107235541-a5f6qye","updated":"20231107235541"},"Children":[{"Type":"NodeText","Data":"这里有两个的技术细节需要提前和大家同步："}]},{"ID":"20231107235541-e3ldvwj","Type":"NodeList","ListData":{},"Properties":{"id":"20231107235541-e3ldvwj","updated":"20231107235555"},"Children":[{"ID":"20231107235555-8gucobd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107235555-8gucobd","updated":"20231107235555"},"Children":[{"ID":"20231107235555-ua7eho8","Type":"NodeParagraph","Properties":{"id":"20231107235555-ua7eho8","updated":"20231107235555"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"分钟级时间分片："},{"Type":"NodeText","Data":" 为了避免产生 redis 大 key 问题，此处采用本文 1.2 小节中提到的多级时间轮等级制度，以分钟的维度进行时间片的纵向划分，每个分钟级时间片对应一个独立的 zset 有序表，保证每次执行任务时处理的数据规模仅为分钟的量级"}]}]}]},{"ID":"20231107235541-eh7a4ac","Type":"NodeList","ListData":{},"Properties":{"id":"20231107235541-eh7a4ac","updated":"20231107235541"},"Children":[{"ID":"20231107235549-xhtaszp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107235549-xhtaszp"},"Children":[{"ID":"20231107235549-bfsyhfy","Type":"NodeParagraph","Properties":{"id":"20231107235549-bfsyhfy"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"惰性删除机制："},{"Type":"NodeText","Data":" 为了简化删除定时任务的流程. 在使用方指定删除定时任务时，我们不直接从 zset 中删除数据，而是额外记录一个已删除任务的 set. 后续在检索定时任务时，通过使用 set 进行定时任务的过滤，实现定时任务的惰性删除."}]}]}]},{"ID":"20231107235633-v759ygd","Type":"NodeParagraph","Properties":{"id":"20231107235633-v759ygd","updated":"20231107235633"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231107235633-myu337b.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231107235634-wjxdq1n","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231107235634-wjxdq1n","updated":"20231107235645"},"Children":[{"Type":"NodeText","Data":"核心类"}]},{"ID":"20231107235645-ekbuirz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231107235645-ekbuirz","updated":"20231107235652"},"Children":[{"Type":"NodeText","Data":"redis 时间轮"}]},{"ID":"20231107235652-b56d3u8","Type":"NodeParagraph","Properties":{"id":"20231107235652-b56d3u8","updated":"20231107235659"},"Children":[{"Type":"NodeText","Data":"在 redis 版时间轮中有两个核心类，第一个是关于时间轮的类定义："}]},{"ID":"20231107235720-8udrdae","Type":"NodeList","ListData":{},"Properties":{"id":"20231107235720-8udrdae","updated":"20231107235724"},"Children":[{"ID":"20231107235724-9sp5hgq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107235724-9sp5hgq","updated":"20231107235724"},"Children":[{"ID":"20231107235724-92gggs7","Type":"NodeParagraph","Properties":{"id":"20231107235724-92gggs7","updated":"20231107235825"},"Children":[{"Type":"NodeText","Data":"redisClient： 定时任务的存储是基于 redis zset 实现的，因此需要内置一个 redis 客户端。"}]}]},{"ID":"20231107235826-nmae74q","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107235826-nmae74q"},"Children":[{"ID":"20231107235826-qc76icd","Type":"NodeParagraph","Properties":{"id":"20231107235826-qc76icd","updated":"20231107235916"},"Children":[{"Type":"NodeText","Data":" httpClient：定时任务执行时，是通过请求使用方预留回调地址的方式实现的，因此需要内置一个 http 客户端"}]}]},{"ID":"20231107235916-o05kjui","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231107235916-o05kjui"},"Children":[{"ID":"20231107235916-llnyffx","Type":"NodeParagraph","Properties":{"id":"20231107235916-llnyffx","updated":"20231108000000"},"Children":[{"Type":"NodeText","Data":"channel ×  2：ticker 和stopc 对应为 golang 标准库定时器以及停止 goroutine 的控制器"}]}]}]},{"ID":"20231108000000-4v7m3au","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108000000-4v7m3au","updated":"20231108011953"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 基于 redis 实现的分布式版时间轮\ntype RTimeWheel struct {\n\tk// 内置的单例工具，用于保证 stopc 只被关闭一次\n\tsync.Once\n\t// redis 客户端\n\tredisClient *redis.Client\n\t// http 客户端 ，在执行定时任务时需要使用到\n\thttpClient *http.Client\n\t// 用于停止时间轮的控制器 channel\n\tstopc chan struct{}\n\t// 触发定时扫描任务的定时器\n\tticker *time.Ticker\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108011956-0mbw8p2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231108011956-0mbw8p2","updated":"20231108012004"},"Children":[{"Type":"NodeText","Data":"定时任务"}]},{"ID":"20231108012004-rui5p3j","Type":"NodeParagraph","Properties":{"id":"20231108012004-rui5p3j","updated":"20231108012256"},"Children":[{"Type":"NodeText","Data":"定时任务的类型定义如下，其中包括定时任务的唯一键 key，以及执行定时任务回调时需要使用到的 http 协议参数."}]},{"ID":"20231108012257-sh3gnwn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108012257-sh3gnwn","updated":"20231108013227"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 使用方提交的每一笔定时任务\ntype RTaskElement struct {\n\t// 定时任务全局唯一 key\n\tKey string `json:\"key\"`\n\t// 定时任务执行时，回调的 http url\n\tCallbackURL string `json:\"callback_url\"`\n\t// 回调时使用的http方法\n\tMethod string `json:\"method\"`\n\t// 回调时传递的请求参数\n\tReq interface{} `json:\"req\"`\n\t// 回调时使用的 http 请求头\n\tHeader map[string]string `json:\"header\"`\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108013230-anjlyfk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231108013230-anjlyfk","updated":"20231108013250"},"Children":[{"Type":"NodeText","Data":"redis lua 使用事项"}]},{"ID":"20231108013300-vef5tbm","Type":"NodeParagraph","Properties":{"id":"20231108013300-vef5tbm","updated":"20231108013300"},"Children":[{"Type":"NodeText","Data":"本项目使用的 redis 客户端是我个人基于 golang-redis 客户端 sdk——redigo 进一步封装实现的，redigo 的开源地址为： https://github.com/gomodule/redigo"}]},{"ID":"20231108013300-nm0qvx7","Type":"NodeParagraph","Properties":{"id":"20231108013300-nm0qvx7","updated":"20231108013300"},"Children":[{"Type":"NodeText","Data":"此处主要在 redisClient 中封装了一个 Eval 方法，便于使用 redis lua 脚本执行复合指令."}]},{"ID":"20231108013443-4wmd9fw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108013443-4wmd9fw","updated":"20231108013450"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"bHVh"},{"Type":"NodeCodeBlockCode","Data":"// Eval：执行 lua 脚本.\n// src——lua 脚本内容 keyCount——key 的数量 keysAndArgs——由 key 和 args 组成的列表\nfunc (c *Client) Eval(ctx context.Context, src string, keyCount int, keysAndArgs []interface{}) (interface{}, error) {\n    args := make([]interface{}, 2+len(keysAndArgs))\n    args[0] = src\n    args[1] = keyCount\n    copy(args[2:], keysAndArgs)\n\n\n    // 从 redis 链接池中获取一个连接\n    conn, err := c.pool.GetContext(ctx)\n    if err != nil {\n        return -1, err\n    }\n    // 使用完成后将连接放回池子\n    defer conn.Close()\n    // 执行 lua 脚本\n    return conn.Do(\"EVAL\", args...)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108013503-ndvzw1g","Type":"NodeParagraph","Properties":{"id":"20231108013503-ndvzw1g","updated":"20231108013503"},"Children":[{"Type":"NodeText","Data":"lua 脚本是 redis 的高级功能，能够保证针在单个 redis 节点内执行的一系列指令具备原子性，中途不会被其他操作者打断."}]},{"ID":"20231108013503-wmw3qwv","Type":"NodeParagraph","Properties":{"id":"20231108013503-wmw3qwv","updated":"20231108013503"},"Children":[{"Type":"NodeText","Data":"redis lua 功能介绍："}]},{"ID":"20231108013517-3h39ss2","Type":"NodeParagraph","Properties":{"id":"20231108013517-3h39ss2"},"Children":[{"Type":"NodeText","Data":"https://redis.io/docs/interact/programmability/eval-intro/"}]},{"ID":"20231108013503-usy5iqs","Type":"NodeParagraph","Properties":{"id":"20231108013503-usy5iqs","updated":"20231108013503"},"Children":[{"Type":"NodeText","Data":"lua 语法教程：https://www.runoob.com/lua/lua-tutorial.html"}]},{"ID":"20231108013503-o1yc80j","Type":"NodeParagraph","Properties":{"id":"20231108013503-o1yc80j","updated":"20231108013503"},"Children":[{"Type":"NodeText","Data":"此处之所以需要使用 lua 脚本，是因为在实现时间轮的过程中，存在一系列本身不具备原子性但在业务流程中不可拆解的复合操作，需要由 lua 脚本赋予其原子性质."}]},{"ID":"20231108013503-czo8qd2","Type":"NodeParagraph","Properties":{"id":"20231108013503-czo8qd2","updated":"20231108013503"},"Children":[{"Type":"NodeText","Data":"在使用 lua 时，尤其需要注意的点是，只有操作的数据属于单个 redis 节点时，才能保证其原子性. 然而在生产环境中，redis 通常采用纵向分治的集群模式，这使得 key 不同的数据可能被分发在不同的 redis 节点上，此时 lua 脚本的性质就无法保证."}]},{"ID":"20231108013534-ki7mxtn","Type":"NodeParagraph","Properties":{"id":"20231108013534-ki7mxtn","updated":"20231108013534"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231108013534-hnfdyco.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231108013543-g6fj9mt","Type":"NodeParagraph","Properties":{"id":"20231108013543-g6fj9mt","updated":"20231108013543"},"Children":[{"Type":"NodeText","Data":"在使用 lua 脚本时，倘若一系列复合操作都是针对于同一个 key，那么数据必然位于同一个节点，没有任何疑议. 倘若我们在 lua 中涉及到对多个 key 的操作，那么这些 key 对应的数据就可能从属于不同的 redis 节点，此时 lua 脚本存在失效的风险."}]},{"ID":"20231108013543-lp5a5n8","Type":"NodeParagraph","Properties":{"id":"20231108013543-lp5a5n8","updated":"20231108013543"},"Children":[{"Type":"NodeText","Data":"针对这个问题，本项目采取的是定制的分区策略，来保证指定的 key 一定被分发到相同的 redis 节点上. 此处使用的方式是通过 \"{}\" 进行 hash_tag 的标识，所有拥有相同 hash_tag 的 key 都一定会被分发到相同的节点上."}]},{"ID":"20231108013543-sdcvu2l","Type":"NodeParagraph","Properties":{"id":"20231108013543-sdcvu2l","updated":"20231108013543"},"Children":[{"Type":"NodeText","Data":"该分区策略可参见 redis 官方文档：https://redis.io/commands/cluster-keyslot/"}]},{"ID":"20231108013543-s3ovzk5","Type":"NodeParagraph","Properties":{"id":"20231108013543-s3ovzk5","updated":"20231108013543"},"Children":[{"Type":"NodeText","Data":"指令示例如下："}]},{"ID":"20231108013545-aebazdb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108013545-aebazdb","updated":"20231108013551"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"bHVh"},{"Type":"NodeCodeBlockCode","Data":"\u003e CLUSTER KEYSLOT somekey\n(integer) 11058\n\u003e CLUSTER KEYSLOT foo{hash_tag}\n(integer) 2515\n\u003e CLUSTER KEYSLOT bar{hash_tag}\n(integer) 2515\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108013555-pa1izkb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231108013555-pa1izkb","updated":"20231108013600"},"Children":[{"Type":"NodeText","Data":"构造器"}]},{"ID":"20231108013607-v5fkrdw","Type":"NodeParagraph","Properties":{"id":"20231108013607-v5fkrdw","updated":"20231108013607"},"Children":[{"Type":"NodeText","Data":"在构造时间轮实例时，使用方需要注入 redis 客户端以及 http 客户端."}]},{"ID":"20231108013607-a6x00s6","Type":"NodeParagraph","Properties":{"id":"20231108013607-a6x00s6","updated":"20231108013607"},"Children":[{"Type":"NodeText","Data":"在初始化流程中，ticker 为 golang 标准库实现的定时器，定时器的执行时间间隔固定为 1 s. 此外会异步运行 run 方法，启动一个常驻 goroutine，生命周期会通过 stopc channel 进行控制."}]},{"ID":"20231108013630-p2mt6on","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108013630-p2mt6on","updated":"20231108013731"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 构造 redis 实现的分布式时间轮\nfunc NewRTimeWheel(redisClient *redis.Client, httpClient *thttp.Client) *RTimeWheel {\n    // 创建时间轮实例\n    r := RTimeWheel{\n        // 创建定时器，每隔 1 s 执行一次\n        ticker:      time.NewTicker(time.Second),\n        redisClient: redisClient,\n        httpClient:  httpClient,\n        stopc:       make(chan struct{}),\n    }\n\n\n    // 异步启动时间轮\n    go r.run()\n    return \u0026r\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108013633-oefdial","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231108013633-oefdial","updated":"20231108013640"},"Children":[{"Type":"NodeText","Data":"启动与停止"}]},{"ID":"20231108013640-26w1gg8","Type":"NodeParagraph","Properties":{"id":"20231108013640-26w1gg8","updated":"20231108013645"},"Children":[{"Type":"NodeText","Data":"时间轮常驻 goroutine 运行流程同样通过 for + select 的形式运行："}]},{"ID":"20231108013645-i55xyjv","Type":"NodeList","ListData":{},"Properties":{"id":"20231108013645-i55xyjv","updated":"20231108013659"},"Children":[{"ID":"20231108013647-u9lmx45","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231108013647-u9lmx45","updated":"20231108013647"},"Children":[{"ID":"20231108013647-rfeblvo","Type":"NodeParagraph","Properties":{"id":"20231108013647-rfeblvo","updated":"20231108013653"},"Children":[{"Type":"NodeText","Data":"接收到 stopc 信号时，goroutine 退出，时间轮停止运行"}]}]},{"ID":"20231108013654-j7iktbc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231108013654-j7iktbc","updated":"20231108013659"},"Children":[{"ID":"20231108013654-x6f6i9o","Type":"NodeParagraph","Properties":{"id":"20231108013654-x6f6i9o","updated":"20231108013659"},"Children":[{"Type":"NodeText","Data":"接收到 ticker 信号时，开启一个异步 goroutine 用于执行当前批次的定时任务"}]}]}]},{"ID":"20231108013711-3fe17wr","Type":"NodeParagraph","Properties":{"id":"20231108013711-3fe17wr","updated":"20231108013711"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231108013711-vr14zcm.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231108013712-wp7izoh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108013712-wp7izoh","updated":"20231108013724"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 运行时间轮\nfunc (r *RTimeWheel) run() {\n    // 通过 for + select 的代码结构运行一个常驻 goroutine 是常规操作\n    for {\n        select {\n        // 接收到终止信号，则退出 goroutine\n        case \u003c-r.stopc:\n            return\n        // 每次接收到来自定时器的信号，则批量扫描并执行定时任务\n        case \u003c-r.ticker.C:\n            // 每次 tick 获取任务\n            go r.executeTasks()\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108013740-ggpu0v3","Type":"NodeParagraph","Properties":{"id":"20231108013740-ggpu0v3","updated":"20231108013740"},"Children":[{"Type":"NodeText","Data":"停止时间轮的 Stop 方法通过关闭 stopc 保证常驻 goroutine 能够及时退出."}]},{"ID":"20231108013741-858zr1b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108013741-858zr1b","updated":"20231108013748"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 停止时间轮\nfunc (r *RTimeWheel) Stop() {\n    // 基于单例工具，保证 stopc 只能被关闭一次\n    r.Do(func() {\n        // 关闭 stopc，使得常驻 goroutine 停止运行\n        close(r.stopc)\n        // 终止定时器 ticker\n        r.ticker.Stop()\n    })\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108013749-2z2z0fr","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231108013749-2z2z0fr","updated":"20231108013758"},"Children":[{"Type":"NodeText","Data":"创建任务"}]},{"ID":"20231108013803-9e09z8j","Type":"NodeParagraph","Properties":{"id":"20231108013803-9e09z8j","updated":"20231108013803"},"Children":[{"Type":"NodeText","Data":"在创建定时任务时，每笔定时任务需要根据其执行的时间找到从属的分钟时间片."}]},{"ID":"20231108013803-3o2yloz","Type":"NodeParagraph","Properties":{"id":"20231108013803-3o2yloz","updated":"20231108013803"},"Children":[{"Type":"NodeText","Data":"定时任务真正的存储逻辑定义在一段 lua 脚本中，通过 redis 客户端的 Eval 方法执行."}]},{"ID":"20231108013804-hv01rw4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108013804-hv01rw4","updated":"20231108013812"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 添加定时任务\nfunc (r *RTimeWheel) AddTask(ctx context.Context, key string, task *RTaskElement, executeAt time.Time) error {\n    // 前置对定时任务的参数进行校验\n    if err := r.addTaskPrecheck(task); err != nil {\n        return err\n    }\n\n\n    task.Key = key\n    // 将定时任务序列化成字节数组\n    taskBody, _ := json.Marshal(task)\n    // 通过执行 lua 脚本，实现将定时任务添加 redis zset 中. 本质上底层使用的是 zadd 指令.\n    _, err := r.redisClient.Eval(ctx, LuaAddTasks, 2, []interface{}{\n        // 分钟级 zset 时间片\n        r.getMinuteSlice(executeAt),\n        // 标识任务删除的集合\n        r.getDeleteSetKey(executeAt),\n        // 以执行时刻的秒级时间戳作为 zset 中的 score\n        executeAt.Unix(),\n        // 任务明细\n        string(taskBody),\n        // 任务 key，用于存放在删除集合中\n        key,\n    })\n    return err\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108013820-c237v8t","Type":"NodeParagraph","Properties":{"id":"20231108013820-c237v8t","updated":"20231108013820"},"Children":[{"Type":"NodeText","Data":"下面展示的是获取分钟级定时任务有序表 minuteSlice 以及已删除任务集合 deleteSet 的细节."}]},{"ID":"20231108013820-4dkxkqu","Type":"NodeParagraph","Properties":{"id":"20231108013820-4dkxkqu","updated":"20231108013820"},"Children":[{"Type":"NodeText","Data":"此处呼应了 3.3 小节，通过以分钟级表达式作为 {hash_tag} 的方式，确保 minuteSlice 和 deleteSet 一定会分发到相同的 redis 节点之上，进一步保证 lua 脚本的原子性能够生效."}]},{"ID":"20231108013820-fphttvt","Type":"NodeList","ListData":{},"Properties":{"id":"20231108013820-fphttvt","updated":"20231108013825"},"Children":[{"ID":"20231108013825-lro7hkg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231108013825-lro7hkg","updated":"20231108013825"},"Children":[{"ID":"20231108013825-rorgog8","Type":"NodeParagraph","Properties":{"id":"20231108013825-rorgog8","updated":"20231108013825"},"Children":[{"Type":"NodeText","Data":"获取定时任务有序表 key 的方法："}]}]}]},{"ID":"20231108013821-8bn4hqp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108013821-8bn4hqp","updated":"20231108013832"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (r *RTimeWheel) getMinuteSlice(executeAt time.Time) string {\n    return fmt.Sprintf(\"xiaoxu_timewheel_task_{%s}\", util.GetTimeMinuteStr(executeAt))\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108013833-8xwi9zr","Type":"NodeList","ListData":{},"Properties":{"id":"20231108013833-8xwi9zr","updated":"20231108013839"},"Children":[{"ID":"20231108013839-mkh58qz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231108013839-mkh58qz","updated":"20231108013839"},"Children":[{"ID":"20231108013839-fjjvvx1","Type":"NodeParagraph","Properties":{"id":"20231108013839-fjjvvx1","updated":"20231108013840"},"Children":[{"Type":"NodeText","Data":"获取删除任务集合 key 的方法："}]}]}]},{"ID":"20231108013840-lqed7fr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108013840-lqed7fr","updated":"20231108013847"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (r *RTimeWheel) getDeleteSetKey(executeAt time.Time) string {\n    return fmt.Sprintf(\"xiaoxu_timewheel_delset_{%s}\", util.GetTimeMinuteStr(executeAt))\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108013856-qfpzjvf","Type":"NodeParagraph","Properties":{"id":"20231108013856-qfpzjvf","updated":"20231108013856"},"Children":[{"Type":"NodeText","Data":"下面展示一下创建定时任务流程中 lua 脚本的执行逻辑："}]},{"ID":"20231108013905-afxq05l","Type":"NodeParagraph","Properties":{"id":"20231108013905-afxq05l","updated":"20231108013905"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231108013905-qwh74iw.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231108013906-vwf2lnt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108013906-vwf2lnt","updated":"20231108013913"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"const (\n    // 添加任务时，如果存在删除 key 的标识，则将其删除\n    // 添加任务时，根据时间（所属的 min）决定数据从属于哪个分片{}\n    LuaAddTasks = `\n       -- 获取的首个 key 为 zset 的 key\n       local zsetKey = KEYS[1]\n       -- 获取的第二个 key 为标识已删除任务 set 的 key\n       local deleteSetKey = KEYS[2]\n       -- 获取的第一个 arg 为定时任务在 zset 中的 score\n       local score = ARGV[1]\n       -- 获取的第二个 arg 为定时任务明细数据\n       local task = ARGV[2]\n       -- 获取的第三个 arg 为定时任务唯一键，用于将其从已删除任务 set 中移除\n       local taskKey = ARGV[3]\n       -- 每次添加定时任务时，都直接将其从已删除任务 set 中移除，不管之前是否在 set 中\n       redis.call('srem',deleteSetKey,taskKey)\n       -- 调用 zadd 指令，将定时任务添加到 zset 中\n       return redis.call('zadd',zsetKey,score,task)\n    `\n)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108013915-wwbu6h3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231108013915-wwbu6h3","updated":"20231108013921"},"Children":[{"Type":"NodeText","Data":"删除任务"}]},{"ID":"20231108013921-hrmupyc","Type":"NodeParagraph","Properties":{"id":"20231108013921-hrmupyc","updated":"20231108013927"},"Children":[{"Type":"NodeText","Data":"删除定时任务的方式是将定时任务追加到分钟级的已删除任务 set 中. 之后在检索定时任务时，会根据这个 set 对定时任务进行过滤，实现惰性删除机制."}]},{"ID":"20231108013928-ehbdwoa","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108013928-ehbdwoa","updated":"20231108013934"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 从 redis 时间轮中删除一个定时任务\nfunc (r *RTimeWheel) RemoveTask(ctx context.Context, key string, executeAt time.Time) error {\n    // 执行 lua 脚本，将被删除的任务追加到 set 中.\n    _, err := r.redisClient.Eval(ctx, LuaDeleteTask, 1, []interface{}{\n        r.getDeleteSetKey(executeAt),\n        key,\n    })\n    return err\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108013935-berq7am","Type":"NodeParagraph","Properties":{"id":"20231108013935-berq7am","updated":"20231108013940"},"Children":[{"Type":"NodeText","Data":"lua 执行逻辑如下："}]},{"ID":"20231108013953-kfvkeov","Type":"NodeParagraph","Properties":{"id":"20231108013953-kfvkeov","updated":"20231108013953"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231108013953-jxs2rcx.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231108013954-lcwdrvn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108013954-lcwdrvn","updated":"20231108014005"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"const(  \n    // 删除定时任务 lua 脚本\n    LuaDeleteTask = `\n       -- 获取标识删除任务的 set 集合的 key\n       local deleteSetKey = KEYS[1]\n       -- 获取定时任务的唯一键\n       local taskKey = ARGV[1]\n       -- 将定时任务唯一键添加到 set 中\n       redis.call('sadd',deleteSetKey,taskKey)\n       -- 倘若是 set 中的首个元素，则对 set 设置 120 s 的过期时间\n       local scnt = redis.call('scard',deleteSetKey)\n       if (tonumber(scnt) == 1)\n       then\n           redis.call('expire',deleteSetKey,120)\n       end\n       return scnt\n)  \n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108014006-wgdlupx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231108014006-wgdlupx","updated":"20231108014013"},"Children":[{"Type":"NodeText","Data":"执行定时任务"}]},{"ID":"20231108014013-p4y7286","Type":"NodeParagraph","Properties":{"id":"20231108014013-p4y7286","updated":"20231108014019"},"Children":[{"Type":"NodeText","Data":"在执行定时任务时，会通过 getExecutableTasks 方法批量获取到满足执行条件的定时任务 list，然后并发调用 execute 方法完成定时任务的回调执行."}]},{"ID":"20231108014019-ruf5rpf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108014019-ruf5rpf","updated":"20231108014027"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 批量执行定时任务\nfunc (r *RTimeWheel) executeTasks() {\n    defer func() {\n        if err := recover(); err != nil {\n            // log\n        }\n    }()\n\n\n    // 并发控制，保证 30 s 之内完成该批次全量任务的执行，及时回收 goroutine，避免发生 goroutine 泄漏\n    tctx, cancel := context.WithTimeout(context.Background(), time.Second*30)\n    defer cancel()\n    // 根据当前时间条件扫描 redis zset，获取所有满足执行条件的定时任务\n    tasks, err := r.getExecutableTasks(tctx)\n    if err != nil {\n        // log\n        return\n    }\n\n\n    // 并发执行任务，通过 waitGroup 进行聚合收口\n    var wg sync.WaitGroup\n    for _, task := range tasks {\n        wg.Add(1)\n        // shadow\n        task := task\n        go func() {\n            defer func() {\n                if err := recover(); err != nil {\n                }\n                wg.Done()\n            }()\n            // 执行定时任务\n            if err := r.executeTask(tctx, task); err != nil {\n                // log\n            }\n        }()\n    }\n    wg.Wait()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108014028-zyro53y","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231108014028-zyro53y","updated":"20231108014036"},"Children":[{"Type":"NodeText","Data":"检索定时任务"}]},{"ID":"20231108014042-teqht4n","Type":"NodeParagraph","Properties":{"id":"20231108014042-teqht4n","updated":"20231108014042"},"Children":[{"Type":"NodeText","Data":"最后介绍一下，如何根据当前时间获取到满足执行条件的定时任务列表："}]},{"ID":"20231108014106-7vxkm69","Type":"NodeList","ListData":{},"Properties":{"id":"20231108014106-7vxkm69","updated":"20231108014106"},"Children":[{"ID":"20231108014106-7rudm1c","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231108014106-7rudm1c","updated":"20231108014106"},"Children":[{"ID":"20231108014042-6yf0c5y","Type":"NodeParagraph","Properties":{"id":"20231108014042-6yf0c5y","updated":"20231108014106"},"Children":[{"Type":"NodeText","Data":" 每次检索时，首先根据当前时刻，推算出所从属的分钟级时间片"}]}]},{"ID":"20231108014106-lp825nv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231108014106-lp825nv","updated":"20231108014106"},"Children":[{"ID":"20231108014042-0bmq0jn","Type":"NodeParagraph","Properties":{"id":"20231108014042-0bmq0jn","updated":"20231108014106"},"Children":[{"Type":"NodeText","Data":" 然后获得当前的秒级时间戳，作为 zrange 指令检索的 score 范围"}]}]},{"ID":"20231108014106-6tq7ipx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231108014106-6tq7ipx","updated":"20231108014106"},"Children":[{"ID":"20231108014042-1np5pmh","Type":"NodeParagraph","Properties":{"id":"20231108014042-1np5pmh","updated":"20231108014106"},"Children":[{"Type":"NodeText","Data":"调用 lua 脚本，同时获取到已删除任务 set 以及 score 范围内的定时任务 list."}]}]},{"ID":"20231108014106-nd9k370","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231108014106-nd9k370","updated":"20231108014106"},"Children":[{"ID":"20231108014042-4iko8lq","Type":"NodeParagraph","Properties":{"id":"20231108014042-4iko8lq","updated":"20231108014106"},"Children":[{"Type":"NodeText","Data":"通过 set 过滤掉被删除的任务，然后返回满足执行条件的定时任务"}]}]}]},{"ID":"20231108014107-bhdazf3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108014107-bhdazf3","updated":"20231108014120"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (r *RTimeWheel) getExecutableTasks(ctx context.Context) ([]*RTaskElement, error) {\n    now := time.Now()\n    // 根据当前时间，推算出其从属的分钟级时间片\n    minuteSlice := r.getMinuteSlice(now)\n    // 推算出其对应的分钟级已删除任务集合\n    deleteSetKey := r.getDeleteSetKey(now)\n    nowSecond := util.GetTimeSecond(now)\n    // 以秒级时间戳作为 score 进行 zset 检索\n    score1 := nowSecond.Unix()\n    score2 := nowSecond.Add(time.Second).Unix()\n    // 执行 lua 脚本，本质上是通过 zrange 指令结合秒级时间戳对应的 score 进行定时任务检索\n    rawReply, err := r.redisClient.Eval(ctx, LuaZrangeTasks, 2, []interface{}{\n        minuteSlice, deleteSetKey, score1, score2,\n    })\n    if err != nil {\n        return nil, err\n    }\n\n\n    // 结果中，首个元素对应为已删除任务的 key 集合，后续元素对应为各笔定时任务\n    replies := gocast.ToInterfaceSlice(rawReply)\n    if len(replies) == 0 {\n        return nil, fmt.Errorf(\"invalid replies: %v\", replies)\n    }\n\n\n    deleteds := gocast.ToStringSlice(replies[0])\n    deletedSet := make(map[string]struct{}, len(deleteds))\n    for _, deleted := range deleteds {\n        deletedSet[deleted] = struct{}{}\n    }\n\n\n    // 遍历各笔定时任务，倘若其存在于删除集合中，则跳过，否则追加到 list 中返回，用于后续执行\n    tasks := make([]*RTaskElement, 0, len(replies)-1)\n    for i := 1; i \u003c len(replies); i++ {\n        var task RTaskElement\n        if err := json.Unmarshal([]byte(gocast.ToString(replies[i])), \u0026task); err != nil {\n            // log\n            continue\n        }\n\n\n        if _, ok := deletedSet[task.Key]; ok {\n            continue\n        }\n        tasks = append(tasks, \u0026task)\n    }\n\n\n    return tasks, nil\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108014137-srltmdt","Type":"NodeParagraph","Properties":{"id":"20231108014137-srltmdt","updated":"20231108014137"},"Children":[{"Type":"NodeText","Data":"lua 脚本的执行逻辑如下："}]},{"ID":"20231108014146-9mu27ln","Type":"NodeParagraph","Properties":{"id":"20231108014146-9mu27ln","updated":"20231108014146"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231108014146-qvtfnx3.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231108014152-8zoukjy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231108014152-8zoukjy","updated":"20231108014153"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"(  \n    // 扫描 redis 时间轮. 获取分钟范围内,已删除任务集合 以及在时间上达到执行条件的定时任务进行返回\n    LuaZrangeTasks = `\n       -- 第一个 key 为存储定时任务的 zset key\n       local zsetKey = KEYS[1]\n       -- 第二个 key 为已删除任务 set 的 key\n       local deleteSetKey = KEYS[2]\n       -- 第一个 arg 为 zrange 检索的 score 左边界\n       local score1 = ARGV[1]\n       -- 第二个 arg 为 zrange 检索的 score 右边界\n       local score2 = ARGV[2]\n       -- 获取到已删除任务的集合\n       local deleteSet = redis.call('smembers',deleteSetKey)\n       -- 根据秒级时间戳对 zset 进行 zrange 检索，获取到满足时间条件的定时任务\n       local targets = redis.call('zrange',zsetKey,score1,score2,'byscore')\n       -- 检索到的定时任务直接从时间轮中移除，保证分布式场景下定时任务不被重复获取\n       redis.call('zremrangebyscore',zsetKey,score1,score2)\n       -- 返回的结果是一个 table\n       local reply = {}\n       -- table 的首个元素为已删除任务集合\n       reply[1] = deleteSet\n       -- 依次将检索到的定时任务追加到 table 中\n       for i, v in ipairs(targets) do\n           reply[#reply+1]=v\n       end\n       return reply\n    `\n)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231108014155-zpfwhvi","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231108014155-zpfwhvi","updated":"20231108014158"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20231108014205-nbwoqfy","Type":"NodeParagraph","Properties":{"id":"20231108014205-nbwoqfy","updated":"20231108014205"},"Children":[{"Type":"NodeText","Data":"本期和大家探讨了如何基于 golang 从零到一实现时间轮算法，通过原理结合源码，详细展示了单机版和 redis 分布式版时间轮的实现方式."}]},{"ID":"20231108014205-t9igde0","Type":"NodeParagraph","Properties":{"id":"20231108014205-t9igde0","updated":"20231108014205"},"Children":[{"Type":"NodeText","Data":"最后我们展望一下，时间轮算法在工程实践中具体能得到怎样的应用呢？"}]},{"ID":"20231108014205-rhaurto","Type":"NodeParagraph","Properties":{"id":"20231108014205-rhaurto","updated":"20231108014205"},"Children":[{"Type":"NodeText","Data":"此前我基于 redis zset 时间轮的模型实现了一个分布式定时任务调度系统 xtimer，大家感兴趣的话可以阅读一下我之前分享的这篇文章："},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"http://mp.weixin.qq.com/s?__biz=MzkxMjQzMjA0OQ==\u0026amp;mid=2247483769\u0026amp;idx=1\u0026amp;sn=38d4a0c15e0e7a9f74a58e43f293e8a2\u0026amp;chksm=c10c4fa7f67bc6b1b08602e328c7ac506e4dc4c942427c730ecbfe3f18f0d1e268b1aa1e0d32\u0026amp;scene=21#wechat_redirect","TextMarkTextContent":"基于协程池架构实现的分布式定时器 XTimer"}]},{"ID":"20231108014205-cdlhjpk","Type":"NodeParagraph","Properties":{"id":"20231108014205-cdlhjpk","updated":"20231108014205"},"Children":[{"Type":"NodeText","Data":"该项目源码已于 github 开源：http://github.com/xiaoxuxiansheng/xtimer"}]},{"ID":"20231108014216-ysifzuz","Type":"NodeParagraph","Properties":{"id":"20231108014216-ysifzuz","updated":"20231108014216"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20231108014216-e64eyef.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}