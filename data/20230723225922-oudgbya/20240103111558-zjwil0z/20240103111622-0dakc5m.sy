{"ID":"20240103111622-0dakc5m","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f341","id":"20240103111622-0dakc5m","tags":"Go-GC,Go 内存分配,Go 垃圾回收,需要仔细看","title":"Golang GC 从理论到针对服务的定制化应用","updated":"20240110001452"},"Children":[{"ID":"20240103111645-mmrl81a","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240103111645-mmrl81a","updated":"20240103111658"},"Children":[{"Type":"NodeText","Data":"理论"}]},{"ID":"20240103111659-bk7alxr","Type":"NodeParagraph","Properties":{"id":"20240103111659-bk7alxr","updated":"20240103111706"},"Children":[{"Type":"NodeText","Data":"GC 和内存分配方式是强相关的两个技术，因此在分析两者的设计原理之时，要结合起来一起看。"}]},{"ID":"20240103111720-ro5nt4t","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240103111720-ro5nt4t","updated":"20240103111723"},"Children":[{"Type":"NodeText","Data":"GC 算法"}]},{"ID":"20240103145852-qdd5sxt","Type":"NodeParagraph","Properties":{"id":"20240103145852-qdd5sxt","updated":"20240103145852"},"Children":[{"Type":"NodeText","Data":"标记-清除"}]},{"ID":"20240103145852-11rmkz0","Type":"NodeParagraph","Properties":{"id":"20240103145852-11rmkz0","updated":"20240103145852"},"Children":[{"Type":"NodeText","Data":"标记-整理"}]},{"ID":"20240103145852-9b7he23","Type":"NodeParagraph","Properties":{"id":"20240103145852-9b7he23","updated":"20240103145852"},"Children":[{"Type":"NodeText","Data":"标记-复制"}]},{"ID":"20240103145852-dwb1era","Type":"NodeParagraph","Properties":{"id":"20240103145852-dwb1era","updated":"20240103145852"},"Children":[{"Type":"NodeText","Data":"分代收集"}]},{"ID":"20240103145854-nnd8npa","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240103145854-nnd8npa","updated":"20240103145904"},"Children":[{"Type":"NodeText","Data":"内存分配方式"}]},{"ID":"20240103111622-3xw855g","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240103111622-3xw855g","updated":"20240103145916"},"Children":[{"Type":"NodeText","Data":"线性分配方式"}]},{"ID":"20240103145916-usr7ouo","Type":"NodeBlockquote","Properties":{"id":"20240103145916-usr7ouo","updated":"20240103150001"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240103145920-4ysvmly","Type":"NodeParagraph","Properties":{"id":"20240103145920-4ysvmly","updated":"20240103145929"},"Children":[{"Type":"NodeText","Data":"线性分配（Bump Allocator）是一种高效的内存分配方法，但是有较大的局限性。当我们使用线性分配器时，只需要在内存中维护一个指向内存特定位置的指针，如果用户程序向分配器申请内存，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置，即移动下图中的指针："}]},{"ID":"20240103145940-218trbx","Type":"NodeParagraph","Properties":{"id":"20240103145940-218trbx","updated":"20240103145940"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240103145940-r327rmx.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240103150001-lxnu69t","Type":"NodeParagraph","Properties":{"id":"20240103150001-lxnu69t","updated":"20240103150001"},"Children":[{"Type":"NodeText","Data":"线性分配器虽然线性分配器实现为它带来了较快的执行速度以及较低的实现复杂度，但是线性分配器无法在内存被释放时重用内存。如下图所示，如果已经分配的内存被回收，线性分配器无法重新利用红色的内存："},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR8QS8Sz0QV86dibz0Q9qIj2fPWy7CiczdeH7nic21nw6qVe7MSyHmvIjkdT8c4YIgmJmUetak26GDQ/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"线性分配器回收内存因为线性分配器具有上述特性，所以需要与合适的垃圾回收算法配合使用，例如：标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法，它们可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能了。因为线性分配器需要与具有拷贝特性的垃圾回收算法配合，所以 C 和 C++ 等需要直接对外暴露指针的语言就无法使用该策略。"}]},{"ID":"20240103150001-z3iuli6","Type":"NodeParagraph","Properties":{"id":"20240103150001-z3iuli6","updated":"20240103150001"},"Children":[{"Type":"NodeText","Data":"引用自："}]},{"ID":"20240103150001-dzxfhxp","Type":"NodeParagraph","Properties":{"id":"20240103150001-dzxfhxp","updated":"20240103150001"},"Children":[{"Type":"NodeText","Data":"[https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95]"}]}]},{"ID":"20240103150517-vcwwoey","Type":"NodeParagraph","Properties":{"id":"20240103150517-vcwwoey","updated":"20240103150517"},"Children":[{"Type":"NodeText","Data":"应用代表：Java（如果使用 Serial, ParNew 等带有 Compact 过程的收集器时，采用分配的方式为线性分配）"}]},{"ID":"20240103150517-0lr0290","Type":"NodeParagraph","Properties":{"id":"20240103150517-0lr0290","updated":"20240103150517"},"Children":[{"Type":"NodeText","Data":"问题：内存碎片"}]},{"ID":"20240103150517-irmsi1r","Type":"NodeParagraph","Properties":{"id":"20240103150517-irmsi1r","updated":"20240103150517"},"Children":[{"Type":"NodeText","Data":"解决方式：GC 算法中加入「复制/整理」阶段"}]},{"ID":"20240103150518-x0aets6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240103150518-x0aets6","updated":"20240103150526"},"Children":[{"Type":"NodeText","Data":"空闲链表分配"}]},{"ID":"20240103150526-hygiri6","Type":"NodeBlockquote","Properties":{"id":"20240103150526-hygiri6","updated":"20240103150535"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240103150535-99oh79n","Type":"NodeParagraph","Properties":{"id":"20240103150535-99oh79n","updated":"20240103150535"},"Children":[{"Type":"NodeText","Data":"空闲链表分配器（Free-List Allocator）可以重用已经被释放的内存，它在内部会维护一个类似链表的数据结构。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表："},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR8QS8Sz0QV86dibz0Q9qIj3IsjleS1qlHJ0tPDSVw4qraPAgOrmHcicvOelmicyG2mQU1VjmTf8Rqw/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"空闲链表分配器因为不同的内存块通过指针构成了链表，所以使用这种方式的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以它的时间复杂度是 O(n)。空闲链表分配器可以选择不同的策略在链表中的内存块中进行选择，最常见的是以下四种："}]},{"ID":"20240103150535-uux0x3y","Type":"NodeList","ListData":{},"Properties":{"id":"20240103150535-uux0x3y","updated":"20240103150535"},"Children":[{"ID":"20240103150535-kr3t799","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103150535-kr3t799","updated":"20240103150535"},"Children":[{"ID":"20240103150535-thtri43","Type":"NodeParagraph","Properties":{"id":"20240103150535-thtri43","updated":"20240103150535"},"Children":[{"Type":"NodeText","Data":"首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块；"}]}]},{"ID":"20240103150535-k5ut694","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103150535-k5ut694","updated":"20240103150535"},"Children":[{"ID":"20240103150535-y089p59","Type":"NodeParagraph","Properties":{"id":"20240103150535-y089p59","updated":"20240103150535"},"Children":[{"Type":"NodeText","Data":"循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块；"}]}]},{"ID":"20240103150535-ym8h9jk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103150535-ym8h9jk","updated":"20240103150535"},"Children":[{"ID":"20240103150535-f5eij7z","Type":"NodeParagraph","Properties":{"id":"20240103150535-f5eij7z","updated":"20240103150535"},"Children":[{"Type":"NodeText","Data":"最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块；"}]}]},{"ID":"20240103150535-8oxf5b5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103150535-8oxf5b5","updated":"20240103150535"},"Children":[{"ID":"20240103150535-7qon07d","Type":"NodeParagraph","Properties":{"id":"20240103150535-7qon07d","updated":"20240103150535"},"Children":[{"Type":"NodeText","Data":"隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块；"}]}]}]},{"ID":"20240103150535-nzmsbkt","Type":"NodeParagraph","Properties":{"id":"20240103150535-nzmsbkt","updated":"20240103150535"},"Children":[{"Type":"NodeText","Data":"引用自：[https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95]"}]}]},{"ID":"20240103150549-slwhv8k","Type":"NodeParagraph","Properties":{"id":"20240103150549-slwhv8k","updated":"20240103150549"},"Children":[{"Type":"NodeText","Data":"应用代表：GO、Java（如果使用 CMS 这种基于标记-清除，采用分配的方式为空闲链表分配）"}]},{"ID":"20240103150549-nokdekc","Type":"NodeParagraph","Properties":{"id":"20240103150549-nokdekc","updated":"20240103150549"},"Children":[{"Type":"NodeText","Data":"问题：相比线性分配方式的 bump-pointer 分配操作（top += size），空闲链表的分配操作过重，例如在 GO 程序的 pprof 图中经常可以看到 mallocgc() 占用了比较多的 CPU；"}]},{"ID":"20240103150550-rumdcdx","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240103150550-rumdcdx","updated":"20240103150556"},"Children":[{"Type":"NodeText","Data":"在Golang中的应用"}]},{"ID":"20240103150556-2ip19m0","Type":"NodeParagraph","Properties":{"id":"20240103150556-2ip19m0","updated":"20240103150601"},"Children":[{"Type":"NodeText","Data":"完整讲解：https://time.geekbang.org/column/article/484271"}]},{"ID":"20240103150615-ukyutjb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240103150615-ukyutjb","updated":"20240103150621"},"Children":[{"Type":"NodeText","Data":"内存分配方式"}]},{"ID":"20240103150622-dfqag2s","Type":"NodeParagraph","Properties":{"id":"20240103150622-dfqag2s","updated":"20240103150642"},"Children":[{"Type":"NodeText","Data":"Golang 采用了基于空闲链表分配方式的TCMalloc 算法。"}]},{"ID":"20240103150643-lmy44s8","Type":"NodeBlockquote","Properties":{"id":"20240103150643-lmy44s8","updated":"20240103150708"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240103150652-ytnp5pb","Type":"NodeParagraph","Properties":{"id":"20240103150652-ytnp5pb","updated":"20240103150701"},"Children":[{"Type":"NodeText","Data":"关于TCMalloc 官方文档"}]},{"ID":"20240103150702-6rojj47","Type":"NodeParagraph","Properties":{"id":"20240103150702-6rojj47","updated":"20240103150708"},"Children":[{"Type":"NodeText","Data":"[https://github.com/google/tcmalloc/blob/master/docs/design.md]"}]}]},{"ID":"20240103152821-jdprlzs","Type":"NodeParagraph","Properties":{"id":"20240103152821-jdprlzs","updated":"20240103152821"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240103152821-eh9jl79.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240103152826-jnouuau","Type":"NodeBlockquote","Properties":{"id":"20240103152826-jnouuau","updated":"20240103152829"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240103152829-pp694j0","Type":"NodeList","ListData":{},"Properties":{"id":"20240103152829-pp694j0","updated":"20240103152829"},"Children":[{"ID":"20240103152829-jn6f3es","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152829-jn6f3es","updated":"20240103152829"},"Children":[{"ID":"20240103152829-16zw17h","Type":"NodeParagraph","Properties":{"id":"20240103152829-16zw17h","updated":"20240103152829"},"Children":[{"Type":"NodeText","Data":"Front-end：它是一个内存缓存，提供了快速分配和重分配内存给应用的功能。它主要由2部分组成：Per-thread cache 和 Per-CPU cache。"}]}]},{"ID":"20240103152829-zvrn142","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152829-zvrn142","updated":"20240103152829"},"Children":[{"ID":"20240103152829-fyw2tba","Type":"NodeParagraph","Properties":{"id":"20240103152829-fyw2tba","updated":"20240103152829"},"Children":[{"Type":"NodeText","Data":"Middle-end：职责是给Front-end提供缓存。也就是说当Front-end缓存内存不够用时，从Middle-end申请内存。它主要是 Central free list 这部分内容。"}]}]},{"ID":"20240103152829-lurev85","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152829-lurev85","updated":"20240103152829"},"Children":[{"ID":"20240103152829-7pngau7","Type":"NodeParagraph","Properties":{"id":"20240103152829-7pngau7","updated":"20240103152829"},"Children":[{"Type":"NodeText","Data":"Back-end：这一块是负责从操作系统获取内存，并给Middle-end提供缓存使用。它主要涉及 Page Heap 内容。"}]}]}]},{"ID":"20240103152829-xv2kqqi","Type":"NodeParagraph","Properties":{"id":"20240103152829-xv2kqqi","updated":"20240103152829"},"Children":[{"Type":"NodeText","Data":"TCMalloc将整个虚拟内存空间划分为n个同等大小的Page。将n个连续的page连接在一起组成一个Span。PageHeap向OS申请内存，申请的span可能只有一个page，也可能有n个page。ThreadCache内存不够用会向CentralCache申请，CentralCache内存不够用时会向PageHeap申请，PageHeap不够用就会向OS操作系统申请。"}]},{"ID":"20240103152829-nocfqrq","Type":"NodeParagraph","Properties":{"id":"20240103152829-nocfqrq","updated":"20240103152829"},"Children":[{"Type":"NodeText","Data":"引用自：[https://www.cnblogs.com/jiujuan/p/13869547.html]"}]}]},{"ID":"20240103152845-g1315si","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240103152845-g1315si","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"GC 算法"}]},{"ID":"20240103152845-khses8i","Type":"NodeParagraph","Properties":{"id":"20240103152845-khses8i","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"Golang 采用了基于并发标记与清扫算法的三色标记法。"}]},{"ID":"20240103152845-qghf1d2","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240103152845-qghf1d2","updated":"20240103152845"},"Children":[{"ID":"20240103152845-v76k082","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240103152845-v76k082","updated":"20240103152845"},"Children":[{"ID":"20240103152845-gycu585","Type":"NodeParagraph","Properties":{"id":"20240103152845-gycu585","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"Golang GC 的四个阶段"}]}]}]},{"ID":"20240103152845-gop8ljn","Type":"NodeBlockquote","Properties":{"id":"20240103152845-gop8ljn","updated":"20240103152845"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240103152845-n89u9m4","Type":"NodeParagraph","Properties":{"id":"20240103152845-n89u9m4","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"Mark Prepare - STW 做标记阶段的准备工作，需要停止所有正在运行的goroutine(即STW)，标记根对象，启用内存屏障，内存屏障有点像内存读写钩子，它用于在后续并发标记的过程中，维护三色标记的完备性(三色不变性)，这个过程通常很快，大概在10-30微秒。"}]},{"ID":"20240103152845-deibt9r","Type":"NodeParagraph","Properties":{"id":"20240103152845-deibt9r","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"Marking - Concurrent 标记阶段会将大概25%(gcBackgroundUtilization)的P用于标记对象，逐个扫描所有G的堆栈，执行三色标记，在这个过程中，所有新分配的对象都是黑色，被扫描的G会被暂停，扫描完成后恢复，这部分工作叫后台标记(gcBgMarkWorker)。这会降低系统大概25%的吞吐量，比如MAXPROCS=6，那么GC P期望使用率为6*0.25=1.5，这150%P会通过专职(Dedicated)/兼职(Fractional)/懒散(Idle) 三种工作模式的Worker共同来完成。这还没完，为了保证在Marking过程中，其它G分配堆内存太快，导致Mark跟不上Allocate的速度，还需要其它G配合做一部分标记的工作，这部分工作叫辅助标记(mutator assists)。在Marking期间，每次G分配内存都会更新它的”负债指数”(gcAssistBytes)，分配得越快，gcAssistBytes越大，这个指数乘以全局的”负载汇率”(assistWorkPerByte)，就得到这个G需要帮忙Marking的内存大小(这个计算过程叫revise)，也就是它在本次分配的mutator assists工作量(gcAssistAlloc)。"}]},{"ID":"20240103152845-7mac7ux","Type":"NodeParagraph","Properties":{"id":"20240103152845-7mac7ux","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"Mark Termination - STW 标记阶段的最后工作是Mark Termination，关闭内存屏障，停止后台标记以及辅助标记，做一些清理工作，整个过程也需要STW，大概需要60-90微秒。在此之后，所有的P都能继续为应用程序G服务了。"}]},{"ID":"20240103152845-rolkq74","Type":"NodeParagraph","Properties":{"id":"20240103152845-rolkq74","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"Sweeping - Concurrent 在标记工作完成之后，剩下的就是清理过程了，清理过程的本质是将没有被使用的内存块整理回收给上一个内存管理层级(mcache -\u003e mcentral -\u003e mheap -\u003e OS)，清理回收的开销被平摊到应用程序的每次内存分配操作中，直到所有内存都Sweeping完成。当然每个层级不会全部将待清理内存都归还给上一级，避免下次分配再申请的开销，比如Go1.12对mheap归还OS内存做了优化，使用NADV_FREE延迟归还内存。"}]},{"ID":"20240103152845-gazpr4v","Type":"NodeParagraph","Properties":{"id":"20240103152845-gazpr4v","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"引用自：[https://wudaijun.com/2020/01/go-gc-keypoint-and-monitor/]"}]}]},{"ID":"20240103152845-90p7l34","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240103152845-90p7l34","updated":"20240103152845"},"Children":[{"ID":"20240103152845-tq0km9f","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240103152845-tq0km9f","updated":"20240103152845"},"Children":[{"ID":"20240103152845-afeyva6","Type":"NodeParagraph","Properties":{"id":"20240103152845-afeyva6","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"关于 GC 触发阈值"}]}]}]},{"ID":"20240103152845-zj2du69","Type":"NodeBlockquote","Properties":{"id":"20240103152845-zj2du69","updated":"20240103152845"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240103152845-ab9s6y6","Type":"NodeParagraph","Properties":{"id":"20240103152845-ab9s6y6","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR8QS8Sz0QV86dibz0Q9qIjcrXM4iagWHrJ1icbGicUEmoGWFJlJIjdWQO6vlhLvq4V84swH129b4H4w/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"对应关系如下："}]},{"ID":"20240103152845-5jr9hu8","Type":"NodeList","ListData":{},"Properties":{"id":"20240103152845-5jr9hu8","updated":"20240103152845"},"Children":[{"ID":"20240103152845-akg74vn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152845-akg74vn","updated":"20240103152845"},"Children":[{"ID":"20240103152845-3lb13xm","Type":"NodeParagraph","Properties":{"id":"20240103152845-3lb13xm","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"GC开始时内存使用量：GC trigger；"}]}]},{"ID":"20240103152845-msyl9dv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152845-msyl9dv","updated":"20240103152845"},"Children":[{"ID":"20240103152845-5pq863q","Type":"NodeParagraph","Properties":{"id":"20240103152845-5pq863q","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"GC标记完成时内存使用量：Heap size at GC completion；"}]}]},{"ID":"20240103152845-83xizvk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152845-83xizvk","updated":"20240103152845"},"Children":[{"ID":"20240103152845-d5bx83a","Type":"NodeParagraph","Properties":{"id":"20240103152845-d5bx83a","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"GC标记完成时的存活内存量：图中标记的Previous marked heap size为上一轮的GC标记完成时的存活内存量；"}]}]},{"ID":"20240103152845-ot74bgq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152845-ot74bgq","updated":"20240103152845"},"Children":[{"ID":"20240103152845-y5zz1zf","Type":"NodeParagraph","Properties":{"id":"20240103152845-y5zz1zf","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"本轮GC标记完成时的预期内存使用量：Goal heap size；"}]}]}]},{"ID":"20240103152845-lrlxgnl","Type":"NodeParagraph","Properties":{"id":"20240103152845-lrlxgnl","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"引用自: https://www.jianshu.com/p/4069d1e3d716"}]}]},{"ID":"20240103152845-x31ytij","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240103152845-x31ytij","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"存在问题"}]},{"ID":"20240103152845-38n3558","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240103152845-38n3558","updated":"20240103152845"},"Children":[{"ID":"20240103152845-12x343q","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240103152845-12x343q","updated":"20240103152845"},"Children":[{"ID":"20240103152845-915v7zb","Type":"NodeParagraph","Properties":{"id":"20240103152845-915v7zb","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"GC Marking - Concurrent 阶段，这个阶段有三个问题："}]},{"ID":"20240103152845-d7p5zwr","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240103152845-d7p5zwr","updated":"20240103152845"},"Children":[{"ID":"20240103152845-yj7life","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240103152845-yj7life","updated":"20240103152845"},"Children":[{"ID":"20240103152845-hdprduq","Type":"NodeParagraph","Properties":{"id":"20240103152845-hdprduq","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"GC 协程和业务协程是并行运行的，大概会占用 25% 的CPU，使得程序的吞吐量下降；"}]}]},{"ID":"20240103152845-3qmuvio","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240103152845-3qmuvio","updated":"20240103152845"},"Children":[{"ID":"20240103152845-7rxtur2","Type":"NodeParagraph","Properties":{"id":"20240103152845-7rxtur2","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"如果业务 goroutine 分配堆内存太快，导致 Mark 跟不上 Allocate 的速度，那么业务 goroutine 会被招募去做协助标记，暂停对业务逻辑的执行，这会影响到服务处理请求的耗时。"}]}]},{"ID":"20240103152845-a0pud8i","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240103152845-a0pud8i","updated":"20240103152845"},"Children":[{"ID":"20240103152845-sg45cmy","Type":"NodeParagraph","Properties":{"id":"20240103152845-sg45cmy","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"GOGC 在稳态场景下可以很好的工作，但是在瞬态场景下，如定时的缓存失效，定时的流量脉冲，GC 影响会急剧上升。一个典型例子：IO 密集型服务 耗时优化：https://segmentfault.com/a/1190000041637173"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR8QS8Sz0QV86dibz0Q9qIjLnFocn4iacoA6h1Ric0offic9SSQs9WNUaPqx1GPHB9PgotIiaEsE3VDQQ/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}]}]},{"ID":"20240103152845-na0yvks","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240103152845-na0yvks","updated":"20240103152845"},"Children":[{"ID":"20240103152845-agmx6so","Type":"NodeParagraph","Properties":{"id":"20240103152845-agmx6so","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"GC Mark Prepare、Mark Termination - STW 阶段，这两个阶段虽然按照官方说法时间会很短，但是在实际的线上服务中，有时会在 trace 图中观测到长达十几 ms 的停顿，原因可能为：OS 线程在做内存申请的时候触发内存整理被“卡住”，Go Runtime 无法抢占处于这种情况的 goroutine ，进而阻塞 STW 完成。（内存申请卡住原因：HugePage配置不合理）"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR8QS8Sz0QV86dibz0Q9qIjAmBDW5JBtibooicQFeuoSe46INhVicZutqmIb7NqmiaKrhWqSgiaoZ4jkFg/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20240103152845-by95x9b","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240103152845-by95x9b","updated":"20240103152845"},"Children":[{"ID":"20240103152845-rqgyfdh","Type":"NodeParagraph","Properties":{"id":"20240103152845-rqgyfdh","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"过于关注 STW 的优化，带来服务吞吐量的下降（高峰期内存分配和 GC 时间的 CPU 占用超过 30% ）；"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR8QS8Sz0QV86dibz0Q9qIjjAQgsnfCPRn8xqVThlaeX4Yib9bISeVHibepN4SqiaQZYGASo4Dg0DpfA/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20240103152845-6h13aer","Type":"NodeBlockquote","Properties":{"id":"20240103152845-6h13aer","updated":"20240103152845"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240103152845-1fij2bd","Type":"NodeParagraph","Properties":{"id":"20240103152845-1fij2bd","updated":"20240103152845"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"性能问题之 GC"}]},{"ID":"20240103152845-ztl2ffa","Type":"NodeParagraph","Properties":{"id":"20240103152845-ztl2ffa","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"这里谈一下 GC 的问题，或者说内存管理的问题。"}]},{"ID":"20240103152845-nwy1kwy","Type":"NodeParagraph","Properties":{"id":"20240103152845-nwy1kwy","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"内存管理包括了内存分配和垃圾回收两个方面，对于 Go 来说，GC 是一个并发 - 标记 - 清除（CMS）算法收集器。但是需要注意一点，Go 在实现 GC 的过程当中，过多地把重心放在了暂停时间——也就是 Stop the World（STW）的时间方面，但是代价是牺牲了 GC 中的其他特性。"}]},{"ID":"20240103152845-pq4qzxn","Type":"NodeParagraph","Properties":{"id":"20240103152845-pq4qzxn","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"我们知道，GC 有很多需要关注的方面，比如吞吐量——GC 肯定会减慢程序，那么它对吞吐量有多大的影响；还有，在一段固定的 CPU 时间里可以回收多少垃圾；另外还有 Stop the World 的时间和频率；以及新申请内存的分配速度；还有在分配内存时，空间的浪费情况；以及在多核机器下，GC 能否充分利用多核等很多方面问题。非常遗憾的是，Golang 在设计和实现时，过度强调了暂停时间有限。但这带来了其他影响：比如在执行的过程当中，堆是不能压缩的，也就是说，对象也是不能移动的；还有它也是一个不分代的 GC。所以体现在性能上，就是内存分配和 GC 通常会占用比较多 CPU 资源。"}]},{"ID":"20240103152845-kxksxmh","Type":"NodeParagraph","Properties":{"id":"20240103152845-kxksxmh","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"我们有同事进行过一些统计，很多微服务在晚高峰期，内存分配和 GC 时间甚至会占用超过 30% 的 CPU 资源。占用这么高资源的原因大概有两点，一个是 Go 里面比较频繁地进行内存分配操作；另一个是 Go 在分配堆内存时，实现相对比较重，消耗了比较多 CPU 资源。比如它中间有 acquired M 和 GC 互相抢占的锁；它的代码路径也比较长；指令数也比较多；内存分配的局部性也不是特别好。"}]},{"ID":"20240103152845-kwqe577","Type":"NodeParagraph","Properties":{"id":"20240103152845-kwqe577","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"引用自：https://mp.weixin.qq.com/s/0X4lasAf5Sbt_tromlqwIQ"}]}]},{"ID":"20240103152845-mgozct2","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240103152845-mgozct2","updated":"20240103152845"},"Children":[{"ID":"20240103152845-ffxtuar","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20240103152845-ffxtuar","updated":"20240103152845"},"Children":[{"ID":"20240103152845-ggv6inx","Type":"NodeParagraph","Properties":{"id":"20240103152845-ggv6inx","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"由于 GC 不分代，每次 GC 都要扫描全量的存活对象，导致 GC 开销较高。（解决方式：GO 的分代 GC [https://www.jianshu.com/p/2383743edb7b]）"}]}]}]},{"ID":"20240103152845-1mjta5f","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240103152845-1mjta5f","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"优化"}]},{"ID":"20240103152845-7axqzli","Type":"NodeParagraph","Properties":{"id":"20240103152845-7axqzli","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"强烈建议阅读官方这篇 Go 垃圾回收指南（翻译）[https://blog.leonard.wang/archives/gc-guide]"}]},{"ID":"20240103152845-38n72fu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240103152845-38n72fu","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"目标"}]},{"ID":"20240103152845-aesuig6","Type":"NodeList","ListData":{},"Properties":{"id":"20240103152845-aesuig6","updated":"20240103152845"},"Children":[{"ID":"20240103152845-mx5x7sq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152845-mx5x7sq","updated":"20240103152845"},"Children":[{"ID":"20240103152845-4rhbe5j","Type":"NodeParagraph","Properties":{"id":"20240103152845-4rhbe5j","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"降低 CPU 占用；"}]}]},{"ID":"20240103152845-7vx4sva","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152845-7vx4sva","updated":"20240103152845"},"Children":[{"ID":"20240103152845-7bobnfc","Type":"NodeParagraph","Properties":{"id":"20240103152845-7bobnfc","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"降低服务接口延时；"}]}]}]},{"ID":"20240103152845-7xp1euz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240103152845-7xp1euz","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"方向"}]},{"ID":"20240103152845-85s7pnw","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240103152845-85s7pnw","updated":"20240103152845"},"Children":[{"ID":"20240103152845-vjq59j7","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240103152845-vjq59j7","updated":"20240103152845"},"Children":[{"ID":"20240103152845-pivptq2","Type":"NodeParagraph","Properties":{"id":"20240103152845-pivptq2","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"降低 GC 频率；"}]}]},{"ID":"20240103152845-xdy55a7","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240103152845-xdy55a7","updated":"20240103152845"},"Children":[{"ID":"20240103152845-32kanm0","Type":"NodeParagraph","Properties":{"id":"20240103152845-32kanm0","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"减少堆上对象数量；"}]}]}]},{"ID":"20240103152845-gw48lpo","Type":"NodeBlockquote","Properties":{"id":"20240103152845-gw48lpo","updated":"20240103152845"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240103152845-umx5gld","Type":"NodeParagraph","Properties":{"id":"20240103152845-umx5gld","updated":"20240103152845"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"问题：为什么降低 GC 频率可以改善延迟"}]},{"ID":"20240103152845-g9thnh5","Type":"NodeParagraph","Properties":{"id":"20240103152845-g9thnh5","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"关键的一点是，降低 GC 频率也可能会改善延迟。这不仅适用于通过修改调整参数来降低 GC 频率，例如增加 GOGC 和/或内存限制，还适用于优化指南中描述的优化。"}]},{"ID":"20240103152845-qg9qzgc","Type":"NodeParagraph","Properties":{"id":"20240103152845-qg9qzgc","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"然而，理解延迟通常比理解吞吐量更复杂，因为它是程序即时执行的产物，而不仅仅是成本的聚合之物。因此，延迟和GC频率之间的联系更加脆弱，可能不那么直接。下面是一个可能导致延迟的来源列表，供那些倾向于深入研究的人使用。"}]},{"ID":"20240103152845-43lqoyx","Type":"NodeList","ListData":{},"Properties":{"id":"20240103152845-43lqoyx","updated":"20240103152845"},"Children":[{"ID":"20240103152845-a62d2tc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152845-a62d2tc","updated":"20240103152845"},"Children":[{"ID":"20240103152845-xh77lze","Type":"NodeParagraph","Properties":{"id":"20240103152845-xh77lze","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"当 GC 在标记和扫描阶段之间转换时，短暂的 stop-the-world 暂停"}]}]},{"ID":"20240103152845-s67kvxj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152845-s67kvxj","updated":"20240103152845"},"Children":[{"ID":"20240103152845-amsfk6y","Type":"NodeParagraph","Properties":{"id":"20240103152845-amsfk6y","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"调度延迟是因为 GC 在标记阶段占用了 25% 的 CPU 资源"}]}]},{"ID":"20240103152845-w1ybzkv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152845-w1ybzkv","updated":"20240103152845"},"Children":[{"ID":"20240103152845-tjfbsrt","Type":"NodeParagraph","Properties":{"id":"20240103152845-tjfbsrt","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"用户 goroutine 在高内存分配速率下的辅助标记"}]}]},{"ID":"20240103152845-7vmevyl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152845-7vmevyl","updated":"20240103152845"},"Children":[{"ID":"20240103152845-zifb8oz","Type":"NodeParagraph","Properties":{"id":"20240103152845-zifb8oz","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"当 GC 处于标记阶段时，指针写入需要额外的处理（write barrier）"}]}]},{"ID":"20240103152845-5fy6jvk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240103152845-5fy6jvk","updated":"20240103152845"},"Children":[{"ID":"20240103152845-ezt6ntw","Type":"NodeParagraph","Properties":{"id":"20240103152845-ezt6ntw","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"运行中的 goroutine 必须被暂停，以便扫描它们的根。"}]}]}]},{"ID":"20240103152845-uy5r75l","Type":"NodeParagraph","Properties":{"id":"20240103152845-uy5r75l","updated":"20240103152845"},"Children":[{"Type":"NodeText","Data":"引用自：https://blog.leonard.wang/archives/gc-guide"}]}]},{"ID":"20240110001338-z6h6e77","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240110001338-z6h6e77","updated":"20240110001345"},"Children":[{"Type":"NodeText","Data":"手段"}]},{"ID":"20240110001346-guiwb8n","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240110001346-guiwb8n","updated":"20240110001352"},"Children":[{"Type":"NodeText","Data":"sync.pool"}]},{"ID":"20240110001353-g0n48ah","Type":"NodeParagraph","Properties":{"id":"20240110001353-g0n48ah","updated":"20240110001358"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"原理："},{"Type":"NodeText","Data":" 使用 sync.pool() 缓存对象，减少堆上对象分配数；"}]},{"ID":"20240110001417-8bqbflz","Type":"NodeParagraph","Properties":{"id":"20240110001417-8bqbflz","updated":"20240110001418"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"注意："},{"Type":"NodeText","Data":" sync.pool 是全局对象，读写存在竞争问题，因此在这方面会消耗一定的 CPU，但之所以通常用它优化后 CPU 会有提升，是因为它的对象复用功能对 GC 和内存分配带来的优化，因此 sync.pool 的优化效果取决于锁竞争增加的 CPU 消耗与优化 GC 与内存分配减少的 CPU 消耗这两者的差值；"}]},{"ID":"20240110001452-mgz8hl4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240110001452-mgz8hl4","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"设置 GOGC 参数（go 1.19 之前）"}]},{"ID":"20240110001452-p8lbmwn","Type":"NodeParagraph","Properties":{"id":"20240110001452-p8lbmwn","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"原理："},{"Type":"NodeText","Data":" GOGC 默认值是 100，也就是下次 GC 触发的 heap 的大小是这次 GC 之后的 heap 的一倍，通过调大 GOGC 值（gcpercent）的方式，达到减少 GC 次数的目的；"}]},{"ID":"20240110001452-5u6hs8y","Type":"NodeBlockquote","Properties":{"id":"20240110001452-5u6hs8y","updated":"20240110001452"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240110001452-gv3qi2x","Type":"NodeParagraph","Properties":{"id":"20240110001452-gv3qi2x","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"公式：gc_trigger = heap_marked * (1+gcpercent/100)"}]},{"ID":"20240110001452-slxmbjv","Type":"NodeParagraph","Properties":{"id":"20240110001452-slxmbjv","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"heap_marked：上一个 GC 中被标记的(存活的)字节数；"}]},{"ID":"20240110001452-6nz4gfj","Type":"NodeParagraph","Properties":{"id":"20240110001452-6nz4gfj","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"gcpercent：通过 GOGC 来设置，默认是 100，也就是当前内存分配到达上次存活堆内存 2 倍时，触发 GC；"}]},{"ID":"20240110001452-t90n5s6","Type":"NodeParagraph","Properties":{"id":"20240110001452-t90n5s6","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"在 go 1.19 及之后，这个公式变为了 heap_marked + (heap_marked + GC roots) * gcpercent / 100"}]},{"ID":"20240110001452-4l7otbi","Type":"NodeParagraph","Properties":{"id":"20240110001452-4l7otbi","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"GC roots：全局变量和goroutine的栈"}]}]},{"ID":"20240110001452-mo5pag7","Type":"NodeParagraph","Properties":{"id":"20240110001452-mo5pag7","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"存在问题："},{"Type":"NodeText","Data":" GOGC 参数不易控制，设置较小提升有限，设置较大容易有 OOM 风险，因为堆大小本身是在实时变化的，在任何流量下都设置一个固定值，是一件有风险的事情。"}]},{"ID":"20240110001452-dre0a1k","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240110001452-dre0a1k","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"ballast 内存控制（go 1.19 之前）"}]},{"ID":"20240110001452-d4k02o5","Type":"NodeParagraph","Properties":{"id":"20240110001452-d4k02o5","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"原理："},{"Type":"NodeText","Data":" 仍然是从利用了下次 GC 触发的 heap 的大小是这次 GC 之后的 heap 的一倍这一原理，初始化一个生命周期贯穿整个 Go 应用生命周期的超大 slice，用于内存占位，实际操作有以下两种方式"}]},{"ID":"20240110001452-nnyw499","Type":"NodeBlockquote","Properties":{"id":"20240110001452-nnyw499","updated":"20240110001452"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240110001452-re3n2se","Type":"NodeParagraph","Properties":{"id":"20240110001452-re3n2se","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"公式：gc_trigger = heap_marked * (1+gcpercent/100)"}]},{"ID":"20240110001452-81jlxln","Type":"NodeParagraph","Properties":{"id":"20240110001452-81jlxln","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"gcpercent：通过 GOGC 来设置，默认是 100，也就是当前内存分配到达上次存活堆内存 2 倍时，触发 GC；"}]},{"ID":"20240110001452-l1em42v","Type":"NodeParagraph","Properties":{"id":"20240110001452-l1em42v","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"heap_marked：上一个 GC 中被标记的(存活的)字节数；"}]}]},{"ID":"20240110001452-gp4u7hl","Type":"NodeParagraph","Properties":{"id":"20240110001452-gp4u7hl","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"相比于设置 GOGC 的优势"}]},{"ID":"20240110001452-c77ya5w","Type":"NodeList","ListData":{},"Properties":{"id":"20240110001452-c77ya5w","updated":"20240110001452"},"Children":[{"ID":"20240110001452-av5g2iu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240110001452-av5g2iu","updated":"20240110001452"},"Children":[{"ID":"20240110001452-dp2svqt","Type":"NodeParagraph","Properties":{"id":"20240110001452-dp2svqt","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"安全性更高，OOM 风险小；"}]}]},{"ID":"20240110001452-es4dpr3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240110001452-es4dpr3","updated":"20240110001452"},"Children":[{"ID":"20240110001452-42ha2z0","Type":"NodeParagraph","Properties":{"id":"20240110001452-42ha2z0","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"效果更好，可以从 pprof 图看出，后者的优化效果更大；"}]}]}]},{"ID":"20240110001452-ik4tbp4","Type":"NodeParagraph","Properties":{"id":"20240110001452-ik4tbp4","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"负面考量"}]},{"ID":"20240110001452-m6l9dnz","Type":"NodeParagraph","Properties":{"id":"20240110001452-m6l9dnz","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"问：虽然通过大切片占位的方式可以有效降低 GC 频率，但是每次 GC 需要扫描和回收的对象数量变多了，是否会导致进行 GC 的那一段时间产生耗时毛刺？"}]},{"ID":"20240110001452-xio360c","Type":"NodeParagraph","Properties":{"id":"20240110001452-xio360c","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"答：不会，GC 有两个阶段 mark 与 sweep，unused_objects 只与 sweep 阶段有关，但这个过程是非常快速的；mark 阶段是 GC 时间占用最主要的部分，但其只与当前的 inuse_objects 有关，与 unused_objects 无太大关系；因此，综上所述，降低频率确实会让每次 GC 时的 unused_objects 有所增长，但并不会对 GC 增加太多负担；"}]},{"ID":"20240110001452-hab143m","Type":"NodeBlockquote","Properties":{"id":"20240110001452-hab143m","updated":"20240110001452"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240110001452-vd4xmjo","Type":"NodeParagraph","Properties":{"id":"20240110001452-vd4xmjo","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"关于 ballast 内存控制更详细的内容：https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/"}]}]},{"ID":"20240110001452-6k03rrv","Type":"NodeParagraph","Properties":{"id":"20240110001452-6k03rrv","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"以上三种优化操作的相关实践："},{"Type":"NodeText","Data":" Go 语言-计算密集型服务 性能优化[https://segmentfault.com/a/1190000041602269]"}]},{"ID":"20240110001452-jkac5rh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240110001452-jkac5rh","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"GCTuner（go 1.19 之前）"}]},{"ID":"20240110001452-myvm17u","Type":"NodeParagraph","Properties":{"id":"20240110001452-myvm17u","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"原理："},{"Type":"NodeText","Data":" https://eng.uber.com/how-we-saved-70k-cores-across-30-mission-critical-services/"}]},{"ID":"20240110001452-wdxbv7j","Type":"NodeParagraph","Properties":{"id":"20240110001452-wdxbv7j","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实现："},{"Type":"NodeText","Data":" https://github.com/bytedance/gopkg/tree/develop/util/gctuner"}]},{"ID":"20240110001452-7qqwljp","Type":"NodeParagraph","Properties":{"id":"20240110001452-7qqwljp","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"简述："},{"Type":"NodeText","Data":" 同上文讲到的设置 GOGC 参数的思路相同，但增加了自动调整的设计，而非在程序初始设置一个固定值，可以有效避免高峰期的 OOM 问题。"}]},{"ID":"20240110001452-ebjvqar","Type":"NodeParagraph","Properties":{"id":"20240110001452-ebjvqar","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"优点："},{"Type":"NodeText","Data":" 不需要修改 GO 源码，通用性较强；"}]},{"ID":"20240110001452-ez14isd","Type":"NodeParagraph","Properties":{"id":"20240110001452-ez14isd","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺点："},{"Type":"NodeText","Data":"对内存的控制不够精准。"}]},{"ID":"20240110001452-cbrux16","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240110001452-cbrux16","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"GO SetMemoryLimit（go 1.19 及之后）"}]},{"ID":"20240110001452-fm9sh2x","Type":"NodeParagraph","Properties":{"id":"20240110001452-fm9sh2x","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"原理："},{"Type":"NodeText","Data":" https://github.com/golang/proposal/blob/master/design/48409-soft-memory-limit.md"}]},{"ID":"20240110001452-aqeki39","Type":"NodeParagraph","Properties":{"id":"20240110001452-aqeki39","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"简述："}]},{"ID":"20240110001452-582w05o","Type":"NodeBlockquote","Properties":{"id":"20240110001452-582w05o","updated":"20240110001452"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240110001452-t945qfi","Type":"NodeParagraph","Properties":{"id":"20240110001452-t945qfi","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"通过对 Go 使用的内存总量设置软内存限制来调整 Go 垃圾收集器的行为。此选项有两种形式：runtime/debug调用的新函数SetMemoryLimit和GOMEMLIMIT环境变量。总之，运行时将尝试通过限制堆的大小并通过更积极地将内存返回给底层平台来维持此内存限制。这包括一种有助于减轻垃圾收集死循环的机制。最后，通过设置GOGC=off，Go 运行时将始终将堆增长到满内存限制。这个新选项使应用程序可以更好地控制其资源经济性。它使用户能够："}]},{"ID":"20240110001452-hdm7x34","Type":"NodeList","ListData":{},"Properties":{"id":"20240110001452-hdm7x34","updated":"20240110001452"},"Children":[{"ID":"20240110001452-3gjq5wx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240110001452-3gjq5wx","updated":"20240110001452"},"Children":[{"ID":"20240110001452-t82i1n9","Type":"NodeParagraph","Properties":{"id":"20240110001452-t82i1n9","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"更好地利用他们已经拥有的内存；"}]}]},{"ID":"20240110001452-9wz9n8b","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240110001452-9wz9n8b","updated":"20240110001452"},"Children":[{"ID":"20240110001452-xk53083","Type":"NodeParagraph","Properties":{"id":"20240110001452-xk53083","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"自信地降低他们的内存限制，知道 Go 会遵守他们；"}]}]},{"ID":"20240110001452-b4hdcyq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240110001452-b4hdcyq","updated":"20240110001452"},"Children":[{"ID":"20240110001452-c0w1fek","Type":"NodeParagraph","Properties":{"id":"20240110001452-c0w1fek","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"避免使用不受支持的 GC 调整方式；"}]}]}]}]},{"ID":"20240110001452-u6a68e3","Type":"NodeParagraph","Properties":{"id":"20240110001452-u6a68e3","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"效果测试"},{"Type":"NodeText","Data":"：https://colobu.com/2022/06/20/how-to-use-SetMemoryLimit/"}]},{"ID":"20240110001452-hxjpsuh","Type":"NodeParagraph","Properties":{"id":"20240110001452-hxjpsuh","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"其他："}]},{"ID":"20240110001452-ah98zn2","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240110001452-ah98zn2","updated":"20240110001452"},"Children":[{"ID":"20240110001452-4kfcida","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240110001452-4kfcida","updated":"20240110001452"},"Children":[{"ID":"20240110001452-bimchh5","Type":"NodeParagraph","Properties":{"id":"20240110001452-bimchh5","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"与 GCTuner 的区别：a. 两者都是通过调节 heapgoal 和 gctrigger 的值（GC 触发阈值），达到影响 GC 触发时机的目的；b. GCTuner 对于 heapgoal 值的调整，依赖 SetFinalizer 的执行时机，在执行时通过设置 GOGC 参数间接调整的，在每个 GC 周期时最多调整一次；而 SetMemoryLimit 是一直在实时动态调整的，在每次检查是否需要触发GC的时候重新算的，不仅是每一轮 GC 完时决定，因此对于内存的控制更加精准。"}]}]},{"ID":"20240110001452-ce0jjj1","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240110001452-ce0jjj1","updated":"20240110001452"},"Children":[{"ID":"20240110001452-gxus9pq","Type":"NodeParagraph","Properties":{"id":"20240110001452-gxus9pq","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"对内存的控制非常精准，可以关注到所有由 runtime 管理的内存，包括全局 Data 段、BSS 段所占用的内存；goroutine 栈的内存；被GC管理的内存；非 GC 管理的内存，如 trace、GC 管理所需的 mspan 等数据结构；缓存在 Go Heap 中没有被使用，也暂时未归还操作系统的内存；"}]}]},{"ID":"20240110001452-5fmv7wt","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240110001452-5fmv7wt","updated":"20240110001452"},"Children":[{"ID":"20240110001452-c00n32s","Type":"NodeParagraph","Properties":{"id":"20240110001452-c00n32s","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"一般配合 GOGC = off 一起使用，可以达到最好的效果。"}]}]}]},{"ID":"20240110001452-den2qel","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240110001452-den2qel","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"Bigcache"}]},{"ID":"20240110001452-ttbbess","Type":"NodeParagraph","Properties":{"id":"20240110001452-ttbbess","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"原理："},{"Type":"NodeText","Data":" https://colobu.com/2019/11/18/how-is-the-bigcache-is-fast/"}]},{"ID":"20240110001452-mo7hiyf","Type":"NodeParagraph","Properties":{"id":"20240110001452-mo7hiyf","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"会在内存中分配大数组用以达到 0 GC 的目的，并使用 map[int]int，维护对对象的引用；"}]},{"ID":"20240110001452-3yoyqqm","Type":"NodeBlockquote","Properties":{"id":"20240110001452-3yoyqqm","updated":"20240110001452"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240110001452-2fjcm43","Type":"NodeParagraph","Properties":{"id":"20240110001452-2fjcm43","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"当 map 中的 key 和 value 都是基础类型时，GC 就不会扫到 map 里的 key 和 value"}]}]},{"ID":"20240110001452-0fsfjqv","Type":"NodeParagraph","Properties":{"id":"20240110001452-0fsfjqv","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"图片"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR8QS8Sz0QV86dibz0Q9qIjY5cVyKBtzMzympEBL902HqiaZL3Rznhdq7fxGoaI0gGcNaJd9FeNl6A/640?wx_fmt=png\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1"},{"Type":"NodeCloseParen"}]},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"存在问题："},{"Type":"NodeText","Data":" 由于大数组的存在，会起到同 ballast 内存控制手段的效果，一定程度上会影响到 GC 频率；"}]},{"ID":"20240110001452-jiku2md","Type":"NodeParagraph","Properties":{"id":"20240110001452-jiku2md","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"相关实践："},{"Type":"NodeText","Data":" IO 密集型服务 耗时优化[https://segmentfault.com/a/1190000041637173]"}]},{"ID":"20240110001452-cf8wcky","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240110001452-cf8wcky","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"fastcache"}]},{"ID":"20240110001452-clhsdkn","Type":"NodeParagraph","Properties":{"id":"20240110001452-clhsdkn","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"与 bigcache 类似，但使用 syscall.mmap 申请堆外内存，避免了像 bigcache 影响 GC 的问题；"}]},{"ID":"20240110001452-eua51gh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240110001452-eua51gh","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"堆外分配"}]},{"ID":"20240110001452-0pa2918","Type":"NodeParagraph","Properties":{"id":"20240110001452-0pa2918","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"绕过 Go runtime 直接分配内存，使 runtime 感知不到此块内存，从而不增加 GC 开销。"}]},{"ID":"20240110001452-l5curnh","Type":"NodeList","ListData":{},"Properties":{"id":"20240110001452-l5curnh","updated":"20240110001452"},"Children":[{"ID":"20240110001452-q78y1i2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240110001452-q78y1i2","updated":"20240110001452"},"Children":[{"ID":"20240110001452-mwrg44u","Type":"NodeParagraph","Properties":{"id":"20240110001452-mwrg44u","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"fastcache：直接调用 syscall.mmap 申请堆外内存使用；"}]}]},{"ID":"20240110001452-77y6s9f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240110001452-77y6s9f","updated":"20240110001452"},"Children":[{"ID":"20240110001452-5k3jmtn","Type":"NodeParagraph","Properties":{"id":"20240110001452-5k3jmtn","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"offheap：使用 cgo 管理堆外内存；"}]}]}]},{"ID":"20240110001452-oixtahu","Type":"NodeParagraph","Properties":{"id":"20240110001452-oixtahu","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"问题：管理成本高，灵活性低；"}]},{"ID":"20240110001452-8sekuim","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240110001452-8sekuim","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"GAB（Goroutine allocation buffer）"}]},{"ID":"20240110001452-1621wkk","Type":"NodeParagraph","Properties":{"id":"20240110001452-1621wkk","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"优化对象分配效率，并减少 GC 扫描的工作量。"}]},{"ID":"20240110001452-guvmjir","Type":"NodeBlockquote","Properties":{"id":"20240110001452-guvmjir","updated":"20240110001452"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240110001452-9t0re23","Type":"NodeParagraph","Properties":{"id":"20240110001452-9t0re23","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"经过调研发现，很多微服务进行内存分配时，分配的对象大部分都是比较小的对象。基于这个观测，我们设计了 GAB（Goroutine allocation buffer）机制，用来优化小对象内存分配。Go 的内存分配用的是 tcmalloc 算法，传统的 tcmalloc，会为每个分配请求执行一个比较完整的 malloc GC 方法，而我们的 Gab 为每个 Goroutine 预先分配一个比较大的 buffer，然后使用 bump-pointer 的方式，为适合放进 Gab 里的小对象来进行快速分配。我们算法和 tcmalloc 算法完全兼容，而且它的分配操作可以随意被 Stop the world 打断。虽然我们的 Gab 优化可能会造成一些空间浪费，但是在很多微服务上测试后，发现 CPU 性能大概节省了 5% 到 12%。"}]},{"ID":"20240110001452-2bv1wlz","Type":"NodeParagraph","Properties":{"id":"20240110001452-2bv1wlz","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"引用自：https://mp.weixin.qq.com/s/0X4lasAf5Sbt_tromlqwIQ"}]}]},{"ID":"20240110001452-clmpldh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240110001452-clmpldh","updated":"20240110001452"},"Children":[{"Type":"NodeText","Data":"Go1.20 arena"}]},{"ID":"20240110001452-ku549q6","Type":"NodeParagraph","Properties":{"id":"20240110001452-ku549q6","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"官方文档："},{"Type":"NodeText","Data":" https://github.com/golang/go/issues/51317"}]},{"ID":"20240110001452-9y9flp6","Type":"NodeParagraph","Properties":{"id":"20240110001452-9y9flp6","updated":"20240110001452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"简述："},{"Type":"NodeText","Data":" 可以经由 runtime 申请内存，但由用户手动管理此块堆内存。因为是经由 runtime 申请的，可以被 runtime 感知到，因此可以纳入 GC 触发条件中的内存计算里，有效降低 OOM 风险。"}]}]}