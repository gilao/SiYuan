{"ID":"20240226142124-0talgvv","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f999","id":"20240226142124-0talgvv","title":"Go map 加有序排序的一些挣扎","updated":"20240226144031"},"Children":[{"ID":"20240226142145-s1667xi","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226142145-s1667xi","updated":"20240226142209"},"Children":[{"Type":"NodeText","Data":"快速背景"}]},{"ID":"20240226142210-ilpjkt0","Type":"NodeParagraph","Properties":{"id":"20240226142210-ilpjkt0","updated":"20240226142210"},"Children":[{"Type":"NodeText","Data":"Go 提供了一种内置的 map 类型，它实现了一个哈希表，在 Go 程序中普遍应用广泛，能够做一系列的增删改查。"}]},{"ID":"20240226142222-1e4a0fb","Type":"NodeParagraph","Properties":{"id":"20240226142222-1e4a0fb","updated":"20240226142229"},"Children":[{"Type":"NodeText","Data":"类型签名如下："}]},{"ID":"20240226142229-7gzm99p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226142229-7gzm99p","updated":"20240226142332"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"map[KeyType]ValueType\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226142334-mkwdbnr","Type":"NodeParagraph","Properties":{"id":"20240226142334-mkwdbnr","updated":"20240226142347"},"Children":[{"Type":"NodeText","Data":"最小演示代码："}]},{"ID":"20240226142347-k71b3ur","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226142347-k71b3ur","updated":"20240226142354"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n m := make(map[int32]string)\n m[0] = \"煎鱼1\"\n m[1] = \"煎鱼2\"\n m[2] = \"煎鱼3\"\n m[3] = \"煎鱼4\"\n m[4] = \"煎鱼5\"\n m[5] = \"煎鱼6\"\n for k, v := range m {\n  log.Printf(\"k: %v, v: %v\", k, v)\n }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226142357-8ma7r6w","Type":"NodeParagraph","Properties":{"id":"20240226142357-8ma7r6w","updated":"20240226142400"},"Children":[{"Type":"NodeText","Data":"输出结果："}]},{"ID":"20240226142400-69g6mhu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226142400-69g6mhu","updated":"20240226142406"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"$ go run demo.go\n2023/12/28 23:36:02 k: 2, v: 煎鱼3\n2023/12/28 23:36:02 k: 3, v: 煎鱼4\n2023/12/28 23:36:02 k: 4, v: 煎鱼5\n2023/12/28 23:36:02 k: 5, v: 煎鱼6\n2023/12/28 23:36:02 k: 0, v: 煎鱼1\n2023/12/28 23:36:02 k: 1, v: 煎鱼2\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226142407-lw9n7ih","Type":"NodeParagraph","Properties":{"id":"20240226142407-lw9n7ih","updated":"20240226142411"},"Children":[{"Type":"NodeText","Data":"输出结果看着没有什么问题。但细心查看的同学应该发现了。在"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"遍历 map 类型时，访问结果是无序的"},{"Type":"NodeText","Data":"。明显多执行几次就会发现与我们声明的顺序不一致。"}]},{"ID":"20240226142426-ovly4ao","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240226142426-ovly4ao","updated":"20240226142426"},"Children":[{"Type":"NodeText","Data":"社区讨论"}]},{"ID":"20240226142426-vf3yyk6","Type":"NodeParagraph","Properties":{"id":"20240226142426-vf3yyk6","updated":"20240226142427"},"Children":[{"Type":"NodeText","Data":"这可不。这么尴尬的无序结果。对于初学者而言很容易导致潜在的 BUG，引发一些问题/事故。"}]},{"ID":"20240226142426-lx1ufdt","Type":"NodeParagraph","Properties":{"id":"20240226142426-lx1ufdt","updated":"20240226142427"},"Children":[{"Type":"NodeText","Data":"大家为此做出过努力。提出过各种提案。例如："}]},{"ID":"20240226142426-gnza1ox","Type":"NodeList","ListData":{},"Properties":{"id":"20240226142426-gnza1ox","updated":"20240226142427"},"Children":[{"ID":"20240226142426-fk4jllm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226142426-fk4jllm","updated":"20240226142426"},"Children":[{"ID":"20240226142426-m3lb31r","Type":"NodeParagraph","Properties":{"id":"20240226142426-m3lb31r","updated":"20240226142426"},"Children":[{"Type":"NodeText","Data":"《proposal: Go 2: add native type for map that maintains key order"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[1]"},{"Type":"NodeText","Data":"》"}]}]},{"ID":"20240226142426-g6a83vc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226142426-g6a83vc","updated":"20240226142426"},"Children":[{"ID":"20240226142426-98am0jp","Type":"NodeParagraph","Properties":{"id":"20240226142426-98am0jp","updated":"20240226142426"},"Children":[{"Type":"NodeText","Data":"《proposal: add string key sorted map as built in type"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[2]"},{"Type":"NodeText","Data":"》"}]}]},{"ID":"20240226142426-ppegsi3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226142426-ppegsi3","updated":"20240226142426"},"Children":[{"ID":"20240226142426-7lve37v","Type":"NodeParagraph","Properties":{"id":"20240226142426-7lve37v","updated":"20240226142426"},"Children":[{"Type":"NodeText","Data":"《proposal: Add a sorting function for map"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[3]"},{"Type":"NodeText","Data":"》"}]}]}]},{"ID":"20240226142426-vu2qucy","Type":"NodeParagraph","Properties":{"id":"20240226142426-vu2qucy","updated":"20240226142427"},"Children":[{"Type":"NodeText","Data":"基于这些提案，也有人提出了新的关键字 sortedMap："}]},{"ID":"20240226142426-wapc6ek","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226142426-wapc6ek","updated":"20240226142427"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type User struct{\n   UserId string\n   Name string\n}\n\nfunc main(){\n  db := sortedMap[string]*User{}\n  db[\"煎鱼2\"] = \u0026User{UserId:\"煎鱼2\",Name:\"n2\"}\n  db[\"煎鱼1\"] = \u0026User{UserId:\"煎鱼1\",Name:\"n1\"}\n  for userId, user := range db {\n    fmt.Println(userId, user.Name)\n  }\n\n  // should output\n  // 煎鱼1 n1\n  // 煎鱼2 n2\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226142426-so9pvtb","Type":"NodeParagraph","Properties":{"id":"20240226142426-so9pvtb","updated":"20240226142427"},"Children":[{"Type":"NodeText","Data":"但最终都失败告终。原因不外乎以下几类原因："}]},{"ID":"20240226142426-24cts53","Type":"NodeList","ListData":{},"Properties":{"id":"20240226142426-24cts53","updated":"20240226142427"},"Children":[{"ID":"20240226142426-nunkbt5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226142426-nunkbt5","updated":"20240226142426"},"Children":[{"ID":"20240226142426-thtqf6u","Type":"NodeParagraph","Properties":{"id":"20240226142426-thtqf6u","updated":"20240226142426"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Go1 兼容性保障规范"},{"Type":"NodeText","Data":"：对 map 类型从无序改到有序，必然会存在破坏性变更。这活现在干不了。以后未来的 Go2 再说吧（拖字诀）。"}]}]},{"ID":"20240226142426-z5lugvy","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226142426-z5lugvy","updated":"20240226142426"},"Children":[{"ID":"20240226142426-atsge6l","Type":"NodeParagraph","Properties":{"id":"20240226142426-atsge6l","updated":"20240226142426"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"排序后 map 的速度慢"},{"Type":"NodeText","Data":"：如果将默认映射类型改为排序映射，那么不需要排序映射实现或已编写代码在需要时对键进行排序的人都会受到惩罚。（via @Dave Cheney）"}]}]},{"ID":"20240226142426-rww5h0v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226142426-rww5h0v","updated":"20240226142426"},"Children":[{"ID":"20240226142426-sqxbe6h","Type":"NodeParagraph","Properties":{"id":"20240226142426-sqxbe6h","updated":"20240226142426"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实现稳定排序的 map 麻烦"},{"Type":"NodeText","Data":"：Go 在标准库 fmt 里实现了稳定排序的 map 输出，整体实现较为难以解决。言外之意不建议将稳定排序加入 map 类型的支持内。（via @Rob Pike）"}]}]}]},{"ID":"20240226144008-qnbptb1","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240226144008-qnbptb1","updated":"20240226144008"},"Children":[{"Type":"NodeText","Data":"参考实现"}]},{"ID":"20240226144008-belseqf","Type":"NodeParagraph","Properties":{"id":"20240226144008-belseqf","updated":"20240226144009"},"Children":[{"Type":"NodeText","Data":"Go 核心团队推荐查看："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"https://github.com/golang/go/blob/master/src/internal/fmtsort/sort.go"},{"Type":"NodeText","Data":"​ 的实现逻辑。如果要对 map 类型做稳定排序。要做一样的事情，甚至更多。"}]},{"ID":"20240226144008-x3el4ta","Type":"NodeParagraph","Properties":{"id":"20240226144008-x3el4ta","updated":"20240226144009"},"Children":[{"Type":"NodeText","Data":"说白了，就是要做大小对比、顺序排序。还要适配所有的类型。"}]},{"ID":"20240226144008-cn18w6n","Type":"NodeParagraph","Properties":{"id":"20240226144008-cn18w6n","updated":"20240226144008"},"Children":[{"Type":"NodeText","Data":"对应源代码的其中一角："}]},{"ID":"20240226144010-qi5sjat","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226144010-qi5sjat","updated":"20240226144019"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type SortedMap struct {\n Key   []reflect.Value\n Value []reflect.Value\n}\n\nfunc (o *SortedMap) Len() int           { return len(o.Key) }\nfunc (o *SortedMap) Less(i, j int) bool { return compare(o.Key[i], o.Key[j]) \u003c 0 }\nfunc (o *SortedMap) Swap(i, j int) {\n o.Key[i], o.Key[j] = o.Key[j], o.Key[i]\n o.Value[i], o.Value[j] = o.Value[j], o.Value[i]\n}\n\nfunc Sort(mapValue reflect.Value) *SortedMap {\n if mapValue.Type().Kind() != reflect.Map {\n  return nil\n }\n\n n := mapValue.Len()\n key := make([]reflect.Value, 0, n)\n value := make([]reflect.Value, 0, n)\n iter := mapValue.MapRange()\n for iter.Next() {\n  key = append(key, iter.Key())\n  value = append(value, iter.Value())\n }\n sorted := \u0026SortedMap{\n  Key:   key,\n  Value: value,\n }\n sort.Stable(sorted)\n return sorted\n}\n\nfunc compare(aVal, bVal reflect.Value) int {\n aType, bType := aVal.Type(), bVal.Type()\n if aType != bType {\n  return -1 // No good answer possible, but don't return 0: they're not equal.\n }\n switch aVal.Kind() {\n case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n  a, b := aVal.Int(), bVal.Int()\n  switch {\n  case a \u003c b:\n   return -1\n  case a \u003e b:\n   return 1\n  default:\n   return 0\n  }\n case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\n  ...\n\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226144020-xxz9iyc","Type":"NodeParagraph","Properties":{"id":"20240226144020-xxz9iyc","updated":"20240226144025"},"Children":[{"Type":"NodeText","Data":"如果只是标准库 fmt 输出流用到，常规的实现就行。但如果内置到 map 类型中，就还要考量性能、开销、可维护性的综合因素。折腾起来也是不太妙的，会引入不少的复杂度。"}]},{"ID":"20240226144031-7lg9rob","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240226144031-7lg9rob","updated":"20240226144031"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20240226144031-koobyhq","Type":"NodeParagraph","Properties":{"id":"20240226144031-koobyhq","updated":"20240226144031"},"Children":[{"Type":"NodeText","Data":"虽然社区很多人提过很多种不同的建议。但，显然，Go 核心团队不是无法实现一个带稳定排序的 map 类型。"}]},{"ID":"20240226144031-0wfbml0","Type":"NodeParagraph","Properties":{"id":"20240226144031-0wfbml0","updated":"20240226144031"},"Children":[{"Type":"NodeText","Data":"为此在实现上要付出较高的改造代价和性能、开销风险。外加 less is more 的设计哲学。导致此项功能特性一直停滞不前。"}]},{"ID":"20240226144031-lvr3vqz","Type":"NodeParagraph","Properties":{"id":"20240226144031-lvr3vqz","updated":"20240226144031"},"Children":[{"Type":"NodeText","Data":"这个大背景下，大家也慢慢还是选择了第三条路。使用第三方库，或者配合 slice 来做，要不就是基于近年的泛型来实现了。"}]}]}