{"ID":"20230724000542-k4y78jh","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f397","id":"20230724000542-k4y78jh","tags":"Grpc,Grpc 原理","title":"Go 内置RPC原理","updated":"20230724000729"},"Children":[{"ID":"20230724000609-db4p659","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724000609-db4p659","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"Demo"}]},{"ID":"20230724000609-5orm7ba","Type":"NodeParagraph","Properties":{"id":"20230724000609-5orm7ba","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"**Demo 是参考 Go 源码 **"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"src/net/rpc/server.go"},{"Type":"NodeText","Data":"​，做出了一丢丢的修改。"}]},{"ID":"20230724000609-gacpxmy","Type":"NodeList","ListData":{},"Properties":{"id":"20230724000609-gacpxmy","updated":"20230724000609"},"Children":[{"ID":"20230724000609-i66xga9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-i66xga9","updated":"20230724000609"},"Children":[{"ID":"20230724000609-iyk5ir3","Type":"NodeParagraph","Properties":{"id":"20230724000609-iyk5ir3","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"首先定义请求的入参和出餐；"}]}]}]},{"ID":"20230724000609-8zudld5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-8zudld5","updated":"20230724000723"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package common\n\ntype Args struct {\n    A,B int\n}\n\ntype Quotient struct {\n    Quo,Rem int\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-6a9j44x","Type":"NodeParagraph","Properties":{"id":"20230724000609-6a9j44x","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"接着在定义一个对象，并给这个对象写两个方法"}]},{"ID":"20230724000609-7qqwq3j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-7qqwq3j","updated":"20230724000721"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Arith struct{}\n\nfunc (t *Arith) Multiply(args *Args, reply *int) error {\n    *reply = args.A * args.B\n    return nil\n}\n\nfunc (t *Arith) Divide(args *Args, quo *Quotient) error {\n    if args.B == 0 {\n        return errors.New(\"divide by zero\")\n    }\n    quo.Quo = args.A / args.B\n    quo.Rem = args.A % args.B\n    return nil\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-6z9nnev","Type":"NodeParagraph","Properties":{"id":"20230724000609-6z9nnev","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"然后起一个RPC Server："}]},{"ID":"20230724000609-tv7kktn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-tv7kktn","updated":"20230724000719"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    arith := new(Arith)\n    err := rpc.Register(arith)\n    if err != nil {\n        return\n    }\n    rpc.HandleHTTP()\n    l, e := net.Listen(\"tcp\", \":9876\")\n    if e != nil {\n        panic(e)\n    }\n\n    go func() {\n        err = http.Serve(l, nil)\n        if err != nil {\n\n        }\n    }()\n\n    var wg sync.WaitGroup\n    wg.Add(1)\n    wg.Wait()\n\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-nwa3tby","Type":"NodeParagraph","Properties":{"id":"20230724000609-nwa3tby","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"最后初始化 RPC Client，并发起调用"}]},{"ID":"20230724000609-x0mjrmn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-x0mjrmn","updated":"20230724000715"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Args struct {\n    A, B int\n}\n\ntype Quotient struct {\n    Quo, Rem int\n}\n\nfunc main() {\n    client, err := rpc.DialHTTP(\"tcp\", \"127.0.0.1:9876\")\n    if err != nil {\n        panic(err)\n    }\n\n    args := Args{A: 7, B: 8}\n    var reply int\n    // 同步调用\n    err = client.Call(\"Arith.Multiply\", \u0026args, \u0026reply)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Printf(\"Call Arith: %d * %d = %d\\n\", args.A, args.B, reply)\n\n    // 异步调用\n    quotient := new(Quotient)\n    divCall := client.Go(\"Arith.Divide\", args, quotient, nil)\n    replyCall := \u003c-divCall.Done\n\n    fmt.Printf(\"Go Divide: %d divide %d = %+v %+v\\n\", args.A, args.B, replyCall.Reply, quotient)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-awnay1m","Type":"NodeParagraph","Properties":{"id":"20230724000609-awnay1m","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RPC 调用成功"}]},{"ID":"20230724000609-f9d1ehn","Type":"NodeParagraph","Properties":{"id":"20230724000609-f9d1ehn","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image-20230721155334594"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file://E:\\Typora%20picture\\image-20230721155334594.png?lastModify=1690128365"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230724000609-dmqraaq","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724000609-dmqraaq","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"这 RPC 吗"}]},{"ID":"20230724000609-f9gu21p","Type":"NodeParagraph","Properties":{"id":"20230724000609-f9gu21p","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RPC 是 Remote Procedure Call 的缩写，一般翻译为远程调用，"}]},{"ID":"20230724000609-5fqbxrn","Type":"NodeParagraph","Properties":{"id":"20230724000609-5fqbxrn","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"一般来说 RPC 框架存在的意义是让你****调用远程方法像调用本地方法一样方便"},{"Type":"NodeText","Data":"，也就是将复杂的编解码、通信过程都封装起来，让代码写起来更简单。"}]},{"ID":"20230724000609-ps9b1s1","Type":"NodeParagraph","Properties":{"id":"20230724000609-ps9b1s1","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"既然有 Http，为什么还要有 RPC？如果你理解 RPC，我相信你不会问出这样的问题，他们是两个维度的东西，RPC 关注的是远程调用的封装，Http 是一种协议，RPC 没有规定通信协议，RPC 也可以使用 Http，这不矛盾。这种问法就好像在问既然有了苹果手机，为什么还要有中国移动？"}]},{"ID":"20230724000609-4nshqv4","Type":"NodeParagraph","Properties":{"id":"20230724000609-4nshqv4","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"扯远了，我们回头看一下上述的例子是否符合我们对 RPC 的定义。"}]},{"ID":"20230724000609-25k2z3f","Type":"NodeList","ListData":{},"Properties":{"id":"20230724000609-25k2z3f","updated":"20230724000609"},"Children":[{"ID":"20230724000609-nqc1uy5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-nqc1uy5","updated":"20230724000609"},"Children":[{"ID":"20230724000609-l3lpatk","Type":"NodeParagraph","Properties":{"id":"20230724000609-l3lpatk","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"首先是远程调用，我们是开了一个 Server，监听了9876端口，然后 Client 与之通信，将这两个程序部署在两台机器上，只要网络是通的，照样可以正常工作"}]}]},{"ID":"20230724000609-4m0zy7h","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-4m0zy7h","updated":"20230724000609"},"Children":[{"ID":"20230724000609-xcbf44v","Type":"NodeParagraph","Properties":{"id":"20230724000609-xcbf44v","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"其次它符合****调用远程方法像调用本地方法一样方便"},{"Type":"NodeText","Data":"，代码中没有处理编解码，也没有处理通信，只不过方法名以参数的形式传入，和一般的 RPC 稍有不同，倒是很像 Dubbo 的泛化调用"}]}]}]},{"ID":"20230724000609-dwdpdq5","Type":"NodeParagraph","Properties":{"id":"20230724000609-dwdpdq5","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"综上两点，这很 RPC。"}]},{"ID":"20230724000609-4ajacoq","Type":"NodeParagraph","Properties":{"id":"20230724000609-4ajacoq","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"下面我将用两段内容分别剖析 Go 内置的 RPC Server 与 Client 的原理，来看看 Go 是如何实现一个 RPC 的。"}]},{"ID":"20230724000609-titj9zn","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724000609-titj9zn","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"RPC Server原理"}]},{"ID":"20230724000609-3k92gyt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724000609-3k92gyt","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"注册服务"}]},{"ID":"20230724000609-iq1w7bl","Type":"NodeParagraph","Properties":{"id":"20230724000609-iq1w7bl","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"**这里的服务指的是一个具有公开方法的对象，比如上面 Demo 中的 **"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Arith"},{"Type":"NodeText","Data":"​，只需要调用 Register 就能注册"}]},{"ID":"20230724000609-nfycv2m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-nfycv2m","updated":"20230724000707"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"rpc.Register(arith)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-27xc0br","Type":"NodeParagraph","Properties":{"id":"20230724000609-27xc0br","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"注册完成了一下动作："}]},{"ID":"20230724000609-nrzbic1","Type":"NodeList","ListData":{},"Properties":{"id":"20230724000609-nrzbic1","updated":"20230724000609"},"Children":[{"ID":"20230724000609-tgzkc6u","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-tgzkc6u","updated":"20230724000609"},"Children":[{"ID":"20230724000609-sokhrkl","Type":"NodeParagraph","Properties":{"id":"20230724000609-sokhrkl","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"利用反射获取这个对象的类型、类名、值、以及公开方法"}]}]},{"ID":"20230724000609-3ik1n8l","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-3ik1n8l","updated":"20230724000609"},"Children":[{"ID":"20230724000609-kcyjj6j","Type":"NodeParagraph","Properties":{"id":"20230724000609-kcyjj6j","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"**将其包装为 service 对象，并存在 server的 serviceMap 中，serviceMap的key默认为类名，比如这里是 Arith，也可以调用另一个注册方法 **"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RegisterName"},{"Type":"NodeText","Data":"​来自定义名称"}]}]}]},{"ID":"20230724000609-draygqn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724000609-draygqn","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"注册 Http Handle"}]},{"ID":"20230724000609-t8gu361","Type":"NodeParagraph","Properties":{"id":"20230724000609-t8gu361","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这里你可能会问，为啥 RPC 要注册 Http Handle。没错，Go 内置的 RPC 通信是基于 Http 协议的，所以需要注册。只需要一行代码："}]},{"ID":"20230724000609-8f85mjd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-8f85mjd","updated":"20230724000704"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"rpc.HandleHTTP()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-spoxn5t","Type":"NodeParagraph","Properties":{"id":"20230724000609-spoxn5t","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"它调用的是 Http 的 Handle 方法，也就是 HandleFunc 的底层实现，这块如果不清楚，可以看之前的文章"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=MzI5NjE2MDQwNg==\u0026amp;mid=2247488101\u0026amp;idx=1\u0026amp;sn=ba4888e87883db7c19e7b92dcc06f966\u0026amp;scene=21#wechat_redirect","TextMarkTextContent":"《一文读懂 Go Http Server 原理》"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230724000609-inve10x","Type":"NodeParagraph","Properties":{"id":"20230724000609-inve10x","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"它注册了两个特殊的 Path："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"/_goRPC_"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"/debug/rpc"},{"Type":"NodeText","Data":"​，其中有一个是 Debug 专用，当然也可以自定义。"}]},{"ID":"20230724000609-kjce6ur","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724000609-kjce6ur","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"逻辑处理"}]},{"ID":"20230724000609-e1wsv77","Type":"NodeParagraph","Properties":{"id":"20230724000609-e1wsv77","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"注册时传入了RPC 的Server 对象，这个对象必须实现 Handler 的ServeHTTP 接口，也就是处理逻辑的入口在这个 ServeHTTP中："}]},{"ID":"20230724000609-bvgh7hd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-bvgh7hd","updated":"20230724000700"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Handler interface {\n    ServeHTTP(ResponseWriter,*Request)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-9kjub4g","Type":"NodeParagraph","Properties":{"id":"20230724000609-9kjub4g","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"我们看 RPC Server 是如何实现这个接口的："}]},{"ID":"20230724000609-mxy5ekp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-mxy5ekp","updated":"20230724000657"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// ServeHTTP implements an http.Handler that answers RPC requests.\nfunc (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n // ①\n  if req.Method != \"CONNECT\" {\n  w.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n  w.WriteHeader(http.StatusMethodNotAllowed)\n  io.WriteString(w, \"405 must CONNECT\\n\")\n  return\n }\n  // ②\n conn, _, err := w.(http.Hijacker).Hijack()\n if err != nil {\n  log.Print(\"rpc hijacking \", req.RemoteAddr, \": \", err.Error())\n  return\n }\n  // ③\n io.WriteString(conn, \"HTTP/1.0 \"+connected+\"\\n\\n\")\n // ④\n server.ServeConn(conn)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-k7u71tg","Type":"NodeParagraph","Properties":{"id":"20230724000609-k7u71tg","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"我对这段代码标了号，逐一看："}]},{"ID":"20230724000609-pzs2vt4","Type":"NodeList","ListData":{},"Properties":{"id":"20230724000609-pzs2vt4","updated":"20230724000609"},"Children":[{"ID":"20230724000609-i59x363","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-i59x363","updated":"20230724000609"},"Children":[{"ID":"20230724000609-p2zcnxp","Type":"NodeParagraph","Properties":{"id":"20230724000609-p2zcnxp","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"①：限制了请求的 Method 必须是 CONNECT，如果不是则直接返回错误，这么做是为什么？看下 Method 字段的注释就恍然大悟：Go 的 Http Client 是发不出 CONNECT 的请求，也就是 RPC 的 Server 是没办法通过 Go 的 Http Client 访问，限制必须得使用 RPC Client"}]}]}]},{"ID":"20230724000609-vyr1t0o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-vyr1t0o","updated":"20230724000654"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Request struct {\n // Method specifies the HTTP method (GET, POST, PUT, etc.).\n // For client requests, an empty string means GET.\n //\n // Go's HTTP client does not support sending a request with\n // the CONNECT method. See the documentation on Transport for\n // details.\n Method string\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-yi993zr","Type":"NodeList","ListData":{},"Properties":{"id":"20230724000609-yi993zr","updated":"20230724000609"},"Children":[{"ID":"20230724000609-ic90phc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-ic90phc","updated":"20230724000609"},"Children":[{"ID":"20230724000609-zgc3t3g","Type":"NodeParagraph","Properties":{"id":"20230724000609-zgc3t3g","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"②：Hijack 是劫持 Http 的连接，劫持后需要手动处理连接的关闭，这个操作是为了复用连接"}]}]},{"ID":"20230724000609-bhdp33v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-bhdp33v","updated":"20230724000609"},"Children":[{"ID":"20230724000609-7xcznsf","Type":"NodeParagraph","Properties":{"id":"20230724000609-7xcznsf","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"③：先写一行响应："}]}]}]},{"ID":"20230724000609-lr9xy5a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-lr9xy5a","updated":"20230724000647"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aHR0cA=="},{"Type":"NodeCodeBlockCode","Data":"\"HTTP/1.0 200 Connnected to Go RPC \\n\\n\"\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-jhgr3h7","Type":"NodeList","ListData":{},"Properties":{"id":"20230724000609-jhgr3h7","updated":"20230724000609"},"Children":[{"ID":"20230724000609-4c805yr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-4c805yr","updated":"20230724000609"},"Children":[{"ID":"20230724000609-dlouct9","Type":"NodeParagraph","Properties":{"id":"20230724000609-dlouct9","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"④：开始真正的处理，这里段比较长，大致做了如下几点事情："}]}]},{"ID":"20230724000609-vdgaj3s","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-vdgaj3s","updated":"20230724000609"},"Children":[{"ID":"20230724000609-uyto0la","Type":"NodeList","ListData":{},"Properties":{"id":"20230724000609-uyto0la","updated":"20230724000609"},"Children":[{"ID":"20230724000609-wmnuoar","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-wmnuoar","updated":"20230724000609"},"Children":[{"ID":"20230724000609-wp6nl6w","Type":"NodeParagraph","Properties":{"id":"20230724000609-wp6nl6w","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"读出请求，包括要调用的service，参数等"}]}]},{"ID":"20230724000609-6s193rf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-6s193rf","updated":"20230724000609"},"Children":[{"ID":"20230724000609-o59ghyg","Type":"NodeParagraph","Properties":{"id":"20230724000609-o59ghyg","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"通过反射异步地调用对应的方法"}]}]},{"ID":"20230724000609-y1xvf25","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-y1xvf25","updated":"20230724000609"},"Children":[{"ID":"20230724000609-vlh6w96","Type":"NodeParagraph","Properties":{"id":"20230724000609-vlh6w96","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"将执行结果编码写回连接"}]}]}]}]},{"ID":"20230724000609-0i89n69","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-0i89n69","updated":"20230724000609"},"Children":[{"ID":"20230724000609-wrq1z69","Type":"NodeList","ListData":{},"Properties":{"id":"20230724000609-wrq1z69","updated":"20230724000609"},"Children":[{"ID":"20230724000609-vh10tpx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-vh10tpx","updated":"20230724000609"},"Children":[{"ID":"20230724000609-mf2js6a","Type":"NodeParagraph","Properties":{"id":"20230724000609-mf2js6a","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"准备好数据、编解码器"}]}]},{"ID":"20230724000609-a1k20se","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20230724000609-a1k20se","updated":"20230724000609"},"Children":[{"ID":"20230724000609-10fp09t","Type":"NodeParagraph","Properties":{"id":"20230724000609-10fp09t","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在一个大循环里处理每一个请求，处理流程是："}]}]}]}]}]},{"ID":"20230724000609-w6c06fd","Type":"NodeParagraph","Properties":{"id":"20230724000609-w6c06fd","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"说到这里，代码中有个对象池的设计挺巧妙，这里展开说说。"}]},{"ID":"20230724000609-571xji0","Type":"NodeParagraph","Properties":{"id":"20230724000609-571xji0","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在高并发下，Server 端的 Request 对象和 Response 对象会频繁地创建，这里用了队列来实现了对象池。以 Request 对象池做个介绍，在 Server 对象中有一个 Request 指针，Request 中有个 next 指针"}]},{"ID":"20230724000609-ac160k7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-ac160k7","updated":"20230724000633"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Server struct {\n    ...\n    freeReq \t*Request\n    ..\n}\ntype Request struct {\n\tServiceMethod\tstring\n\tSeq\t\t\t\tuint64\n\tnext\t\t\t*Request\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-ydhhrzv","Type":"NodeParagraph","Properties":{"id":"20230724000609-ydhhrzv","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在读取请求时需要这个对象，如果池中没有对象，则 new 一个出来，有的话就拿到，并将 Server 中的指针指向 next："}]},{"ID":"20230724000609-411k2rc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-411k2rc","updated":"20230724000630"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (server *Server) getRequest() *Request {\n\tserver.reqLock.Lock()\n\treq := server.freeReq\n\tif req == nil {\n\t\treq = new(Request)\n\t} else {\n\t\tserver.freeReq = req.next\n\t\t*req = Request{}\n\t}\n\tserver.reqLock.Unlock()\n\treturn req\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-0d6j0r7","Type":"NodeParagraph","Properties":{"id":"20230724000609-0d6j0r7","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"请求处理完成时，释放这个对象，插入到链表的头部"}]},{"ID":"20230724000609-fwi4a3n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-fwi4a3n","updated":"20230724000628"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (server *Server) freeRequest(req *Request) {\n    server.reqLock.Lock()\n    req.next = server.freeReq\n    server.freeReq = req\n    server.reqLock.Unlock()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-sthags1","Type":"NodeParagraph","Properties":{"id":"20230724000609-sthags1","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"640"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file://E:\\Typora%20picture\\640-16899273305101.gif?lastModify=1690128365"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230724000609-vl9x1p7","Type":"NodeParagraph","Properties":{"id":"20230724000609-vl9x1p7","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"回到正题，Client 和 Server 之间只有一条连接，如果是异步执行，怎么保证返回的数据是正确的呢？"}]},{"ID":"20230724000609-wno7y1q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724000609-wno7y1q","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"RPC Client 原理"}]},{"ID":"20230724000609-3y0nj8y","Type":"NodeParagraph","Properties":{"id":"20230724000609-3y0nj8y","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Client 使用第一步是 New 一个 Client 对象，在这一步，它偷偷起了一个协程，干什么呢？用来读取 Server 端的返回，这也是 Go 惯用的伎俩。"}]},{"ID":"20230724000609-hf5jy0z","Type":"NodeParagraph","Properties":{"id":"20230724000609-hf5jy0z","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"每一次 Client 的调用都被封装为一个 Call 对象，包含了调用的方法、参数、响应、错误、是否完成。"}]},{"ID":"20230724000609-wza3sl0","Type":"NodeParagraph","Properties":{"id":"20230724000609-wza3sl0","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"同时 Client 对象有一个 pending map，key 为请求的递增序号，当 Client 发起调用时，将序号自增，并把当前的 Call 对象放到 pending map 中，然后再向连接写入请求。"}]},{"ID":"20230724000609-jxk8q68","Type":"NodeParagraph","Properties":{"id":"20230724000609-jxk8q68","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"写入的请求先后分别为 Request 和参数，可以理解为 header 和 body，其中 Request 就包含了 Client 的请求自增序号。"}]},{"ID":"20230724000609-yqr17s2","Type":"NodeParagraph","Properties":{"id":"20230724000609-yqr17s2","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Server 端响应时把这个序号带回去，Client 接收响应时读出返回数据，再去 pending map 里找到对应的请求，通知给对应的阻塞协程。"}]},{"ID":"20230724000609-jxhbydp","Type":"NodeParagraph","Properties":{"id":"20230724000609-jxhbydp","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这不就能把请求和响应串到一起了吗？这一招很多 RPC 框架也是这么玩的。"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"640 (1)"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"file://E:\\Typora%20picture\\640%20(1).gif?lastModify=1690128365"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20230724000609-ia5au90","Type":"NodeParagraph","Properties":{"id":"20230724000609-ia5au90","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Client 、Server 流程都走完，但我们忽略了编解码细节，Go RPC 默认使用 gob 编解码器，这里也稍微介绍下 gob。"}]},{"ID":"20230724000609-09728by","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724000609-09728by","updated":"20230724000609"},"Children":[{"Type":"NodeText","Data":"gob 编解码"}]},{"ID":"20230724000609-yx62huk","Type":"NodeParagraph","Properties":{"id":"20230724000609-yx62huk","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"gob 是GO 实现一个Go亲和的协议，可以简单理解这个协议只能在Go中用。 Go Client RPC 对便解码接口的定义如下："}]},{"ID":"20230724000609-5vbx4db","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-5vbx4db","updated":"20230724000624"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type ClientCodec interface {\n    WriteRequest(*Request,interface{}) error\n    ReadResponseHeader(*Reponse) error\n    ReadResponseBody(interface{}) error\n\n    Close() error\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-hztrxt7","Type":"NodeParagraph","Properties":{"id":"20230724000609-hztrxt7","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"同时，Server端也有一个定义"}]},{"ID":"20230724000609-ayjyp6d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-ayjyp6d","updated":"20230724000616"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type ServerCodec interface {\n ReadRequestHeader(*Request) error\n ReadRequestBody(interface{}) error\n WriteResponse(*Response, interface{}) error\n\n Close() error\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-cxe2otn","Type":"NodeParagraph","Properties":{"id":"20230724000609-cxe2otn","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"gob 是其一个实现，这里只看 Client："}]},{"ID":"20230724000609-frz0fo6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724000609-frz0fo6","updated":"20230724000614"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func (c *gobClientCodec) WriteRequest(r *Request, body interface{}) (err error) {\n\tif err = c.enc.Encode(r); err != nil {\n\t\treturn\n\t}\n\tif err = c.enc.Encode(body); err != nil {\n\t\treturn\n\t}\n\treturn c.encBuf.Flush()\n}\n\nfunc (c *gobClientCodec) ReadResponseHeader(r *Response) error {\n\treturn c.dec.Decode(r)\n}\n\nfunc (c *gobClientCodec) ReadResponseBody(body interface{}) error {\n\treturn c.dec.Decode(body)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724000609-3saglyt","Type":"NodeParagraph","Properties":{"id":"20230724000609-3saglyt","updated":"20230724000609"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"追踪到底层就是 Encoder 的 EncodeValue 和 DecodeValue 方法，Encode 的细节我不打算写，因为我也不想看这一块，最终结果就是把结构体编码成了二进制数据，调用 writeMessage。"}]}]}