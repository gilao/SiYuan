{"ID":"20231218224344-0vmkhwl","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f48e","id":"20231218224344-0vmkhwl","tags":"Go-类型转换,Go-类型断言,公众号-Golang语言开发栈","title":"Go 语言怎么使用类型转换和类型断言","updated":"20231218225846"},"Children":[{"ID":"20231218224401-uc21fdw","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231218224401-uc21fdw","updated":"20231218224404"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20231218224413-sq9s770","Type":"NodeParagraph","Properties":{"id":"20231218224413-sq9s770","updated":"20231218225846"},"Children":[{"Type":"NodeText","Data":"Go 语言是强类型编程语言，一些使用弱类型编程语言的读者朋友们在初学 Go 语言时，多多少少都会不太适应 Go 语言的类型。 "}]},{"ID":"20231218224413-hqv7wxo","Type":"NodeParagraph","Properties":{"id":"20231218224413-hqv7wxo","updated":"20231218224419"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Go 语言变量类型包含基础类型和复合类型，类型转换和类型断言一般是对基础类型的处理，基础类型包含整数、浮点数、布尔和字符串。"}]},{"ID":"20231218224413-d5f8reb","Type":"NodeParagraph","Properties":{"id":"20231218224413-d5f8reb","updated":"20231218224413"},"Children":[{"Type":"NodeText","Data":"其中整数类型又称为整型，分为有符合和无符号，各自又包含不同大小，8位、16位、32位和64位，其中 int32 和 uint8 的类型别名分别是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"rune"},{"Type":"NodeText","Data":"​和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231218224413-y4sers9","Type":"NodeParagraph","Properties":{"id":"20231218224413-y4sers9","updated":"20231218224413"},"Children":[{"Type":"NodeText","Data":"浮点数类型分为 float32 和 float64，为了避免精度丢失，一般我们选择使用 float64，float32 和 float64 之间可以直接转换，整型和浮点数类型之间也可以直接转换，需要注意丢失精度的问题。"}]},{"ID":"20231218224413-phajhte","Type":"NodeParagraph","Properties":{"id":"20231218224413-phajhte","updated":"20231218224413"},"Children":[{"Type":"NodeText","Data":"布尔类型的值只有两个，分别是 true 和 false，类型零值为 false。需要注意的是它无法像弱类型编程语言可以隐式转换为 1 和 0。"}]},{"ID":"20231218224413-bw1mlvn","Type":"NodeParagraph","Properties":{"id":"20231218224413-bw1mlvn","updated":"20231218224413"},"Children":[{"Type":"NodeText","Data":"字符串类型是一组使用双引号引起来的字节序列，它可以包含任意数据。需要注意的是它不可以改变，因为多个字符串可以共享同一块内存空间。"}]},{"ID":"20231218224413-ljflsr8","Type":"NodeParagraph","Properties":{"id":"20231218224413-ljflsr8","updated":"20231218224413"},"Children":[{"Type":"NodeText","Data":"本文我们介绍 Go 语言的类型转换和类型断言。"}]},{"ID":"20231218224344-0pw4yak","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231218224344-0pw4yak","updated":"20231218224544"},"Children":[{"Type":"NodeText","Data":"类型转换"}]},{"ID":"20231218224551-ja6qapb","Type":"NodeParagraph","Properties":{"id":"20231218224551-ja6qapb","updated":"20231218224551"},"Children":[{"Type":"NodeText","Data":"我们在项目开发时，可能会遇到一些需要类型转换的场景，比如我们使用 Go 语言开发 Api 接口。"}]},{"ID":"20231218224551-9x9qxge","Type":"NodeParagraph","Properties":{"id":"20231218224551-9x9qxge","updated":"20231218224551"},"Children":[{"Type":"NodeText","Data":"客户端（调用方）在请求我们使用 Go 语言开发的 Api 接口时，虽然会按照我们预先协商的参数类型，但是随着项目的不断迭代，可能以前定义的变量类型需要修改。"}]},{"ID":"20231218224551-65zx1xr","Type":"NodeParagraph","Properties":{"id":"20231218224551-65zx1xr","updated":"20231218224551"},"Children":[{"Type":"NodeText","Data":"因为 Go 语言是强类型语言，不支持类型隐式转换，我们就需要显式转换变量的类型。"}]},{"ID":"20231218224551-bt5qa6w","Type":"NodeParagraph","Properties":{"id":"20231218224551-bt5qa6w","updated":"20231218224551"},"Children":[{"Type":"NodeText","Data":"Go 语言类型转换的方式："}]},{"ID":"20231218224551-31qkwir","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231218224551-31qkwir","updated":"20231218224551"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"强制转换"}]},{"ID":"20231218224551-xxnkaw4","Type":"NodeParagraph","Properties":{"id":"20231218224551-xxnkaw4","updated":"20231218224551"},"Children":[{"Type":"NodeText","Data":"整数类型之间可以强制转换，代码如下："}]},{"ID":"20231218224552-igcf1ad","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231218224552-igcf1ad","updated":"20231218224918"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n\tvar a int64\n\ta = 1\n\tfmt.Printf(\"%T\\t%d\\n\", a, a)\n\tvar b int8\n\tb = int8(a)\n\tfmt.Printf(\"%T\\t%d\\n\", b, b)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231218224925-yxqhze8","Type":"NodeParagraph","Properties":{"id":"20231218224925-yxqhze8","updated":"20231218224925"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们定义 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"int64"},{"Type":"NodeText","Data":"​ 类型的变量 a，使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;类型\u0026gt;(\u0026lt;数值\u0026gt;)"},{"Type":"NodeText","Data":"​ 的格式，直接把变量 a 的由 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"int64"},{"Type":"NodeText","Data":"​ 转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"int8"},{"Type":"NodeText","Data":"​ 的变量 b。"}]},{"ID":"20231218224925-xe4u43c","Type":"NodeParagraph","Properties":{"id":"20231218224925-xe4u43c","updated":"20231218225002"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1); background-color: var(--b3-font-background3);"},"TextMarkType":"text strong","TextMarkTextContent":"浮点数类型之间，浮点数和整型之间，也可以强制转换，"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1); background-color: var(--b3-font-background3);\"}"},{"Type":"NodeText","Data":"代码如下："}]},{"ID":"20231218224926-reblyrm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231218224926-reblyrm","updated":"20231218224937"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\nfunc main(){\n    var a float64\n    a = 3.1415926\n    fmt.Printf(\"%T\\t%f\\n\", a, a)\n    var b float32\n    b = float32(a)\n    fmt.Printf(\"%T\\t%f\\n\", b, b)\n    var c int64\n    c = int64(b)\n    fmt.Printf(\"%T\\t%d\\n\", c, c)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231218224942-644zy73","Type":"NodeParagraph","Properties":{"id":"20231218224942-644zy73","updated":"20231218224942"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们定义 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float64"},{"Type":"NodeText","Data":"​ 类型的变量 a，使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;类型\u0026gt;(\u0026lt;数值\u0026gt;)"},{"Type":"NodeText","Data":"​ 的格式，直接把变量 a 由 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float64"},{"Type":"NodeText","Data":"​ 转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float32"},{"Type":"NodeText","Data":"​ 的变量 b，然后变量 b 由 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float32"},{"Type":"NodeText","Data":"​ 转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"int64"},{"Type":"NodeText","Data":"​ 的变量 c。需要注意丢失精度的问题。"}]},{"ID":"20231218224942-sm6ndoy","Type":"NodeParagraph","Properties":{"id":"20231218224942-sm6ndoy","updated":"20231218224942"},"Children":[{"Type":"NodeText","Data":"布尔类型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bool"},{"Type":"NodeText","Data":"​，它的值只有两个，分别是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"​，它没有其它类型可以强制转换，不过可以使用标准库或三方库对布尔类型进行类型转换。"}]},{"ID":"20231218224942-rxxev97","Type":"NodeParagraph","Properties":{"id":"20231218224942-rxxev97","updated":"20231218224942"},"Children":[{"Type":"NodeText","Data":"字符串类型是一组使用双引号引起来的字节序列，所以 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"string"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[]byte"},{"Type":"NodeText","Data":"​ 之间可以强制转换，代码如下："}]},{"ID":"20231218225058-d4gejat","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231218225058-d4gejat","updated":"20231218225059"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main(){\n    var a string\n    a = \"golang\"\n    fmt.Printf(\"%T\\t%s\\n\", a, a)\n    var b []byte\n    b = []byte(a)\n    fmt.Printf(\"%T\\t%d\\n\", b, b)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231218225101-av27v1b","Type":"NodeParagraph","Properties":{"id":"20231218225101-av27v1b","updated":"20231218225107"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们定义 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"string"},{"Type":"NodeText","Data":"​ 类型的变量 a，使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;类型\u0026gt;(\u0026lt;数值\u0026gt;)"},{"Type":"NodeText","Data":"​ 的格式，直接把变量 a 由 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"string"},{"Type":"NodeText","Data":"​ 转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[]byte"},{"Type":"NodeText","Data":"​ 的变量 b，反之亦然。"}]},{"ID":"20231218225108-o3qjsow","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231218225108-o3qjsow","updated":"20231218225125"},"Children":[{"Type":"NodeText","Data":"使用标准库或三方库"}]},{"ID":"20231218225425-nvnbsc8","Type":"NodeParagraph","Properties":{"id":"20231218225425-nvnbsc8","updated":"20231218225426"},"Children":[{"Type":"NodeText","Data":"无法强制转换的类型，可以使用标准库或三方库，比如布尔类型，代码如下："}]},{"ID":"20231218225427-1crjgpb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231218225427-1crjgpb","updated":"20231218225432"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main(){\n    var a bool\n    a = true\n    fmt.Printf(\"%T\\t%t\\n\", a, a)\n    var b string\n    b = strconv.FormatBool(a)\n    fmt.Printf(\"%T\\t%s\\n\", b, b)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231218225554-y8ysuyz","Type":"NodeParagraph","Properties":{"id":"20231218225554-y8ysuyz","updated":"20231218225554"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们定义 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bool"},{"Type":"NodeText","Data":"​ 类型的变量 a，使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;类型\u0026gt;(\u0026lt;数值\u0026gt;)"},{"Type":"NodeText","Data":"​ 的格式，使用标准库 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"strconv"},{"Type":"NodeText","Data":"​ 的方法把变量 a 由 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bool"},{"Type":"NodeText","Data":"​ 转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"string"},{"Type":"NodeText","Data":"​ 的变量 b。"}]},{"ID":"20231218225554-ww5tufp","Type":"NodeParagraph","Properties":{"id":"20231218225554-ww5tufp","updated":"20231218225554"},"Children":[{"Type":"NodeText","Data":"除了标准库 strconv"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[1]"},{"Type":"NodeText","Data":" 之外，标准库 fmt"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[2]"},{"Type":"NodeText","Data":" 也提供了类型转换的方法；还有一些三方库，比如 cast"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[3]"},{"Type":"NodeText","Data":"。限于篇幅，此处不再详细赘述，感兴趣的读者朋友们可以阅读相关文档了解更多。"}]},{"ID":"20231218225605-yhtiqmr","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231218225605-yhtiqmr","updated":"20231218225613"},"Children":[{"Type":"NodeText","Data":"类型断言"}]},{"ID":"20231218225702-rnj6fzt","Type":"NodeParagraph","Properties":{"id":"20231218225702-rnj6fzt","updated":"20231218225702"},"Children":[{"Type":"NodeText","Data":"我们在项目开发时，可能想要定义参数的类型为通用类型，比如我们使用 Go 语言开发 Api 接口。"}]},{"ID":"20231218225702-dr4lhq9","Type":"NodeParagraph","Properties":{"id":"20231218225702-dr4lhq9","updated":"20231218225702"},"Children":[{"Type":"NodeText","Data":"我们想要尽量适配客户端（调用方）传参使用不同类型，比如调用方是使用弱类型编程语言的场景。"}]},{"ID":"20231218225702-kjz7qpm","Type":"NodeParagraph","Properties":{"id":"20231218225702-kjz7qpm","updated":"20231218225711"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"我们可以定义变量类型的空接口类型 "},{"Type":"NodeTextMark","TextMarkType":"code strong","TextMarkTextContent":"interface{}"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，然后使用类型断言，获取传参的实际类型，按需处理为我们想要的类型。"}]},{"ID":"20231218225702-kcq3i50","Type":"NodeParagraph","Properties":{"id":"20231218225702-kcq3i50","updated":"20231218225702"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20231218225712-wa5ej26","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231218225712-wa5ej26","updated":"20231218225719"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main(){\n    var id interface{}\n    id = 1 // 参数 id 接收到的值为整型\n    fmt.Printf(\"%T\\t%v\\n\", id, id)\n    // 需要使用字符串类型的变量 id 赋值给字符串类型的变量 uid\n    var uid string\n    value, ok := id.(string)\n    if ok {\n        uid = value\n    }\n    fmt.Printf(\"%T\\t%v\\n\", uid, uid)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231218225724-ksppmzp","Type":"NodeParagraph","Properties":{"id":"20231218225724-ksppmzp","updated":"20231218225724"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们定义 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"interface{}"},{"Type":"NodeText","Data":"​ 空接口类型的变量 id，作为接收请求参数，实际需要使用字符串类型的数据，我们使用类型断言检查变量 id 的值是否是字符串类型，是字符串类型则赋值给变量 uid。"}]},{"ID":"20231218225724-xm5pkuv","Type":"NodeParagraph","Properties":{"id":"20231218225724-xm5pkuv","updated":"20231218225724"},"Children":[{"Type":"NodeText","Data":"需要注意的是，我们在使用类型断言时，最好使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ok-idiom"},{"Type":"NodeText","Data":"​ 模式，避免引发 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"panic"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231218225724-jdjehew","Type":"NodeParagraph","Properties":{"id":"20231218225724-jdjehew","updated":"20231218225728"},"Children":[{"Type":"NodeText","Data":"此外，还有 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"switch case"},{"Type":"NodeText","Data":"​ 方式的类型断言，也称为"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"类型选择"},{"Type":"NodeText","Data":"。可以处理多种类型，代码如下："}]},{"ID":"20231218225728-ewusjiq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231218225728-ewusjiq","updated":"20231218225735"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\nfunc main() {\n    var id interface{}\n    id = 1 // 参数 id 接收到的值为整型\n    fmt.Printf(\"0-%T\\t%v\\n\", id, id)\n    // 需要使用字符串类型的变量 id 赋值给字符串类型的变量 uid\n    var uid string\n    switch val := id.(type) {\n    case string:\n     uid = val\n     fmt.Printf(\"1-%T\\t%v\\n\", uid, uid)\n    case int:\n     uid = strconv.Itoa(val)\n     fmt.Printf(\"2-%T\\t%v\\n\", uid, uid)\n    default:\n     fmt.Printf(\"3-%T\\t%v\\n\", uid, uid)\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231218225742-f0bzhen","Type":"NodeParagraph","Properties":{"id":"20231218225742-f0bzhen","updated":"20231218225742"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"switch case"},{"Type":"NodeText","Data":"​ 方式的类型断言参数 id，如果参数的值是我们需要的类型，则直接使用，反之，则类型转换之后再使用。"}]},{"ID":"20231218225742-f163z1j","Type":"NodeParagraph","Properties":{"id":"20231218225742-f163z1j","updated":"20231218225742"},"Children":[{"Type":"NodeText","Data":"细心的读者朋友们可能发现该方式的类型断言格式有所不同，小括号中的数据类型改为 type。"}]},{"ID":"20231218225742-zt0wvh1","Type":"NodeParagraph","Properties":{"id":"20231218225742-zt0wvh1","updated":"20231218225742"},"Children":[{"Type":"NodeText","Data":"需要注意的是，使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"switch case"},{"Type":"NodeText","Data":"​ 方式的类型断言，即便省略 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":"​，也不会因为不是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ok-idiom"},{"Type":"NodeText","Data":"​ 模式的类型断言而引发 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"panic"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231218225745-cx70dlg","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231218225745-cx70dlg","updated":"20231218225756"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20231218225802-8p4c01q","Type":"NodeParagraph","Properties":{"id":"20231218225802-8p4c01q","updated":"20231218225802"},"Children":[{"Type":"NodeText","Data":"本文我们介绍 Go 语言中让之前一直使用弱类型编程语言的读者朋友们迷惑的类型转换和类型断言。"}]},{"ID":"20231218225802-a1grjh1","Type":"NodeParagraph","Properties":{"id":"20231218225802-a1grjh1","updated":"20231218225802"},"Children":[{"Type":"NodeText","Data":"读完本文，大家至少可以区分类型转换和类型断言的区别，和了解各自的使用场景。"}]}]}