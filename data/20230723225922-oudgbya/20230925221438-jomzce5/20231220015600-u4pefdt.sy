{"ID":"20231220015600-u4pefdt","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f403","id":"20231220015600-u4pefdt","tags":"公众号-Golang语言开发栈,Go-goroutine","title":"Go 语言使用 goroutine 运行闭包的“坑”","updated":"20231220020027"},"Children":[{"ID":"20231220015600-g1mns7h","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220015600-g1mns7h","updated":"20231220015701"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20231220015711-kncq791","Type":"NodeParagraph","Properties":{"id":"20231220015711-kncq791","updated":"20231220015711"},"Children":[{"Type":"NodeText","Data":"在 Go 语言中，函数支持匿名函数，闭包就是一种特殊的匿名函数，它可以用于访问函数体外部的变量。"}]},{"ID":"20231220015711-ba83e36","Type":"NodeParagraph","Properties":{"id":"20231220015711-ba83e36","updated":"20231220015711"},"Children":[{"Type":"NodeText","Data":"需要注意的是，在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for ... range ..."},{"Type":"NodeText","Data":"​ 中，使用 goroutine 执行闭包时，经常会掉“坑”。"}]},{"ID":"20231220015711-wmnpiw5","Type":"NodeParagraph","Properties":{"id":"20231220015711-wmnpiw5","updated":"20231220015711"},"Children":[{"Type":"NodeText","Data":"因为匿名函数可以访问函数体外部的变量，而 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for ... range ..."},{"Type":"NodeText","Data":"​ 返回的 val 的值是引用的同一个内存地址的数据，所以匿名函数访问的函数体外部的 val 值是循环中最后输出的一个值。"}]},{"ID":"20231220015724-1ru63v8","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220015724-1ru63v8","updated":"20231220015746"},"Children":[{"Type":"NodeText","Data":"“踩坑”示例代码"}]},{"ID":"20231220015758-wi5qxx0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220015758-wi5qxx0","updated":"20231220015808"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n done := make(chan bool)\n\n values := []string{\"a\", \"b\", \"c\"}\n for _, v := range values {\n  go func() {\n   fmt.Println(v)\n   done \u003c- true\n  }()\n }\n\n // wait for all goroutines to complete before exiting\n for _ = range values {\n  \u003c-done\n }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220015758-x1zsqnt","Type":"NodeParagraph","Properties":{"id":"20231220015758-x1zsqnt","updated":"20231220015758"},"Children":[{"Type":"NodeText","Data":"输出结果："}]},{"ID":"20231220015758-0hcl3pn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220015758-0hcl3pn","updated":"20231220015911"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"c\nc\nc\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220015758-905ynqi","Type":"NodeParagraph","Properties":{"id":"20231220015758-905ynqi","updated":"20231220015758"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for ... range ..."},{"Type":"NodeText","Data":"​ 中，使用 goroutine 执行闭包，打印切片中的元素，实际输出结果不是我们期望得到的输出结果。"}]},{"ID":"20231220015758-bgure7u","Type":"NodeParagraph","Properties":{"id":"20231220015758-bgure7u","updated":"20231220015833"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这是因为循环的每次迭代都使用相同的变量 v 实例，因此每个闭包共享该单个变量。我们可以在示例代码中简单修改，同时输出变量 v 的内存地址和值。"}]},{"ID":"20231220015758-gj2usjw","Type":"NodeParagraph","Properties":{"id":"20231220015758-gj2usjw","updated":"20231220015758"},"Children":[{"Type":"NodeText","Data":"把 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"fmt.Println(v)"},{"Type":"NodeText","Data":"​ 修改为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"fmt.Printf(\u0026quot;val=%s pointer=%p\\n\u0026quot;, v, \u0026amp;v)"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231220015758-yy9bidd","Type":"NodeParagraph","Properties":{"id":"20231220015758-yy9bidd","updated":"20231220015758"},"Children":[{"Type":"NodeText","Data":"修改后的输出结果："}]},{"ID":"20231220015758-6070vqt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220015758-6070vqt","updated":"20231220015906"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"val=c pointer=0xc000010200\nval=c pointer=0xc000010200\nval=c pointer=0xc000010200\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220015758-og1tc9d","Type":"NodeParagraph","Properties":{"id":"20231220015758-og1tc9d","updated":"20231220015758"},"Children":[{"Type":"NodeText","Data":"我们可以在输出结果中发现，打印变量 v 的内存地址都是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0xc000010200"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231220015758-ivjx9hp","Type":"NodeParagraph","Properties":{"id":"20231220015758-ivjx9hp","updated":"20231220015758"},"Children":[{"Type":"NodeText","Data":"当闭包运行时，它会在执行 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"fmt.Println"},{"Type":"NodeText","Data":"​ 时打印变量 v 的值，但 v 的值可能在 goroutine 启动后已被修改。感兴趣的读者朋友们可以使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"go vet"},{"Type":"NodeText","Data":"​ 检查。"}]},{"ID":"20231220015758-9w87rw5","Type":"NodeParagraph","Properties":{"id":"20231220015758-9w87rw5","updated":"20231220015758"},"Children":[{"Type":"NodeText","Data":"怎么避免“踩坑”呢？"}]},{"ID":"20231220015758-xcybix0","Type":"NodeParagraph","Properties":{"id":"20231220015758-xcybix0","updated":"20231220015853"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"一种方法是将变量作为参数传递给闭包："},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20231220015758-ql6yl7x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220015758-ql6yl7x","updated":"20231220015901"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n done := make(chan bool)\n\n values := []string{\"a\", \"b\", \"c\"}\n for _, v := range values {\n  go func(param string) {\n   // fmt.Println(v)\n   fmt.Printf(\"val=%s pointer=%p\\n\", param, \u0026param)\n   done \u003c- true\n  }(v)\n }\n\n // wait for all goroutines to complete before exiting\n for _ = range values {\n  \u003c-done\n }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220015758-0k4en80","Type":"NodeParagraph","Properties":{"id":"20231220015758-0k4en80","updated":"20231220015758"},"Children":[{"Type":"NodeText","Data":"输出结果："}]},{"ID":"20231220015758-iqfy2o8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220015758-iqfy2o8","updated":"20231220015920"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"val=c pointer=0xc000010200\nval=a pointer=0xc00009a000\nval=b pointer=0xc0000a4000\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220015758-0cel70t","Type":"NodeParagraph","Properties":{"id":"20231220015758-0cel70t","updated":"20231220015758"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，通过将变量 v 的值作为参数传递给闭包，然后，该值作为形参 param 的值，在函数体内部被访问。"}]},{"ID":"20231220015758-6j5uvan","Type":"NodeParagraph","Properties":{"id":"20231220015758-6j5uvan","updated":"20231220020002"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"另外一种方法是创建一个新变量："},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20231220015758-rwbdkrc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220015758-rwbdkrc","updated":"20231220015925"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n done := make(chan bool)\n\n values := []string{\"a\", \"b\", \"c\"}\n for _, v := range values {\n  param := v\n  go func() {\n   // fmt.Println(v)\n   fmt.Printf(\"val=%s pointer=%p\\n\", param, \u0026param)\n   done \u003c- true\n  }()\n }\n\n // wait for all goroutines to complete before exiting\n for _ = range values {\n  \u003c-done\n }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220015758-ix32teu","Type":"NodeParagraph","Properties":{"id":"20231220015758-ix32teu","updated":"20231220015758"},"Children":[{"Type":"NodeText","Data":"输出结果："}]},{"ID":"20231220015758-wy44za6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220015758-wy44za6","updated":"20231220015758"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"val=c pointer=0xc000082200\nval=a pointer=0xc0000821e0\nval=b pointer=0xc0000821f0\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220015758-juqxuy5","Type":"NodeParagraph","Properties":{"id":"20231220015758-juqxuy5","updated":"20231220015758"},"Children":[{"Type":"NodeText","Data":"通过输出结果可以发现，该种方式也可以达到我们期望的结果。"}]},{"ID":"20231220020015-vpcei1r","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220020015-vpcei1r","updated":"20231220020019"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20231220020027-fxlqrp1","Type":"NodeParagraph","Properties":{"id":"20231220020027-fxlqrp1","updated":"20231220020027"},"Children":[{"Type":"NodeText","Data":"本文我们介绍了在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for ... range ..."},{"Type":"NodeText","Data":"​ 中，Go 语言在每次迭代时，没有定义一个新变量，导致使用 goroutine 运行闭包时，经常会掉“坑”。"}]},{"ID":"20231220020027-xrcuveb","Type":"NodeParagraph","Properties":{"id":"20231220020027-xrcuveb","updated":"20231220020027"},"Children":[{"Type":"NodeText","Data":"我们给出避免“踩坑”的两种方法，其中，第二种方法更简单。"}]}]}