{"ID":"20231215114346-ogxa9m9","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f30b","id":"20231215114346-ogxa9m9","tags":"公众号-Golang语言开发栈,Go-泛型,Go-1.18","title":"Go 1.18 新增三大功能之一“泛型”怎么使用？","updated":"20231215144750"},"Children":[{"ID":"20231215114346-2qlqhtu","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231215114346-2qlqhtu","updated":"20231215140051"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20231215140142-pdakabl","Type":"NodeParagraph","Properties":{"id":"20231215140142-pdakabl","updated":"20231215140142"},"Children":[{"Type":"NodeText","Data":"在 Go v1.18 中，Go 语言新增三个功能，分别是“泛型”、“模糊测试” 和 “工作区”。"}]},{"ID":"20231215140142-dlupwkr","Type":"NodeParagraph","Properties":{"id":"20231215140142-dlupwkr","updated":"20231215140142"},"Children":[{"Type":"NodeText","Data":"本文我们介绍 Go 社区呼声最高的 “泛型” 的使用方式。"}]},{"ID":"20231215140142-0k79nm6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215140142-0k79nm6","updated":"20231215140155"},"Children":[{"Type":"NodeText","Data":"引言"}]},{"ID":"20231215140156-9a6wj7j","Type":"NodeParagraph","Properties":{"id":"20231215140156-9a6wj7j","updated":"20231215140207"},"Children":[{"Type":"NodeText","Data":"读者朋友们应该了解 Go 语言是一门强类型语言，如果你是从弱类型语言转过来的话，刚开始上手时可能会比较别扭。"}]},{"ID":"20231215140208-x0uedzb","Type":"NodeParagraph","Properties":{"id":"20231215140208-x0uedzb","updated":"20231215140224"},"Children":[{"Type":"NodeText","Data":"比如，我列举一个简单的示例："}]},{"ID":"20231215140225-rcinfp3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215140225-rcinfp3","updated":"20231215140234"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func MinInt(x, y int) int {\n    if x \u003c y {\n        return x\n    }\n    return y\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215140238-c09jsc6","Type":"NodeParagraph","Properties":{"id":"20231215140238-c09jsc6","updated":"20231215140239"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们定义一个比较大小的函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MinInt()"},{"Type":"NodeText","Data":"​，需要注意的是，该函数参数列表和返回值的类型是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"​，如果我们想要比较的数值是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float64"},{"Type":"NodeText","Data":"​ 浮点数类型，我们就无法使用该函数。"}]},{"ID":"20231215140252-ex0lb6k","Type":"NodeParagraph","Properties":{"id":"20231215140252-ex0lb6k","updated":"20231215140300"},"Children":[{"Type":"NodeText","Data":"聪明的读者朋友们可能会想到，再定义一个函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MinFloat64()"},{"Type":"NodeText","Data":"​ 函数。"}]},{"ID":"20231215140301-jdoblcq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215140301-jdoblcq","updated":"20231215140307"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func MinFloat64(x, y float64) float64 {\n    if x \u003c y {\n        return x\n    }\n    return y\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215140307-kt5zppd","Type":"NodeParagraph","Properties":{"id":"20231215140307-kt5zppd","updated":"20231215140313"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们又定义一个比较 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float64"},{"Type":"NodeText","Data":"​ 类型的数值大小的函数，这种办法也不是不可以，但是，我们知道 Go 语言的数值类型还有其他很多种，比如 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"int8"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"int32"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"int64"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"uint8"},{"Type":"NodeText","Data":"​ ..."}]},{"ID":"20231215140318-6k0i0d4","Type":"NodeParagraph","Properties":{"id":"20231215140318-6k0i0d4","updated":"20231215140318"},"Children":[{"Type":"NodeText","Data":"所以，我们难道需要为每种数值类型都定义一个比较大小的函数吗？"}]},{"ID":"20231215140318-qn13bwj","Type":"NodeParagraph","Properties":{"id":"20231215140318-qn13bwj","updated":"20231215140318"},"Children":[{"Type":"NodeText","Data":"此时，经验丰富的读者朋友们想到了使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"interface{}"},{"Type":"NodeText","Data":"​ 空接口类型，代码如下："}]},{"ID":"20231215140318-9m86ypg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215140318-9m86ypg","updated":"20231215143118"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func MinAny(x, y interface{}) interface{} {\n if x, ok := x.(int); ok {\n  if y, ok := y.(int); ok {\n   if x \u003c y {\n    return x\n   }\n  }\n }\n if x, ok := x.(float64); ok {\n  if y, ok := y.(float64); ok {\n   if x \u003c y {\n    return x\n   }\n  }\n }\n return y\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215143119-98zyen3","Type":"NodeParagraph","Properties":{"id":"20231215143119-98zyen3","updated":"20231215143131"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们将函数的参数列表和返回值都定义为空接口类型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"interface{}"},{"Type":"NodeText","Data":"​，使用此方法确实可以避免我们为每种数值类型定义一个比较数值大小的函数，但是，该方式也有弊端，那就是需要我们在函数体中，对每种数值类型做类型断言。"}]},{"ID":"20231215143139-3gg5fgc","Type":"NodeParagraph","Properties":{"id":"20231215143139-3gg5fgc","updated":"20231215143139"},"Children":[{"Type":"NodeText","Data":"综上所述，在 Go v1.18 之前，我们如果想要使用相同的逻辑处理不同类型的变量时，就会比较麻烦。"}]},{"ID":"20231215143139-ahi2akf","Type":"NodeParagraph","Properties":{"id":"20231215143139-ahi2akf","updated":"20231215143139"},"Children":[{"Type":"NodeText","Data":"Go v1.18 新增的“泛型”功能，使这个问题得到解决，避免我们写一些重复代码。"}]},{"ID":"20231215143141-hb336p8","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231215143141-hb336p8","updated":"20231215143148"},"Children":[{"Type":"NodeText","Data":"类型参数"}]},{"ID":"20231215143148-lwh0mms","Type":"NodeParagraph","Properties":{"id":"20231215143148-lwh0mms","updated":"20231215143206"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Go 语言中的“泛型”是通过支持类型参数实现的，类型参数又可以分为“函数的类型参数”，“类型的类型参数”和“方法的类型参数”。"}]},{"ID":"20231215143207-fw6anlz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215143207-fw6anlz","updated":"20231215143214"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"函数的类型参数 - 泛型函数"}]},{"ID":"20231215143222-576jjtq","Type":"NodeParagraph","Properties":{"id":"20231215143222-576jjtq","updated":"20231215143222"},"Children":[{"Type":"NodeText","Data":"我们先使用 “泛型” 重写一下 Part 02 的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MinAny()"},{"Type":"NodeText","Data":"​ 函数，代码如下："}]},{"ID":"20231215143222-31zlgwa","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215143222-31zlgwa","updated":"20231215143235"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func MinAny[T int](x, y T) T {\n    if x \u003c y {\n        return x\n    }\n    return y\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215143440-ajn6m1r","Type":"NodeParagraph","Properties":{"id":"20231215143440-ajn6m1r","updated":"20231215143440"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们可以发现，在函数名和参数列表之间的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[T int]"},{"Type":"NodeText","Data":"​，这就是类型参数，我们在函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MinAny"},{"Type":"NodeText","Data":"​ 中使用类型参数，该函数就是“泛型函数”。"}]},{"ID":"20231215143440-gwyxcxi","Type":"NodeParagraph","Properties":{"id":"20231215143440-gwyxcxi","updated":"20231215143440"},"Children":[{"Type":"NodeText","Data":"类型参数支持多个类型，使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"|"},{"Type":"NodeText","Data":"​ 分隔，例如："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[T int | float64]"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231215143440-ob5rick","Type":"NodeParagraph","Properties":{"id":"20231215143440-ob5rick","updated":"20231215143440"},"Children":[{"Type":"NodeText","Data":"想必有读者朋友们会问，如果类型参数需要支持所有数值类型，那岂不是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[]"},{"Type":"NodeText","Data":"​中的代码会特别长。"}]},{"ID":"20231215143440-1wt8b3t","Type":"NodeParagraph","Properties":{"id":"20231215143440-1wt8b3t","updated":"20231215143440"},"Children":[{"Type":"NodeText","Data":"不用担心，我们可以声明一个接口类型，不同的是，接口类型中不再是函数，而是类型，代码如下："}]},{"ID":"20231215143442-4g9opev","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215143442-4g9opev","updated":"20231215143447"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type ordered interface {\n    ~int | ~float64\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215143448-shuf4kz","Type":"NodeParagraph","Properties":{"id":"20231215143448-shuf4kz","updated":"20231215143615"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们定义一个类型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ordered"},{"Type":"NodeText","Data":"​，他的语法类似定义接口类型，区别是函数变成了类型名称（波浪线开头代表类型本身和以该类型为底层类型的所有类型）。"}]},{"ID":"20231215143616-dm37bez","Type":"NodeParagraph","Properties":{"id":"20231215143616-dm37bez","updated":"20231215143620"},"Children":[{"Type":"NodeText","Data":"我们改写一下 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MinAny"},{"Type":"NodeText","Data":"​ 函数，代码如下："}]},{"ID":"20231215143621-fzb2wdl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215143621-fzb2wdl","updated":"20231215143627"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\nfunc MinAny[T ordered](x, y T) T {\n    if x \u003c y {\n        return x\n    }\n    return y\n} \n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215143628-sxvu6h3","Type":"NodeParagraph","Properties":{"id":"20231215143628-sxvu6h3","updated":"20231215144234"},"Children":[{"Type":"NodeText","Data":" 需要注意的是，如果 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[]"},{"Type":"NodeText","Data":"​ 中包含多个类型参数，需要使用英文逗号 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":","},{"Type":"NodeText","Data":"​ 分隔，并且类型参数的形参名字不能相同，例如："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[T ordered, T1 ordered1]"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231215144222-fxu1jdh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215144222-fxu1jdh","updated":"20231215144356"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"类型的类型参数 - 泛型类型"}]},{"ID":"20231215144357-80qhm1m","Type":"NodeParagraph","Properties":{"id":"20231215144357-80qhm1m","updated":"20231215144422"},"Children":[{"Type":"NodeText","Data":"与函数一样，Go 语言的自定义类型也可以使用类型参数，例如："}]},{"ID":"20231215144422-cgisybl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215144422-cgisybl","updated":"20231215144427"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type MinSalary[T int | float64] struct {\n    salary T\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215144434-4rpjbeo","Type":"NodeParagraph","Properties":{"id":"20231215144434-4rpjbeo","updated":"20231215144434"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们定义一个自定义类型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MinSalary"},{"Type":"NodeText","Data":"​，它是一个“泛型类型”，与定义一个自定义“普通类型”的区别是在类型名字后面跟一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[]"},{"Type":"NodeText","Data":"​中括号，里面包含类型参数（其中T是类型形参，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float64"},{"Type":"NodeText","Data":"​是类型实参）。"}]},{"ID":"20231215144434-hk3uwhy","Type":"NodeParagraph","Properties":{"id":"20231215144434-hk3uwhy","updated":"20231215144553"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"需要注意的是，“泛型类型”和“泛型函数”使用方式不同，它不能像“泛型函数”具备类型推断的功能，而是需要显示指定类型实参，代码如下："}]},{"ID":"20231215144435-wnuctyc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215144435-wnuctyc","updated":"20231215144440"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"salary := \u0026MinSalary[int]{\n    salary: 1000,\n}\nfmt.Printf(\"%+v\\n\", salary)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215144445-2c41zli","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215144445-2c41zli","updated":"20231215144445"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"方法的类型参数 - 泛型方法"}]},{"ID":"20231215144445-smdxlox","Type":"NodeParagraph","Properties":{"id":"20231215144445-smdxlox","updated":"20231215144445"},"Children":[{"Type":"NodeText","Data":"我们知道，Go 语言可以为自定义类型定义方法，同样也可以为“泛型类型”定义“泛型方法”。"}]},{"ID":"20231215144445-1d4tgvl","Type":"NodeParagraph","Properties":{"id":"20231215144445-1d4tgvl","updated":"20231215144445"},"Children":[{"Type":"NodeText","Data":"我们还是先来阅读一段代码："}]},{"ID":"20231215144449-j1fjppy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215144449-j1fjppy","updated":"20231215144450"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Salary[T int | float64] struct {\n    money T\n}\n\nfunc (s *Salary[T]) Min(x, y T) T {\n    if x \u003c y {\n        return x\n    }\n    return y\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215144459-1xxml3x","Type":"NodeParagraph","Properties":{"id":"20231215144459-1xxml3x","updated":"20231215144625"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们为“泛型类型” "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Salary"},{"Type":"NodeText","Data":"​ 定义一个方法 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Min"},{"Type":"NodeText","Data":"​，细心的读者朋友们应该已经发现，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"方法的接收者除了类型名称之外，还有类型参数的形参 "},{"Type":"NodeTextMark","TextMarkType":"code strong","TextMarkTextContent":"*Salary[T]"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"。"}]},{"ID":"20231215144459-3mczqp9","Type":"NodeParagraph","Properties":{"id":"20231215144459-3mczqp9","updated":"20231215144638"},"Children":[{"Type":"NodeText","Data":"除此之外，语法上没有太大区别，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"需要注意的是“泛型方法”不能像“泛型函数”那样，具有自身的类型参数，以下代码目前是不支持的。"}]},{"ID":"20231215144639-0p3dst0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215144639-0p3dst0","updated":"20231215144649"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\nfunc (s *Salary[T]) Min[T1 int](x, y T) T {\n    if x \u003c y {\n        return x\n    }\n    return y\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215144750-67d4ry1","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231215144750-67d4ry1","updated":"20231215144750"},"Children":[{"Type":"NodeText","Data":" 总结"}]},{"ID":"20231215144750-dntcgj2","Type":"NodeParagraph","Properties":{"id":"20231215144750-dntcgj2","updated":"20231215144750"},"Children":[{"Type":"NodeText","Data":"本文我们介绍 Go v1.18 新增的“泛型”功能，介绍类型参数的语法和在函数、自定义类型和类型方法中的使用方式。"}]},{"ID":"20231215144750-xzxk290","Type":"NodeParagraph","Properties":{"id":"20231215144750-xzxk290","updated":"20231215144750"},"Children":[{"Type":"NodeText","Data":"阅读完本文，读者朋友们应该对“泛型”有初步认识，并且可以简单运用。建议读者朋友们检查一下自己的项目代码，寻找可以使用“泛型”优化的代码片段。"}]}]}