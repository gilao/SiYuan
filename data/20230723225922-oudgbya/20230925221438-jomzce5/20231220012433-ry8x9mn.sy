{"ID":"20231220012433-ry8x9mn","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f5fd","id":"20231220012433-ry8x9mn","tags":"公众号-Golang语言开发栈,需要仔细看","title":"Golang 语言 method 接收者使用值类型和指针类型的区别","updated":"20231220014525"},"Children":[{"ID":"20231220012433-2ymp8wa","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220012433-2ymp8wa","updated":"20231220013031"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20231220013032-oryjbi0","Type":"NodeParagraph","Properties":{"id":"20231220013032-oryjbi0","updated":"20231220013056"},"Children":[{"Type":"NodeText","Data":"在 Golang 语言中，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"function 的参数和 method 的接收者都可以选择使用值传递和指针传递（“引用传递”），需要注意的是，其中指针传递是传递的指针值的副本，而不是指针指向的数据的副本。"},{"Type":"NodeText","Data":"也就是说 Golang 语言和 C 系的所有语言相同，一切传递都是值传递。本文我们主要介绍 method 的接收者怎么选择使用值类型和指针类型。"}]},{"ID":"20231220013058-5ruaosr","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220013058-5ruaosr","updated":"20231220013130"},"Children":[{"Type":"NodeText","Data":"method 接收者的类型选择"}]},{"ID":"20231220013135-z5qjk45","Type":"NodeParagraph","Properties":{"id":"20231220013135-z5qjk45","updated":"20231220013135"},"Children":[{"Type":"NodeText","Data":"在使用关键字 type 定义的类型上定义 method，method 的接收者也可以作为 method 的参数，类似于 function 的参数，所以 method 的接收者和 function 参数一样，我们也需要考虑选择使用值类型和指针类型。"}]},{"ID":"20231220013135-4ivbgbc","Type":"NodeParagraph","Properties":{"id":"20231220013135-4ivbgbc","updated":"20231220013505"},"Children":[{"Type":"NodeText","Data":"关于这个问题，我们通常会从两方面去考虑"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"一是如果该 method 需要修改接收者，那么接收者必须使用指针类型；二是如果接收者占用的内存大小较大，出于性能考虑，我们也会选择使用指针类型的接收者"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"text","TextMarkTextContent":"。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20231220013135-ypizqa0","Type":"NodeParagraph","Properties":{"id":"20231220013135-ypizqa0","updated":"20231220013600"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"除此之外，我们还需考虑一致性。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeText","Data":"也就是说，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"strong text","TextMarkTextContent":"如果该类型的某些 method 必须使用指针类型的接收者，其他 method 也应该使用指针类型的接收者。因此无论如何使用该类型，它的方法集都是一致的。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20231220013135-yts5eza","Type":"NodeParagraph","Properties":{"id":"20231220013135-yts5eza","updated":"20231220013700"},"Children":[{"Type":"NodeText","Data":"最后，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果接收者是基本类型，切片和小结构体，他们的值类型的内存占用较低，并且易读。所以，该情况下除非 method 的语义需要必须使用指针类型的接收者，否则，我们可以选择使用值类型的接收者。"}]},{"ID":"20231220013223-sh6b7mj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220013223-sh6b7mj","updated":"20231220014502"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\ntype User struct {\n name string\n}\n\nfunc (u User) SetNameValueType(str string) {\n fmt.Printf(\"SetNameValueType() pointer:%p\\n\", \u0026u) // SetNameValueType() pointer:0xc000096240\n u.name = str\n}\n\nfunc (u *User) SetNamePointerType(str string) {\n fmt.Printf(\"SetNamePointerType() pointer:%p\\n\", u) // SetNamePointerType() pointer:0xc000096220\n u.name = str\n}\n\nfunc main () {\n user1 := \u0026User{}\n fmt.Printf(\"pointer:%p\\n\", user1) // pointer:0xc000096220\n fmt.Println(user1) // \u0026{}\n user1.SetNameValueType(\"lucy\")\n fmt.Println(user1) // \u0026{}\n user1.SetNamePointerType(\"lily\")\n fmt.Println(user1) // \u0026{lily}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220013223-m1ow7b8","Type":"NodeParagraph","Properties":{"id":"20231220013223-m1ow7b8","updated":"20231220013223"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们可以发现值类型的接收者，调用方拷贝了副本；指针类型的接收者，调用方未拷贝副本。"}]},{"ID":"20231220013712-a71sjto","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220013712-a71sjto","updated":"20231220013719"},"Children":[{"Type":"NodeText","Data":"复合类型"}]},{"ID":"20231220013729-7n47a2u","Type":"NodeParagraph","Properties":{"id":"20231220013729-7n47a2u","updated":"20231220013757"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"map 和 slice 值类似于指针：它们是包含指向底层 map 或 slice 数据的指针的描述符。复制 map 或 slice 值不会复制它指向的数据。需要注意的是，如果超过 slice 的容量，运行时会重新分配一个新内存地址。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20231220013729-rbysncf","Type":"NodeParagraph","Properties":{"id":"20231220013729-rbysncf","updated":"20231220013729"},"Children":[{"Type":"NodeText","Data":"map 源码："}]},{"ID":"20231220013729-ncv2zkc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220013729-ncv2zkc","updated":"20231220014456"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type hmap struct {\n count     int // # live cells == size of map.  Must be first (used by len() builtin)\n flags     uint8\n B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)\n noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details\n hash0     uint32 // hash seed\n\n buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.\n oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing\n nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)\n\n extra *mapextra // optional fields\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220013729-lun5bzs","Type":"NodeParagraph","Properties":{"id":"20231220013729-lun5bzs","updated":"20231220013729"},"Children":[{"Type":"NodeText","Data":"slice 源码："}]},{"ID":"20231220013729-drymnb2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220013729-drymnb2","updated":"20231220014451"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type slice struct {\n array unsafe.Pointer\n len   int\n cap   int\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220013729-kxl7cus","Type":"NodeParagraph","Properties":{"id":"20231220013729-kxl7cus","updated":"20231220013729"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20231220013729-mdlgcs6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220013729-mdlgcs6","updated":"20231220014447"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main () {\n user1 := \u0026User{}\n fmt.Printf(\"pointer:%p\\n\", user1) // pointer:0xc000096220\n fmt.Println(user1) // \u0026{}\n user1.SetNameValueType(\"lucy\")\n fmt.Println(user1) // \u0026{}\n user1.SetNamePointerType(\"lily\")\n fmt.Println(user1) // \u0026{lily}\n\n // m := make(map[int]int)\n m := map[int]int{}\n fmt.Printf(\"map pointer:%p\\n\", m) // map pointer:0xc000100180\n m[0] = 1\n fmt.Printf(\"map pointer:%p\\n\", m) // map pointer:0xc000100180\n m[1] = 2\n\n s := make([]int, 0, 1)\n fmt.Printf(\"slice pointer:%p\\n\", s) // slice pointer:0xc00001c0a0\n s = append(s, 1)\n fmt.Printf(\"slice pointer:%p\\n\", s) // slice pointer:0xc00001c0a0\n s = append(s, 2)\n fmt.Printf(\"slice pointer:%p\\n\", s) // slice pointer:0xc00001c0b0\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220013729-ebdjcly","Type":"NodeParagraph","Properties":{"id":"20231220013729-ebdjcly","updated":"20231220014142"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们可以发现 "},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"map 类型未分配新内存地址，使用 append 函数向 slice 中追加元素，当元素个数未超出其容量之前，slice 也未分配新内存地址。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20231220013729-nr6uzd7","Type":"NodeParagraph","Properties":{"id":"20231220013729-nr6uzd7","updated":"20231220014203"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"strong text","TextMarkTextContent":"关于接口类型，复制接口值将复制存储在接口值中的对象。如果接口值持有一个结构体，则复制接口值会复制该结构体。如果接口值持有指针，则复制接口值会复制指针，但不会复制它指向的数据。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20231220014203-o5701jb","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220014203-o5701jb","updated":"20231220014239"},"Children":[{"Type":"NodeText","Data":"值类型怎么避免拷贝副本"}]},{"ID":"20231220014254-awp2x97","Type":"NodeParagraph","Properties":{"id":"20231220014254-awp2x97","updated":"20231220014254"},"Children":[{"Type":"NodeText","Data":"阅读到这里，读者朋友可能会简单认为使用值类型会拷贝副本，使用指针类型不会拷贝副本。实际上，我们可以通过优化代码，在不改变语义的前提下，实现使用值类型也不会拷贝副本。"}]},{"ID":"20231220014254-uxy7hbw","Type":"NodeParagraph","Properties":{"id":"20231220014254-uxy7hbw","updated":"20231220014254"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20231220014254-btuia0e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220014254-btuia0e","updated":"20231220014434"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type User struct {\n name string\n}\n\nfunc (u User) SetNameValueType(str string) {\n fmt.Printf(\"SetNameValueType() pointer:%p\\n\", \u0026u) // SetNameValueType() pointer:0xc000096240\n u.name = str\n}\n\nfunc (u User) ValueSetName(str string) User {\n u.name = str\n return u\n}\n\nfunc main () {\n user2 := \u0026User{}\n fmt.Printf(\"user2 pointer:%p\\n\", user2) // user2 pointer:0xc000010290\n user2.SetNameValueType(\"tom\") // SetNameValueType() pointer:0xc0000102a0\n\n user3 := \u0026User{}\n fmt.Printf(\"user3 pointer:%p\\n\", user3) // user3 pointer:0xc0000102b0\n user3.ValueSetName(\"bob\")\n fmt.Printf(\"pointer:%p\\n\", user3) // pointer:0xc0000102b0\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220014254-cai0mpl","Type":"NodeParagraph","Properties":{"id":"20231220014254-cai0mpl","updated":"20231220014254"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们发现 User 的 SetNameValueType 方法和 ValueSetName 方法，二者都是值传递，但是 SetNameValueType 方法会拷贝副本，ValueSetName 方法不会拷贝副本。原因是我们给 ValueSetName 方法定义了一个 User 类型的返回值，从而避免了 ValueSetName 方法拷贝副本。"}]},{"ID":"20231220014509-7ipbf6k","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220014509-7ipbf6k","updated":"20231220014515"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20231220014516-pn2wdpp","Type":"NodeParagraph","Properties":{"id":"20231220014516-pn2wdpp","updated":"20231220014525"},"Children":[{"Type":"NodeText","Data":"本文我们主要介绍了 method 的接收者使用值传递和指针传递的区别，并且讲述了选择使用值传递和指针传递需要考虑的决定因素，也指出了复合类型与值类型的区别。最后，使用一个简单示例演示了通过优化代码，在不改变语义的前提下，怎么实现使用值类型也不会拷贝副本。"}]}]}