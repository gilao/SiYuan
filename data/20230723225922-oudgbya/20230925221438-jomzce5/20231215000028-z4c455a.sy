{"ID":"20231215000028-z4c455a","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f9a4","id":"20231215000028-z4c455a","tags":"Go,Go 1.21.0版本变化","title":"Go 1.21.0 新增 3 个内置函数详解","updated":"20231215014028"},"Children":[{"ID":"20231215000028-ovnhp4e","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231215000028-ovnhp4e","updated":"20231215000135"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20231215000139-zmu2q4q","Type":"NodeParagraph","Properties":{"id":"20231215000139-zmu2q4q","updated":"20231215000139"},"Children":[{"Type":"NodeText","Data":"Go 1.21.0 新增 3 个内置函数，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"max"},{"Type":"NodeText","Data":"​ 函数，返回 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"N"},{"Type":"NodeText","Data":"​ 个入参中最小/最大的参数，参数类型为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Ordered"},{"Type":"NodeText","Data":"​（有序类型，即支持比较运算符的类型）。"}]},{"ID":"20231215000139-njqk6e6","Type":"NodeParagraph","Properties":{"id":"20231215000139-njqk6e6","updated":"20231215000139"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear"},{"Type":"NodeText","Data":"​ 函数，删除 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​ 中的所有元素，将切片中的所有元素改为切片类型的零值。"}]},{"ID":"20231215000139-yn3cf1y","Type":"NodeParagraph","Properties":{"id":"20231215000139-yn3cf1y","updated":"20231215000139"},"Children":[{"Type":"NodeText","Data":"本文我们详细介绍 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"max"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear"},{"Type":"NodeText","Data":"​ 的使用方式。"}]},{"ID":"20231215000140-og94oo5","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231215000140-og94oo5","updated":"20231215000150"},"Children":[{"Type":"NodeText","Data":"Min and max"}]},{"ID":"20231215000200-rsp3mtz","Type":"NodeParagraph","Properties":{"id":"20231215000200-rsp3mtz","updated":"20231215000200"},"Children":[{"Type":"NodeText","Data":"源码"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"/usr/local/go/src/builtin/builtin.go"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231215000201-zonjmnh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215000201-zonjmnh","updated":"20231215000207"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// The max built-in function returns the largest value of a fixed number of\n// arguments of [cmp.Ordered] types. There must be at least one argument.\n// If T is a floating-point type and any of the arguments are NaNs,\n// max will return NaN.\nfunc max[T cmp.Ordered](x T, y ...T) T\n\n// The min built-in function returns the smallest value of a fixed number of\n// arguments of [cmp.Ordered] types. There must be at least one argument.\n// If T is a floating-point type and any of the arguments are NaNs,\n// min will return NaN.\nfunc min[T cmp.Ordered](x T, y ...T) T\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215000215-6zn2dn3","Type":"NodeParagraph","Properties":{"id":"20231215000215-6zn2dn3","updated":"20231215000215"},"Children":[{"Type":"NodeText","Data":"阅读源码，我们可以发现其是泛型函数，入参是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[cmp.Ordered]"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"cmp"},{"Type":"NodeText","Data":"​ 包也是 Go 1.21.0 新增的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"package"},{"Type":"NodeText","Data":"​，它提供 3 个函数，分别是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Less"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Compare"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"isNaN"},{"Type":"NodeText","Data":"​，感兴趣的读者朋友们可以阅读源码，本文将不展开介绍 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"cmp"},{"Type":"NodeText","Data":"​ 包提供的函数。"}]},{"ID":"20231215000215-vxvensq","Type":"NodeParagraph","Properties":{"id":"20231215000215-vxvensq","updated":"20231215000215"},"Children":[{"Type":"NodeText","Data":"如果读者朋友们还不熟悉泛型，建议先阅读之前的一篇介绍泛型的文章「"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==\u0026amp;mid=2247486861\u0026amp;idx=1\u0026amp;sn=2ceac03668f74305f376ce23fed4885b\u0026amp;chksm=9f81a7e3a8f62ef5d2dfcbcca483a7cb7d9f90349b29982cdff4c6c535e2416ad4bc8d109e7d\u0026amp;scene=21#wechat_redirect","TextMarkTextContent":"Go 1.18 新增三大功能之一“泛型”怎么使用？"},{"Type":"NodeText","Data":"」。"}]},{"ID":"20231215004041-p7huo8f","Type":"NodeParagraph","Properties":{"id":"20231215004041-p7huo8f","updated":"20231215004046"},"Children":[{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[cmp.Ordered]"},{"Type":"NodeText","Data":"​类型源码："}]},{"ID":"20231215004047-mgigu8e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215004047-mgigu8e","updated":"20231215004104"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// Ordered is a constraint that permits any ordered type: any type\n// that supports the operators \u003c \u003c= \u003e= \u003e.\n// If future releases of Go add new ordered types,\n// this constraint will be modified to include them.\n//\n// Note that floating-point types may contain NaN (\"not-a-number\") values.\n// An operator such as == or \u003c will always report false when\n// comparing a NaN value with any other value, NaN or not.\n// See the [Compare] function for a consistent way to compare NaN values.\ntype Ordered interface {\n ~int | ~int8 | ~int16 | ~int32 | ~int64 |\n  ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |\n  ~float32 | ~float64 |\n  ~string\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215004159-sse0nb9","Type":"NodeParagraph","Properties":{"id":"20231215004159-sse0nb9","updated":"20231215004159"},"Children":[{"Type":"NodeText","Data":"内置函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"max"},{"Type":"NodeText","Data":"​ 分别计算任意数量（至少有一个参数）的可比较类型参数的最小值和最大值。"}]},{"ID":"20231215004159-9f0qe6e","Type":"NodeParagraph","Properties":{"id":"20231215004159-9f0qe6e","updated":"20231215004159"},"Children":[{"Type":"NodeText","Data":"所谓可比较类型参数，即可以使用运算符比较的参数，比如整型、浮点型、字符串。"}]},{"ID":"20231215004159-fc8mhjl","Type":"NodeParagraph","Properties":{"id":"20231215004159-fc8mhjl","updated":"20231215004159"},"Children":[{"Type":"NodeText","Data":"如果泛型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ 是浮点数类型，并且任意参数是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NaN"},{"Type":"NodeText","Data":"​(\"not-a-number\")，则函数的返回结果是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NaN"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231215004159-kxd9kgi","Type":"NodeParagraph","Properties":{"id":"20231215004159-kxd9kgi","updated":"20231215004159"},"Children":[{"Type":"NodeText","Data":"所谓不可比较类型参数，即不可以使用运算符比较的参数，比如 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"function"},{"Type":"NodeText","Data":"​，它们不可以作为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"max"},{"Type":"NodeText","Data":"​ 的参数。"}]},{"ID":"20231215004218-stqpqdt","Type":"NodeBlockquote","Properties":{"id":"20231215004218-stqpqdt","updated":"20231215004227"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231215004220-3rsm2u6","Type":"NodeParagraph","Properties":{"id":"20231215004220-3rsm2u6","updated":"20231215004227"},"Children":[{"Type":"NodeText","Data":"注意：虽然 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"function"},{"Type":"NodeText","Data":"​ 三种类型不可比较，但是，有个特例，即它们都可以和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nil"},{"Type":"NodeText","Data":"​ 比较。"}]}]},{"ID":"20231215004227-nh5jozj","Type":"NodeParagraph","Properties":{"id":"20231215004227-nh5jozj","updated":"20231215004403"},"Children":[{"Type":"NodeText","Data":"接下来，我们使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"max"},{"Type":"NodeText","Data":"​ 分别计算整型、浮点型、字符串，代码如下："}]},{"ID":"20231215004405-bbbktgi","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215004405-bbbktgi","updated":"20231215004411"},"Children":[{"Type":"NodeText","Data":"示例一："}]},{"ID":"20231215004411-hur6rxl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215004411-hur6rxl","updated":"20231215004418"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    m := min()\n    fmt.Println(m) // invalid operation: not enough arguments for min() (expected 1, found 0)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215004420-g5c6jtd","Type":"NodeParagraph","Properties":{"id":"20231215004420-g5c6jtd","updated":"20231215004845"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们没有传入参数，执行代码，返回错误信息。"}]},{"ID":"20231215004846-4iyjq7s","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215004846-4iyjq7s","updated":"20231215004850"},"Children":[{"Type":"NodeText","Data":"示例二："}]},{"ID":"20231215004851-c4moatw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215004851-c4moatw","updated":"20231215004858"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    s := []int{1, 2, 3}\n    m := min(s...)\n    fmt.Println(m) // invalid operation: invalid use of ... with built-in min\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215004900-yjhgskh","Type":"NodeParagraph","Properties":{"id":"20231215004900-yjhgskh","updated":"20231215004916"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们传入切片类型参数，执行代码，返回错误信息。"}]},{"ID":"20231215004925-2qz6mkn","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215004925-2qz6mkn","updated":"20231215004928"},"Children":[{"Type":"NodeText","Data":"示例三："}]},{"ID":"20231215004928-9va30z3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215004928-9va30z3","updated":"20231215004935"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    var x int\n    m := min(x)\n    fmt.Println(m) // 0\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215004944-kslj962","Type":"NodeParagraph","Properties":{"id":"20231215004944-kslj962","updated":"20231215004944"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们定义一个整型参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":"​，并将其作为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 函数的入参，返回值赋值给参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m"},{"Type":"NodeText","Data":"​，打印 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m"},{"Type":"NodeText","Data":"​ 输出的值为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":"​，即参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":"​ 的值。"}]},{"ID":"20231215004944-31t5lfk","Type":"NodeParagraph","Properties":{"id":"20231215004944-31t5lfk","updated":"20231215004944"},"Children":[{"Type":"NodeText","Data":"根据打印输出结果，我们可以得出结论，当我们给 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 函数仅传入一个参数时，返回结果和入参的值相等，即 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m == x"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231215004947-giq513z","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215004947-giq513z","updated":"20231215004952"},"Children":[{"Type":"NodeText","Data":"示例四："}]},{"ID":"20231215004952-fwlfknr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215004952-fwlfknr","updated":"20231215005003"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    var x, y int = 1, 2\n    m := min(x, y)\n    fmt.Println(m) // 1\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215005008-pq77jby","Type":"NodeParagraph","Properties":{"id":"20231215005008-pq77jby","updated":"20231215005008"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们定义整型参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"y"},{"Type":"NodeText","Data":"​，分别赋值 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"2"},{"Type":"NodeText","Data":"​，并将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"y"},{"Type":"NodeText","Data":"​ 作为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 函数的入参，返回值赋值给参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m"},{"Type":"NodeText","Data":"​，打印 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m"},{"Type":"NodeText","Data":"​ 输出的值为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​，即参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"y"},{"Type":"NodeText","Data":"​ 中值最小的参数的值。"}]},{"ID":"20231215005017-g0xbx0m","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215005017-g0xbx0m","updated":"20231215005021"},"Children":[{"Type":"NodeText","Data":"示例五："}]},{"ID":"20231215005022-w58zv2t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215005022-w58zv2t","updated":"20231215005030"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    c := min(1, 2.0, 3)\n    fmt.Printf(\"%T\\t%v\\n\", c, c) // float64 1\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215005040-tjuisvl","Type":"NodeParagraph","Properties":{"id":"20231215005040-tjuisvl","updated":"20231215005040"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们给 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 函数传入三个参数，分别是整型参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​、浮点型参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"2.0"},{"Type":"NodeText","Data":"​ 和整型参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"3"},{"Type":"NodeText","Data":"​，返回值赋值给参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"c"},{"Type":"NodeText","Data":"​，打印 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"c"},{"Type":"NodeText","Data":"​ 的类型和值，输出结果为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float64 1"},{"Type":"NodeText","Data":"​，即三个参数中值最小的参数的值。"}]},{"ID":"20231215005040-gw71w48","Type":"NodeParagraph","Properties":{"id":"20231215005040-gw71w48","updated":"20231215005040"},"Children":[{"Type":"NodeText","Data":"但是，值最小的参数的类型发生了变化，由整型转换为浮点型，这是因为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 函数中的参数，如果有浮点型参数，则所有参数都会转换为浮点型参数作比较，因为运行该示例代码的电脑是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"64"},{"Type":"NodeText","Data":"​ 位操作系统，所以参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"2.0"},{"Type":"NodeText","Data":"​ 的类型为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float64"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231215005040-0qxngc7","Type":"NodeParagraph","Properties":{"id":"20231215005040-0qxngc7","updated":"20231215005040"},"Children":[{"Type":"NodeText","Data":"如果我们指定浮点数类型，则参数都会转换为指定的浮点数类型参数作比较。"}]},{"ID":"20231215013020-7juo6bk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215013020-7juo6bk","updated":"20231215013027"},"Children":[{"Type":"NodeText","Data":"示例六："}]},{"ID":"20231215013028-pku43bb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215013028-pku43bb","updated":"20231215013045"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    t := min(\"foo\", \"bar\")\n    fmt.Println(t) // bar\n    t1 := min(\"\", \"foo\", \"bar\")\n    fmt.Println(t) // \"\"\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215013052-p1xxxpy","Type":"NodeParagraph","Properties":{"id":"20231215013052-p1xxxpy","updated":"20231215013052"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们给 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 函数传入两个参数，分别是字符串 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"foo"},{"Type":"NodeText","Data":"​ 和字符串 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bar"},{"Type":"NodeText","Data":"​，返回值赋值为参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"t"},{"Type":"NodeText","Data":"​，打印 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"t"},{"Type":"NodeText","Data":"​ 输出的值为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bar"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231215013052-ruujod6","Type":"NodeParagraph","Properties":{"id":"20231215013052-ruujod6","updated":"20231215013052"},"Children":[{"Type":"NodeText","Data":"我们给 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 函数传入三个参数，分别是空字符串、字符串 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"foo"},{"Type":"NodeText","Data":"​ 和字符串 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bar"},{"Type":"NodeText","Data":"​，返回值赋值给参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"t1"},{"Type":"NodeText","Data":"​，打印 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"t1"},{"Type":"NodeText","Data":"​ 输出的值为空字符串。"}]},{"ID":"20231215013052-yfdj5sy","Type":"NodeParagraph","Properties":{"id":"20231215013052-yfdj5sy","updated":"20231215013052"},"Children":[{"Type":"NodeText","Data":"根据 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"t"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"t1"},{"Type":"NodeText","Data":"​ 的值，我们可以得出结论，即如果 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 函数的入参为字符串类型的参数，则按照字典序返回最小的字符串，如果有空字符串，则返回空字符串。"}]},{"ID":"20231215013157-zhszjxq","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215013157-zhszjxq","updated":"20231215013205"},"Children":[{"Type":"NodeText","Data":"示例七："}]},{"ID":"20231215013206-ri1u9v4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215013206-ri1u9v4","updated":"20231215013214"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    m := min(3.14, math.NaN(), 1.0)\n    fmt.Println(m) // NaN\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215013221-wioogqw","Type":"NodeParagraph","Properties":{"id":"20231215013221-wioogqw","updated":"20231215013221"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，参数为浮点数类型，包含 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NaN"},{"Type":"NodeText","Data":"​，返回结果则是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NaN"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231215013221-d89wdj7","Type":"NodeParagraph","Properties":{"id":"20231215013221-d89wdj7","updated":"20231215013221"},"Children":[{"Type":"NodeText","Data":"函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"max"},{"Type":"NodeText","Data":"​ 和函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 的使用方式相同，返回结果相反。"}]},{"ID":"20231215013221-qs5w6ro","Type":"NodeParagraph","Properties":{"id":"20231215013221-qs5w6ro","updated":"20231215013221"},"Children":[{"Type":"NodeText","Data":"在项目开发中，我们可以使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"max"},{"Type":"NodeText","Data":"​ 直接比较一组数据，得出最小/最大的结果值，而不再需要循环遍历。"}]},{"ID":"20231215013221-tniltif","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215013221-tniltif","updated":"20231215013221"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"特别提示："}]},{"ID":"20231215013221-skkiy3y","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231215013221-skkiy3y","updated":"20231215013221"},"Children":[{"ID":"20231215013221-m1kz8h9","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231215013221-m1kz8h9","updated":"20231215013221"},"Children":[{"ID":"20231215013221-t41si2l","Type":"NodeParagraph","Properties":{"id":"20231215013221-t41si2l","updated":"20231215013221"},"Children":[{"Type":"NodeText","Data":"整型参数，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"max"},{"Type":"NodeText","Data":"​ 的参数可以交换和组合。"}]}]},{"ID":"20231215013221-k9ilxlq","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231215013221-k9ilxlq","updated":"20231215013221"},"Children":[{"ID":"20231215013221-4oll3n6","Type":"NodeParagraph","Properties":{"id":"20231215013221-4oll3n6","updated":"20231215013221"},"Children":[{"Type":"NodeText","Data":"字符串类型参数，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"max"},{"Type":"NodeText","Data":"​ 的参数逐个字节比较，得出最小/最大的字符串，参数可以交换和组合。"}]}]},{"ID":"20231215013221-xaeucs1","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20231215013221-xaeucs1","updated":"20231215013221"},"Children":[{"ID":"20231215013221-4baaiuk","Type":"NodeParagraph","Properties":{"id":"20231215013221-4baaiuk","updated":"20231215013221"},"Children":[{"Type":"NodeText","Data":"浮点型参数"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-0.0"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0.0"},{"Type":"NodeText","Data":"​ 作为参数，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-0.0"},{"Type":"NodeText","Data":"​ 小于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0.0"},{"Type":"NodeText","Data":"​；负无穷大，小于任意其它数值；正无穷大，大于任意其它数值。"}]}]},{"ID":"20231215013221-ti16xrm","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20231215013221-ti16xrm","updated":"20231215013221"},"Children":[{"ID":"20231215013221-0ut4o0y","Type":"NodeParagraph","Properties":{"id":"20231215013221-0ut4o0y","updated":"20231215013221"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"max"},{"Type":"NodeText","Data":"​ 的任意参数是 NaN"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[1]"},{"Type":"NodeText","Data":"，则返回结果是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NaN"},{"Type":"NodeText","Data":"​ (\"not-a-number\") 值。"}]}]}]},{"ID":"20231215013621-597jqj1","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231215013621-597jqj1","updated":"20231215013649"},"Children":[{"Type":"NodeText","Data":"Clear"}]},{"ID":"20231215013649-pzjg4q2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215013649-pzjg4q2","updated":"20231215013706"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// The clear built-in function clears maps and slices.\n// For maps, clear deletes all entries, resulting in an empty map.\n// For slices, clear sets all elements up to the length of the slice\n// to the zero value of the respective element type. If the argument\n// type is a type parameter, the type parameter's type set must\n// contain only map or slice types, and clear performs the operation\n// implied by the type argument.\nfunc clear[T ~[]Type | ~map[Type]Type1](t T)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215013716-kyol6yp","Type":"NodeParagraph","Properties":{"id":"20231215013716-kyol6yp","updated":"20231215013716"},"Children":[{"Type":"NodeText","Data":"阅读源码，我们可以发现 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear"},{"Type":"NodeText","Data":"​ 也是泛型函数，入参为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"type parameter"},{"Type":"NodeText","Data":"​ （类型参数），如果是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​，则删除 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​ 中的所有元素，返回一个空 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​；如果是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":"​，则将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":"​ 中的所有元素改为切片类型的零值。"}]},{"ID":"20231215013716-rydnqow","Type":"NodeParagraph","Properties":{"id":"20231215013716-rydnqow","updated":"20231215013716"},"Children":[{"Type":"NodeText","Data":"需要注意的是，如果函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear"},{"Type":"NodeText","Data":"​ 的入参是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"type parameter"},{"Type":"NodeText","Data":"​ （类型参数），则类型参数的集合必须仅包含 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​ 或 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":"​，函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear"},{"Type":"NodeText","Data":"​ 则按照类型参数集合中的字段类型，执行相应的操作。"}]},{"ID":"20231215013855-fqmuy99","Type":"NodeBlockquote","Properties":{"id":"20231215013855-fqmuy99","updated":"20231215013858"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231215013857-l2ovp6f","Type":"NodeParagraph","Properties":{"id":"20231215013857-l2ovp6f","updated":"20231215013858"},"Children":[{"Type":"NodeText","Data":"注意：如果 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":"​ 为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nil"},{"Type":"NodeText","Data":"​，函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear"},{"Type":"NodeText","Data":"​ 的执行则是无效操作。"}]}]},{"ID":"20231215013900-uci7qco","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215013900-uci7qco","updated":"20231215013904"},"Children":[{"Type":"NodeText","Data":"示例一"}]},{"ID":"20231215013933-e4o0u8e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215013933-e4o0u8e","updated":"20231215013945"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    s := []int{1, 2, 3}\n    fmt.Printf(\"len=%d\\t s=%+v\\n\", len(s), s) // len=3      s=[1 2 3]\n    clear(s)\n    fmt.Printf(\"len=%d\\t s=%+v\\n\", len(s), s) // len=3      s=[0 0 0]\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215013949-in23rmq","Type":"NodeParagraph","Properties":{"id":"20231215013949-in23rmq","updated":"20231215013949"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们可以发现使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear"},{"Type":"NodeText","Data":"​ 执行的切片，其长度不变，所有元素变为切片类型的零值。"}]},{"ID":"20231215013950-i0imzh3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215013950-i0imzh3","updated":"20231215013956"},"Children":[{"Type":"NodeText","Data":"示例二"}]},{"ID":"20231215013956-ntm8fd3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215013956-ntm8fd3","updated":"20231215014001"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    m := map[string]int{\"go\": 100, \"php\": 80}\n    fmt.Printf(\"len=%d\\tm=%+v\\n\", len(m), m) // len=2   m=map[go:100 php:80]\n    clear(m)\n    fmt.Printf(\"len=%d\\tm=%+v\\n\", len(m), m) // len=0   m=map[]\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215014007-s98p4hs","Type":"NodeParagraph","Properties":{"id":"20231215014007-s98p4hs","updated":"20231215014007"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们可以发现使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear"},{"Type":"NodeText","Data":"​ 执行的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​，其长度变为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":"​，所有元素被删除。"}]},{"ID":"20231215014008-o33hv6w","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231215014008-o33hv6w","updated":"20231215014012"},"Children":[{"Type":"NodeText","Data":"示例三："}]},{"ID":"20231215014013-67ch9n0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231215014013-67ch9n0","updated":"20231215014021"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n    d := []Data{\n        {\n            User:   map[int]string{1: \"frank\", 2: \"lucy\"},\n            Salary: map[string]int{\"frank\": 1000, \"lucy\": 2000},\n        },\n    }\n    fmt.Printf(\"d=%+v\\n\", d) // d=[{User:map[1:frank 2:lucy] Salary:map[frank:1000 lucy:2000]}]\n    clear(d)\n    fmt.Printf(\"d=%+v\\n\", d) // d=[{User:map[] Salary:map[]}]\n  \n    d1 := []Data1{\n        {\n            User:   \"frank\",\n            Salary: 1000,\n        },\n    }\n    fmt.Printf(\"d1=%+v\\n\", d1) // d1=[{User:frank Salary:1000}]\n    clear(d1)\n    fmt.Printf(\"d1=%+v\\n\", d1) // d1=[{User: Salary:0}]\n}\n\ntype Data struct {\n    User   map[int]string\n    Salary map[string]int\n}\n\ntype Data1 struct {\n    User   string\n    Salary int\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231215014028-p6famrs","Type":"NodeParagraph","Properties":{"id":"20231215014028-p6famrs","updated":"20231215014028"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们可以发现使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear"},{"Type":"NodeText","Data":"​ 执行类型参数集合参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"d"},{"Type":"NodeText","Data":"​ 的类型是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":"​ ， "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":"​类型的参数类型是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"struct"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"struct"},{"Type":"NodeText","Data":"​ 的字段类型为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​，返回结果是按照 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"struct"},{"Type":"NodeText","Data":"​ 的字段类型做相应处理，该示例是删除 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​ 中的所有元素；参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"d1"},{"Type":"NodeText","Data":"​ 同理。"}]},{"ID":"20231215014028-qpbsjur","Type":"NodeParagraph","Properties":{"id":"20231215014028-qpbsjur","updated":"20231215014028"},"Children":[{"Type":"NodeText","Data":"关于类型参数的示例，阅读起来比较烧脑，建议读者朋友们运行代码加深理解。"}]},{"ID":"20231215014028-0n16kvu","Type":"NodeParagraph","Properties":{"id":"20231215014028-0n16kvu","updated":"20231215014028"},"Children":[{"Type":"NodeText","Data":"在项目开发中，我们可以使用函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear"},{"Type":"NodeText","Data":"​ 删除 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​ 中的元素，替代通过循环遍历调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"delete"},{"Type":"NodeText","Data":"​ 删除 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​ 中的元素；使用函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear"},{"Type":"NodeText","Data":"​ 将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":"​ 中的元素的值修改为切片类型的零值，替代通过循环遍历修改切片中的元素的值为切片类型的零值。"}]}]}