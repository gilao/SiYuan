{"ID":"20231220011321-4x1ra6q","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f416","id":"20231220011321-4x1ra6q","tags":"公众号-Golang语言开发栈,Go-Mutex,Go-RWMutex","title":"Golang 语言中基础同步原语 Mutex 和 RWMutex 的区别","updated":"20231220012409"},"Children":[{"ID":"20231220011321-q8v4zyj","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220011321-q8v4zyj","updated":"20231220011420"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20231220011426-4l5r2qq","Type":"NodeParagraph","Properties":{"id":"20231220011426-4l5r2qq","updated":"20231220011445"},"Children":[{"Type":"NodeText","Data":"Golang 语言天生支持并发，关于并发编程，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"Golang 语言还有一句口号：“不要通过共享内存进行通信；而是通过通信共享内存”。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20231220011426-550gusz","Type":"NodeParagraph","Properties":{"id":"20231220011426-550gusz","updated":"20231220011426"},"Children":[{"Type":"NodeText","Data":"但是，通过“共享内存进行通信”的方式作为并发编程的解决方案在传统的编程语言中更为流行。在 Golang 语言标准库 sync 包中也提供了“通过共享内存进行通信”的并发编程解决方案。"}]},{"ID":"20231220011426-73ysh0f","Type":"NodeParagraph","Properties":{"id":"20231220011426-73ysh0f","updated":"20231220011426"},"Children":[{"Type":"NodeText","Data":"其中，在 sync 包中最重要的同步工具就是 "},{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==\u0026amp;mid=2247484031\u0026amp;idx=1\u0026amp;sn=7b6728f4f781a6fcdcf1986404b1ad59\u0026amp;chksm=9f81a811a8f62107bbc39e6dbf0aa22dfa679b3a5dc0bf4b2115403d05d4a33110709323f1fb\u0026amp;scene=21#wechat_redirect","TextMarkTextContent":"sync.Mutex"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==\u0026amp;mid=2247484049\u0026amp;idx=1\u0026amp;sn=5a49b5a9d19891fb3b92c8612a594e74\u0026amp;chksm=9f81a8ffa8f621e98d5b4758bea5bb337f8e152c293fa1e2532c84eb3379ab9ae2ea1a15e67e\u0026amp;scene=21#wechat_redirect","TextMarkTextContent":"sync.RWMutex"},{"Type":"NodeText","Data":"​。因为在之前的文章已经介绍过二者的使用，所以本文我们不再赘述。本文主要介绍使用二者的注意事项和二者的区别。"}]},{"ID":"20231220011505-pdn2a75","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220011505-pdn2a75","updated":"20231220011511"},"Children":[{"Type":"NodeText","Data":"Mutex"}]},{"ID":"20231220011519-pln3pnx","Type":"NodeParagraph","Properties":{"id":"20231220011519-pln3pnx","updated":"20231220011519"},"Children":[{"Type":"NodeText","Data":"Mutex 也称为互斥锁，互斥锁就是互相排斥的锁，它可以用作保护临界区的共享资源，保证同一时刻只有一个 goroutine 操作临界区中的共享资源。互斥锁 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​ 类型有两个方法，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Unlock"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231220011519-9x6suct","Type":"NodeParagraph","Properties":{"id":"20231220011519-9x6suct","style":"color: var(--b3-font-color6);","updated":"20231220011519"},"Children":[{"Type":"NodeText","Data":"使用互斥锁的注意事项："}]},{"ID":"20231220011519-jjum0fq","Type":"NodeList","ListData":{},"Properties":{"id":"20231220011519-jjum0fq","style":"color: var(--b3-font-color6);","updated":"20231220011841"},"Children":[{"ID":"20231220011519-175cklo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011519-175cklo","style":"color: var(--b3-font-color6);","updated":"20231220011519"},"Children":[{"ID":"20231220011519-arqp1eh","Type":"NodeParagraph","Properties":{"id":"20231220011519-arqp1eh","updated":"20231220011519"},"Children":[{"Type":"NodeText","Data":"Mutex 类型变量的零值是一个未锁定状态的互斥锁。"}]}]},{"ID":"20231220011519-d1xrij6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011519-d1xrij6","style":"color: var(--b3-font-color6);","updated":"20231220011841"},"Children":[{"ID":"20231220011519-ke7ilyo","Type":"NodeParagraph","Properties":{"id":"20231220011519-ke7ilyo","updated":"20231220011841"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"strong text","TextMarkTextContent":"Mutex 在首次被使用之后就不能再被拷贝（Mutex 是值类型，拷贝会同时拷贝互斥锁的状态）。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]}]},{"ID":"20231220011519-peirq2b","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011519-peirq2b","style":"color: var(--b3-font-color6);","updated":"20231220011519"},"Children":[{"ID":"20231220011519-w1lae1t","Type":"NodeParagraph","Properties":{"id":"20231220011519-w1lae1t","updated":"20231220011519"},"Children":[{"Type":"NodeText","Data":"Mutex 在未锁定状态（还未锁定或已被解锁），调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Unlock"},{"Type":"NodeText","Data":"​ 方法，将会引发运行时错误。"}]}]},{"ID":"20231220011519-9l11b0p","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011519-9l11b0p","style":"color: var(--b3-font-color6);","updated":"20231220011519"},"Children":[{"ID":"20231220011519-3uf5bil","Type":"NodeParagraph","Properties":{"id":"20231220011519-3uf5bil","updated":"20231220011519"},"Children":[{"Type":"NodeText","Data":"Mutex 的锁定状态与特定 goroutine 没有关联，Mutex 被一个 goroutine 锁定， 可以被另外一个 goroutine 解锁。（不建议使用，必须使用时需要格外小心。）"}]}]},{"ID":"20231220011519-okpa8ob","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011519-okpa8ob","style":"color: var(--b3-font-color6);","updated":"20231220011519"},"Children":[{"ID":"20231220011519-w2kzj0w","Type":"NodeParagraph","Properties":{"id":"20231220011519-w2kzj0w","updated":"20231220011519"},"Children":[{"Type":"NodeText","Data":"Mutex 的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"​ 方法和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Unlock"},{"Type":"NodeText","Data":"​ 方法要成对使用，不要忘记将锁定的互斥锁解锁，一般做法是使用 defer。"}]}]}]},{"ID":"20231220011519-emdhh5y","Type":"NodeParagraph","Properties":{"id":"20231220011519-emdhh5y","updated":"20231220011519"},"Children":[{"Type":"NodeText","Data":"互斥锁源码："}]},{"ID":"20231220011545-7b42tv1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220011545-7b42tv1","updated":"20231220011650"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Mutex struct {\n  state int32 // 互斥锁的状态\n  sema uint32 // 信号量，用于控制互斥锁的状态\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220011652-xxdx4rd","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220011652-xxdx4rd","updated":"20231220011720"},"Children":[{"Type":"NodeText","Data":"RWMutex"}]},{"ID":"20231220011720-p1laqzp","Type":"NodeParagraph","Properties":{"id":"20231220011720-p1laqzp","updated":"20231220011815"},"Children":[{"Type":"NodeText","Data":"RWMutex 也称为读写互斥锁，读写互斥锁就是读取/写入互相排斥的锁。它可以由任意数量的读取操作的 goroutine 或单个写入操作的 goroutine 持有。读写互斥锁 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RWMutex"},{"Type":"NodeText","Data":"​ 类型有五个方法，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Unlock"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rlock"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RUnlock"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RLocker"},{"Type":"NodeText","Data":"​。其中，RLocker 返回一个 Locker 接口，该接口通过调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"rw.RLock"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"rw.RUnlock"},{"Type":"NodeText","Data":"​ 来实现 Lock 和 Unlock 方法。"}]},{"ID":"20231220011907-x9c58yj","Type":"NodeParagraph","Properties":{"id":"20231220011907-x9c58yj","updated":"20231220011907"},"Children":[{"Type":"NodeText","Data":"使用读写互斥锁的注意事项："}]},{"ID":"20231220011907-9fgy9us","Type":"NodeList","ListData":{},"Properties":{"id":"20231220011907-9fgy9us","updated":"20231220012103"},"Children":[{"ID":"20231220011907-rj7ouy6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011907-rj7ouy6","updated":"20231220011927"},"Children":[{"ID":"20231220011907-7rqt90c","Type":"NodeParagraph","Properties":{"id":"20231220011907-7rqt90c","updated":"20231220011927"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RWMutex 类型变量的零值是一个未锁定状态的互斥锁。"}]}]},{"ID":"20231220011907-iaaelku","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011907-iaaelku","updated":"20231220011951"},"Children":[{"ID":"20231220011907-j69i752","Type":"NodeParagraph","Properties":{"id":"20231220011907-j69i752","updated":"20231220011951"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RWMutex 在首次被使用之后就不能再被拷贝。"}]}]},{"ID":"20231220011907-czx30u9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011907-czx30u9","updated":"20231220011941"},"Children":[{"ID":"20231220011907-gtf5b8b","Type":"NodeParagraph","Properties":{"id":"20231220011907-gtf5b8b","updated":"20231220011941"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"strong text","TextMarkTextContent":"RWMutex 的读锁或写锁在未锁定状态，解锁操作都会引发 panic。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]}]},{"ID":"20231220011907-cy4mefw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011907-cy4mefw","updated":"20231220011959"},"Children":[{"ID":"20231220011907-ac4p392","Type":"NodeParagraph","Properties":{"id":"20231220011907-ac4p392","updated":"20231220011959"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RWMutex 的一个写锁 "},{"Type":"NodeTextMark","TextMarkType":"code strong","TextMarkTextContent":"Lock"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":" 去锁定临界区的共享资源，如果临界区的共享资源已被（读锁或写锁）锁定，这个写锁操作的 goroutine 将被阻塞直到解锁。"}]}]},{"ID":"20231220011907-l9n1ona","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011907-l9n1ona","updated":"20231220012005"},"Children":[{"ID":"20231220011907-luqn16r","Type":"NodeParagraph","Properties":{"id":"20231220011907-luqn16r","updated":"20231220012005"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RWMutex 的读锁不要用于递归调用，比较容易产生死锁。"}]}]},{"ID":"20231220011907-kppmvme","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011907-kppmvme","updated":"20231220012018"},"Children":[{"ID":"20231220011907-uza3gh5","Type":"NodeParagraph","Properties":{"id":"20231220011907-uza3gh5","updated":"20231220012018"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"RWMutex 的锁定状态与特定的 goroutine 没有关联。一个 goroutine 可以 RLock（Lock），另一个 goroutine 可以 RUnlock（Unlock）。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]}]},{"ID":"20231220011907-ubqb3xk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011907-ubqb3xk","updated":"20231220012059"},"Children":[{"ID":"20231220011907-iphmdgv","Type":"NodeParagraph","Properties":{"id":"20231220011907-iphmdgv","updated":"20231220012059"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"写锁被解锁后，所有因操作锁定读锁而被阻塞的 goroutine 会被唤醒，并都可以成功锁定读锁。"}]}]},{"ID":"20231220011907-jly0n46","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220011907-jly0n46","updated":"20231220012103"},"Children":[{"ID":"20231220011907-q67p4xo","Type":"NodeParagraph","Properties":{"id":"20231220011907-q67p4xo","updated":"20231220012103"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"读锁被解锁后，在没有被其他读锁锁定的前提下，所有因操作锁定写锁而被阻塞的 goroutine，其中等待时间最长的一个 goroutine 会被唤醒。"}]}]}]},{"ID":"20231220011907-i1pzjgg","Type":"NodeParagraph","Properties":{"id":"20231220011907-i1pzjgg","updated":"20231220011907"},"Children":[{"Type":"NodeText","Data":"读写互斥锁源码："}]},{"ID":"20231220011907-pjulrrb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220011907-pjulrrb","updated":"20231220011913"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type RWMutex struct {\n w           Mutex  // held if there are pending writers\n writerSem   uint32 // semaphore for writers to wait for completing readers\n readerSem   uint32 // semaphore for readers to wait for completing writers\n readerCount int32  // number of pending readers\n readerWait  int32  // number of departing readers\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220012219-7lfrfj6","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220012219-7lfrfj6","updated":"20231220012238"},"Children":[{"Type":"NodeText","Data":"Mutex 和 RWMutex 的区别"}]},{"ID":"20231220012247-jq26g6f","Type":"NodeParagraph","Properties":{"id":"20231220012247-jq26g6f","updated":"20231220012329"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"strong text","TextMarkTextContent":"RWMutex 和 Mutex 的区别是 RWMutex 将对临界区的共享资源的读写操作做了区分，RWMutex 可以针对读写操作做不同级别的锁保护。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20231220012247-hyton73","Type":"NodeParagraph","Properties":{"id":"20231220012247-hyton73","updated":"20231220012247"},"Children":[{"Type":"NodeText","Data":"RWMutex 读写锁中包含读锁和写锁，它的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Unlock"},{"Type":"NodeText","Data":"​ 方法用作写锁保护，它的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RLock"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RUnlock"},{"Type":"NodeText","Data":"​ 方法用作读锁保护。"}]},{"ID":"20231220012247-39273r2","Type":"NodeParagraph","Properties":{"id":"20231220012247-39273r2","updated":"20231220012247"},"Children":[{"Type":"NodeText","Data":"RWMutex 读写锁中的读锁和写锁关系如下："}]},{"ID":"20231220012247-8oceulo","Type":"NodeList","ListData":{},"Properties":{"id":"20231220012247-8oceulo","updated":"20231220012357"},"Children":[{"ID":"20231220012247-0yy120x","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220012247-0yy120x","updated":"20231220012349"},"Children":[{"ID":"20231220012247-rdrp810","Type":"NodeParagraph","Properties":{"id":"20231220012247-rdrp810","updated":"20231220012349"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在写锁处于锁定状态时，操作锁定读锁的 goroutine 会被阻塞。"}]}]},{"ID":"20231220012247-ot8hoaz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220012247-ot8hoaz","updated":"20231220012353"},"Children":[{"ID":"20231220012247-tdenpud","Type":"NodeParagraph","Properties":{"id":"20231220012247-tdenpud","updated":"20231220012353"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在写锁处于锁定状态时，操作锁定写锁的 goroutine 会被阻塞。"}]}]},{"ID":"20231220012247-3lhtxnf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220012247-3lhtxnf","updated":"20231220012357"},"Children":[{"ID":"20231220012247-qbh2344","Type":"NodeParagraph","Properties":{"id":"20231220012247-qbh2344","updated":"20231220012357"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在读锁处于锁定状态时，操作锁定写锁的 goroutine 会被阻塞。"}]}]}]},{"ID":"20231220012247-v1ihe3y","Type":"NodeParagraph","Properties":{"id":"20231220012247-v1ihe3y","updated":"20231220012247"},"Children":[{"Type":"NodeText","Data":"但是，在读锁处于锁定状态时，操作锁定读锁的 goroutine 不会被阻塞。我们可以理解为读锁保护的临界区的共享资源，多个读操作可以同时执行。"}]},{"ID":"20231220012358-qvjape3","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220012358-qvjape3","updated":"20231220012403"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20231220012409-4tsnuiy","Type":"NodeParagraph","Properties":{"id":"20231220012409-4tsnuiy","updated":"20231220012409"},"Children":[{"Type":"NodeText","Data":"本文我们介绍了 Golang 语言中的基本同步原语互斥锁和读写互斥锁使用时的注意事项，然后总结了二者的区别。读写互斥锁可以对临界区的共享资源做更加细粒度的访问控制，在读锁持有锁时，其他操作读锁的 goroutine 不被被阻塞，（也就是说不限制对临界区的共享资源的并发读）所以在读多写少的场景，我们可以使用读写互斥锁替代互斥锁，提升应用程序的性能。"}]},{"ID":"20231220012409-r8r24m0","Type":"NodeParagraph","Properties":{"id":"20231220012409-r8r24m0","updated":"20231220012409"},"Children":[{"Type":"NodeText","Data":"推荐阅读："}]}]}