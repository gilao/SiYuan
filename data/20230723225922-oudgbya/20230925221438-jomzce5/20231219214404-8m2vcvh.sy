{"ID":"20231219214404-8m2vcvh","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f3bb","id":"20231219214404-8m2vcvh","tags":"公众号-Golang语言开发栈,Go-goroutine,Go-Channel","title":"Go 语言如何通过通信共享内存","updated":"20231219222331"},"Children":[{"ID":"20231219214404-wi833sw","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231219214404-wi833sw","updated":"20231219214756"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20231219214806-bvtd6qp","Type":"NodeParagraph","Properties":{"id":"20231219214806-bvtd6qp","updated":"20231219214806"},"Children":[{"Type":"NodeText","Data":"Go 语言使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​，可以实现通过通信共享内存。"}]},{"ID":"20231219214806-ay5cdhu","Type":"NodeParagraph","Properties":{"id":"20231219214806-ay5cdhu","updated":"20231219214806"},"Children":[{"Type":"NodeText","Data":"本文我们介绍 Go 语言怎么通过通信共享内存。"}]},{"ID":"20231219214811-6t53ktl","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231219214811-6t53ktl","updated":"20231219214845"},"Children":[{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231219214845-l5iwmn6","Type":"NodeParagraph","Properties":{"id":"20231219214845-l5iwmn6","updated":"20231219214916"},"Children":[{"Type":"NodeText","Data":"在了解 Go 语言怎么通过通信共享内存之前。我们需要先了解一些预备知识，即 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 是什么？"}]},{"ID":"20231219215051-1p2ry48","Type":"NodeParagraph","Properties":{"id":"20231219215051-1p2ry48","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":" ："}]},{"ID":"20231219215051-xlne0b8","Type":"NodeParagraph","Properties":{"id":"20231219215051-xlne0b8","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 具有简单的模型：它是与其它 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"并发"},{"Type":"NodeText","Data":"运行在同一地址空间的函数。"}]},{"ID":"20231219215051-wbf4opf","Type":"NodeParagraph","Properties":{"id":"20231219215051-wbf4opf","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 是轻量级的，所有消耗几乎就只有栈空间的分配。而且栈最开始是非常小的，所以他们很廉价，仅在需要时才会随着堆空间的分配（和释放）而变化。"}]},{"ID":"20231219215051-6eylfv2","Type":"NodeParagraph","Properties":{"id":"20231219215051-6eylfv2","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"摘自「Effective Go - channels"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[1]"},{"Type":"NodeText","Data":"」。"}]},{"ID":"20231219215051-b7nhww8","Type":"NodeBlockquote","Properties":{"id":"20231219215051-b7nhww8","updated":"20231219215051"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20231219215051-6bkhvad","Type":"NodeParagraph","Properties":{"id":"20231219215051-6bkhvad","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"注意："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 之所以取名为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​，是因为现有的术语 - 线程、协程、进程等等 - 无法准确传达它的含义。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"也有些资料将 "},{"Type":"NodeTextMark","TextMarkType":"strong code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":" 翻译为 Go 协程或 Go 程。"}]}]},{"ID":"20231219215051-38bkf33","Type":"NodeParagraph","Properties":{"id":"20231219215051-38bkf33","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 也非常简单，在函数或方法前添加 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"go"},{"Type":"NodeText","Data":"​ 关键字，即可在新的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 中调用它。当调用完成后，该 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 也会安静地退出。"}]},{"ID":"20231219215051-ov252hq","Type":"NodeParagraph","Properties":{"id":"20231219215051-ov252hq","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"此外，匿名函数也可以在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 中调用。"}]},{"ID":"20231219215051-wcs1lbi","Type":"NodeParagraph","Properties":{"id":"20231219215051-wcs1lbi","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 的实现原理和调度器模型 GPM，感兴趣的读者朋友们可以自行查阅相关资料。"}]},{"ID":"20231219215051-r6bktm2","Type":"NodeParagraph","Properties":{"id":"20231219215051-r6bktm2","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"："}]},{"ID":"20231219215051-t67282p","Type":"NodeParagraph","Properties":{"id":"20231219215051-t67282p","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"我们已了解，什么是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​，以及怎么使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 调用函数或方法、匿名函数。"}]},{"ID":"20231219215051-qunc11o","Type":"NodeParagraph","Properties":{"id":"20231219215051-qunc11o","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"但是，想要实现 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 之间的通信，我们还需要了解 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231219215051-iq9gsjx","Type":"NodeParagraph","Properties":{"id":"20231219215051-iq9gsjx","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 需要使用内置函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"make"},{"Type":"NodeText","Data":"​ 分配内存，其结果值充当了对底层数据结构的引用。如果提供了一个可选的参数，它就会为该 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 设置缓冲区大小，否则，该 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 则为无缓冲区的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231219215051-4i9fshk","Type":"NodeParagraph","Properties":{"id":"20231219215051-4i9fshk","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 的实现原理，感兴趣的读者朋友们可以阅读「"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==\u0026amp;mid=2247484967\u0026amp;idx=1\u0026amp;sn=0845e77784ae705a06ae920910f58346\u0026amp;scene=21#wechat_redirect","TextMarkTextContent":"Golang 语言中的 channel 实现原理"},{"Type":"NodeText","Data":"」。"}]},{"ID":"20231219215051-wpskx9h","Type":"NodeParagraph","Properties":{"id":"20231219215051-wpskx9h","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"需要注意的是，两个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 之间通过无缓冲区的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 通信时，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"同步"},{"Type":"NodeText","Data":"交换数据。"}]},{"ID":"20231219215051-n5ixuq8","Type":"NodeParagraph","Properties":{"id":"20231219215051-n5ixuq8","updated":"20231219215051"},"Children":[{"Type":"NodeText","Data":"作为两个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 之间的通信管道，向 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 中发送数据的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 称为“发送者”，反之，从 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 中接收数据的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 称为“接收者”。"}]},{"ID":"20231219220155-d1rsap0","Type":"NodeParagraph","Properties":{"id":"20231219220155-d1rsap0"}},{"ID":"20231219220254-8iv28c1","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231219220254-8iv28c1","updated":"20231219220318"},"Children":[{"Type":"NodeText","Data":"通过通信共享内存"}]},{"ID":"20231219220319-v77ncy7","Type":"NodeParagraph","Properties":{"id":"20231219220319-v77ncy7","updated":"20231219220330"},"Children":[{"Type":"NodeText","Data":"我们已经基本了解 Go 语言的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​，接下来我们看一下两个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 之间怎么使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ （无缓冲区和缓冲区）进行通信？"}]},{"ID":"20231219220340-hwea18w","Type":"NodeParagraph","Properties":{"id":"20231219220340-hwea18w","updated":"20231219220340"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"无缓冲区 "},{"Type":"NodeTextMark","TextMarkType":"strong code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"："}]},{"ID":"20231219220340-wslirxw","Type":"NodeParagraph","Properties":{"id":"20231219220340-wslirxw","updated":"20231219220340"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20231219220340-mcoh5ww","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231219220340-mcoh5ww","updated":"20231219220340"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func main() {\n c := make(chan int) // 定义一个无缓冲区 channel\n go func() {         // 启动一个 goroutine 调用匿名函数\n  fmt.Println(\"启动一个 goroutine 调用匿名函数\")\n  c \u003c- 1 // 该 goroutine 向 channel 发送一个值（信号）\n }()\n fmt.Println(\"main 函数\")\n out := \u003c-c // main goroutine 从 channel 中接收一个值（信号），再未接收到值（信号）之前，一直阻塞\n fmt.Println(out) // 该打印无实际意义，仅为了读者容易理解\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231219220340-zgk6lqx","Type":"NodeParagraph","Properties":{"id":"20231219220340-zgk6lqx","updated":"20231219220340"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们定义一个无缓冲区 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​，执行匿名函数的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 作为发送者，main "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 作为接收者。"}]},{"ID":"20231219220340-c8fv5tr","Type":"NodeParagraph","Properties":{"id":"20231219220340-c8fv5tr","updated":"20231219220340"},"Children":[{"Type":"NodeText","Data":"需要注意的是，无缓冲区 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​，接收者在收到值之前，发送者会一直阻塞。同理，发送者在发送值之前，接收者也会一直阻塞。"}]},{"ID":"20231219220340-m1300w5","Type":"NodeParagraph","Properties":{"id":"20231219220340-m1300w5","updated":"20231219220340"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缓冲区 "},{"Type":"NodeTextMark","TextMarkType":"strong code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"："}]},{"ID":"20231219220340-36paxha","Type":"NodeParagraph","Properties":{"id":"20231219220340-36paxha","updated":"20231219220340"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20231219220340-ws8khhm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231219220340-ws8khhm","updated":"20231219220340"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func main() {\n  // c := make(chan int) // 无缓冲区 channel\n c := make(chan int, 5) // 缓冲区 channel\n for i := 0; i \u003c 20; i++ {\n  c \u003c- 1\n  go func() {\n   fmt.Println(\"do something:\", i)\n   \u003c-c\n  }()\n }\n\n time.Sleep(time.Second * 2) // 为了防止 main goroutine 提前退出\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231219220340-6qev80l","Type":"NodeParagraph","Properties":{"id":"20231219220340-6qev80l","updated":"20231219220340"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们定义一个缓冲区大小为 5 的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​，执行匿名函数的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 作为接收者，main "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 作为发送者。"}]},{"ID":"20231219221840-a9iva4l","Type":"NodeParagraph","Properties":{"id":"20231219221840-a9iva4l","updated":"20231219221840"},"Children":[{"Type":"NodeText","Data":"需要注意的是，该段代码中有 5 个执行匿名函数的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​，即 N 个接收者，1 个发送者（main "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​）。"}]},{"ID":"20231219221840-v9mbqgd","Type":"NodeParagraph","Properties":{"id":"20231219221840-v9mbqgd","updated":"20231219221840"},"Children":[{"Type":"NodeText","Data":"我们前面讲过，接收者在收到值之前会一直阻塞，而无缓冲区 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 在接收者收到值之前，发送者会一直阻塞。"}]},{"ID":"20231219221840-g7c16iz","Type":"NodeParagraph","Properties":{"id":"20231219221840-g7c16iz","updated":"20231219221840"},"Children":[{"Type":"NodeText","Data":"如果我们将上面这段代码中的缓冲区 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 换成无缓冲区 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"N - 1"},{"Type":"NodeText","Data":"​ 个接收者在接收到值之前，发送者会一直阻塞，发送者阻塞，导致接收者一直接收不到值，也会一直阻塞，从而导致死锁。"}]},{"ID":"20231219221840-2shbekz","Type":"NodeParagraph","Properties":{"id":"20231219221840-2shbekz","updated":"20231219221840"},"Children":[{"Type":"NodeText","Data":"上面这段话有些拗口，读者朋友们可以通过运行使用无缓冲区 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 的代码来帮助自己理解。"}]},{"ID":"20231219221840-wk5zs7i","Type":"NodeParagraph","Properties":{"id":"20231219221840-wk5zs7i","updated":"20231219221840"},"Children":[{"Type":"NodeText","Data":"我们运行使用缓冲区大小为 5 的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 的代码，发现代码可以正常运行，发送者和接收者之间不会产生死锁。"}]},{"ID":"20231219221840-aikmigx","Type":"NodeParagraph","Properties":{"id":"20231219221840-aikmigx","updated":"20231219221840"},"Children":[{"Type":"NodeText","Data":"这是因为缓冲区 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​，发送者仅在值被复制到缓冲区之前阻塞，如果缓冲区已满，发送者会一直阻塞，直到某个接收者取出一个值。"}]},{"ID":"20231219221840-x7ku1e1","Type":"NodeParagraph","Properties":{"id":"20231219221840-x7ku1e1","updated":"20231219221840"},"Children":[{"Type":"NodeText","Data":"回到上面这段示例代码中，执行匿名函数的 N 个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 作为接收者，在没有收到 main "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 发送的数据之前，一直处于阻塞状态，直到作为发送者的 main "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 发送数据到缓冲区 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 中。"}]},{"ID":"20231219221840-tts6ksg","Type":"NodeParagraph","Properties":{"id":"20231219221840-tts6ksg","updated":"20231219221840"},"Children":[{"Type":"NodeText","Data":"读者朋友们如果仔细阅读这段代码，会发现上面这段代码虽然不会产生死锁，但是存在一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bug"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20231219221840-nvodgvw","Type":"NodeParagraph","Properties":{"id":"20231219221840-nvodgvw","updated":"20231219221840"},"Children":[{"Type":"NodeText","Data":"解决方案可以阅读我们之前的一篇文章「"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==\u0026amp;mid=2247486513\u0026amp;idx=1\u0026amp;sn=7bbe1f2c24819fc19b3db7e6c2f30937\u0026amp;scene=21#wechat_redirect","TextMarkTextContent":"Go 语言使用 goroutine 运行闭包的“坑”"},{"Type":"NodeText","Data":"」，限于篇幅，我就不在本文中赘述了。"}]},{"ID":"20231219222311-093x36l","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231219222311-093x36l","updated":"20231219222321"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20231219222330-51cgpsn","Type":"NodeParagraph","Properties":{"id":"20231219222330-51cgpsn","updated":"20231219222330"},"Children":[{"Type":"NodeText","Data":"本文我们介绍 Go 语言中，什么是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​，其中 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 分为无缓冲区和缓冲区。"}]},{"ID":"20231219222330-fd0tkwe","Type":"NodeParagraph","Properties":{"id":"20231219222330-fd0tkwe","updated":"20231219222330"},"Children":[{"Type":"NodeText","Data":"在简单了解 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​ 后，我们又介绍怎么使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​，实现两个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"goroutine"},{"Type":"NodeText","Data":"​ 之间通信。"}]},{"ID":"20231219222331-8wvkl3d","Type":"NodeParagraph","Properties":{"id":"20231219222331-8wvkl3d"}}]}