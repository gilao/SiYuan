{"ID":"20240226110917-hl1zf8m","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f3a1","id":"20240226110917-hl1zf8m","title":"Go 语言实战： 构建强大的延迟任务队列","updated":"20240226141726"},"Children":[{"ID":"20240226110939-lz3wkx2","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226110939-lz3wkx2","updated":"20240226110948"},"Children":[{"Type":"NodeText","Data":"1. 介绍"}]},{"ID":"20240226110956-8j4jucr","Type":"NodeParagraph","Properties":{"id":"20240226110956-8j4jucr","updated":"20240226110956"},"Children":[{"Type":"NodeText","Data":"延迟队列是一种数据结构，用于处理需要在未来某个特定时间执行的任务。这些任务被添加到队列中，并且指定了一个执行时间，只有到达指定的时间点时才能从队列中取出并执行。"}]},{"ID":"20240226110956-jwx50o9","Type":"NodeParagraph","Properties":{"id":"20240226110956-jwx50o9","updated":"20240226110956"},"Children":[{"Type":"NodeText","Data":"在实际应用中，延迟队列可以用于处理各种需要延迟处理的任务，例如发送邮件提醒、订单自动取消、对超时任务的处理等。由于任务的执行是在未来的某个时间点，因此这些任务不会立即执行，而是存储在队列中，直到它的预定执行时间才会被执行。"}]},{"ID":"20240226111743-udk6vsz","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226111743-udk6vsz","updated":"20240226111751"},"Children":[{"Type":"NodeText","Data":"2. Simple"}]},{"ID":"20240226111756-p0hpwc9","Type":"NodeParagraph","Properties":{"id":"20240226111756-p0hpwc9","updated":"20240226111756"},"Children":[{"Type":"NodeText","Data":"在 Go 语言中，我们可以使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"time"},{"Type":"NodeText","Data":"​ 包提供的计时器功能，通过使用 Go 中的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":"​ 存储延迟处理的任务，实现一个简单的延迟队列的功能。"}]},{"ID":"20240226111756-y1adzlf","Type":"NodeParagraph","Properties":{"id":"20240226111756-y1adzlf","updated":"20240226111756"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240226111756-as2of8z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226111756-as2of8z","updated":"20240226111824"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type Task struct {\n  ExecuteTime time.Time\n  Job func()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226111829-k4o5x2e","Type":"NodeParagraph","Properties":{"id":"20240226111829-k4o5x2e","updated":"20240226111829"},"Children":[{"Type":"NodeText","Data":"首先，我们定义一个结构体 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Task"},{"Type":"NodeText","Data":"​，它包含一个可以执行任务的函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Job"},{"Type":"NodeText","Data":"​，和一个执行时间 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ExecuteTime"},{"Type":"NodeText","Data":"​，这是期望执行该函数的时间。"}]},{"ID":"20240226111829-6aiu427","Type":"NodeParagraph","Properties":{"id":"20240226111829-6aiu427","updated":"20240226111829"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240226111830-hqms4n5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226111830-hqms4n5","updated":"20240226111859"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type DelayQueue struct{\n  TaskQueue []Task\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226112541-uq1uvk6","Type":"NodeParagraph","Properties":{"id":"20240226112541-uq1uvk6","updated":"20240226112851"},"Children":[{"Type":"NodeText","Data":"接下来我们定义一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":"​结构体，它拥有一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TaskQueue"},{"Type":"NodeText","Data":"​，这是一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Task"},{"Type":"NodeText","Data":"​ 类型的切片，用于保存待执行任务的列表。"}]},{"ID":"20240226112851-yld3isa","Type":"NodeParagraph","Properties":{"id":"20240226112851-yld3isa","updated":"20240226112858"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240226112859-b1ldk8k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226112859-b1ldk8k","updated":"20240226113008"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 添加任务\nfunc (d *DelayQueue) AddTask(t Task) {\n  d.TaskQueue = append(d.TaskQueue, t)\n}\n\n// 移除任务\nfunc (d *DelayQueue) RemoveTask() {\n d.TaskQueue = d.TaskQueue[1:]\n}\n\n// 执行任务\nfunc (d *DelayQueue) ExecuteTasks() {\n for len(d.TaskQueue) \u003e 0 {\n  // 获取队列最顶部的任务\n  currentTask := d.TaskQueue[0]\n  // 如果执行时间还没到，等待\n  if time.Now().Before(currentTask.ExecuteTime) {\n   time.Sleep(currentTask.ExecuteTime.Sub(time.Now()))\n  }\n  // 执行任务\n  currentTask.Job()\n  // 移除已执行的任务\n  d.RemoveTask()\n }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226113039-m4cufg3","Type":"NodeParagraph","Properties":{"id":"20240226113039-m4cufg3","updated":"20240226113039"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":"​ 包含三个方法："}]},{"ID":"20240226113039-2xy0kol","Type":"NodeParagraph","Properties":{"id":"20240226113039-2xy0kol","updated":"20240226113039"},"Children":[{"Type":"NodeText","Data":"第一个方法是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"AddTask(t Task)"},{"Type":"NodeText","Data":"​。此方法将提供的任务 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"t"},{"Type":"NodeText","Data":"​ 添加到 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TaskQueue"},{"Type":"NodeText","Data":"​ 的末尾。"}]},{"ID":"20240226113039-7bb6b8v","Type":"NodeParagraph","Properties":{"id":"20240226113039-7bb6b8v","updated":"20240226113039"},"Children":[{"Type":"NodeText","Data":"第二个方法是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RemoveTask()"},{"Type":"NodeText","Data":"​。此方法从 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TaskQueue"},{"Type":"NodeText","Data":"​ 中移除第一个任务。"}]},{"ID":"20240226113039-ptusy5y","Type":"NodeParagraph","Properties":{"id":"20240226113039-ptusy5y","updated":"20240226113039"},"Children":[{"Type":"NodeText","Data":"第三个方法是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ExecuteTasks()"},{"Type":"NodeText","Data":"​。此方法将执行 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TaskQueue"},{"Type":"NodeText","Data":"​ 中的所有任务。如果队列顶部任务的执行时间还未到，该方法将等待。一旦时间到了，它将会执行 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Job"},{"Type":"NodeText","Data":"​ 并从 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TaskQueue"},{"Type":"NodeText","Data":"​ 中移除该任务。"}]},{"ID":"20240226113040-cjtxjdh","Type":"NodeParagraph","Properties":{"id":"20240226113040-cjtxjdh","updated":"20240226113046"},"Children":[{"Type":"NodeText","Data":"示例代码"}]},{"ID":"20240226113046-i689rbz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226113046-i689rbz","updated":"20240226113053"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n fmt.Println(\"Start DelayQueue\")\n queue := DelayQueue{}\n firstTask := Task{\n  ExecuteTime: time.Now().Add(4 * time.Second),\n  Job: func() {\n   fmt.Println(\"Executed task 1 after delay\")\n  },\n }\n queue.AddTask(firstTask)\n\n secondTask := Task{\n  ExecuteTime: time.Now().Add(10 * time.Second),\n  Job: func() {\n   fmt.Println(\"Executed task 2 after delay\")\n  },\n }\n queue.AddTask(secondTask)\n\n queue.ExecuteTasks()\n fmt.Println(\"Done!\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226113135-sijxepv","Type":"NodeParagraph","Properties":{"id":"20240226113135-sijxepv","updated":"20240226113135"},"Children":[{"Type":"NodeText","Data":"输出结果："}]},{"ID":"20240226113136-fjpvvwu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226113136-fjpvvwu","updated":"20240226113141"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"Start DelayQueue\nExecuted task 1 after delay\nExecuted task 2 after delay\nDone!\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226113147-0wnj2ni","Type":"NodeParagraph","Properties":{"id":"20240226113147-0wnj2ni","updated":"20240226113147"},"Children":[{"Type":"NodeText","Data":"在示例代码中，我们创建了一个延时队列，将任务添加到队列中，并在指定的延时后执行它们。"}]},{"ID":"20240226113147-2s9iaft","Type":"NodeParagraph","Properties":{"id":"20240226113147-2s9iaft","updated":"20240226113147"},"Children":[{"Type":"NodeText","Data":"通过使用这些结构体和方法，我们可以在 Go 中实现简单的延迟执行任务的功能。"}]},{"ID":"20240226113147-ehhc4hn","Type":"NodeParagraph","Properties":{"id":"20240226113147-ehhc4hn","updated":"20240226113147"},"Children":[{"Type":"NodeText","Data":"但是，当 Go 程序重启时，存储在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"slice"},{"Type":"NodeText","Data":"​ 中的延迟处理的任务将全部丢失。"}]},{"ID":"20240226113149-qkn65pn","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226113149-qkn65pn","updated":"20240226113158"},"Children":[{"Type":"NodeText","Data":"3. Complex"}]},{"ID":"20240226113205-fu373nq","Type":"NodeParagraph","Properties":{"id":"20240226113205-fu373nq","updated":"20240226113205"},"Children":[{"Type":"NodeText","Data":"在 Go 程序中，如果想在重启后保留数据，我们可以将数据持久化到 Redis，可以使用 go-redis/redis 库"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"[1]"},{"Type":"NodeText","Data":"与 Redis 交互。而对于延迟队列的需求，则可以使用 Redis 的 ZSET（有序集合）特性来实现。"}]},{"ID":"20240226113218-vdale9r","Type":"NodeParagraph","Properties":{"id":"20240226113218-vdale9r","updated":"20240226113221"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240226113212-cs9vjn0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226113212-cs9vjn0","updated":"20240226113227"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 定义一个全局的redisdb变量\nvar redisdb *redis.Client\n\n// 初始化连接\nfunc initClient() (err error) {\n redisdb = redis.NewClient(\u0026redis.Options{\n  Addr:     \"localhost:6379\",\n  Password: \"\", // no password set\n  DB:       0,  // use default DB\n })\n\n _, err = redisdb.Ping().Result()\n if err != nil {\n  return err\n }\n return nil\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226113239-fbiky88","Type":"NodeParagraph","Properties":{"id":"20240226113239-fbiky88","updated":"20240226113239"},"Children":[{"Type":"NodeText","Data":"全局变量 redisdb 是 redis.Client 类型的指针，用来保存到 Redis 客户端的引用。"}]},{"ID":"20240226113239-jgve46o","Type":"NodeParagraph","Properties":{"id":"20240226113239-jgve46o","updated":"20240226113239"},"Children":[{"Type":"NodeText","Data":"initClient 函数初始化连接到 Redis 服务器，该服务器在本地主机的 6379 端口运行。它将一个新的 Redis 客户端分配给 redisdb 变量。如果连接成功，它就会 ping Redis 服务器以测试连接。"}]},{"ID":"20240226113239-elsxjsv","Type":"NodeParagraph","Properties":{"id":"20240226113239-elsxjsv","updated":"20240226113239"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240226113245-2zq478t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226113245-2zq478t","updated":"20240226113252"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 向队列中添加任务\nfunc addTaskToQueue(task string, executeTime int64) {\n err := redisdb.ZAdd(\"delay-queue\", redis.Z{\n  Score:  float64(executeTime),\n  Member: task,\n }).Err()\n\n if err != nil {\n  panic(err)\n }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226113258-s1hukba","Type":"NodeParagraph","Properties":{"id":"20240226113258-s1hukba","updated":"20240226113259"},"Children":[{"Type":"NodeText","Data":"addTaskToQueue 函数将具有执行时间的任务添加到 Redis 等待排序的集合 \"delay-queue\"。执行时间是一个 UNIX 时间戳，作为排序集合中的项目的 score，允许 Redis 按照他们应该执行的时间来排序项目。"}]},{"ID":"20240226113325-3cesixc","Type":"NodeParagraph","Properties":{"id":"20240226113325-3cesixc","updated":"20240226113325"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240226113326-2d53w8x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226113326-2d53w8x","updated":"20240226113334"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// 从队列中获取并处理任务\nfunc getAndExecuteTasks() {\n for {\n  // 使用 ZRANGEBYSCORE 命令获取分数（时间戳）\u003c= 当前时间的任务\n  tasks, err := redisdb.ZRangeByScore(\"delay-queue\", redis.ZRangeBy{\n   Min: \"-inf\",\n   Max: fmt.Sprintf(\"%d\", time.Now().Unix()),\n  }).Result()\n\n  if err != nil {\n   time.Sleep(1 * time.Second)\n   continue\n  }\n\n  // 处理任务\n  for _, task := range tasks {\n   fmt.Println(\"Executing task: \", task)\n   // 执行完任务后，用 ZREM 移除该任务\n   redisdb.ZRem(\"delay-queue\", task)\n  }\n\n  // 暂停一秒\n  time.Sleep(1 * time.Second)\n }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226141621-o2qggri","Type":"NodeParagraph","Properties":{"id":"20240226141621-o2qggri","updated":"20240226141621"},"Children":[{"Type":"NodeText","Data":"getAndExecuteTasks 函数不断检查 \"delay-queue\"。它提取队列中 score 小于或等于当前时间戳的任务，意味着这些任务现在应该执行或者他们应该在过去就已经执行。获取任务后，它打印任务（模拟执行）并从队列中删除任务。"}]},{"ID":"20240226141622-lrxjcpk","Type":"NodeParagraph","Properties":{"id":"20240226141622-lrxjcpk","updated":"20240226141629"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240226141629-7umbnsp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226141629-7umbnsp","updated":"20240226141637"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func main() {\n err := initClient()\n if err != nil {\n  fmt.Println(\"redis connect error:\", err)\n  return\n }\n\n // 添加一些测试任务\n addTaskToQueue(\"task1\", time.Now().Add(10*time.Second).Unix())\n addTaskToQueue(\"task2\", time.Now().Add(20*time.Second).Unix())\n\n // 执行延迟队列中的任务\n getAndExecuteTasks()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226141639-1lks5o3","Type":"NodeParagraph","Properties":{"id":"20240226141639-1lks5o3","updated":"20240226141643"},"Children":[{"Type":"NodeText","Data":"输出结果"}]},{"ID":"20240226141644-gedyyfk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226141644-gedyyfk","updated":"20240226141651"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"Executing task:  task1\nExecuting task:  task2\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226141656-hp8wpda","Type":"NodeParagraph","Properties":{"id":"20240226141656-hp8wpda","updated":"20240226141656"},"Children":[{"Type":"NodeText","Data":"main 函数调用这些函数。首先，它初始化 Redis 客户端。如果初始化和连接成功，它将一些测试任务添加到队列中，并启动任务执行循环。"}]},{"ID":"20240226141656-ul55zbb","Type":"NodeParagraph","Properties":{"id":"20240226141656-ul55zbb","updated":"20240226141656"},"Children":[{"Type":"NodeText","Data":"总结一下，这段 Go 代码使用 Redis 的 "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkTextContent":"Sorted Set"},{"Type":"NodeText","Data":" 数据类型创建了一个延时队列系统，其中的任务按照他们的执行时间进行排序，一个任务工作者循环获取并执行队列中的任务。这是一个简单而高效地实现作业调度系统的方法。"}]},{"ID":"20240226141657-sgrf7rk","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226141657-sgrf7rk","updated":"20240226141716"},"Children":[{"Type":"NodeText","Data":"4 总结"}]},{"ID":"20240226141726-rrancnx","Type":"NodeParagraph","Properties":{"id":"20240226141726-rrancnx","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"本文我们分别实现简单版和复杂版的延迟队列，其中简单版延迟队列，只使用 Go 实现，复杂版延迟队列，使用 Go 和 Redis 实现。"}]},{"ID":"20240226141726-gwd088g","Type":"NodeParagraph","Properties":{"id":"20240226141726-gwd088g","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"只使用 Go 实现延迟队列："}]},{"ID":"20240226141726-sfsw1vb","Type":"NodeParagraph","Properties":{"id":"20240226141726-sfsw1vb","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"优点："}]},{"ID":"20240226141726-5h4nwfl","Type":"NodeParagraph","Properties":{"id":"20240226141726-5h4nwfl","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"不需要外部依赖：只使用 Go 实现延迟队列，你不需要安装和维护外部的 Redis 服务器。"}]},{"ID":"20240226141726-ogy4h94","Type":"NodeParagraph","Properties":{"id":"20240226141726-ogy4h94","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"缺点："}]},{"ID":"20240226141726-c3i5qjt","Type":"NodeParagraph","Properties":{"id":"20240226141726-c3i5qjt","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"健壮性和持久性：如果程序崩溃或重新启动，延迟队列的数据可能会丢失。"}]},{"ID":"20240226141726-phjr88o","Type":"NodeParagraph","Properties":{"id":"20240226141726-phjr88o","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"并发控制：使用 Go 内置的数据结构（如 channels 或 slices）在多个 goroutines 之间共享状态变量可能需要精细的并发控制，比如使用 mutexes 或者 channels。"}]},{"ID":"20240226141726-5evon4b","Type":"NodeParagraph","Properties":{"id":"20240226141726-5evon4b","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"使用 Go + Redis 实现延迟队列："}]},{"ID":"20240226141726-0vwrsmn","Type":"NodeParagraph","Properties":{"id":"20240226141726-0vwrsmn","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"优点："}]},{"ID":"20240226141726-g99dymd","Type":"NodeParagraph","Properties":{"id":"20240226141726-g99dymd","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"数据持久性：Redis 提供了数据持久性，即使在程序重启或崩溃后，队列中的数据依然可以恢复。"}]},{"ID":"20240226141726-gv9ff97","Type":"NodeParagraph","Properties":{"id":"20240226141726-gv9ff97","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"简化并发：Redis 提供的数据结构（如 sorted set）是原子操作，可以简化并发控制。"}]},{"ID":"20240226141726-zz1cmiv","Type":"NodeParagraph","Properties":{"id":"20240226141726-zz1cmiv","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"功能强大：使用 Redis，你可以利用其提供的一些内建功能，如超时、"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkTextContent":"TTL"},{"Type":"NodeText","Data":"、持久化等。"}]},{"ID":"20240226141726-a55ubx3","Type":"NodeParagraph","Properties":{"id":"20240226141726-a55ubx3","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"缺点："}]},{"ID":"20240226141726-0o8zzuv","Type":"NodeParagraph","Properties":{"id":"20240226141726-0o8zzuv","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"需要额外的组件：使用 Redis 意味着需要安装和运行 Redis 服务器，这可能增加系统的复杂性和运维成本。"}]},{"ID":"20240226141726-ycfuq27","Type":"NodeParagraph","Properties":{"id":"20240226141726-ycfuq27","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"网络延迟：如果 Go 程序和 Redis 服务器不在同一台机器上，网络延迟可能会影响延迟的准确性。"}]},{"ID":"20240226141726-6rpl4yn","Type":"NodeParagraph","Properties":{"id":"20240226141726-6rpl4yn","updated":"20240226141726"},"Children":[{"Type":"NodeText","Data":"总的来说，如果我们对延迟队列的持久性、准确性和并发性有高要求，那么 Go + Redis 的方案可能会更适合。如果我们想要一个更简单的解决方案，并且可以容忍在程序崩溃时部分数据丢失，那么只使用 Go 实现可能会更合适。"}]}]}