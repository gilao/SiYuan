{"ID":"20231220000018-r76mb09","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f951","id":"20231220000018-r76mb09","tags":"公众号-Golang语言开发栈,Go-unsafe库","title":"Golang 语言中的非类型安全指针","updated":"20231220005942"},"Children":[{"ID":"20231220000018-824kkn6","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220000018-824kkn6","updated":"20231220000512"},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"ID":"20231220000521-lbntuul","Type":"NodeParagraph","Properties":{"id":"20231220000521-lbntuul","updated":"20231220000521"},"Children":[{"Type":"NodeText","Data":"Golang 语言中的 unsafe 包中包含的操作会绕过 Golang 程序的类型安全检查，直接操作内存，从而达到提升性能的目的。导入 unsafe 包可能是不可移植（non-portable）的（随着 Golang 的版本迭代，可能会失效），并且不受 Go 1 兼容性准则的保护，所以我们应该谨慎使用。"}]},{"ID":"20231220000521-80gf8k7","Type":"NodeParagraph","Properties":{"id":"20231220000521-80gf8k7","updated":"20231220000521"},"Children":[{"Type":"NodeText","Data":"本文主要介绍 unsafe 包的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​，它表示任意类型的指针，它类似于 C 语言中的无类型指针 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"void*"},{"Type":"NodeText","Data":"​，可以作为指针类型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*T"},{"Type":"NodeText","Data":"​ 和 uintptr 类型值之间互相转换的中转站。"}]},{"ID":"20231220000521-mwa7btu","Type":"NodeParagraph","Properties":{"id":"20231220000521-mwa7btu","updated":"20231220001700"},"Children":[{"Type":"NodeText","Data":"我们知道 Golang 语言中的指针类型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*T"},{"Type":"NodeText","Data":"​，表示一个指向 T 类型变量的指针，因为 Golang 语言是强类型的静态语言，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":"为了安全考虑，规定两个不同的指针类型之间不可以互相转换，比如 "},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"code strong text","TextMarkTextContent":"*int"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":" 不能与 "},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"code strong text","TextMarkTextContent":"*float64"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":" 互相转换。但是，实际上是可以使用 "},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"code strong text","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"strong text","TextMarkTextContent":" 进行转换。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20231220000521-qjd9mz4","Type":"NodeParagraph","Properties":{"id":"20231220000521-qjd9mz4","updated":"20231220000521"},"Children":[{"Type":"NodeText","Data":"Golang 语言中的内置数据类型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"uintptr"},{"Type":"NodeText","Data":"​ 也可以表示任何指针，它实际是数值类型，可以用于存储内存地址。它和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 最大的区别是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 不支持指针运算，比如 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"+"},{"Type":"NodeText","Data":"​ 运算符，但 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"uintptr"},{"Type":"NodeText","Data":"​ 可以支持。以下是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"uintptr"},{"Type":"NodeText","Data":"​ 的源码："}]},{"ID":"20231220000521-041mtny","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220000521-041mtny","updated":"20231220002143"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// uintptr is an integer type that is large enough to hold the bit pattern of\n// any pointer.\ntype uintptr uintptr\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220001849-0dxfonu","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220001849-0dxfonu","updated":"20231220001905"},"Children":[{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Ponter"},{"Type":"NodeText","Data":"​ 类型"}]},{"ID":"20231220001906-usp6hju","Type":"NodeParagraph","Properties":{"id":"20231220001906-usp6hju","updated":"20231220001928"},"Children":[{"Type":"NodeText","Data":"有了前面内容的铺垫，我们开始介绍 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Ponter"},{"Type":"NodeText","Data":"​，它表示指向任意类型的指针。以下是 unsafe 包的源码："}]},{"ID":"20231220001929-xcokk3t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220001929-xcokk3t","updated":"20231220002022"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// ArbitraryType is here for the purposes of documentation only and is not actually\n// part of the unsafe package. It represents the type of an arbitrary Go expression.\ntype ArbitraryType int\ntype Pointer *ArbitraryType\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220002911-a0iy0c1","Type":"NodeParagraph","Properties":{"id":"20231220002911-a0iy0c1","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Ponter"},{"Type":"NodeText","Data":"​ 类型有四个转换规则："}]},{"ID":"20231220002911-xj2ggj6","Type":"NodeList","ListData":{},"Properties":{"id":"20231220002911-xj2ggj6","updated":"20231220002911"},"Children":[{"ID":"20231220002911-6rph17z","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220002911-6rph17z","style":"color: var(--b3-font-color1);","updated":"20231220002911"},"Children":[{"ID":"20231220002911-mnxon0u","Type":"NodeParagraph","Properties":{"id":"20231220002911-mnxon0u","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"任何类型的指针值 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*T"},{"Type":"NodeText","Data":"​ 都可以转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​。"}]}]},{"ID":"20231220002911-evy1mzv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220002911-evy1mzv","style":"color: var(--b3-font-color1);","updated":"20231220002911"},"Children":[{"ID":"20231220002911-mot3jyb","Type":"NodeParagraph","Properties":{"id":"20231220002911-mot3jyb","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 可以转换为任何类型的指针值 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*T"},{"Type":"NodeText","Data":"​。"}]}]},{"ID":"20231220002911-osjq6kw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220002911-osjq6kw","style":"color: var(--b3-font-color1);","updated":"20231220002911"},"Children":[{"ID":"20231220002911-eqt0rkd","Type":"NodeParagraph","Properties":{"id":"20231220002911-eqt0rkd","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"uintptr 可以转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​。"}]}]},{"ID":"20231220002911-ztg6w5f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220002911-ztg6w5f","style":"color: var(--b3-font-color1);","updated":"20231220002911"},"Children":[{"ID":"20231220002911-oim6w4i","Type":"NodeParagraph","Properties":{"id":"20231220002911-oim6w4i","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 可以转换为 uintptr。"}]}]}]},{"ID":"20231220002911-4pe0jks","Type":"NodeParagraph","Properties":{"id":"20231220002911-4pe0jks","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 允许程序绕过类型安全检查读写任意内存，所以使用时应格外小心。"}]},{"ID":"20231220002911-7z3jj7c","Type":"NodeParagraph","Properties":{"id":"20231220002911-7z3jj7c","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 包含 6 个使用模式："}]},{"ID":"20231220002911-7620wpv","Type":"NodeList","ListData":{},"Properties":{"id":"20231220002911-7620wpv","updated":"20231220002911"},"Children":[{"ID":"20231220002911-y3dh4eb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220002911-y3dh4eb","updated":"20231220002911"},"Children":[{"ID":"20231220002911-x05p3tq","Type":"NodeParagraph","Properties":{"id":"20231220002911-x05p3tq","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 作为中转，将一个指针类型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*T"},{"Type":"NodeText","Data":"​ 转换为另外一个指针类型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*T"},{"Type":"NodeText","Data":"​。"}]}]},{"ID":"20231220002911-xh1e17a","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220002911-xh1e17a","updated":"20231220002911"},"Children":[{"ID":"20231220002911-k6d8sjn","Type":"NodeParagraph","Properties":{"id":"20231220002911-k6d8sjn","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 转换为 uintptr（但不返回给 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​），然后使用 uintptr 值。"}]}]},{"ID":"20231220002911-i87bq7y","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220002911-i87bq7y","updated":"20231220002911"},"Children":[{"ID":"20231220002911-c9o35y8","Type":"NodeParagraph","Properties":{"id":"20231220002911-c9o35y8","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 转换为 uintptr，然后使用 uintptr 值进行算术运算，最后将运算结果 uintptr 值再转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​。"}]}]},{"ID":"20231220002911-ut9fppz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220002911-ut9fppz","updated":"20231220002911"},"Children":[{"ID":"20231220002911-je1jy07","Type":"NodeParagraph","Properties":{"id":"20231220002911-je1jy07","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"syscall.Syscall"},{"Type":"NodeText","Data":"​ 时，将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 转换为 uintptr 值，作为参数传递。"}]}]},{"ID":"20231220002911-e459e1o","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220002911-e459e1o","updated":"20231220002911"},"Children":[{"ID":"20231220002911-2n2yrei","Type":"NodeParagraph","Properties":{"id":"20231220002911-2n2yrei","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"reflect.Value.Pointer"},{"Type":"NodeText","Data":"​ 或 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"reflect.Value.UnsafeAddr"},{"Type":"NodeText","Data":"​ 的返回结果 uintptr 值，从 uintptr 转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​。"}]}]},{"ID":"20231220002911-7b9mrec","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231220002911-7b9mrec","updated":"20231220002911"},"Children":[{"ID":"20231220002911-vu4d7ib","Type":"NodeParagraph","Properties":{"id":"20231220002911-vu4d7ib","updated":"20231220002911"},"Children":[{"Type":"NodeText","Data":"将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"reflect.SliceHeader"},{"Type":"NodeText","Data":"​ 或 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"reflect.StringHeader"},{"Type":"NodeText","Data":"​ 值的 Data 字段与 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 进行转换。"}]}]}]},{"ID":"20231220005011-z46d7jw","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220005011-z46d7jw","updated":"20231220005056"},"Children":[{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 和 uintptr 使用示例"}]},{"ID":"20231220005056-jjd39az","Type":"NodeParagraph","Properties":{"id":"20231220005056-jjd39az","updated":"20231220005134"},"Children":[{"Type":"NodeText","Data":"因为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 不支持运算，所以如果需要指针运算，还需要借助 uintptr 实现。以下示例是通过指针偏移对 struct 结构体中的字段进行指针运算操作，从而找到该字段的内存地址。"}]},{"ID":"20231220005143-70q77hj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231220005143-70q77hj","updated":"20231220005144"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n \"fmt\"\n \"unsafe\"\n)\n\ntype user struct {\n name string\n age uint\n}\nfunc main () {\n // 定义一个指针变量\n student := new(user)\n // user 结构体中的 name 字段是第一个字段，可以直接通过指针修改，不需要使用偏移\n studentName := (*string)(unsafe.Pointer(student))\n *studentName = \"lucy\"\n // user 结构体中的 age 字段不是第一个字段，所以需要使用偏移才能找到 age 字段的内存地址，修改值\n studentAge := (*uint)(unsafe.Pointer(uintptr(unsafe.Pointer(student)) + unsafe.Offsetof(student.age)))\n *studentAge = 18\n fmt.Println(*student)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231220005315-xntn7ag","Type":"NodeParagraph","Properties":{"id":"20231220005315-xntn7ag","updated":"20231220005315"},"Children":[{"Type":"NodeText","Data":"阅读上面这段代码，我们使用 new 函数定义了一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*user"},{"Type":"NodeText","Data":"​ 类型的指针变量 student，然后使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*user"},{"Type":"NodeText","Data":"​ 类型的指针变量 student 转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*string"},{"Type":"NodeText","Data":"​ 类型的指针变量 studentName，然后修改 studentName 的值，实际上就是修改 name 字段的值。"}]},{"ID":"20231220005315-4ahtt80","Type":"NodeParagraph","Properties":{"id":"20231220005315-4ahtt80","updated":"20231220005315"},"Children":[{"Type":"NodeText","Data":"因为 age 字段不是 user 结构体的第一个字段，所以需要先使用偏移量找到 age 字段的内存地址，具体操作步骤是：先将 student 指针变量通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 和 uintptr 转换为 uintptr，然后就可以使用函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Offsetof"},{"Type":"NodeText","Data":"​ 计算出 age 字段的偏移量，该函数返回结果也是 uintptr 类型，因为 uintptr 支持运算，最后使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"+"},{"Type":"NodeText","Data":"​ 运算符获取 age 字段的内存地址。"}]},{"ID":"20231220005315-8afuiqv","Type":"NodeParagraph","Properties":{"id":"20231220005315-8afuiqv","updated":"20231220005315"},"Children":[{"Type":"NodeText","Data":"找到 age 字段的内存地址之后，还要使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unsafe.Pointer"},{"Type":"NodeText","Data":"​ 转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*uint"},{"Type":"NodeText","Data":"​ 指针类型，才可以对该内存地址进行读写操作。"}]},{"ID":"20231220005836-f4bdtlm","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231220005836-f4bdtlm","updated":"20231220005933"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20231220005934-142vybt","Type":"NodeParagraph","Properties":{"id":"20231220005934-142vybt","updated":"20231220005942"},"Children":[{"Type":"NodeText","Data":"本文介绍了非类型安全指针，它可用于指针类型之间互相转换，但是它绕开了类型安全检查，同时随着 Golang 的版本迭代，unsafe 包可能会失效，并且 unsafe 包不受 Go 1 兼容性准则的保护，所以我们应该谨慎使用。"}]}]}