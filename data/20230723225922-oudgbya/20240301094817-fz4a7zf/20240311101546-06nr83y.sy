{"ID":"20240311101546-06nr83y","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f994","id":"20240311101546-06nr83y","title":"Go 接口：nil 接口为什么不等于 nil？","updated":"20240311104553"},"Children":[{"ID":"20240311101601-ydn9ouv","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240311101601-ydn9ouv","updated":"20240311101619"},"Children":[{"Type":"NodeText","Data":"一、前言"}]},{"ID":"20240311101626-6nguzub","Type":"NodeParagraph","Properties":{"id":"20240311101626-6nguzub","updated":"20240311101626"},"Children":[{"Type":"NodeText","Data":"Go 语言核心团队的技术负责人 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Russ Cox"},{"Type":"NodeText","Data":" 也曾说过这样一句话：“如果要从 Go 语言中挑选出一个特性放入其他语言，我会选择接口”，这句话足以说明接口这一语法特性在这位 Go 语言大神心目中的地位。"}]},{"ID":"20240311101626-wpj35ap","Type":"NodeParagraph","Properties":{"id":"20240311101626-wpj35ap","updated":"20240311101747"},"Children":[{"Type":"NodeText","Data":"为什么接口在 Go 中有这么高的地位呢？"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这是因为接口是 Go 这门静态语言中唯一“动静兼备”的语法特性。"},{"Type":"NodeText","Data":"而且，接口“动静兼备”的特性给 Go 带来了强大的表达能力，但同时也给 Go 语言初学者带来了不少困惑。要想真正解决这些困惑，我们必须深入到 Go 运行时层面，看看 Go 语言在运行时是如何表示接口类型的。"}]},{"ID":"20240311101626-7azv98k","Type":"NodeParagraph","Properties":{"id":"20240311101626-7azv98k","updated":"20240311101626"},"Children":[{"Type":"NodeText","Data":"接下来，我们先来看看接口的静态与动态特性，看看“动静皆备”的含义。"}]},{"ID":"20240311101547-v3m7sr3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240311101547-v3m7sr3","updated":"20240311101645"},"Children":[{"Type":"NodeText","Data":"1.1 接口的静态特性与动态特性"}]},{"ID":"20240311101655-zes0uya","Type":"NodeParagraph","Properties":{"id":"20240311101655-zes0uya","updated":"20240311101655"},"Children":[{"Type":"NodeText","Data":"接口的静态特性体现在接口类型变量具有静态类型。"}]},{"ID":"20240311101655-y30zaxw","Type":"NodeParagraph","Properties":{"id":"20240311101655-y30zaxw","updated":"20240311101655"},"Children":[{"Type":"NodeText","Data":"比如 var err error 中变量 err 的静态类型为 error。拥有静态类型，那就意味着编译器会在编译阶段对所有接口类型变量的赋值操作进行类型检查，编译器会检查右值的类型是否实现了该接口方法集合中的所有方法。如果不满足，就会报错："}]},{"ID":"20240311101656-nn0wbc1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311101656-nn0wbc1","updated":"20240311101715"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\nvar err error = 1 // cannot use 1 (type int) as type error in assignment: int does not implement error (missing Error method)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311101716-kjx0ayx","Type":"NodeParagraph","Properties":{"id":"20240311101716-kjx0ayx","updated":"20240311101720"},"Children":[{"Type":"NodeText","Data":"而接口的动态特性，就体现在接口类型变量在运行时还存储了右值的真实类型信息，这个右值的真实类型被称为接口类型变量的动态类型。例如，下面示例代码："}]},{"ID":"20240311101722-2lib0zm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311101722-2lib0zm","updated":"20240311101815"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"var err error\nerr = errors.New(\"error1\")\nfmt.Printf(\"%T\\n\", err)  // *errors.errorString\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311101816-kkw3lv9","Type":"NodeParagraph","Properties":{"id":"20240311101816-kkw3lv9","updated":"20240311101824"},"Children":[{"Type":"NodeText","Data":"我们可以看到，这个示例通过 errros.New 构造了一个错误值，赋值给了 error 接口类型变量 err，并通过 fmt.Printf 函数输出接口类型变量 err 的动态类型为 *errors.errorString。"}]},{"ID":"20240311101825-uej6va0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240311101825-uej6va0","updated":"20240311101840"},"Children":[{"Type":"NodeText","Data":"二、nil error 值 != nil"}]},{"ID":"20240311101841-nmmz4as","Type":"NodeParagraph","Properties":{"id":"20240311101841-nmmz4as","updated":"20240311101941"},"Children":[{"Type":"NodeText","Data":"我们先来看一段改编自GO FAQ 中的例子的代码："}]},{"ID":"20240311101943-od4gw6f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311101943-od4gw6f","updated":"20240311101958"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\ntype MyError struct {\n    error\n}\n\nvar ErrBad = MyError{\n    error: errors.New(\"bad things happened\"),\n}\n\nfunc bad() bool {\n    return false\n}\n\nfunc returnsError() error {\n    var p *MyError = nil\n    if bad() {\n        p = \u0026ErrBad\n    }\n    return p\n}\n\nfunc main() {\n    err := returnsError()\n    if err != nil {\n        fmt.Printf(\"error occur: %+v\\n\", err)\n        return\n    }\n    fmt.Println(\"ok\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311102004-efbvsz8","Type":"NodeParagraph","Properties":{"id":"20240311102004-efbvsz8","updated":"20240311102004"},"Children":[{"Type":"NodeText","Data":"在这个例子中，我们的关注点集中在 returnsError 这个函数上面。这个函数定义了一个 *MyError 类型的变量 p，初值为 nil。如果函数 bad 返回 false，returnsError 函数就会直接将 p（此时 p = nil）作为返回值返回给调用者，之后调用者会将 returnsError 函数的返回值（error 接口类型）与 nil 进行比较，并根据比较结果做出最终处理。"}]},{"ID":"20240311102004-85m4hwu","Type":"NodeParagraph","Properties":{"id":"20240311102004-85m4hwu","updated":"20240311102004"},"Children":[{"Type":"NodeText","Data":"我们运行这段程序后，输出如下："}]},{"ID":"20240311102111-4cai3us","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311102111-4cai3us","updated":"20240311102125"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"error occur: \u003cnil\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311102134-g4xjthi","Type":"NodeParagraph","Properties":{"id":"20240311102134-g4xjthi","updated":"20240311102134"},"Children":[{"Type":"NodeText","Data":"按照预期：程序执行应该是p 为 nil，returnsError 返回 p，那么 main 函数中的 err 就等于 nil，于是程序输出 ok 后退出。但是我们看到，示例程序并未按照预期，程序显然是进入了错误处理分支，输出了 err 的值。那这里就有一个问题了：明明 returnsError 函数返回的 p 值为 nil，为什么却满足了 if err != nil 的条件进入错误处理分支呢？"}]},{"ID":"20240311102134-5hypb94","Type":"NodeParagraph","Properties":{"id":"20240311102134-5hypb94","updated":"20240311102134"},"Children":[{"Type":"NodeText","Data":"为了弄清楚这个问题，我们来了解接口类型变量的内部表示。"}]},{"ID":"20240311102139-s83j0of","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240311102139-s83j0of","updated":"20240311102209"},"Children":[{"Type":"NodeText","Data":"3.1 interface 源代码解析"}]},{"ID":"20240311102209-duvmj3k","Type":"NodeParagraph","Properties":{"id":"20240311102209-duvmj3k","updated":"20240311102215"},"Children":[{"Type":"NodeText","Data":"接口类型“动静兼备”的特性也决定了它的变量的内部表示绝不像一个静态类型变量（如 int、float64）那样简单，我们可以在 $GOROOT/src/runtime/runtime2.go 中找到接口类型变量在运行时的表示："}]},{"ID":"20240311102221-y0ozfp3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311102221-y0ozfp3","updated":"20240311102606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// $GOROOT/src/runtime/runtime2.go\ntype iface struct {\n  tab *itab\n  data unsafe.Pointer\n}\ntype eface struct {\n  _type *_type\n  data unsafe.Pointer\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311102620-3wu51r5","Type":"NodeParagraph","Properties":{"id":"20240311102620-3wu51r5","updated":"20240311102620"},"Children":[{"Type":"NodeText","Data":"我们看到，在运行时层面，接口类型变量有两种内部表示：iface 和 eface，这两种表示分别用于不同的接口类型变量："}]},{"ID":"20240311102620-awo4nw5","Type":"NodeList","ListData":{},"Properties":{"id":"20240311102620-awo4nw5","updated":"20240311102620"},"Children":[{"ID":"20240311102620-le0y69v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311102620-le0y69v","updated":"20240311102620"},"Children":[{"ID":"20240311102620-xf3qc3d","Type":"NodeParagraph","Properties":{"id":"20240311102620-xf3qc3d","updated":"20240311102620"},"Children":[{"Type":"NodeText","Data":"eface 用于表示没有方法的空接口（empty interface）类型变量，也就是 interface{} 类型的变量；"}]}]},{"ID":"20240311102620-nk1s6ze","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311102620-nk1s6ze","updated":"20240311102620"},"Children":[{"ID":"20240311102620-uer90gq","Type":"NodeParagraph","Properties":{"id":"20240311102620-uer90gq","updated":"20240311102620"},"Children":[{"Type":"NodeText","Data":"iface 用于表示其余拥有方法的接口 interface 类型变量。"}]}]}]},{"ID":"20240311102620-ky9rhrx","Type":"NodeParagraph","Properties":{"id":"20240311102620-ky9rhrx","updated":"20240311102620"},"Children":[{"Type":"NodeText","Data":"这两个结构的共同点是它们都有两个指针字段，并且第二个指针字段的功能相同，都是指向当前赋值给该接口类型变量的动态类型变量的值。"}]},{"ID":"20240311102620-icb8mfx","Type":"NodeParagraph","Properties":{"id":"20240311102620-icb8mfx","updated":"20240311102620"},"Children":[{"Type":"NodeText","Data":"那它们的不同点在哪呢？就在于 eface 表示的空接口类型并没有方法列表，因此它的第一个指针字段指向一个 _type 类型结构，这个结构为该接口类型变量的动态类型的信息，它的定义是这样的："}]},{"ID":"20240311102651-rdvl8u0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311102651-rdvl8u0","updated":"20240311102658"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"\n// $GOROOT/src/runtime/type.go\n\ntype _type struct {\n    size       uintptr\n    ptrdata    uintptr // size of memory prefix holding all pointers\n    hash       uint32\n    tflag      tflag\n    align      uint8\n    fieldAlign uint8\n    kind       uint8\n    // function for comparing objects of this type\n    // (ptr to object A, ptr to object B) -\u003e ==?\n    equal func(unsafe.Pointer, unsafe.Pointer) bool\n    // gcdata stores the GC type data for the garbage collector.\n    // If the KindGCProg bit is set in kind, gcdata is a GC program.\n    // Otherwise it is a ptrmask bitmap. See mbitmap.go for details.\n    gcdata    *byte\n    str       nameOff\n    ptrToThis typeOff\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311102700-kmrtgis","Type":"NodeParagraph","Properties":{"id":"20240311102700-kmrtgis","updated":"20240311102704"},"Children":[{"Type":"NodeText","Data":"而 iface 除了要存储动态类型信息之外，还要存储接口本身的信息（接口的类型信息、方法列表信息等）以及动态类型所实现的方法的信息，因此 iface 的第一个字段指向一个 itab 类型结构。itab 结构的定义如下："}]},{"ID":"20240311102706-yq2tv7c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311102706-yq2tv7c","updated":"20240311102713"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// $GOROOT/src/runtime/runtime2.go\ntype itab struct {\n    inter *interfacetype\n    _type *_type\n    hash  uint32 // copy of _type.hash. Used for type switches.\n    _     [4]byte\n    fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311102718-v6ipxnn","Type":"NodeParagraph","Properties":{"id":"20240311102718-v6ipxnn","updated":"20240311102719"},"Children":[{"Type":"NodeText","Data":"这里我们也可以看到，itab 结构中的第一个字段 inter 指向的 interfacetype 结构，存储着这个接口类型自身的信息。你看一下下面这段代码表示的 interfacetype 类型定义，这个 interfacetype 结构由类型信息（typ）、包路径名（pkgpath）和接口方法集合切片（mhdr）组成"}]},{"ID":"20240311102720-4q8x72y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311102720-4q8x72y","updated":"20240311102727"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// $GOROOT/src/runtime/type.go\ntype interfacetype struct {\n    typ     _type\n    pkgpath name\n    mhdr    []imethod\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311102733-tglin4q","Type":"NodeParagraph","Properties":{"id":"20240311102733-tglin4q","updated":"20240311102733"},"Children":[{"Type":"NodeText","Data":"itab 结构中的字段 _type 则存储着这个接口类型变量的动态类型的信息，字段 fun 则是动态类型已实现的接口方法的调用地址数组。"}]},{"ID":"20240311102733-ebis1im","Type":"NodeParagraph","Properties":{"id":"20240311102733-ebis1im","updated":"20240311102733"},"Children":[{"Type":"NodeText","Data":"下面我们再结合例子用图片来直观展现 eface 和 iface 的结构。首先我们看一个用 eface 表示的空接口类型变量的例子："}]},{"ID":"20240311102734-cfkb166","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311102734-cfkb166","updated":"20240311102741"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type T struct {\n    n int\n    s string\n}\n\nfunc main() {\n    var t = T {\n        n: 17,\n        s: \"hello, interface\",\n    }\n  \n    var ei interface{} = t // Go运行时使用eface结构表示ei\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311102745-v83c9m8","Type":"NodeParagraph","Properties":{"id":"20240311102745-v83c9m8","updated":"20240311102745"},"Children":[{"Type":"NodeText","Data":"这个例子中的空接口类型变量 ei 在 Go 运行时的表示是这样的："}]},{"ID":"20240311102758-75hsbe9","Type":"NodeParagraph","Properties":{"id":"20240311102758-75hsbe9","updated":"20240311102758"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"183a08b52ef68880eea1122330d437ab"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/183a08b52ef68880eea1122330d437ab-20240311102758-5kuv77n.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240311102804-76xp38m","Type":"NodeParagraph","Properties":{"id":"20240311102804-76xp38m","updated":"20240311102804"},"Children":[{"Type":"NodeText","Data":"我们看到空接口类型的表示较为简单，图中上半部分 _type 字段指向它的动态类型 T 的类型信息，下半部分的 data 则是指向一个 T 类型的实例值。"}]},{"ID":"20240311102804-pqd5e6y","Type":"NodeParagraph","Properties":{"id":"20240311102804-pqd5e6y","updated":"20240311102804"},"Children":[{"Type":"NodeText","Data":"我们再来看一个更复杂的用 iface 表示非空接口类型变量的例子："}]},{"ID":"20240311102807-1jktgn7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311102807-1jktgn7","updated":"20240311102820"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type T struct {\n    n int\n    s string\n}\n\nfunc (T) M1() {}\nfunc (T) M2() {}\n\ntype NonEmptyInterface interface {\n    M1()\n    M2()\n}\n\nfunc main() {\n    var t = T{\n        n: 18,\n        s: \"hello, interface\",\n    }\n    var i NonEmptyInterface = t\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311102824-dxr2nwn","Type":"NodeParagraph","Properties":{"id":"20240311102824-dxr2nwn","updated":"20240311102824"},"Children":[{"Type":"NodeText","Data":"和 eface 比起来，iface 的表示稍微复杂些。我也画了一幅表示上面 NonEmptyInterface 接口类型变量在 Go 运行时表示的示意图："}]},{"ID":"20240311102834-0t83ij7","Type":"NodeParagraph","Properties":{"id":"20240311102834-0t83ij7","updated":"20240311102834"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"f891fb53296ad3289d5db23f0d0e6b40"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/f891fb53296ad3289d5db23f0d0e6b40-20240311102834-himcb8m.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240311102843-o6ow1u1","Type":"NodeParagraph","Properties":{"id":"20240311102843-o6ow1u1","updated":"20240311102843"},"Children":[{"Type":"NodeText","Data":"由上面的这两幅图，我们可以看出，每个接口类型变量在运行时的表示都是由两部分组成的，针对不同接口类型我们可以简化记作：eface(_type, data) 和 iface(tab, data)。"}]},{"ID":"20240311102843-n5dg4r5","Type":"NodeParagraph","Properties":{"id":"20240311102843-n5dg4r5","updated":"20240311102843"},"Children":[{"Type":"NodeText","Data":"而且，虽然 eface 和 iface 的第一个字段有所差别，但 tab 和 _type 可以统一看作是动态类型的类型信息。Go 语言中每种类型都会有唯一的 _type 信息，无论是内置原生类型，还是自定义类型都有。Go 运行时会为程序内的全部类型建立只读的共享 _type 信息表，因此拥有相同动态类型的同类接口类型变量的 _type/tab 信息是相同的。"}]},{"ID":"20240311102843-gvnk6tm","Type":"NodeParagraph","Properties":{"id":"20240311102843-gvnk6tm","updated":"20240311102843"},"Children":[{"Type":"NodeText","Data":"而接口类型变量的 data 部分则是指向一个动态分配的内存空间，这个内存空间存储的是赋值给接口类型变量的动态类型变量的值。未显式初始化的接口类型变量的值为nil，也就是这个变量的 _type/tab 和 data 都为 nil。"}]},{"ID":"20240311102843-sqz2pnv","Type":"NodeParagraph","Properties":{"id":"20240311102843-sqz2pnv","updated":"20240311102843"},"Children":[{"Type":"NodeText","Data":"也就是说，我们判断两个接口类型变量是否相等，只需判断 _type/tab 以及 data 是否都相等即可。两个接口变量的 _type/tab 不同时，即两个接口变量的动态类型不相同时，两个接口类型变量一定不等。"}]},{"ID":"20240311102843-kt2opal","Type":"NodeParagraph","Properties":{"id":"20240311102843-kt2opal","updated":"20240311102843"},"Children":[{"Type":"NodeText","Data":"当两个接口变量的 _type/tab 相同时，对 data 的相等判断要有区分。当接口变量的动态类型为指针类型时 (*T)，Go 不会再额外分配内存存储指针值，而会将动态类型的指针值直接存入 data 字段中，这样 data 值的相等性决定了两个接口类型变量是否相等；当接口变量的动态类型为非指针类型 (T) 时，我们判断的将不是 data 指针的值是否相等，而是判断 data 指针指向的内存空间所存储的数据值是否相等，若相等，则两个接口类型变量相等。"}]},{"ID":"20240311102843-ea1m4s8","Type":"NodeParagraph","Properties":{"id":"20240311102843-ea1m4s8","updated":"20240311102843"},"Children":[{"Type":"NodeText","Data":"不过，通过肉眼去辨别接口类型变量是否相等总是困难一些，我们可以引入一些 helper 函数。借助这些函数，我们可以清晰地输出接口类型变量的内部表示，这样就可以一目了然地看出两个变量是否相等了。"}]},{"ID":"20240311102843-n84kpot","Type":"NodeParagraph","Properties":{"id":"20240311102843-n84kpot","updated":"20240311102843"},"Children":[{"Type":"NodeText","Data":"由于 eface 和 iface 是 runtime 包中的非导出结构体定义，我们不能直接在包外使用，所以也就无法直接访问到两个结构体中的数据。不过，Go 语言提供了 println 预定义函数，可以用来输出 eface 或 iface 的两个指针字段的值。"}]},{"ID":"20240311102843-9wxkkb1","Type":"NodeParagraph","Properties":{"id":"20240311102843-9wxkkb1","updated":"20240311102843"},"Children":[{"Type":"NodeText","Data":"在编译阶段，编译器会根据要输出的参数的类型将 println 替换为特定的函数，这些函数都定义在 $GOROOT/src/runtime/print.go 文件中，而针对 eface 和 iface 类型的打印函数实现如下："}]},{"ID":"20240311102845-o4x2xn5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311102845-o4x2xn5","updated":"20240311102851"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"// $GOROOT/src/runtime/print.go\nfunc printeface(e eface) {\n    print(\"(\", e._type, \",\", e.data, \")\")\n}\n\nfunc printiface(i iface) {\n    print(\"(\", i.tab, \",\", i.data, \")\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311102852-vbsrsuv","Type":"NodeParagraph","Properties":{"id":"20240311102852-vbsrsuv","updated":"20240311102856"},"Children":[{"Type":"NodeText","Data":"我们看到，printeface 和 printiface 会输出各自的两个指针字段的值。下面我们就来使用 println 函数输出各类接口类型变量的内部表示信息，并结合输出结果，解析接口类型变量的等值比较操作。"}]},{"ID":"20240311102857-vsgv9e2","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240311102857-vsgv9e2","updated":"20240311102910"},"Children":[{"Type":"NodeText","Data":"3.2 nil 接口变量案例"}]},{"ID":"20240311102910-20sivyv","Type":"NodeParagraph","Properties":{"id":"20240311102910-20sivyv","updated":"20240311102915"},"Children":[{"Type":"NodeText","Data":"我们知道，未赋初值的接口类型变量的值为 nil，这类变量也就是 nil 接口变量，我们来看这类变量的内部表示输出的例子："}]},{"ID":"20240311102916-qti6k83","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311102916-qti6k83","updated":"20240311102932"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"func printNilInterface() {\n  // nil接口变量\n  var i interface{} // 空接口类型\n  var err error     // 非空接口类型\n  println(i)\n  println(err)\n  println(\"i = nil:\", i == nil)\n  println(\"err = nil:\", err == nil)\n  println(\"i = err:\", i == err)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311102937-yz6ggtf","Type":"NodeParagraph","Properties":{"id":"20240311102937-yz6ggtf","updated":"20240311102937"},"Children":[{"Type":"NodeText","Data":"运行这个函数，输出结果是这样的："}]},{"ID":"20240311102938-li4z6h3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311102938-li4z6h3","updated":"20240311102947"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"(0x0,0x0)\n(0x0,0x0)\ni = nil: true\nerr = nil: true\ni = err: true\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311102944-odop613","Type":"NodeParagraph","Properties":{"id":"20240311102944-odop613","updated":"20240311104156"},"Children":[{"Type":"NodeText","Data":"我们看到，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"无论是空接口类型还是非空接口类型变量，一旦变量值为 nil，那么它们内部表示均为 (0x0, 0x0)，也就是类型信息、数据值信息均为空。"},{"Type":"NodeText","Data":"因此上面的变量 i 和 err 等值判断为 true。"}]},{"ID":"20240311102952-7tjfa2s","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240311102952-7tjfa2s","updated":"20240311103006"},"Children":[{"Type":"NodeText","Data":"3.3 空接口类型变量案例"}]},{"ID":"20240311103006-3acfhb1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311103006-3acfhb1","updated":"20240311103014"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":" func printEmptyInterface() {\n      var eif1 interface{} // 空接口类型\n      var eif2 interface{} // 空接口类型\n      var n, m int = 17, 18\n  \n      eif1 = n\n      eif2 = m\n\n      println(\"eif1:\", eif1)\n      println(\"eif2:\", eif2)\n      println(\"eif1 = eif2:\", eif1 == eif2) // false\n  \n      eif2 = 17\n      println(\"eif1:\", eif1)\n      println(\"eif2:\", eif2)\n      println(\"eif1 = eif2:\", eif1 == eif2) // true\n \n      eif2 = int64(17)\n      println(\"eif1:\", eif1)\n      println(\"eif2:\", eif2)\n      println(\"eif1 = eif2:\", eif1 == eif2) // false\n }\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311103022-xb943ol","Type":"NodeParagraph","Properties":{"id":"20240311103022-xb943ol","updated":"20240311103022"},"Children":[{"Type":"NodeText","Data":"运行结果如下："}]},{"ID":"20240311103022-xqn2zmw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311103022-xqn2zmw","updated":"20240311103022"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"eif1: (0x10ac580,0xc00007ef48)\neif2: (0x10ac580,0xc00007ef40)\neif1 = eif2: false\neif1: (0x10ac580,0xc00007ef48)\neif2: (0x10ac580,0x10eb3d0)\neif1 = eif2: true\neif1: (0x10ac580,0xc00007ef48)\neif2: (0x10ac640,0x10eb3d8)\neif1 = eif2: false\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311103022-h7jcv2n","Type":"NodeParagraph","Properties":{"id":"20240311103022-h7jcv2n","updated":"20240311104321"},"Children":[{"Type":"NodeText","Data":"首先，代码执行到第 11 行时，eif1 与 eif2 已经分别被赋值整型值 17 与 18，这样 eif1 和 eif2 的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"动态类型的类型信息是相同的"},{"Type":"NodeText","Data":"（都是 0x10ac580），但 data 指针指向的内存块中存储的值不同，一个是 17，一个是 18，于是 eif1 不等于 eif2。"}]},{"ID":"20240311103022-jlgawrs","Type":"NodeParagraph","Properties":{"id":"20240311103022-jlgawrs","updated":"20240311104332"},"Children":[{"Type":"NodeText","Data":"接着，代码执行到第 16 行的时候，eif2 已经被重新赋值为 17，这样 eif1 和 eif2 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"不仅存储的动态类型的类型信息是相同的（都是 0x10ac580），data 指针指向的内存块中存储值也相同了"},{"Type":"NodeText","Data":"，都是 17，于是 eif1 等于 eif2。"}]},{"ID":"20240311103022-cu291uq","Type":"NodeParagraph","Properties":{"id":"20240311103022-cu291uq","updated":"20240311104356"},"Children":[{"Type":"NodeText","Data":"然后，代码执行到第 21 行时，eif2 已经被重新赋值了 int64 类型的数值 17。这样，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"eif1 和 eif2 存储的动态类型的类型信息就变成不同的了，一个是 int，一个是 int64，即便 data 指针指向的内存块中存储值是相同的，最终 eif1 与 eif2 也是不相等的。"}]},{"ID":"20240311103023-2zz7mn4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240311103023-2zz7mn4","updated":"20240311103034"},"Children":[{"Type":"NodeText","Data":"3.4 非空接口类型变量案例"}]},{"ID":"20240311103034-t7hsza2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311103034-t7hsza2","updated":"20240311103045"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"type T int\n\nfunc (t T) Error() string { \n    return \"bad error\"\n}\n\nfunc printNonEmptyInterface() { \n    var err1 error // 非空接口类型\n    var err2 error // 非空接口类型\n    err1 = (*T)(nil)\n    println(\"err1:\", err1)\n    println(\"err1 = nil:\", err1 == nil)\n\n    err1 = T(5)\n    err2 = T(6)\n    println(\"err1:\", err1)\n    println(\"err2:\", err2)\n    println(\"err1 = err2:\", err1 == err2)\n\n    err2 = fmt.Errorf(\"%d\\n\", 5)\n    println(\"err1:\", err1)\n    println(\"err2:\", err2)\n    println(\"err1 = err2:\", err1 == err2)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311103051-rn2vsil","Type":"NodeParagraph","Properties":{"id":"20240311103051-rn2vsil","updated":"20240311103051"},"Children":[{"Type":"NodeText","Data":"我们看到上面示例中每一轮通过 println 输出的 err1 和 err2 的 tab 和 data 值，要么 data 值不同，要么 tab 与 data 值都不同。"}]},{"ID":"20240311103051-dzw8arp","Type":"NodeParagraph","Properties":{"id":"20240311103051-dzw8arp","updated":"20240311103051"},"Children":[{"Type":"NodeText","Data":"和空接口类型变量一样，只有 tab 和 data 指的数据内容一致的情况下，两个非空接口类型变量之间才能划等号。这里我们要注意 err1 下面的赋值情况："}]},{"ID":"20240311103052-bi8cztj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311103052-bi8cztj","updated":"20240311103106"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"err1 = (*T)(nil)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311103111-nohnvni","Type":"NodeParagraph","Properties":{"id":"20240311103111-nohnvni","updated":"20240311104553"},"Children":[{"Type":"NodeText","Data":"针对这种赋值，println 输出的 err1 是（0x10ed120, 0x0），也就是"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"非空接口类型变量的类型信息并不为空，数据指针为空，因此它与 nil（0x0, 0x0）之间不能划等号"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240311103111-0k3ndy6","Type":"NodeParagraph","Properties":{"id":"20240311103111-0k3ndy6","updated":"20240311103111"},"Children":[{"Type":"NodeText","Data":"现在我们再回到我们开头的那个问题，你是不是已经豁然开朗了呢？开头的问题中，从 returnsError 返回的 error 接口类型变量 err 的数据指针虽然为空，但它的类型信息（iface.tab）并不为空，而是 *MyError 对应的类型信息，这样 err 与 nil（0x0,0x0）相比自然不相等，这就是我们开头那个问题的答案解析，现在你明白了吗？"}]},{"ID":"20240311103112-id7pxbw","Type":"NodeParagraph","Properties":{"id":"20240311103112-id7pxbw"}}]}