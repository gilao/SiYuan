{"ID":"20240311104652-xoeqikp","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f30e","id":"20240311104652-xoeqikp","tags":"Go-竞态检测,Go-Race Detetor","title":"Go 工具 竟态条件检测神器","updated":"20240311110335"},"Children":[{"ID":"20240311104715-mjcwupp","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240311104715-mjcwupp","updated":"20240311104727"},"Children":[{"Type":"NodeText","Data":"一、什么是数据竞争"}]},{"ID":"20240311104727-zn1gmb5","Type":"NodeParagraph","Properties":{"id":"20240311104727-zn1gmb5","updated":"20240311104741"},"Children":[{"Type":"NodeText","Data":"数据竞争问题是指在多线程编程中，两个或多个线程同时访问共享数据，且至少有一个线程对共享数据进行了写操作，从而导致程序出现未定义的行为。数据竞争问题是多线程编程中常见的问题，也是一种非常难以调试和修复的问题。"}]},{"ID":"20240311104743-uzo36k9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240311104743-uzo36k9","updated":"20240311104807"},"Children":[{"Type":"NodeText","Data":"1.1 数据竞争问题通常会导致哪些情况出现？"}]},{"ID":"20240311104807-m6c28e2","Type":"NodeList","ListData":{},"Properties":{"id":"20240311104807-m6c28e2","updated":"20240311105124"},"Children":[{"ID":"20240311104808-1jfp0l2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311104808-1jfp0l2","updated":"20240311105124"},"Children":[{"ID":"20240311104808-y5gov7i","Type":"NodeParagraph","Properties":{"id":"20240311104808-y5gov7i","updated":"20240311105124"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"资源争用"},{"Type":"NodeText","Data":"：多个线程同时访问同一个共享资源，例如同一个变量，同一个文件等导致资源争用，从而影响程序的正确性和性能。"}]}]},{"ID":"20240311104920-640xkag","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311104920-640xkag"},"Children":[{"ID":"20240311104920-xi5h9ug","Type":"NodeParagraph","Properties":{"id":"20240311104920-xi5h9ug","updated":"20240311105021"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"内存访问冲突："},{"Type":"NodeText","Data":"多个线程同时访问同一个内存地址，导致内存访问冲突，从而导致出现未定义的行为，例如崩溃、死锁等。"}]}]},{"ID":"20240311105022-p147xd3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311105022-p147xd3","updated":"20240311105121"},"Children":[{"ID":"20240311105022-i4cktrk","Type":"NodeParagraph","Properties":{"id":"20240311105022-i4cktrk","updated":"20240311105121"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"竟态条件"},{"Type":"NodeText","Data":"：多个线程同时访问同一个代码块，导致代码的执行顺序不确定，从而导致程序出现未定义的行为。"}]}]}]},{"ID":"20240311104652-j2ns118","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240311104652-j2ns118","updated":"20240311105141"},"Children":[{"Type":"NodeText","Data":"1.2 数据竞争问题产生的原因"}]},{"ID":"20240311105142-rnsz1y8","Type":"NodeList","ListData":{},"Properties":{"id":"20240311105142-rnsz1y8","updated":"20240311105146"},"Children":[{"ID":"20240311105146-zofbg9a","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311105146-zofbg9a","updated":"20240311105146"},"Children":[{"ID":"20240311105146-lzpfgpl","Type":"NodeParagraph","Properties":{"id":"20240311105146-lzpfgpl","updated":"20240311105300"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"多个线程同时访问共享数据："},{"Type":"NodeText","Data":" 当多个线程同时访问同一个共享数据时，就有可能产生数据竞争问题。例如：多个线程同时访问一个变量，同一文件等。"}]}]},{"ID":"20240311105301-f7emuwl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311105301-f7emuwl"},"Children":[{"ID":"20240311105301-7shnx38","Type":"NodeParagraph","Properties":{"id":"20240311105301-7shnx38","updated":"20240311105329"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"至少有一个线程对共享数据进行了写操作"},{"Type":"NodeText","Data":"：当至少有一个线程对共享数据进行了写操作时，就有可能产生数据竞争问题。因为多个线程同时对同一个数据进行写操作，就有可能导致数据的不一致性。"}]}]},{"ID":"20240311105331-5p175p4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311105331-5p175p4"},"Children":[{"ID":"20240311105331-ugkq6hc","Type":"NodeParagraph","Properties":{"id":"20240311105331-ugkq6hc","updated":"20240311105535"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺乏同步机制"},{"Type":"NodeText","Data":"：当多个线程缺乏同步机制时，就有可能产生数据竞争问题。例如，多个线程同时对同一个变量进行写操作，但是没有使用锁或者其他同步机制来保证线程之间的异步。"}]}]},{"ID":"20240311105536-9k1m6tn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311105536-9k1m6tn"},"Children":[{"ID":"20240311105536-izsyvas","Type":"NodeParagraph","Properties":{"id":"20240311105536-izsyvas","updated":"20240311105717"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"竟态条件"},{"Type":"NodeText","Data":"：当多个线程同时执行一个代码块时，就有可能产生竟态条件，从而导致数据竞争问题。例如，多个线程同时执行一个if语句，但是if 语句中的条件依赖于共享数据，就有可能导致数据竞争问题。"}]}]}]},{"ID":"20240311105718-pljkx1v","Type":"NodeParagraph","Properties":{"id":"20240311105718-pljkx1v","updated":"20240311105726"},"Children":[{"Type":"NodeText","Data":"为了避免竞态条件的产生，需要使用同步机制（如互斥锁、条件变量等）来协调线程之间的访问。然而，在复杂的程序中，竞态条件可能难以察觉，因此 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Golang"},{"Type":"NodeText","Data":" 提供了竞态条件检测工具 Race Detector。"}]},{"ID":"20240311105727-98s32q0","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240311105727-98s32q0","updated":"20240311105743"},"Children":[{"Type":"NodeText","Data":"二、Race Detetor"}]},{"ID":"20240311105744-asafoe0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240311105744-asafoe0","updated":"20240311105747"},"Children":[{"Type":"NodeText","Data":"2.1 原理"}]},{"ID":"20240311105754-azy64vc","Type":"NodeParagraph","Properties":{"id":"20240311105754-azy64vc","updated":"20240311105754"},"Children":[{"Type":"NodeText","Data":"race detector 集成在了 golang 的工具链中，当设置了 -race 标志位时，编译器会使用代码记录所有的内存访问，包括访问内存的时间和方式，而运行时库则监控对共享变量的不同步访问情况。当检测到这种竞态行为时，将会打印警告信息。"}]},{"ID":"20240311105754-n7r1mie","Type":"NodeParagraph","Properties":{"id":"20240311105754-n7r1mie","updated":"20240311105754"},"Children":[{"Type":"NodeText","Data":"因为 race detector 只有在代码运行起来并且竞争条件被触发后才能检测到，所以需要在实际工作负载状态下进行检测，但是开启竞态条件检测会占用10倍的 CPU 和内存，因此在生产环境进行是不太现实的，所以推荐在负载测试或者集成测试阶段进行竞态条件检测（也可以在生产环境中部署多个实例，其中一个实例开启竞态条件检测）。"}]},{"ID":"20240311105754-05y4y60","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240311105754-05y4y60","updated":"20240311105754"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"2.2 使用方法"}]},{"ID":"20240311105801-7vnnf0w","Type":"NodeParagraph","Properties":{"id":"20240311105801-7vnnf0w","updated":"20240311105801"},"Children":[{"Type":"NodeText","Data":"race detector 与 go 工具链集成。设置 -race 命令行标志后，编译器会使用记录访问内存的时间和方式的代码来检测所有内存访问，同时运行时库会监视对共享变量的非同步访问。当检测到这种“不雅”行为时，会打印一条警告。"}]},{"ID":"20240311105801-bniv3d6","Type":"NodeParagraph","Properties":{"id":"20240311105801-bniv3d6","updated":"20240311105801"},"Children":[{"Type":"NodeText","Data":"由于其设计，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"竞争检测器只能在竞争条件实际被运行代码触发时检测到竞争条件，这意味着在实际工作负载下运行启用竞争的二进制文件非常重要。"},{"Type":"NodeText","Data":"但是，启用竞争的二进制文件可以使用十倍的 CPU 和内存，因此始终启用竞争检测器是不切实际的。摆脱这种困境的一种方法是在启用竞争检测器的情况下运行一些测试。负载测试和集成测试是很好的候选者，因为它们倾向于执行代码的并发部分。另一种使用生产工作负载的方法是在正在运行的服务器池中部署一个支持竞争的实例。"}]},{"ID":"20240311105801-vicz1kd","Type":"NodeParagraph","Properties":{"id":"20240311105801-vicz1kd","updated":"20240311105801"},"Children":[{"Type":"NodeText","Data":"竞争检测器与 Go 工具链完全集成。要在启用竞争检测器的情况下构建代码，只需将 -race 标志添加到命令行："}]},{"ID":"20240311105826-ma82cdm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311105826-ma82cdm","updated":"20240311105925"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"go test -race mytest // 测试包\ngo run -race mytest.go // 编译并运行\ngo build -race mytestcmd // 编译\ngo install -race mytest // 安装包\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311105936-o6ys10l","Type":"NodeParagraph","Properties":{"id":"20240311105936-o6ys10l","updated":"20240311105955"},"Children":[{"Type":"NodeText","Data":"看一个具体的示例，代码如下："}]},{"ID":"20240311105956-fxphuc8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311105956-fxphuc8","updated":"20240311110150"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"pacakge main\n\nimport \"fmt\"\n\nfunc main() {\n  done := make(chan bool)\n  m := make(map[string]string)\n  m[\"name\"] = \"world\"\n  go func() {\n    m[\"name\"] = \"data race\"\n    done \u003c- true\n  }()\n  fmt.Println(\"Hello\",m[\"name\"])\n  \u003c-done\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311105945-zkwzf58","Type":"NodeParagraph","Properties":{"id":"20240311105945-zkwzf58","updated":"20240311110224"},"Children":[{"Type":"NodeText","Data":"使用如下命令进行竞态条件检测："}]},{"ID":"20240311110224-2m91bdd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311110224-2m91bdd","updated":"20240311110327"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"$ go run -race racy.go\nHello,world\n================\nWARNING: DATA RACE\nWrite at 0x00c0000940c0 by goroutine 6:\n  runtime.mapassign_faststr()\n      /usr/local/go1.21/src/runtime/map_faststr.go:203 +0x0\n  main.main.func1()\n      /Users/nick/projects/go/workspace/hello/racy.go:10 +0x4a\n\nPrevious read at 0x00c0000940c0 by main goroutine:\n  runtime.mapaccess1_faststr()\n      /usr/local/go1.21/src/runtime/map_faststr.go:13 +0x0\n  main.main()\n      /Users/nick/projects/go/workspace/hello/racy.go:13 +0x159\n\nGoroutine 6 (running) created at:\n  main.main()\n      /Users/nick/projects/go/workspace/hello/racy.go:9 +0x13c\n==================\n==================\nWARNING: DATA RACE\nWrite at 0x00c0000ac088 by goroutine 6:\n  main.main.func1()\n      /Users/nick/projects/go/workspace/hello/racy.go:10 +0x56\n\nPrevious read at 0x00c0000ac088 by main goroutine:\n  main.main()\n      /Users/nick/projects/go/workspace/hello/racy.go:13 +0x164\n\nGoroutine 6 (running) created at:\n  main.main()\n      /Users/nick/projects/go/workspace/hello/racy.go:9 +0x13c\n==================\nFound 2 data race(s)\nexit status 66\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311110334-efev2c2","Type":"NodeParagraph","Properties":{"id":"20240311110334-efev2c2","updated":"20240311110335"},"Children":[{"Type":"NodeText","Data":"race detector 是一个用于检查并发逻辑正确性的强大工具，不会误报，所以一定要认真解决检测出的问题。代码被执行到的越多也就是代码覆盖率越高，检测效果越好。通过合理使用 race detector，可以提高并发程序的质量和稳定性。"}]}]}