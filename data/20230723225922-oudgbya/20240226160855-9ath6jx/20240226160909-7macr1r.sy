{"ID":"20240226160909-7macr1r","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f4d3","id":"20240226160909-7macr1r","title":"golang 高性能无 GC 的缓存库 bigcache 是怎么实现的？","updated":"20240226163213"},"Children":[{"ID":"20240226160944-wtox0kt","Type":"NodeParagraph","Properties":{"id":"20240226160944-wtox0kt","updated":"20240226160949"},"Children":[{"Type":"NodeText","Data":"我们写代码的时候，经常会需要从数据库里读取一些数据，比如配置信息或者诸如每周热点商品之类的数据。"}]},{"ID":"20240226160957-7y592yq","Type":"NodeParagraph","Properties":{"id":"20240226160957-7y592yq","updated":"20240226160957"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"1cc946e967785720ed75e13a6542cd9c"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/1cc946e967785720ed75e13a6542cd9c-20240226160956-b7mz93w.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240226160909-ctiay7m","Type":"NodeParagraph","Properties":{"id":"20240226160909-ctiay7m","updated":"20240226161001"},"Children":[{"Type":"NodeText","Data":"如果这些数据既不经常变化，又需要频繁读取，那比起每次都去读数据库，更优的解决方案就是将它们放到"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"应用的本地内存"},{"Type":"NodeText","Data":"里，这样可以省下不少"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"数据库 IO"},{"Type":"NodeText","Data":"，性能嘎一下就上来了。"}]},{"ID":"20240226161011-t463qk3","Type":"NodeParagraph","Properties":{"id":"20240226161011-t463qk3","updated":"20240226161011"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240226161011-uzkmf6w.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240226161012-okber2o","Type":"NodeParagraph","Properties":{"id":"20240226161012-okber2o","updated":"20240226161016"},"Children":[{"Type":"NodeText","Data":"那么现在问题就来了，假设我要在某个服务应用里实现一个"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缓存组件"},{"Type":"NodeText","Data":"去存各种类型的数据，该怎么实现这个组件呢？"}]},{"ID":"20240226161027-wrn0yss","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226161027-wrn0yss","updated":"20240226161035"},"Children":[{"Type":"NodeText","Data":"从一个 map 说起"}]},{"ID":"20240226161035-t5m5p35","Type":"NodeParagraph","Properties":{"id":"20240226161035-t5m5p35","updated":"20240226161040"},"Children":[{"Type":"NodeText","Data":"最简单的的方案就是使用 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"，也就是"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"字典"},{"Type":"NodeText","Data":"，将需要保存的结构以 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"key-value"},{"Type":"NodeText","Data":"​ 的形式，保存到内存中。比如系统配置，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"key"},{"Type":"NodeText","Data":" 就叫 system_config，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"value"},{"Type":"NodeText","Data":" 就是具体的配置内容。需要读取数据就用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"v = m[key]"},{"Type":"NodeText","Data":"​来获取数据，需要写数据就执行"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m[key] = v"},{"Type":"NodeText","Data":"​."}]},{"ID":"20240226161047-pokem54","Type":"NodeParagraph","Properties":{"id":"20240226161047-pokem54","updated":"20240226161047"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"dd3b8f4c80f4508a1f336bf0d7ef4d55"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/dd3b8f4c80f4508a1f336bf0d7ef4d55-20240226161047-igepuui.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240226161055-v67chly","Type":"NodeParagraph","Properties":{"id":"20240226161055-v67chly","updated":"20240226161055"},"Children":[{"Type":"NodeText","Data":"这样看起来在"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"单线程"},{"Type":"NodeText","Data":"下是满足需求了。但如果我想在"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"多个线程（协程）"},{"Type":"NodeText","Data":"里并发读写这个缓存呢？那必然会发生"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"竞态"},{"Type":"NodeText","Data":"问题。这就需要加个"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"读写锁"},{"Type":"NodeText","Data":"了。读操作前后要"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"加锁和解锁"},{"Type":"NodeText","Data":"，也就是改成下面这样。"}]},{"ID":"20240226161442-oa52fma","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226161442-oa52fma","updated":"20240226161447"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"RLock()\nv = m[key]\nRUnLock()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226161448-gt34r21","Type":"NodeParagraph","Properties":{"id":"20240226161448-gt34r21","updated":"20240226161452"},"Children":[{"Type":"NodeText","Data":"写操作也需要相应修改："}]},{"ID":"20240226161454-nnzcr6x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226161454-nnzcr6x","updated":"20240226161455"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"Lock()\nm[key] = v\nUnLock()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226161504-ckhemqw","Type":"NodeParagraph","Properties":{"id":"20240226161504-ckhemqw","updated":"20240226161504"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"a881ad269e8b132a7e69a1fa7902b9bd"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/a881ad269e8b132a7e69a1fa7902b9bd-20240226161504-0db9pi5.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240226161513-4exel09","Type":"NodeParagraph","Properties":{"id":"20240226161513-4exel09","updated":"20240226161513"},"Children":[{"Type":"NodeText","Data":"这在"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"读写不频繁"},{"Type":"NodeText","Data":"的场景下是完全 ok 的，如果没有什么性能要求，服务也没出现什么瓶颈，就算新来的实习生笑它很 low，你也要有自信，这就是个好用的缓存组件。架构就是这样，能快速满足需求，不出错就行。"}]},{"ID":"20240226161513-uaet0u0","Type":"NodeParagraph","Properties":{"id":"20240226161513-uaet0u0","updated":"20240226161513"},"Children":[{"Type":"NodeText","Data":"但其实这个方案其实也有很大的问题，如果读写 "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkTextContent":"qps"},{"Type":"NodeText","Data":" 非常高，那么就会有一堆请求争抢"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"同一个 map 锁"},{"Type":"NodeText","Data":"，这对性能影响太大了。怎么解决呢？"}]},{"ID":"20240226161516-0pbul47","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226161516-0pbul47","updated":"20240226161525"},"Children":[{"Type":"NodeText","Data":"将锁粒度变小"}]},{"ID":"20240226161525-bf5e0ze","Type":"NodeParagraph","Properties":{"id":"20240226161525-bf5e0ze","updated":"20240226161531"},"Children":[{"Type":"NodeText","Data":"上面的方案中，最大的问题是所有读写请求，都抢的同一个锁，所以竞争才大，如果能将一部分请求改为抢 A 锁，另一部分请求改为抢 B 锁，那竞争就变小了。于是，我们可以将原来的一个 map，进行"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"分片"},{"Type":"NodeText","Data":"，变成多个 map，每个 map 都有自己的锁。发生读写操作时，第一步先对 key 进行 hash 分片，获取分片对应的锁后，再对分片 map 进行读写。只有落在"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"同一个分片"},{"Type":"NodeText","Data":"的请求才会发生锁争抢。也就是说 map 拆的越细，锁竞争就越小。"}]},{"ID":"20240226161550-6n5ih8a","Type":"NodeParagraph","Properties":{"id":"20240226161550-6n5ih8a","updated":"20240226161550"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"d17dd5ff93ff5f43f75dc9fe8105d911"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/d17dd5ff93ff5f43f75dc9fe8105d911-20240226161550-vqf01lc.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240226161556-s8dqi35","Type":"NodeParagraph","Properties":{"id":"20240226161556-s8dqi35","updated":"20240226161556"},"Children":[{"Type":"NodeText","Data":"像这种将资源分割成多个独立的分片（segments/shard），每个段都有一个对应的锁来控制并发访问的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"控制机制"},{"Type":"NodeText","Data":", 其实就是所谓的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"分片（段）锁"},{"Type":"NodeText","Data":"。看起来很完美，但其实还有问题。"}]},{"ID":"20240226162153-1n8ck9o","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226162153-1n8ck9o","updated":"20240226162202"},"Children":[{"Type":"NodeText","Data":"gc 带来的问题"}]},{"ID":"20240226162203-ba1g9xa","Type":"NodeParagraph","Properties":{"id":"20240226162203-ba1g9xa","updated":"20240226162207"},"Children":[{"Type":"NodeText","Data":"像 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"C/C++"},{"Type":"NodeText","Data":"​这类语言中，用户申请的内存需要由用户自己写代码去释放，一不小心忘了释放那就会发生"},{"Type":"NodeTextMark","TextMarkType":"strong a","TextMarkTextContent":"内存泄露"},{"Type":"NodeText","Data":"，给程序员带来了很大的心智负担。为了避免这样的问题，一般高级语言里都会自带 GC，也就是"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"垃圾回收"},{"Type":"NodeText","Data":"（"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkTextContent":"Garbage Collection"},{"Type":"NodeText","Data":"），说白了就是程序员只管申请内存，用完了系统会自动回收释放这些内存。比如 golang，它会每隔一段时间就去扫描哪些变量内存是可以被回收的。对于指针类型，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"golang 会先扫指针，再扫描指针指向的对象里的内容"},{"Type":"NodeText","Data":"。map缓存里放的东西少还好说，缓存里的 "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkTextContent":"key-value"},{"Type":"NodeText","Data":" 一多，那就喜提多遍疯狂扫描，浪费，全是浪费，golang 你糊涂啊。"}]},{"ID":"20240226162244-5pmujy2","Type":"NodeParagraph","Properties":{"id":"20240226162244-5pmujy2","updated":"20240226162244"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"4614e2b30c15bfcc065bb223661bc87c"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/4614e2b30c15bfcc065bb223661bc87c-20240226162244-rhne50a.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240226162248-3lei2ac","Type":"NodeParagraph","Properties":{"id":"20240226162248-3lei2ac","updated":"20240226162259"},"Children":[{"Type":"NodeText","Data":"那有没有办法可以减少这部分 gc 扫描 成本呢？有。golang 对于key 和 value 都不含指针的的map，会选择跳过，不进行 gc 扫描。所以我们需要"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"想办法将 map 里的内容改成完全不含指针"},{"Type":"NodeText","Data":"。原来 map 中放的 key-value，key和value 都可能是指针结构体。"}]},{"ID":"20240226162730-pt696no","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240226162730-pt696no","updated":"20240226162736"},"Children":[{"Type":"NodeText","Data":"对于 Key"}]},{"ID":"20240226162737-54y2bg8","Type":"NodeParagraph","Properties":{"id":"20240226162737-54y2bg8","updated":"20240226162741"},"Children":[{"Type":"NodeText","Data":"原来 key 是用的字符串，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在 golang 中字符串本质上也是指针"},{"Type":"NodeText","Data":"，于是我们将它进行 hash 操作，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"将字符串转为整形"},{"Type":"NodeText","Data":"。信息经过 hash 操作后，有可能会丢掉部分信息，为了避免"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"hash冲突"},{"Type":"NodeText","Data":"时分不清具体是哪个 key-value，我们会将 key 放到 value 中一起处理，继续看下面。"}]},{"ID":"20240226162742-scf8hl7","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240226162742-scf8hl7","updated":"20240226162749"},"Children":[{"Type":"NodeText","Data":"对于 Value"}]},{"ID":"20240226162749-o1oiuq1","Type":"NodeParagraph","Properties":{"id":"20240226162749-o1oiuq1","updated":"20240226162754"},"Children":[{"Type":"NodeText","Data":"我们可以构造一个超大的 byte 数组 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"buf"},{"Type":"NodeText","Data":"​，将原来的 key value 等信息经过序列化，变成二进制01串。将它存放到这个超大 buf 中，并记录它在 超大 buf 中的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"位置 index"},{"Type":"NodeText","Data":"。然后将这个"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"位置 index"},{"Type":"NodeText","Data":" 信息放到 map 的 value 位置上，也就是从 key-velue，变成了 key-index。"}]},{"ID":"20240226162802-kfdnuhv","Type":"NodeParagraph","Properties":{"id":"20240226162802-kfdnuhv","updated":"20240226162802"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"a24c2eeefb073db9ef0740e27b53bdc2"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/a24c2eeefb073db9ef0740e27b53bdc2-20240226162802-gatwh5u.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240226162804-m4nyilo","Type":"NodeParagraph","Properties":{"id":"20240226162804-m4nyilo","updated":"20240226162808"},"Children":[{"Type":"NodeText","Data":"同时为了防止 buf 数组变得过大，占用过多内存导致应用oom，还可以采用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ringbuf"},{"Type":"NodeText","Data":"​ 的结构，写到尾部就重头开始写，如果 ringbuf 空间不够，还能对它进行"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"扩容"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240226162813-vi6yh89","Type":"NodeParagraph","Properties":{"id":"20240226162813-vi6yh89","updated":"20240226162813"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"bab8089a5ef895979ff0718c40b2335f"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/bab8089a5ef895979ff0718c40b2335f-20240226162813-ytcsz5w.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240226162815-9k6swpv","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240226162815-9k6swpv","updated":"20240226162826"},"Children":[{"Type":"NodeText","Data":"写操作"}]},{"ID":"20240226162830-iypor5t","Type":"NodeParagraph","Properties":{"id":"20240226162830-iypor5t","updated":"20240226162830"},"Children":[{"Type":"NodeText","Data":"对于写操作，程序先将 key 进行 hash，得到所在分片 map，加锁。"}]},{"ID":"20240226162830-j888fgn","Type":"NodeList","ListData":{},"Properties":{"id":"20240226162830-j888fgn","updated":"20240226162838"},"Children":[{"ID":"20240226162830-gmplqqb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226162830-gmplqqb","updated":"20240226162834"},"Children":[{"ID":"20240226162830-jnjwtn2","Type":"NodeParagraph","Properties":{"id":"20240226162830-jnjwtn2","updated":"20240226162834"},"Children":[{"Type":"NodeText","Data":"如果不能从分片 map 里拿到 index，也就是 map 中没旧数据，那就找到 ringbuf 里的空位置后写入 value，再将index写入map。"}]}]},{"ID":"20240226162830-v5vmlno","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226162830-v5vmlno","updated":"20240226162838"},"Children":[{"ID":"20240226162830-yk2tl0i","Type":"NodeParagraph","Properties":{"id":"20240226162830-yk2tl0i","updated":"20240226162838"},"Children":[{"Type":"NodeText","Data":"如果能从分片 map 里拿到 index，也就是 map 中有旧数据，那就覆盖写 ringbuf。"}]}]}]},{"ID":"20240226162830-she20nm","Type":"NodeParagraph","Properties":{"id":"20240226162830-she20nm","updated":"20240226162830"},"Children":[{"Type":"NodeText","Data":"然后解锁，结束流程。"}]},{"ID":"20240226162844-fewmgc2","Type":"NodeParagraph","Properties":{"id":"20240226162844-fewmgc2","updated":"20240226162844"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"70666952193c92b413b7320e12c41b7d"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/70666952193c92b413b7320e12c41b7d-20240226162844-bf8p5wy.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240226162851-e9cfygh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240226162851-e9cfygh","updated":"20240226162855"},"Children":[{"Type":"NodeText","Data":"读操作"}]},{"ID":"20240226162855-x1hmci7","Type":"NodeParagraph","Properties":{"id":"20240226162855-x1hmci7","updated":"20240226162858"},"Children":[{"Type":"NodeText","Data":"对于读操作，程序同样先对 key 进行 hash，得到分片 map。加锁，从分片 map 里拿到 value 对应的 index，拿着这个 index 到 ringbuf 数组中去获取到 value 的值，然后解锁，结束流程。"}]},{"ID":"20240226162907-gducrfx","Type":"NodeParagraph","Properties":{"id":"20240226162907-gducrfx","updated":"20240226162907"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"a37875ae625961b34b0222c787479536"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/a37875ae625961b34b0222c787479536-20240226162907-xflx1ve.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240226162908-0kztnfr","Type":"NodeParagraph","Properties":{"id":"20240226162908-0kztnfr","updated":"20240226162912"},"Children":[{"Type":"NodeText","Data":"到这里，我们可以发现 map 的 key 和 value 都被改成了整形数字，也就省下了大量的 gc 扫描，大大提升了组件性能。其实这就是有名的高性能无 GC 的缓存库 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"github.com/allegro/bigcache"},{"Type":"NodeText","Data":"​ 的实现原理。"}]},{"ID":"20240226162913-6bb021i","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226162913-6bb021i","updated":"20240226162923"},"Children":[{"Type":"NodeText","Data":"bigcache 的使用"}]},{"ID":"20240226162923-8f5hwqp","Type":"NodeParagraph","Properties":{"id":"20240226162923-8f5hwqp","updated":"20240226162928"},"Children":[{"Type":"NodeText","Data":"它的使用方法大概像下面这样。"}]},{"ID":"20240226162929-vm8g4ke","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240226162929-vm8g4ke","updated":"20240226162936"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z28="},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n    \"fmt\"\n    \"github.com/allegro/bigcache/v3\"\n)\n\nfunc main() {\n    // 设置 bigcache 配置参数\n    cacheConfig := bigcache.Config{\n        Shards: 1024, // 分片数量，提高并发性\n    }\n\n    // 初始化 bigcache\n    cache, _ := bigcache.NewBigCache(cacheConfig)\n\n    // 写缓存数据\n    key := \"欢迎关注\"\n    value := []byte(\"小白debug\")\n    cache.Set(key, value)\n\n    // 读缓存数据\n    entry, _ := cache.Get(key)\n\n    fmt.Printf(\"Entry: %s\\n\", entry)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240226162937-cuzatud","Type":"NodeParagraph","Properties":{"id":"20240226162937-cuzatud","updated":"20240226162941"},"Children":[{"Type":"NodeText","Data":"说白了就是 Get 方法读缓存数据，Set 方法写缓存数据，比较简单。现在，大概原理和使用方法我们都懂了，我们再来看下 bigcache 中，两个我认为挺"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"巧妙"},{"Type":"NodeText","Data":"的设计点。"}]},{"ID":"20240226162942-hduwfef","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226162942-hduwfef","updated":"20240226162955"},"Children":[{"Type":"NodeText","Data":"ringbuf 中的数据格式"}]},{"ID":"20240226162955-w1p4m2h","Type":"NodeParagraph","Properties":{"id":"20240226162955-w1p4m2h","updated":"20240226162959"},"Children":[{"Type":"NodeText","Data":"在前面的介绍中，我猜你心里可能有疑问，程序从 ringbuf 读写 value 的时候，ringbuf里面放的都是 01 二进制数组，程序怎么知道该"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"读多少bit才算一个完整 value"},{"Type":"NodeText","Data":"？bigcache 的解法非常值得学习，它重新定义了一个新的数据格式。"}]},{"ID":"20240226163003-q6icd99","Type":"NodeParagraph","Properties":{"id":"20240226163003-q6icd99","updated":"20240226163003"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"0c3ef2417f3a1e2024e448417117a6ad"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/0c3ef2417f3a1e2024e448417117a6ad-20240226163003-71t8lo9.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240226163020-tihllnf","Type":"NodeList","ListData":{},"Properties":{"id":"20240226163020-tihllnf","updated":"20240226163020"},"Children":[{"ID":"20240226163020-xexjp06","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226163020-xexjp06","updated":"20240226163020"},"Children":[{"ID":"20240226163020-yj448r9","Type":"NodeParagraph","Properties":{"id":"20240226163020-yj448r9","updated":"20240226163020"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"length 表示 header 到 data 的数据长度"}]}]},{"ID":"20240226163020-ztfb64q","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226163020-ztfb64q","updated":"20240226163020"},"Children":[{"ID":"20240226163020-s0eqxhw","Type":"NodeParagraph","Properties":{"id":"20240226163020-s0eqxhw","updated":"20240226163020"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"header 是固定长度"}]}]},{"ID":"20240226163020-nmcbc71","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226163020-nmcbc71","updated":"20240226163020"},"Children":[{"ID":"20240226163020-goux5pu","Type":"NodeParagraph","Properties":{"id":"20240226163020-goux5pu","updated":"20240226163020"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"data 则是 key 和 value 的完整数据。"}]}]}]},{"ID":"20240226163020-5y4g37i","Type":"NodeParagraph","Properties":{"id":"20240226163020-5y4g37i","updated":"20240226163020"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"当读取 ringbuf 时，我们会先读到 length，有了它，我们就能在 ringbuf 里拿到 header 和 data，header 里又含有 key 的长度，这样就能在 data 里将 key 和 value 完整区分开来。"}]},{"ID":"20240226163020-lun03si","Type":"NodeParagraph","Properties":{"id":"20240226163020-lun03si","updated":"20240226163020"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"很多网络传输框架中都会用到类似的方案，后面有机会跟大家细聊。"}]},{"ID":"20240226163029-3nue9jy","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226163029-3nue9jy","updated":"20240226163051"},"Children":[{"Type":"NodeText","Data":"ringbuffer 的第 0 位"}]},{"ID":"20240226163051-l826d8s","Type":"NodeParagraph","Properties":{"id":"20240226163051-l826d8s","updated":"20240226163055"},"Children":[{"Type":"NodeText","Data":"另外，还有个巧妙的设计是，在 bigcache 中， ringbuffer 的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"第 0 位"},{"Type":"NodeText","Data":"并不用来存放任何数据，这样如果发现 分片 map 中得到数据的 index 为 0，就可以直接认为没有对应的缓存数据，那就不需要跑到 ringbuffer 里去捞一遍数据了，觉得学到了，记得在右下角给我点个赞。"}]},{"ID":"20240226163104-0oliql5","Type":"NodeParagraph","Properties":{"id":"20240226163104-0oliql5","updated":"20240226163104"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"68a70f1c6dac0112c343a3a7be5abd69"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/68a70f1c6dac0112c343a3a7be5abd69-20240226163104-hhrrjas.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240226163105-15qww7u","Type":"NodeParagraph","Properties":{"id":"20240226163105-15qww7u","updated":"20240226163115"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"ringbuf不使用第0位"}]},{"ID":"20240226163116-qzpjaxf","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226163116-qzpjaxf","updated":"20240226163127"},"Children":[{"Type":"NodeText","Data":"bigcache 的缺点"}]},{"ID":"20240226163132-idynv8e","Type":"NodeParagraph","Properties":{"id":"20240226163132-idynv8e","updated":"20240226163132"},"Children":[{"Type":"NodeText","Data":"bigcache 性能非常好，但也不是完全没有问题。比较明显的是，它读写数据时，用的都是"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"byte数组"},{"Type":"NodeText","Data":"，但我们平时写代码用的都是结构体，为了让"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"结构体和 byte 数组互转"},{"Type":"NodeText","Data":"，我们就需要用到"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"序列化和反序列化"},{"Type":"NodeText","Data":"，这些都是成本。"}]},{"ID":"20240226163132-r6163v8","Type":"NodeParagraph","Properties":{"id":"20240226163132-r6163v8","updated":"20240226163132"},"Children":[{"Type":"NodeText","Data":"另外它的缓存淘汰策略也比较粗暴，用的是 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"FIFO"},{"Type":"NodeText","Data":"，不支持 LRU 或 "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkTextContent":"LFU"},{"Type":"NodeText","Data":" 的淘汰策略。"}]},{"ID":"20240226163133-xzvotfi","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240226163133-xzvotfi","updated":"20240226163137"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20240226163207-4yoo30z","Type":"NodeList","ListData":{},"Properties":{"id":"20240226163207-4yoo30z","updated":"20240226163207"},"Children":[{"ID":"20240226163207-blzbe7a","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226163207-blzbe7a","updated":"20240226163207"},"Children":[{"ID":"20240226163207-kw1wye1","Type":"NodeParagraph","Properties":{"id":"20240226163207-kw1wye1","updated":"20240226163207"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"对于不频繁读写的场景，加锁读写 map 就够了。"}]}]},{"ID":"20240226163207-g2z02r1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226163207-g2z02r1","updated":"20240226163207"},"Children":[{"ID":"20240226163207-ytx8376","Type":"NodeParagraph","Properties":{"id":"20240226163207-ytx8376","updated":"20240226163207"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"对于需要频繁读写的场景，可以使用分片锁，减少锁竞争。"}]}]},{"ID":"20240226163207-ay8wmip","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240226163207-ay8wmip","updated":"20240226163207"},"Children":[{"ID":"20240226163207-sd36l0z","Type":"NodeParagraph","Properties":{"id":"20240226163207-sd36l0z","updated":"20240226163207"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"对于 golang，map 中含指针的话会引发 gc 扫描，为了降低这部分成本，引入了 ringbuf，map 的 value 则改为缓存对象在 ringbuf 中的 index，以此提升组件性能。以后面试官问你看没看过哪些优秀组件的源码的时候，你知道该怎么回答了吧？"}]}]}]},{"ID":"20240226163213-nae3zhh","Type":"NodeParagraph","Properties":{"id":"20240226163213-nae3zhh"}}]}