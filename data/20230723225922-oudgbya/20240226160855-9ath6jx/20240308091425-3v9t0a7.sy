{"ID":"20240308091425-3v9t0a7","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1fab4","id":"20240308091425-3v9t0a7","tags":"Go-sentinel-golang 库,需要仔细看","title":"QPS 的计算是怎么实现的？","updated":"20240308091942"},"Children":[{"ID":"20240308091437-znr3nwf","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240308091437-znr3nwf","updated":"20240308091448"},"Children":[{"Type":"NodeText","Data":"QPS 的含义"}]},{"ID":"20240308091448-t9gwyq1","Type":"NodeParagraph","Properties":{"id":"20240308091448-t9gwyq1","updated":"20240308091459"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"QPS（Queries Per Second）"},{"Type":"NodeText","Data":",也就是“"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"每秒查询数"},{"Type":"NodeText","Data":"”，它表示服务器每秒能够处理的请求数量，是一个衡量服务器性能的重要指标。"}]},{"ID":"20240308091425-mt1mc36","Type":"NodeParagraph","Properties":{"id":"20240308091425-mt1mc36","updated":"20240308091513"},"Children":[{"Type":"NodeText","Data":"比如说服务的用户查询 API 支持 100 QPS，就是指这个接口可以做到每秒查 100 次。你务必"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"牢牢记住这个概念"},{"Type":"NodeText","Data":"，因为工作之后经常会听别人提起它。很多面试官就特别爱问：\"你的这个项目（API）的读写性能怎么样，单个实例能支持多少 QPS？\"。这个问题就是个"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"照妖镜"},{"Type":"NodeText","Data":"。面试官可以通过这个问题了解你对项目的了解程度。 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果你答不出来，那你在这个项目中很可能就不是核心开发，或者说你这个项目既不核心也不重要，甚至可能你就没做过这个项目。。。"},{"Type":"NodeText","Data":" 并且这个 QPS 数值还会有一个"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"合理范围"},{"Type":"NodeText","Data":"，有经验的开发能通过这个值判断这个服务 API 底层大概是咋样的。如果你回答的数值过小或过大，那又可以继续细聊过小和过大的原因。"}]},{"ID":"20240308091516-byyw3pm","Type":"NodeParagraph","Properties":{"id":"20240308091516-byyw3pm","updated":"20240308091521"},"Children":[{"Type":"NodeText","Data":"我说下我目前接触下来比较合理的 QPS 范围：带了数据库的服务一般写性能在 5k 以下，读性能一般在 10k 以下，能到 10k 以上的话，那很可能是在数据库前面加了层缓存。如果你的服务还带了个文本算法模型，那使用了 gpu 的情况下 API 一般支持 100~400QPS 左右，如果是个同时支持文本和图片的模型，也就是所谓的多模态模型，那一般在 100QPS 以内。"}]},{"ID":"20240308091536-0lz08hd","Type":"NodeParagraph","Properties":{"id":"20240308091536-0lz08hd","updated":"20240308091536"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"c8a4ea48776bcfe0fed9440beb17b65d"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/c8a4ea48776bcfe0fed9440beb17b65d-20240308091536-0eo7tih.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240308091537-6iyc8m0","Type":"NodeParagraph","Properties":{"id":"20240308091537-6iyc8m0","updated":"20240308091546"},"Children":[{"Type":"NodeText","Data":"比如候选人上来就说服务单实例 API 读写性能都有上万 QPS, 那我可以大概猜到这"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"应该"},{"Type":"NodeText","Data":"是个纯 cpu+内存的 API 链路。但如果候选人还说这里面没做缓存且有数据库调用，那我可能会追问这里头用的是哪款数据库，底层是什么存储引擎？如果候选人还说这里面带了个文本检测的算法模型，那有点违反经验，那我会多聊聊细节，说不定这对我来说是个开眼界的机会。"}]},{"ID":"20240308091547-f8fj6dk","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240308091547-f8fj6dk","updated":"20240308091553"},"Children":[{"Type":"NodeText","Data":"如何计算QPS"}]},{"ID":"20240308091602-rkej1sx","Type":"NodeParagraph","Properties":{"id":"20240308091602-rkej1sx","updated":"20240308091602"},"Children":[{"Type":"NodeText","Data":"现在了解完 QPS 了，假设我们想要获得某个函数 的 QPS，该怎么做呢？\n这一般分两个情况："}]},{"ID":"20240308091602-llae26a","Type":"NodeParagraph","Properties":{"id":"20240308091602-llae26a","updated":"20240308091605"},"Children":[{"Type":"NodeText","Data":"1."},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实时性要求较低"},{"Type":"NodeText","Data":"的监控场景。"}]},{"ID":"20240308091602-8lg438f","Type":"NodeParagraph","Properties":{"id":"20240308091602-8lg438f","updated":"20240308091608"},"Children":[{"Type":"NodeText","Data":"2."},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实时性要求较高"},{"Type":"NodeText","Data":"的服务治理场景。"}]},{"ID":"20240308091617-hhhl70e","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240308091617-hhhl70e","updated":"20240308091617"},"Children":[{"Type":"NodeText","Data":"监控场景"}]},{"ID":"20240308091617-v4ebq5h","Type":"NodeParagraph","Properties":{"id":"20240308091617-v4ebq5h","updated":"20240308091617"},"Children":[{"Type":"NodeText","Data":"监控服务 QPS 是最常见的场景，它对实时性要求不高。如果我们想要查看服务的 QPS，可以在服务代码内部接入 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Prometheus"},{"Type":"NodeText","Data":"​ 的代码库，然后在每个需要计算 QPS 的地方，加入类似"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Counter.Inc()"},{"Type":"NodeText","Data":"​这样的代码，意思是函数执行次数加 1。这个过程也就是所谓的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"打点"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240308091624-iv0an55","Type":"NodeParagraph","Properties":{"id":"20240308091624-iv0an55","updated":"20240308091617"},"Children":[{"Type":"NodeText","Data":"当函数执行到打点函数时，Prometheus 代码库内部会计算这个函数的调用次数，将数据写入到 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"counter_xx.db"},{"Type":"NodeText","Data":"​ 的文件中，再同步到公司的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"时序数据库"},{"Type":"NodeText","Data":"​中，然后我们可以通过一些监控面板，比如 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"grafana"},{"Type":"NodeText","Data":"​调取时序数据库里的打点数据，在监控面板上通过特殊的表达式，也就是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"PromQL"},{"Type":"NodeText","Data":"​，对某段时间里的打点进行求导计算速率，这样就能看到这个函数的调用 QPS 啦。"}]},{"ID":"20240308091643-nbf3adf","Type":"NodeParagraph","Properties":{"id":"20240308091643-nbf3adf","updated":"20240308091617"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"fff4526bcc03c74a097e5d4674b282aa"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/fff4526bcc03c74a097e5d4674b282aa-20240308091643-wsd7vrk.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240308091702-f670t00","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240308091702-f670t00","updated":"20240308091707"},"Children":[{"Type":"NodeText","Data":"服务治理场景"}]},{"ID":"20240308091652-0s4c22c","Type":"NodeParagraph","Properties":{"id":"20240308091652-0s4c22c","updated":"20240308091707"},"Children":[{"Type":"NodeText","Data":"跟监控面板查看服务 QPS 不同的是，我们有时候需要以"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"更高的实时性"},{"Type":"NodeText","Data":"获取 QPS。比如在"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"服务治理"},{"Type":"NodeText","Data":"这一块，我们需要在服务内部加入一些中间层，实时计算服务 api 当前的 QPS，当它大于某个阈值时，可以做一些自定义逻辑，比如是直接拒绝掉一些请求，还是将请求排队等一段时间后再处理等等，也就是所谓的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"限流"},{"Type":"NodeText","Data":"。\n这样的场景都要求我们"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实时计算"},{"Type":"NodeText","Data":"出准确的 QPS，那么接下来就来看下这是怎么实现的？"}]},{"ID":"20240308091712-eiw2jz4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240308091712-eiw2jz4","updated":"20240308091716"},"Children":[{"Type":"NodeText","Data":"基本思路"}]},{"ID":"20240308091723-0a3d3yn","Type":"NodeParagraph","Properties":{"id":"20240308091723-0a3d3yn","updated":"20240308091723"},"Children":[{"Type":"NodeText","Data":"计算某个函数的执行 QPS 说白了就是计算每秒内这个函数被执行了多少次。我们可以参考监控场景的思路，用一个"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"临时变量 cnt"},{"Type":"NodeText","Data":" 记录某个函数的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"执行次数"},{"Type":"NodeText","Data":"，每执行一次就给变量"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"+1"},{"Type":"NodeText","Data":"​，然后计算单位时间内的变化速率。公式就像这样："}]},{"ID":"20240308091723-87k8u17","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240308091723-87k8u17","updated":"20240308091723"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"QPS = (cnt(t) - cnt(t - Δt)) / Δt\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240308091723-g5pmoav","Type":"NodeParagraph","Properties":{"id":"20240308091723-g5pmoav","updated":"20240308091723"},"Children":[{"Type":"NodeText","Data":"其中 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"cnt(t)"},{"Type":"NodeText","Data":"​ 表示在时间 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"t"},{"Type":"NodeText","Data":"​ 的请求数，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Δt"},{"Type":"NodeText","Data":"​表示时间间隔。比如在第 9 秒的时候, cnt 是 80， 到第 10 秒的时候，cnt 是 100，那这一秒内就执行了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":" (100-80)/(10-9) = 20 次"},{"Type":"NodeText","Data":"​, 也就是 20QPS。"}]},{"ID":"20240308091723-0ljlfl6","Type":"NodeParagraph","Properties":{"id":"20240308091723-0ljlfl6","updated":"20240308091723"},"Children":[{"Type":"NodeText","Data":"​​"}]},{"ID":"20240308091735-ir1nojy","Type":"NodeParagraph","Properties":{"id":"20240308091735-ir1nojy","updated":"20240308091735"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"4d233d256ea0804b3f51b6f82248b07a"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/4d233d256ea0804b3f51b6f82248b07a-20240308091735-j7nfcvl.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240308091739-pxtm84w","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240308091739-pxtm84w","updated":"20240308091753"},"Children":[{"Type":"NodeText","Data":"引入 bucket"}]},{"ID":"20240308091800-tvbdam2","Type":"NodeParagraph","Properties":{"id":"20240308091800-tvbdam2","updated":"20240308091801"},"Children":[{"Type":"NodeText","Data":"但这样会有个问题，到了第 10 秒的时候，有时候我还想回去知道第 5 和第 6 秒的 QPS，光一个变量的话，数据老早被覆盖了，根本不够用。于是我们可以将临时变量 cnt，改成了一个数组，数组里每个元素都用来存放(cnt(t) - cnt(t - Δt)) 的值。数组里的每个元素，都叫 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bucket"},{"Type":"NodeText","Data":"​."}]},{"ID":"20240308091805-l132ig4","Type":"NodeParagraph","Properties":{"id":"20240308091805-l132ig4","updated":"20240308091805"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"494f5f207665ce23e70dce02ae1520f6"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/494f5f207665ce23e70dce02ae1520f6-20240308091805-bn0p8lz.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240308091809-v193caw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240308091809-v193caw"},"Children":[{"Type":"NodeText","Data":"调整 bucket 范围粒度"}]},{"ID":"20240308091814-j5dg5g4","Type":"NodeParagraph","Properties":{"id":"20240308091814-j5dg5g4","updated":"20240308091820"},"Children":[{"Type":"NodeText","Data":"我们默认每个 bucket 都用来存放 1s 内的数据增量，但这"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"粒度比较粗"},{"Type":"NodeText","Data":"，我们可以调整为 200ms，这样我们可以获得更细粒度的数据。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"粒度越细，意味着我们计算 QPS 的组件越灵敏，那基于这个 QPS 做的服务治理能力响应就越快"},{"Type":"NodeText","Data":"。于是，原来用 1 个 bucket 存放 1s 内的增量数量，现在就变成要用 5 个 bucket 了。"}]},{"ID":"20240308091825-1samipv","Type":"NodeParagraph","Properties":{"id":"20240308091825-1samipv","updated":"20240308091825"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"8971a0cce1d28e3af4e22d44070ecebe"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/8971a0cce1d28e3af4e22d44070ecebe-20240308091825-1bj42r0.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240308091829-gcrejw1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240308091829-gcrejw1","updated":"20240308091829"},"Children":[{"Type":"NodeText","Data":"引入环形数组"}]},{"ID":"20240308091836-rgtka8w","Type":"NodeParagraph","Properties":{"id":"20240308091836-rgtka8w","updated":"20240308091836"},"Children":[{"Type":"NodeText","Data":"但这样又引入一个新的问题，随着时间变长，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"数组的长度就越长"},{"Type":"NodeText","Data":"，需要的内存就越多，最终导致进程申请的内存过多，被 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"oom（Out of Memory） kill "},{"Type":"NodeText","Data":"​了。为了解决这个问题，我们可以为数组加入最大长度的限制，超过最大长度的部分，就从头开始写，覆盖掉老的数据。这样的数组，就是所谓的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"环状数组"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240308091836-pve038l","Type":"NodeParagraph","Properties":{"id":"20240308091836-pve038l","updated":"20240308091836"},"Children":[{"Type":"NodeText","Data":"虽然环状数组听起来挺高级了，但说白了就是"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"一个用%取模来确定写入位置的定长数组"},{"Type":"NodeText","Data":"，没有想象的那么高端。\n比如数组长度是 5，数组 index 从 0 开始，要写 index=6 的 bucket， 计算 6%5 = 1，那就是写入 index=1 的位置上。"}]},{"ID":"20240308091841-ryw5rbt","Type":"NodeParagraph","Properties":{"id":"20240308091841-ryw5rbt","updated":"20240308091841"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"5115f3532055d1e79811329cbd513a97"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/5115f3532055d1e79811329cbd513a97-20240308091841-73273b1.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240308091846-5j8fi0y","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240308091846-5j8fi0y","updated":"20240308091846"},"Children":[{"Type":"NodeText","Data":"加入滑动窗口"}]},{"ID":"20240308091848-juqownd","Type":"NodeParagraph","Properties":{"id":"20240308091848-juqownd","updated":"20240308091852"},"Children":[{"Type":"NodeText","Data":"有了环形数组之后，现在我们想要计算 qps，就需要引入"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"滑动窗口"},{"Type":"NodeText","Data":"的概念。这玩意听着玄乎，其实就是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"start"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"end"},{"Type":"NodeText","Data":"​ 两个变量。通过它来圈定我们要计算 qps 的 bucket 数组范围。将当前时间跟 bucket 的粒度做"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"取模"},{"Type":"NodeText","Data":"操作，可以大概知道 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"end"},{"Type":"NodeText","Data":"​ 落在哪个 bucket 上，确定了 end 之后，将 end 的时间戳减个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1s"},{"Type":"NodeText","Data":"​就能大概得到 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"start"},{"Type":"NodeText","Data":"​ 在哪个 bucket 上，有了这两个值，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"再将 start 到 end 范围内的 bucket 取出"},{"Type":"NodeText","Data":"。对范围内的 bucket 里的 cnt 求和，得到这段时间内的总和，再除以 Δt，也就是 1s。就可以得到 qps。"}]},{"ID":"20240308091858-olpgtjp","Type":"NodeParagraph","Properties":{"id":"20240308091858-olpgtjp","updated":"20240308091858"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"b244481566ca5b18d25998ba6a1951b5"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/b244481566ca5b18d25998ba6a1951b5-20240308091858-k9930oa.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240308091859-7010t0o","Type":"NodeParagraph","Properties":{"id":"20240308091859-7010t0o","updated":"20240308091902"},"Children":[{"Type":"NodeText","Data":"到这里 qps 的计算过程就介绍完了。"}]},{"ID":"20240308091906-o927udy","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240308091906-o927udy","updated":"20240308091906"},"Children":[{"Type":"NodeText","Data":"如何计算平均耗时"}]},{"ID":"20240308091913-q5i2p8x","Type":"NodeParagraph","Properties":{"id":"20240308091913-q5i2p8x","updated":"20240308091915"},"Children":[{"Type":"NodeText","Data":"既然 qps 可以这么算，那同理，我们也可以计算某个函数的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"平均耗时"},{"Type":"NodeText","Data":"，实现也很简单，上面提到 bucket 有个用来统计调用次数的变量 cnt，现在再加个用来统计延时的变量 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Latency"},{"Type":"NodeText","Data":"​ 。每次执行完函数，就给 bucket 里的 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Latency"},{"Type":"NodeText","Data":" 变量 加上耗时。再通过滑动窗口获得对应的 bucket 数组范围，计算 Latency 的总和，再除以这些 bucket 里的调用次数 cnt 总和。就像下面这样："}]},{"ID":"20240308091920-4u7xqkv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240308091920-4u7xqkv","updated":"20240308091920"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aHRtbA=="},{"Type":"NodeCodeBlockCode","Data":"\n函数的平均耗时 = Latency总和/cnt总和\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240308091927-cr4f3xx","Type":"NodeParagraph","Properties":{"id":"20240308091927-cr4f3xx","updated":"20240308091927"},"Children":[{"Type":"NodeText","Data":"于是就得到了这个函数的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"平均耗时"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240308091927-se034c5","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240308091927-se034c5","updated":"20240308091927"},"Children":[{"Type":"NodeText","Data":"sentinel-golang"}]},{"ID":"20240308091927-fgmxlaa","Type":"NodeParagraph","Properties":{"id":"20240308091927-fgmxlaa","updated":"20240308091927"},"Children":[{"Type":"NodeText","Data":"看到这里，你应该对「怎么基于滑动窗口和 bucket 实现一个计算 QPS 和平均 Latency 的组件」有一定思路了。但没代码，说再多好像也不够解渴，对吧？其实，上面的思路，就是阿里开源的sentinel-golang中 QPS 计算组件的实现方式。sentinel-golang 是个著名的服务治理库，它会基于 QPS 和 Latency 等信息提供一系列限流熔断策略。\n如果你想了解具体的代码实现，可以去看下。链接是："}]},{"ID":"20240308091928-kuqdsvd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240308091928-kuqdsvd","updated":"20240308091935"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aHRtbA=="},{"Type":"NodeCodeBlockCode","Data":"https://github.com/alibaba/sentinel-golang\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240308091935-e8bazbp","Type":"NodeParagraph","Properties":{"id":"20240308091935-e8bazbp","updated":"20240308091941"},"Children":[{"Type":"NodeText","Data":"但茫茫码海，从何看起呢？下面给出一些关键词，大家可以作为入口去搜索看下。首先可以基于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"sliding_window_metric.go"},{"Type":"NodeText","Data":"​ 里的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GetQPS"},{"Type":"NodeText","Data":"​ 开始看起，它是实时计算 QPS 的入口函数。这里面会看到很多上面提到的内容细节，其中前面提到的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"滑动窗口"},{"Type":"NodeText","Data":"，它在 sentinel-golang 中叫 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"LeapArray"},{"Type":"NodeText","Data":"​。 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"bucket环形数组"},{"Type":"NodeText","Data":"，在 sentinel-golang 中叫 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"AtomicBucketWrapArray"},{"Type":"NodeText","Data":"​。环形数组里存放的 bucket 在代码里就是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MetricBucket"},{"Type":"NodeText","Data":"​，但需要注意的是 MetricBucket 里的 count 并不是一个数字类型，而是一个 map 类型，它将上面提到的 cnt 和 Latency 等都作为一种 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"key-value"},{"Type":"NodeText","Data":" 来存放。以后想要新增字段就不需要改代码了，提高了代码"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"扩展性"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240308091942-6u7g58f","Type":"NodeParagraph","Properties":{"id":"20240308091942-6u7g58f"}}]}