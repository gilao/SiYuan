{"ID":"20240620001630-6rc9gll","Spec":"1","Type":"NodeDocument","Properties":{"icon":"26c4","id":"20240620001630-6rc9gll","title":"如何使用Go语言优雅地实现接口限流","type":"doc","updated":"20240620001657"},"Children":[{"ID":"20240620001657-61nv4fv","Type":"NodeParagraph","Properties":{"id":"20240620001657-61nv4fv","updated":"20240620001657"},"Children":[{"Type":"NodeText","Data":"在众多Web开发中，为了保障服务器的稳定性，我们常常需要对接口的调用频率做出限制。而Go语言的强大并发性能使其在此领域有出色的表现。本文将向你详细展示如何利用Go语言实现接口限流。"}]},{"ID":"20240620001657-usn5yiu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240620001657-usn5yiu","updated":"20240620001657"},"Children":[{"Type":"NodeText","Data":"限流原理"}]},{"ID":"20240620001657-mi60txw","Type":"NodeParagraph","Properties":{"id":"20240620001657-mi60txw","updated":"20240620001658"},"Children":[{"Type":"NodeText","Data":"接口限流的目标是防止接口被过度调用，保护系统资源，包括CPU、内存和带宽等。限流通常应用于以下几种场景："}]},{"ID":"20240620001657-5nibhj5","Type":"NodeList","ListData":{},"Properties":{"id":"20240620001657-5nibhj5","updated":"20240620001658"},"Children":[{"ID":"20240620001657-eo07nc8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240620001657-eo07nc8","updated":"20240620001657"},"Children":[{"ID":"20240620001657-eagwxfh","Type":"NodeParagraph","Properties":{"id":"20240620001657-eagwxfh","updated":"20240620001657"},"Children":[{"Type":"NodeText","Data":"防止DDoS攻击"}]}]},{"ID":"20240620001657-6n3n7jt","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240620001657-6n3n7jt","updated":"20240620001657"},"Children":[{"ID":"20240620001657-l8xkgie","Type":"NodeParagraph","Properties":{"id":"20240620001657-l8xkgie","updated":"20240620001657"},"Children":[{"Type":"NodeText","Data":"控制非法爬虫"}]}]},{"ID":"20240620001657-783ofiq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240620001657-783ofiq","updated":"20240620001657"},"Children":[{"ID":"20240620001657-yw1ar26","Type":"NodeParagraph","Properties":{"id":"20240620001657-yw1ar26","updated":"20240620001657"},"Children":[{"Type":"NodeText","Data":"公平分配系统资源"}]}]}]},{"ID":"20240620001657-nhb654x","Type":"NodeParagraph","Properties":{"id":"20240620001657-nhb654x","updated":"20240620001658"},"Children":[{"Type":"NodeText","Data":"限流的实现方式有很多不同，最常见的策略有固定窗口、滑动窗口和漏桶算法。"}]},{"ID":"20240620001657-giu9600","Type":"NodeParagraph","Properties":{"id":"20240620001657-giu9600","updated":"20240620001658"},"Children":[{"Type":"NodeText","Data":"在Go语言中，我们可以使用"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"高并发"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"通道（channel）"},{"Type":"NodeText","Data":"等特性来优雅地实现这些算法。"}]},{"ID":"20240620001657-noihsv9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240620001657-noihsv9","updated":"20240620001657"},"Children":[{"Type":"NodeText","Data":"接口限流的实现"}]},{"ID":"20240620001657-3jd3zth","Type":"NodeParagraph","Properties":{"id":"20240620001657-3jd3zth","updated":"20240620001658"},"Children":[{"Type":"NodeText","Data":"下面我们来看一个具体的实现，这里我们使用滑动窗口算法来实现基于IP的接口限流。"}]},{"ID":"20240620001657-7pzogqq","Type":"NodeParagraph","Properties":{"id":"20240620001657-7pzogqq","updated":"20240620001658"},"Children":[{"Type":"NodeText","Data":"首先，我们定义一个结构体来保存每个IP的请求信息："}]},{"ID":"20240620001657-n81qh13","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240620001657-n81qh13","updated":"20240620001658"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"type visit struct {\n    // 最后一次请求时间\n    lastVisit time.Time\n    // 对应Time窗口内的访问次数\n    visitTimes int\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240620001657-nklqnko","Type":"NodeParagraph","Properties":{"id":"20240620001657-nklqnko","updated":"20240620001658"},"Children":[{"Type":"NodeText","Data":"然后，创建一个全局map来存储所有IP的请求信息："}]},{"ID":"20240620001657-sv90vny","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240620001657-sv90vny","updated":"20240620001658"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"var visitMap = make(map[string]*visit)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240620001657-l5t5dw3","Type":"NodeParagraph","Properties":{"id":"20240620001657-l5t5dw3","updated":"20240620001658"},"Children":[{"Type":"NodeText","Data":"接着，我们实现一个限流handler，该handler将对所有经过的请求做出限流处理："}]},{"ID":"20240620001657-nomthpc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240620001657-nomthpc","updated":"20240620001658"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"func limitFunc(w http.ResponseWriter, r *http.Request) {\n    ip := r.RemoteAddr\n    v, ok := visitMap[ip]\n    if !ok {\n        // 若该IP是首次请求，则初始化visit\n        visitMap[ip] = \u0026visit{lastVisit:time.Now(), visitTimes:1}\n    } else {\n        // 若该IP非首次请求，且距离上次请求时间超过Time窗口，则重设visitTimes\n        if time.Since(v.lastVisit) \u003e time.Minute {\n            v.visitTimes = 1\n        } else if v.visitTimes \u003e MaxVisitTimes {\n            // 若本次请求距离上次请求时间在Time窗口内，且该IP在此时间内的访问次数超过上限，则返回错误\n            http.Error(w, \"too many requests\", http.StatusTooManyRequests)\n            return\n        } else {\n            v.visitTimes++\n        }\n        v.lastVisit = time.Now()\n    }\n    // 通过限流检查后，进入业务处理\n    yourHandler(w, r)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240620001657-rsz0619","Type":"NodeParagraph","Properties":{"id":"20240620001657-rsz0619","updated":"20240620001658"},"Children":[{"Type":"NodeText","Data":"在以上代码中，我们对所有请求做出了频率限制。当一个IP在Time窗口内的访问次数超过上限时，我们就直接返回"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026quot;too many requests\u0026quot;"},{"Type":"NodeText","Data":"​错误，否则，执行业务处理逻辑。"}]},{"ID":"20240620001657-y14ra8k","Type":"NodeParagraph","Properties":{"id":"20240620001657-y14ra8k","updated":"20240620001658"},"Children":[{"Type":"NodeText","Data":"以上即是如何在Go语言中利用其高并发特性实现接口限流的简单示例。实际上，对于大型的分布式系统，我们还可以考虑使用更为复杂的流量整形算法，如"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"令牌桶"},{"Type":"NodeText","Data":"、漏桶等。"}]},{"ID":"20240620001657-ph88oja","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240620001657-ph88oja","updated":"20240620001657"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20240620001657-c6ye8ym","Type":"NodeParagraph","Properties":{"id":"20240620001657-c6ye8ym","updated":"20240620001658"},"Children":[{"Type":"NodeText","Data":"Go语言是实现接口限流的一个非常好的工具。我们通过本文希望你能够更好的理解如何使用Go语言来实现接口限流，并在你的项目中找到适合你的解决方案。"}]}]}