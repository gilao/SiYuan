{"ID":"20240619235011-jdzoqir","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f9ab","id":"20240619235011-jdzoqir","title":"Golang调度器是性能与并发的关键因素","type":"doc","updated":"20240619235040"},"Children":[{"ID":"20240619235040-ef9bpp8","Type":"NodeParagraph","Properties":{"id":"20240619235040-ef9bpp8","updated":"20240619235040"},"Children":[{"Type":"NodeText","Data":"在探讨Go语言的内部机制时，理解Go调度器（Go Scheduler）是至关重要的。Go调度器是Go运行时（runtime）的一部分，并且该运行时内建在你的应用程序中。Go调度器管理着协程（goroutines）的执行，通过高效的并发模型，允许开发者以轻松的方式编写并发代码。本文将深入解析Go调度器的核心组成部分，包括逻辑处理器、"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"核心线程"},{"Type":"NodeText","Data":"、线程池缓存、上下文切换等，并提供丰富的示例说明其工作原理。"}]},{"ID":"20240619235040-pu0wy6h","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240619235040-pu0wy6h","updated":"20240619235040"},"Children":[{"Type":"NodeText","Data":"Go调度器背后的逻辑处理器"}]},{"ID":"20240619235040-bdwj8jb","Type":"NodeParagraph","Properties":{"id":"20240619235040-bdwj8jb","updated":"20240619235041"},"Children":[{"Type":"NodeText","Data":"在Go语言中，逻辑处理器可以看作是系统线程在Go运行时环境中的抽象表示。每个逻辑处理器都分配给了一个操作系统线程，并且在任一时刻，每个线程会执行一个协程。可以通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"runtime.GOMAXPROCS"},{"Type":"NodeText","Data":"​函数设置当前程序并行执行协程的系统线程数量，从而控制并发度。"}]},{"ID":"20240619235040-bu73vns","Type":"NodeParagraph","Properties":{"id":"20240619235040-bu73vns","updated":"20240619235041"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例"},{"Type":"NodeText","Data":"："}]},{"ID":"20240619235040-vcn8hfw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240619235040-vcn8hfw","updated":"20240619235041"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"package main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n    \"sync\"\n)\n\nfunc main() {\n    // 设置逻辑处理器的数量为4\n    runtime.GOMAXPROCS(4)\n\n    var wg sync.WaitGroup\n    wg.Add(2) // 增加2个等待\n\n    go func() {\n        defer wg.Done()\n\n        for count := 0; count \u003c 3; count++ {\n            for char := 'a'; char \u003c 'a'+26; char++ {\n                fmt.Printf(\"%c \", char)\n            }\n        }\n    }()\n\n    go func() {\n        defer wg.Done()\n\n        for count := 0; count \u003c 3; count++ {\n            for char := 'A'; char \u003c 'A'+26; char++ {\n                fmt.Printf(\"%c \", char)\n            }\n        }\n    }()\n\n    fmt.Println(\"Waiting To Finish\")\n    wg.Wait()\n    fmt.Println(\"\\nTerminating Program\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240619235040-tpmkdz9","Type":"NodeParagraph","Properties":{"id":"20240619235040-tpmkdz9","updated":"20240619235041"},"Children":[{"Type":"NodeText","Data":"上述代码展示了逻辑处理器的设定，以及如何通过并发执行的goroutine来进行任务的分配。"}]},{"ID":"20240619235040-s5w7sy6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240619235040-s5w7sy6","updated":"20240619235040"},"Children":[{"Type":"NodeText","Data":"处理器、线程与Goroutine的协作"}]},{"ID":"20240619235040-jabxs58","Type":"NodeParagraph","Properties":{"id":"20240619235040-jabxs58","updated":"20240619235041"},"Children":[{"Type":"NodeText","Data":"Go调度器使用了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"M : N"},{"Type":"NodeText","Data":"​调度模型，其中"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"M"},{"Type":"NodeText","Data":"​表示"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"内核线程"},{"Type":"NodeText","Data":"（OS线程），而"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"N"},{"Type":"NodeText","Data":"​表示goroutines。它不是一对一的，也不是多对一的关系，而是多对多的。Go运行时包含了一个工作窃取算法的调度器，负责在M个线程之间分派N个待执行的goroutine。"}]},{"ID":"20240619235040-20gkuag","Type":"NodeParagraph","Properties":{"id":"20240619235040-20gkuag","updated":"20240619235041"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例"},{"Type":"NodeText","Data":"："}]},{"ID":"20240619235040-ork8gaz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240619235040-ork8gaz","updated":"20240619235041"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 假设在Go中没有直接的API可以展示复杂的M:N的示例\n// 使用这个段落来说明多个goroutine如何在多个线程间调度\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240619235040-c1gt0b6","Type":"NodeParagraph","Properties":{"id":"20240619235040-c1gt0b6","updated":"20240619235041"},"Children":[{"Type":"NodeText","Data":"此处，我们略过API的直接示例，因为Go目前没有提供直接查看或控制详细调度过程的API。但是，可以通过观察程序的运行行为来分析goroutines如何被调度到不同线程上执行。"}]},{"ID":"20240619235040-37afr93","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240619235040-37afr93","updated":"20240619235040"},"Children":[{"Type":"NodeText","Data":"线程池缓存与上下文切换"}]},{"ID":"20240619235040-71rcpum","Type":"NodeParagraph","Properties":{"id":"20240619235040-71rcpum","updated":"20240619235041"},"Children":[{"Type":"NodeText","Data":"Go语言在这个层面提供了线程池的概念，它会复用已存在的线程，以减少频繁的创建和销毁线程造成的开销。当一个goroutine执行完毕并且没有其他goroutine可执行时，线程不会立即销毁，而是会被放入线程池以备后用。"}]},{"ID":"20240619235040-6nfti7m","Type":"NodeParagraph","Properties":{"id":"20240619235040-6nfti7m","updated":"20240619235041"},"Children":[{"Type":"NodeText","Data":"上下文切换在任何"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"多任务操作系统"},{"Type":"NodeText","Data":"中都是资源消耗的主要环节。Go调度器力求最小化上下文切换的代价，这得益于它的工作窃取算法以及轻量级的goroutine实现。"}]},{"ID":"20240619235040-a8l80gs","Type":"NodeParagraph","Properties":{"id":"20240619235040-a8l80gs","updated":"20240619235041"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例"},{"Type":"NodeText","Data":"："}]},{"ID":"20240619235040-ighp0xm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240619235040-ighp0xm","updated":"20240619235041"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 线程池和上下文切换的示例是概念性说明，因Go语言没有直接展示线程池和上下文切换的API\n// 可用以下方式来间接说明goroutine的轻量级和上下文切换\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240619235040-ay2s4r2","Type":"NodeParagraph","Properties":{"id":"20240619235040-ay2s4r2","updated":"20240619235041"},"Children":[{"Type":"NodeText","Data":"在实际的开发实践中，开发者往往无需直接面对上下文切换和线程池缓存的复杂性——这都已经被Go的运行时所抽象和管理。"}]},{"ID":"20240619235040-gwv4z7w","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240619235040-gwv4z7w","updated":"20240619235040"},"Children":[{"Type":"NodeText","Data":"深入怎样把握协程调度"}]},{"ID":"20240619235040-9uz96ap","Type":"NodeParagraph","Properties":{"id":"20240619235040-9uz96ap","updated":"20240619235041"},"Children":[{"Type":"NodeText","Data":"虽然Go调度器的很多细节被运行时所封装，但理解其中的基本原理对于编写高效并发程序仍然具有参考价值。例如，合理地增减逻辑处理器的数量，根据具体的应用场景来平衡CPU密集型任务与IO密集型任务之间的调度策略，都能获得更佳的性能。"}]},{"ID":"20240619235040-n3z5ckg","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240619235040-n3z5ckg","updated":"20240619235040"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20240619235040-j4bk47u","Type":"NodeParagraph","Properties":{"id":"20240619235040-j4bk47u","updated":"20240619235041"},"Children":[{"Type":"NodeText","Data":"Go调度器是Go并发模型的核心，它利用逻辑处理器和线程池实现高效的多任务处理。通过灵活的调度策略，它减少了上下文切换的开销并最大化地利用了处理器资源，使得goroutines能高效并发地执行。深入理解Go调度器的工作原理，有助于开发者编写出更优雅的并发程序，并且提升应用程序的性能。"}]}]}