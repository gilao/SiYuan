{"ID":"20240620001538-jhjykqo","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f346","id":"20240620001538-jhjykqo","title":"深入理解Go协程：廉价但非免费的并发机制","type":"doc","updated":"20240620001558"},"Children":[{"ID":"20240620001558-lz2wq2f","Type":"NodeParagraph","Properties":{"id":"20240620001558-lz2wq2f","updated":"20240620001558"},"Children":[{"Type":"NodeText","Data":"Go语言以其轻量级的并发编程模型闻名，这在Go的世界中被称为“goroutines”。确实，与操作系统线程相比，goroutines在资源消耗（如内存占用）和创建及切换的开销方面，都要显著少得多。但是重要的是要了解，尽管goroutine比较廉价，但它们并不是“免费”的。在这篇文章中，我们将深入探讨为什么说“goroutine是廉价的，但不是免费的”，并且通过一些实践例子来展示如何高效地使用goroutines。"}]},{"ID":"20240620001558-hr2tjat","Type":"NodeParagraph","Properties":{"id":"20240620001558-hr2tjat","updated":"20240620001558"},"Children":[{"Type":"NodeText","Data":"首先，我们要理解goroutine的内部机制和它与操作系统线程的关系："}]},{"ID":"20240620001558-jjqeja8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240620001558-jjqeja8","updated":"20240620001558"},"Children":[{"Type":"NodeText","Data":"Goroutine与操作系统线程"}]},{"ID":"20240620001558-e3cvxpo","Type":"NodeParagraph","Properties":{"id":"20240620001558-e3cvxpo","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"Goroutines在Go语言的运行时（runtime）中实现，运行时负责调度goroutines到OS线程上执行。一个操作系统线程可以同时运行多个goroutine。"}]},{"ID":"20240620001558-nxb6amc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240620001558-nxb6amc","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"1. Goroutine的廉价之处"}]},{"ID":"20240620001558-evz7bcm","Type":"NodeList","ListData":{},"Properties":{"id":"20240620001558-evz7bcm","updated":"20240620001559"},"Children":[{"ID":"20240620001558-61h6q32","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240620001558-61h6q32","updated":"20240620001558"},"Children":[{"ID":"20240620001558-0i8z25h","Type":"NodeParagraph","Properties":{"id":"20240620001558-0i8z25h","updated":"20240620001558"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"内存消耗："},{"Type":"NodeText","Data":" 默认情况下，一个goroutine的栈大小是很小的（通常为2KB），当需要更多空间时可以动态增长。相比之下，操作系统线程的栈通常至少为1MB。"}]}]},{"ID":"20240620001558-619tgre","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240620001558-619tgre","updated":"20240620001558"},"Children":[{"ID":"20240620001558-vvk2ozi","Type":"NodeParagraph","Properties":{"id":"20240620001558-vvk2ozi","updated":"20240620001558"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"创建速度："},{"Type":"NodeText","Data":" 创建goroutine的速度远快于创建OS线程，因为减少了与内核交互的需要。"}]}]},{"ID":"20240620001558-1glr9ys","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240620001558-1glr9ys","updated":"20240620001558"},"Children":[{"ID":"20240620001558-gfuudj8","Type":"NodeParagraph","Properties":{"id":"20240620001558-gfuudj8","updated":"20240620001558"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"上下文切换："},{"Type":"NodeText","Data":" goroutine之间的上下文切换比线程之间的切换更快，因为不需要切换内核状态和虚拟内存空间。"}]}]}]},{"ID":"20240620001558-t873sro","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240620001558-t873sro","updated":"20240620001559"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 创建并启动goroutine的示例\ngo func() {\n    fmt.Println(\"Hello, I am a goroutine!\")\n}()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240620001558-1c8uym5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240620001558-1c8uym5","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"2. 成本体现"}]},{"ID":"20240620001558-exckhlq","Type":"NodeParagraph","Properties":{"id":"20240620001558-exckhlq","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"尽管goroutine非常高效，但它们的创建和运行也是有成本的："}]},{"ID":"20240620001558-8zcvh1i","Type":"NodeList","ListData":{},"Properties":{"id":"20240620001558-8zcvh1i","updated":"20240620001559"},"Children":[{"ID":"20240620001558-f5xf915","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240620001558-f5xf915","updated":"20240620001558"},"Children":[{"ID":"20240620001558-d5xm3i6","Type":"NodeParagraph","Properties":{"id":"20240620001558-d5xm3i6","updated":"20240620001558"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"内存消耗："},{"Type":"NodeText","Data":" 虽然一个goroutine的起始栈很小，但随着goroutine数量的增加，全部的内存消耗会积累起来。"}]}]},{"ID":"20240620001558-5su9bvz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240620001558-5su9bvz","updated":"20240620001558"},"Children":[{"ID":"20240620001558-mzzwsx5","Type":"NodeParagraph","Properties":{"id":"20240620001558-mzzwsx5","updated":"20240620001558"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"调度开销："},{"Type":"NodeText","Data":" 虽然调度机制高效，但当goroutine的数量达到一定规模时，调度本身也会成为性能瓶颈。"}]}]},{"ID":"20240620001558-2x16uw9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240620001558-2x16uw9","updated":"20240620001558"},"Children":[{"ID":"20240620001558-zqeshc3","Type":"NodeParagraph","Properties":{"id":"20240620001558-zqeshc3","updated":"20240620001558"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"资源竞争："},{"Type":"NodeText","Data":" 大量的goroutines可能导致锁竞争、通道争用等问题，影响性能。"}]}]}]},{"ID":"20240620001558-32zs4nk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240620001558-32zs4nk","updated":"20240620001558"},"Children":[{"Type":"NodeText","Data":"实践中的高效goroutines使用"}]},{"ID":"20240620001558-i9z8c7c","Type":"NodeParagraph","Properties":{"id":"20240620001558-i9z8c7c","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"下面我们看一些在实际开发中如何有效地使用goroutines："}]},{"ID":"20240620001558-935ioqo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240620001558-935ioqo","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"1. 控制并发数量"}]},{"ID":"20240620001558-jcwhv1g","Type":"NodeParagraph","Properties":{"id":"20240620001558-jcwhv1g","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"不应无限制地创建goroutines，因为每一个都会占用资源。通常可以使用工作池模式来限制并发数量。"}]},{"ID":"20240620001558-kw27ln3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240620001558-kw27ln3","updated":"20240620001559"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 使用带缓冲的通道控制goroutines数量\nvar wg sync.WaitGroup\nsemaphore := make(chan struct{}, 10) // 最多允许10个goroutines并发\n\nfor i := 0; i \u003c 100; i++ {\n    wg.Add(1)\n    semaphore \u003c- struct{}{} // 获取许可\n    go func(i int) {\n        defer wg.Done()\n        defer func() { \u003c-semaphore }() // 完成时释放许可\n        // 执行任务...\n    }(i)\n}\nwg.Wait() // 等待所有goroutine完成\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240620001558-pl806bi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240620001558-pl806bi","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"2. 合理分配任务"}]},{"ID":"20240620001558-5nno0yz","Type":"NodeParagraph","Properties":{"id":"20240620001558-5nno0yz","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"让每个goroutine都有足够的工作量，避免创建大量执行微小任务的goroutine，这样可以减少调度和上下文切换的开销。"}]},{"ID":"20240620001558-69nsvbf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240620001558-69nsvbf","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"3. 资源共享与同步"}]},{"ID":"20240620001558-mwaabkn","Type":"NodeParagraph","Properties":{"id":"20240620001558-mwaabkn","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"使用通道（channels）和锁（如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"sync.Mutex"},{"Type":"NodeText","Data":"​）来同步goroutines对共享资源的访问。但要避免过度同步造成性能问题。"}]},{"ID":"20240620001558-5aljqqy","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240620001558-5aljqqy","updated":"20240620001558"},"Children":[{"Type":"NodeText","Data":"性能监控与调优"}]},{"ID":"20240620001558-d4ijgp7","Type":"NodeParagraph","Properties":{"id":"20240620001558-d4ijgp7","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"观察和监控goroutine的性能至关重要，以下是一些用于监控的方法："}]},{"ID":"20240620001558-4i8cfx9","Type":"NodeList","ListData":{},"Properties":{"id":"20240620001558-4i8cfx9","updated":"20240620001559"},"Children":[{"ID":"20240620001558-hahbac5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240620001558-hahbac5","updated":"20240620001558"},"Children":[{"ID":"20240620001558-iylyx6r","Type":"NodeParagraph","Properties":{"id":"20240620001558-iylyx6r","updated":"20240620001558"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Go的pprof："},{"Type":"NodeText","Data":" 一个性能分析工具，可以展示goroutines的创建和退出情况。"}]}]},{"ID":"20240620001558-jdyn3hn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240620001558-jdyn3hn","updated":"20240620001558"},"Children":[{"ID":"20240620001558-w0y6nrn","Type":"NodeParagraph","Properties":{"id":"20240620001558-w0y6nrn","updated":"20240620001558"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"运行时统计："},{"Type":"NodeText","Data":" 可以通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"runtime"},{"Type":"NodeText","Data":"​包获取运行时状态，比如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"runtime.NumGoroutine()"},{"Type":"NodeText","Data":"​可以获取当前的goroutine数量。"}]}]}]},{"ID":"20240620001558-1ujslr8","Type":"NodeParagraph","Properties":{"id":"20240620001558-1ujslr8","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"通过监控结果，开发者可以调整并发模型，优化性能。"}]},{"ID":"20240620001558-z08mub4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240620001558-z08mub4","updated":"20240620001558"},"Children":[{"Type":"NodeText","Data":"结论"}]},{"ID":"20240620001558-52j8foe","Type":"NodeParagraph","Properties":{"id":"20240620001558-52j8foe","updated":"20240620001559"},"Children":[{"Type":"NodeText","Data":"Goroutines是Go语言提供的一种强大的并发机制，它让并发编程变得简单易用。但是，像所有的抽象一样，goroutines抽象掉了一些底层的复杂性，这并不意味着可以无视这些复杂性。合理使用goroutines，注意它们的成本，并且在必要时进行性能监控和调优，是每一个Go开发者都应掌握的重要技能。通过本文的介绍，希望您能对goroutines有更深入的理解，并在您的项目中高效地使用它们。"}]}]}