{"ID":"20230724003916-84sjk5m","Spec":"1","Type":"NodeDocument","Properties":{"icon":"2696","id":"20230724003916-84sjk5m","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230724003916-84sjk5m\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230724003941-fn6vbvj\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230724003941-7dxu0k8\u0026quot;,\u0026quot;scrollTop\u0026quot;:300,\u0026quot;focusId\u0026quot;:\u0026quot;20230724003941-fn6vbvj\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","tags":"链表","title":"单链表","updated":"20230724003946"},"Children":[{"ID":"20230724003941-fn6vbvj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724003941-fn6vbvj","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"单链表的定义"}]},{"ID":"20230724003941-8iptruj","Type":"NodeParagraph","Properties":{"id":"20230724003941-8iptruj","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"** 由于顺序表的插入删除操作需要移动大量的元素，影响了运行效率，因此引入了线性表的链式存储——****单链表**。单链表通过一组任意的存储单元来存储线性表中的数据元素，不需要使用地址连续的存储单元，因此它不要求在逻辑上相邻的两个元素在物理位置上也相邻。"}]},{"ID":"20230724003941-nhbgd72","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230724003941-nhbgd72","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"单链表的特点："}]},{"ID":"20230724003941-d3mec1w","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20230724003941-d3mec1w","updated":"20230724003941"},"Children":[{"ID":"20230724003941-zjmix1j","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20230724003941-zjmix1j","updated":"20230724003941"},"Children":[{"ID":"20230724003941-006qamv","Type":"NodeParagraph","Properties":{"id":"20230724003941-006qamv","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"单链表不要求逻辑上相邻的两个元素在物理位置上也相邻，因此不需要连续的存储空间。"}]}]},{"ID":"20230724003941-db6n5au","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20230724003941-db6n5au","updated":"20230724003941"},"Children":[{"ID":"20230724003941-yh3aj54","Type":"NodeParagraph","Properties":{"id":"20230724003941-yh3aj54","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"单链表是非随机的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找。"}]}]}]},{"ID":"20230724003941-5a0njad","Type":"NodeParagraph","Properties":{"id":"20230724003941-5a0njad","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"对于每个链表结点，除了存放元素自身的信息外，还需要存放一个指向其后继的指针。单链表中结点类型的描述："}]},{"ID":"20230724003941-6fmntiy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724003941-6fmntiy","updated":"20230724003941"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"typedef struct LNode{ //定义单链表结点类型\n    int data; //数据域，可以是别的各种数据类型，本文统一用int类型\n    struct LNode *next; //指针域\n}LNode, *LinkList;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724003941-ksqz6iu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724003941-ksqz6iu","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"单链表上的操作"}]},{"ID":"20230724003941-1m8eoyz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724003941-1m8eoyz","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"初始化"}]},{"ID":"20230724003941-tgib2bw","Type":"NodeParagraph","Properties":{"id":"20230724003941-tgib2bw","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"** 通常会用头指针来标识一个单链表，****头指针"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"为NULL时表示一个空表。但是，为了操作方便，会在单链表的第一个结点之前附加一个结点，称为"},{"Type":"NodeText","Data":"头结点**。头结点的数据域可以不设任何信息，也可以记录表长等信息。"}]},{"ID":"20230724003941-cje5c1j","Type":"NodeParagraph","Properties":{"id":"20230724003941-cje5c1j","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"头结点和头指针的区分：不管带不带头结点，头指针始终指向单链表的第一个结点，而头结点是带头结点的单链表中的第一个结点，结点内通常不存储信息。那么单链表的初始化操作就是申请一个头结点，将指针域置空。"}]},{"ID":"20230724003941-bbkx409","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724003941-bbkx409","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"建立单链表"}]},{"ID":"20230724003941-nsw0cnf","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230724003941-nsw0cnf","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"头插法建立单链表"}]},{"ID":"20230724003941-iiipjwo","Type":"NodeParagraph","Properties":{"id":"20230724003941-iiipjwo","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"** 所谓头插法建立单链表是说将新结点插入到当前链表的表头，即头结点之后。如图所示：**"}]},{"ID":"20230724003941-10r6zmk","Type":"NodeParagraph","Properties":{"id":"20230724003941-10r6zmk","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"算法思想：首先初始化一个单链表，其头结点为空，然后循环插入新结点*s：将s的next指向头结点的下一个结点，然后将头结点的next指向s。"}]},{"ID":"20230724003941-u51yzx0","Type":"NodeParagraph","Properties":{"id":"20230724003941-u51yzx0","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"需要指出的是，头插法建立的单链表中结点的次序和输入数据的顺序不一致，是相反的。若希望两者的顺序是一致的，则可采用尾插法建立单链表。"}]},{"ID":"20230724003941-ahbbs9o","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230724003941-ahbbs9o","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"尾插法建立单链表"}]},{"ID":"20230724003941-1gqofyw","Type":"NodeParagraph","Properties":{"id":"20230724003941-1gqofyw","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"所谓尾插法建立单链表，就是将新结点插入到当前链表的表尾。如下图所示："}]},{"ID":"20230724003941-zmf6eeh","Type":"NodeParagraph","Properties":{"id":"20230724003941-zmf6eeh","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"**  算法思想：首先初始化一个单链表，然后声明一个尾指针r，让r始终指向当前链表的尾结点，循环向单链表的尾部插入新的结点*s，将尾指针r的next域指向新结点，再修改尾指针r指向新结点，也就是当前链表的尾结点。最后别忘记将尾结点的指针域置空。**"}]},{"ID":"20230724003941-dbt9dl7","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724003941-dbt9dl7","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"遍历单链表"}]},{"ID":"20230724003941-5dqi9xe","Type":"NodeParagraph","Properties":{"id":"20230724003941-5dqi9xe","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"算法思想：声明一个指针p，从头结点指向的第一个结点开始，如果p不为空，那么就输出当前结点的值，并将p指向下一个结点，直到遍历到最后一个结点为止。"}]},{"ID":"20230724003941-k5in0n1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724003941-k5in0n1","updated":"20230724003941"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"//遍历操作\nvoid PrintList(LinkList L){\n    LNode *p = L-\u003enext;\n    while(p){\n        cout\u003c\u003cp-\u003edata\u003c\u003c\" \";\n        p = p-\u003enext;\n    }\n    cout\u003c\u003cendl;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724003941-0hcm5vh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724003941-0hcm5vh","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"求单链表的长度"}]},{"ID":"20230724003941-o2rgh90","Type":"NodeParagraph","Properties":{"id":"20230724003941-o2rgh90","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"算法思想：声明一个指针p，p指向头结点指向的第一个结点，如果p指向的结点不为空，那么长度加一，将p指向下一个结点，直到遍历到最后一个结点为止。"}]},{"ID":"20230724003941-mjcg5f2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724003941-mjcg5f2","updated":"20230724003941"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"//求单链表的长度\nint Length(LinkList L){\n    LNode *p = L-\u003enext;\n    int len = 0;\n    while(p){\n        len++;\n        p = p-\u003enext;\n    }\n    return len;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724003941-phvpeyz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724003941-phvpeyz","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"查找操作"}]},{"ID":"20230724003941-bkk9z18","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230724003941-bkk9z18","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"按值查找"}]},{"ID":"20230724003941-qj3rfpb","Type":"NodeParagraph","Properties":{"id":"20230724003941-qj3rfpb","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"查找值x在单链表L中的结点指针。"}]},{"ID":"20230724003941-32i3ox0","Type":"NodeParagraph","Properties":{"id":"20230724003941-32i3ox0","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"算法思想：从单链表的第一个结点开始，依次比较表中各个结点的数据域的值，若某结点数据域的值等于x，则返回该结点的指针；若整个单链表中没有这样的结点，则返回空。"}]},{"ID":"20230724003941-am1bvz6","Type":"NodeParagraph","Properties":{"id":"20230724003941-am1bvz6","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"** 实现代码**"}]},{"ID":"20230724003941-5vckcv8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724003941-5vckcv8","updated":"20230724003941"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"//按值查找：查找x在L中的位置\nLNode *LocateElem(LinkList L, int x){\n    LNode *p = L-\u003enext;\n    while(p \u0026\u0026 p-\u003edata != x){\n        p = p-\u003enext;\n    }\n    return p;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724003941-tuoqc1s","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230724003941-tuoqc1s","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"按位查找"}]},{"ID":"20230724003941-yrknxpn","Type":"NodeParagraph","Properties":{"id":"20230724003941-yrknxpn","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"查找单链表L中第 i 个位置的结点指针。"}]},{"ID":"20230724003941-xzdanmu","Type":"NodeParagraph","Properties":{"id":"20230724003941-xzdanmu","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"算法思想：从单链表的第一个结点开始，顺着指针域逐个往下搜索，直到找到第 i 个结点为止，否则返回最后一个结点的指针域NULL。"}]},{"ID":"20230724003941-lfr025r","Type":"NodeParagraph","Properties":{"id":"20230724003941-lfr025r","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"** 实现代码：**"}]},{"ID":"20230724003941-car4uqt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724003941-car4uqt","updated":"20230724003941"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"//按位查找：查找在单链表L中第i个位置的结点\nLNode *GetElem(LinkList L, int i){\n    int j=1;\n    LNode *p = L-\u003enext;\n    if(i==0)return L;\n    if(i\u003c1)return NULL;\n    while(p \u0026\u0026 j\u003ci){\n        p = p-\u003enext;\n        j++;\n    }\n    return p; //如果i大于表长，p=NULL,直接返回p即可\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724003941-o5ajs4r","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724003941-o5ajs4r","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"插入操作"}]},{"ID":"20230724003941-56sdze0","Type":"NodeParagraph","Properties":{"id":"20230724003941-56sdze0","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这里所说的插入是将值为x的新结点插入到单链表L的第i个位置上。（不包括头结点）"}]},{"ID":"20230724003941-897wzy6","Type":"NodeParagraph","Properties":{"id":"20230724003941-897wzy6","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"算法思想：从表头开始遍历，查找第 i-1个结点，即插入位置的前驱结点为"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"p，然后令新结点"},{"Type":"NodeText","Data":"s的指针域指向"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"p的后继结点，再令结点"},{"Type":"NodeText","Data":"p的指针域指向新结点*s。"}]},{"ID":"20230724003941-wu1do9k","Type":"NodeParagraph","Properties":{"id":"20230724003941-wu1do9k","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"** 实现代码：**"}]},{"ID":"20230724003941-mho6iax","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724003941-mho6iax","updated":"20230724003941"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"//将x插入到单链表L的第i个位置上\nvoid Insert(LinkList \u0026L, int i, int x){\n    LNode *p = GetElem(L,i-1);\n    LNode *s = (LNode *)malloc(sizeof(LNode));\n    s-\u003edata = x;\n    s-\u003enext = p-\u003enext;\n    p-\u003enext = s;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724003941-dre7u1s","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230724003941-dre7u1s","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"删除操作"}]},{"ID":"20230724003941-wr2hxym","Type":"NodeParagraph","Properties":{"id":"20230724003941-wr2hxym","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"将单链表的第 i 个结点删除。"}]},{"ID":"20230724003941-ziutk7z","Type":"NodeParagraph","Properties":{"id":"20230724003941-ziutk7z","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"算法思想：先检查删除位置的合法性，然后从头开始遍历，找到表中的第 i-1 个结点，即被删除结点的前驱结点"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"p，被删除结点为"},{"Type":"NodeText","Data":"q，修改"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"p的指针域，将其指向"},{"Type":"NodeText","Data":"q的下一个结点，最后再释放结点*q的存储空间。"}]},{"ID":"20230724003941-7vpy9b7","Type":"NodeParagraph","Properties":{"id":"20230724003941-7vpy9b7","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"** 实现代码：**"}]},{"ID":"20230724003941-a3i2ohe","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724003941-a3i2ohe","updated":"20230724003941"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"//删除操作:将单链表中的第i个结点删除\nvoid Delete(LinkList \u0026L, int i){\n    if(i\u003c1 || i\u003eLength(L))\n        cout\u003c\u003c\"delete failed: index is wrong.\"\u003c\u003cendl;\n        return;\n    LNode *p = GetElem(L,i-1);\n    LNode *q = p-\u003enext;\n    p-\u003enext = q-\u003enext;\n    free(q);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230724003941-jimo7fl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230724003941-jimo7fl","updated":"20230724003941"},"Children":[{"Type":"NodeText","Data":"判空操作"}]},{"ID":"20230724003941-gb2r663","Type":"NodeParagraph","Properties":{"id":"20230724003941-gb2r663","updated":"20230724003941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"算法思想：要判断带头结点的单链表是否为空，只需要看头结点的指针域即可，如果头结点的指针域为空，即单链表中只有一个头结点，那么该单链表为空表。"}]},{"ID":"20230724003941-7dxu0k8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230724003941-7dxu0k8","updated":"20230724003941"},"Children":[{"Type":"NodeCodeBlockFen